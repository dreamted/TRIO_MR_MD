###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     08/Feb/2018  09:39:44 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\code\adcFunc.c                                    #
#    Command line =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\code\adcFunc.c -lC D:\Project\TRIO\2.TRIO-MR\appl #
#                    _stm207_20141204_RvsALC_20151223\out\ -o                 #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\out\ --endian=little --cpu=Cortex-M3 -e           #
#                    --fpu=None --dlib_config "D:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204 #
#                    _RvsALC_20151223\include\ -I                             #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\STM32F2xx_StdPeriph_Driver_v1212\ -I              #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\STM32F2xx_StdPeriph_Driver_v1212\inc\ -I          #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uC-CPU\ -I D:\Project\TRIO\2.TRIO-MR\appl_stm207_ #
#                    20141204_RvsALC_20151223\uC-LIB\ -I                      #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uCOS-II\Ports\ -I D:\Project\TRIO\2.TRIO-MR\appl_ #
#                    stm207_20141204_RvsALC_20151223\uCOS-II\Source\ -I       #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uC-Probe\ -Oh --use_c++_inline                    #
#    List file    =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\out\adcFunc.lst                                   #
#    Object file  =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\out\adcFunc.o                                     #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20151223\code\adcFunc.c
      1          /******************** (C) COPYRIGHT 2007 STMicroelectronics ********************
      2          * File Name          : stm32f10x_adc.c
      3          * Author             : MCD Application Team
      4          * Version            : V1.0
      5          * Date               : 10/08/2007
      6          * Description        : This file provides all the ADC firmware functions.
      7          ********************************************************************************/
      8          #define ADC_C
      9          
     10          // Includes ////////////////////////////////////////////////////////////////////
     11          #include "../include/main.h"

   \                                 In section .text, align 4, keep-with-next
   \   __absolute unsigned long const AdcBuffMax[19]
   \                     AdcBuffMax:
   \   00000000   0x00000064         DC32 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 10, 10
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x0000000A   
   \              0x0000000A   
   \   00000038   0x0000000A         DC32 10, 10, 0, 0, 0
   \              0x0000000A   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   

   \                                 In section .text, align 4, keep-with-next
   \   __absolute unsigned long const Adc3BuffMax[19]
   \                     Adc3BuffMax:
   \   00000000   0x00000064         DC32 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 10, 10
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x0000000A   
   \              0x0000000A   
   \   00000038   0x0000000A         DC32 10, 10, 0, 0, 0
   \              0x0000000A   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute INT32U const AdcEn
   \                     AdcEn:
   \   00000000   0x0000FFFF         DC32 65535

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute INT32U const Adc3En
   \                     Adc3En:
   \   00000000   0x0000FFFF         DC32 65535

   \                                 In section .bss, align 4
   \   __absolute INT16U ADC_AVR_VALUE0[100]
   \                     ADC_AVR_VALUE0:
   \   00000000                      DS8 200

   \                                 In section .bss, align 4
   \   __absolute INT16U ADC_AVR_VALUE1[100]
   \                     ADC_AVR_VALUE1:
   \   00000000                      DS8 200

   \                                 In section .bss, align 4
   \   __absolute INT16U ADC_AVR_VALUE2[100]
   \                     ADC_AVR_VALUE2:
   \   00000000                      DS8 200

   \                                 In section .bss, align 4
   \   __absolute INT16U ADC_AVR_VALUE3[100]
   \                     ADC_AVR_VALUE3:
   \   00000000                      DS8 200

   \                                 In section .bss, align 4
   \   __absolute INT16U ADC_AVR_VALUE4[100]
   \                     ADC_AVR_VALUE4:
   \   00000000                      DS8 200

   \                                 In section .bss, align 4
   \   __absolute INT16U ADC_AVR_VALUE5[100]
   \                     ADC_AVR_VALUE5:
   \   00000000                      DS8 200

   \                                 In section .bss, align 4
   \   __absolute INT16U ADC_AVR_VALUE6[100]
   \                     ADC_AVR_VALUE6:
   \   00000000                      DS8 200

   \                                 In section .bss, align 4
   \   __absolute INT16U ADC_AVR_VALUE7[100]
   \                     ADC_AVR_VALUE7:
   \   00000000                      DS8 200

   \                                 In section .bss, align 4
   \   __absolute INT16U ADC_AVR_VALUE8[100]
   \                     ADC_AVR_VALUE8:
   \   00000000                      DS8 200

   \                                 In section .bss, align 4
   \   __absolute INT16U ADC_AVR_VALUE9[100]
   \                     ADC_AVR_VALUE9:
   \   00000000                      DS8 200

   \                                 In section .bss, align 4
   \   __absolute INT16U ADC_AVR_VALUE10[100]
   \                     ADC_AVR_VALUE10:
   \   00000000                      DS8 200

   \                                 In section .bss, align 4
   \   __absolute INT16U ADC_AVR_VALUE11[100]
   \                     ADC_AVR_VALUE11:
   \   00000000                      DS8 200

   \                                 In section .bss, align 4
   \   __absolute INT16U ADC_AVR_VALUE12[10]
   \                     ADC_AVR_VALUE12:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
   \   __absolute INT16U ADC_AVR_VALUE13[10]
   \                     ADC_AVR_VALUE13:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
   \   __absolute INT16U ADC_AVR_VALUE14[10]
   \                     ADC_AVR_VALUE14:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
   \   __absolute INT16U ADC_AVR_VALUE15[10]
   \                     ADC_AVR_VALUE15:
   \   00000000                      DS8 20

   \                                 In section .data, align 4
   \   __absolute unsigned short *ADC_AVR[19]
   \                     ADC_AVR:
   \   00000000   0x........         DC32 ADC_AVR_VALUE0, ADC_AVR_VALUE1, ADC_AVR_VALUE2, ADC_AVR_VALUE3
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000010   0x........         DC32 ADC_AVR_VALUE4, ADC_AVR_VALUE5, ADC_AVR_VALUE6, ADC_AVR_VALUE7
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000020   0x........         DC32 ADC_AVR_VALUE8, ADC_AVR_VALUE9, ADC_AVR_VALUE10, ADC_AVR_VALUE11
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000030   0x........         DC32 ADC_AVR_VALUE12, ADC_AVR_VALUE13, ADC_AVR_VALUE14, ADC_AVR_VALUE15
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000040   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .data, align 4
   \   __absolute unsigned short *ADC3_AVR[19]
   \                     ADC3_AVR:
   \   00000000   0x........         DC32 ADC_AVR_VALUE0, ADC_AVR_VALUE1, ADC_AVR_VALUE2, ADC_AVR_VALUE3
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000010   0x........         DC32 ADC_AVR_VALUE4, ADC_AVR_VALUE5, ADC_AVR_VALUE6, ADC_AVR_VALUE7
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000020   0x........         DC32 ADC_AVR_VALUE8, ADC_AVR_VALUE9, ADC_AVR_VALUE10, ADC_AVR_VALUE11
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000030   0x........         DC32 ADC_AVR_VALUE12, ADC_AVR_VALUE13, ADC_AVR_VALUE14, ADC_AVR_VALUE15
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000040   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .bss, align 4
   \   __absolute INT16U ADC_DATA[19]
   \                     ADC_DATA:
   \   00000000                      DS8 40

   \                                 In section .bss, align 4
   \   __absolute INT32U ADC_SUM[19]
   \                     ADC_SUM:
   \   00000000                      DS8 76

   \                                 In section .bss, align 4
   \   __absolute INT8U ADCIndex
   \                     ADCIndex:
   \   00000000                      DS8 1
   \   __absolute INT8U ASTART
   \                     ASTART:
   \   00000001                      DS8 1
   \   __absolute INT8U ADC3Index
   \                     ADC3Index:
   \   00000002                      DS8 1
   \   __absolute INT8U ASTART3
   \                     ASTART3:
   \   00000003                      DS8 1
   \   __absolute INT8U ADCSTART[19]
   \                     ADCSTART:
   \   00000004                      DS8 20
   \   __absolute INT16U ADC_WRCNT[19]
   \                     ADC_WRCNT:
   \   00000018                      DS8 40

   \                                 In section .bss, align 4
   \   __absolute INT8U ADC3START[19]
   \                     ADC3START:
   \   00000000                      DS8 20
   \   __absolute INT16U ADC3_WRCNT[19]
   \                     ADC3_WRCNT:
   \   00000014                      DS8 40

   \                                 In section .bss, align 4
   \   __absolute INT16U ADC_DATA1[30]
   \                     ADC_DATA1:
   \   00000000                      DS8 60
     12          

   \                                 In section .text, align 2, keep-with-next
     13          void ADCInit(int INT_EN)
     14          {
   \                     ADCInit:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
     15          	INT32U cpu_sr;
     16          
     17          	ADC_Common_TypeDef *ADCb = ADC;
     18          	ADC_TypeDef *ADCx = ADC1;	
     19          //	ADC_TypeDef *ADCy = ADC2;	
     20          
     21          	OS_ENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000008   0x4605             MOV      R5,R0
     22          
     23          	ADCIndex = 0;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x7001             STRB     R1,[R0, #+0]
     24          	ASTART = 0;
   \   00000012   0x7041             STRB     R1,[R0, #+1]
     25          
     26          	ADC3Index = 0;
   \   00000014   0x7081             STRB     R1,[R0, #+2]
     27          	ASTART3 = 0;
   \   00000016   0x70C1             STRB     R1,[R0, #+3]
     28          
     29          
     30          	ADCx->__B.SQR1.L = 0;	// 1EA
   \   00000018   0x.... 0x....      LDR.W    R6,??DataTable12_1  ;; 0x40012004
   \   0000001C   0x6AB0             LDR      R0,[R6, #+40]
   \   0000001E   0xF420 0x0070      BIC      R0,R0,#0xF00000
   \   00000022   0x62B0             STR      R0,[R6, #+40]
     31          	ADCx->__B.SQR3.SQ1 = 0; // Start Zer0
   \   00000024   0x6B30             LDR      R0,[R6, #+48]
   \   00000026   0x0940             LSRS     R0,R0,#+5
   \   00000028   0x0140             LSLS     R0,R0,#+5
   \   0000002A   0x6330             STR      R0,[R6, #+48]
     32          
     33          	NVIC_Init(ADC_IRQn, INT_EN);
   \   0000002C   0x4621             MOV      R1,R4
   \   0000002E   0x2012             MOVS     R0,#+18
   \   00000030   0x.... 0x....      BL       NVIC_Init
     34          
     35          	// ADC1 regular channel14 configuration
     36          	ADCx->__B.SMPR1.Data = 0x00FFFFFF;				// ADC_SampleTime_239Cycles5
   \   00000034   0xF06F 0x407F      MVN      R0,#-16777216
   \   00000038   0x60B0             STR      R0,[R6, #+8]
     37          	ADCx->__B.SMPR2.Data = 0x3FFFFFFF;				// ADC_SampleTime_239Cycles5
   \   0000003A   0xF06F 0x4040      MVN      R0,#-1073741824
   \   0000003E   0x60F0             STR      R0,[R6, #+12]
     38          
     39          	// ADC
     40          	ADCb->__B.CCR.MULT = __dMODE_INDEPENDENT;		// Multi ADC Mode
   \   00000040   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40012304
   \   00000042   0x6801             LDR      R1,[R0, #+0]
   \   00000044   0x0949             LSRS     R1,R1,#+5
   \   00000046   0x0149             LSLS     R1,R1,#+5
   \   00000048   0x6001             STR      R1,[R0, #+0]
     41          //	ADCb->__B.CCR.MULT = __dMODE_FastInterl;		// Multi ADC Mode
     42          
     43          	ADCb->__B.CCR.DELAY = __DLY_5CYL;				// Delay between 2 sampling Phases
   \   0000004A   0x6801             LDR      R1,[R0, #+0]
   \   0000004C   0xF421 0x6170      BIC      R1,R1,#0xF00
   \   00000050   0x6001             STR      R1,[R0, #+0]
     44          //	ADCb->__B.CCR.DMA = __DMA_DISABLE;				// DMA Mode (for Multi ADC mode)
     45          	ADCb->__B.CCR.ADCPRE = __PRE_DIV8;				// PreScaler, 30MHz/8 = 3.75Mhz
   \   00000052   0x6801             LDR      R1,[R0, #+0]
   \   00000054   0xF441 0x3140      ORR      R1,R1,#0x30000
   \   00000058   0x6001             STR      R1,[R0, #+0]
     46          #if 0	
     47          	1개 67uSec   __PRE_DIV8
     48          	1개 33uSec   __PRE_DIV4
     49          	1개 16uSec   __PRE_DIV2
     50          #endif
     51          	ADCb->__B.CCR.VBATE = DISABLE;					// Delay between 2 sampling Phases
   \   0000005A   0x6801             LDR      R1,[R0, #+0]
   \   0000005C   0xF421 0x0180      BIC      R1,R1,#0x400000
   \   00000060   0x6001             STR      R1,[R0, #+0]
     52          	ADCb->__B.CCR.TSVREFE = ENABLE; 				// temperature sensor enable
   \   00000062   0x6801             LDR      R1,[R0, #+0]
   \   00000064   0xF441 0x0100      ORR      R1,R1,#0x800000
   \   00000068   0x6001             STR      R1,[R0, #+0]
     53          #if 1	
     54          	// ADC1 configuration
     55          	ADCx->__B.CR1.OVRIE = DISABLE;					// Overrun interrupt
   \   0000006A   0x6830             LDR      R0,[R6, #+0]
   \   0000006C   0xF020 0x6080      BIC      R0,R0,#0x4000000
   \   00000070   0x6030             STR      R0,[R6, #+0]
     56          	ADCx->__B.CR1.RES	= __RES_12BIT;					// Resolution
   \   00000072   0x6830             LDR      R0,[R6, #+0]
   \   00000074   0xF020 0x7040      BIC      R0,R0,#0x3000000
   \   00000078   0x6030             STR      R0,[R6, #+0]
     57          	ADCx->__B.CR1.AWDEN = DISABLE;					// Analog watchdog
   \   0000007A   0x6830             LDR      R0,[R6, #+0]
   \   0000007C   0xF420 0x0000      BIC      R0,R0,#0x800000
   \   00000080   0x6030             STR      R0,[R6, #+0]
     58          	ADCx->__B.CR1.SCAN = DISABLE;					// Scan Mode
   \   00000082   0x6830             LDR      R0,[R6, #+0]
   \   00000084   0xF420 0x7080      BIC      R0,R0,#0x100
   \   00000088   0x6030             STR      R0,[R6, #+0]
     59          	ADCx->__B.CR1.EOCIE = INT_EN;					// interrupt enable
   \   0000008A   0x6830             LDR      R0,[R6, #+0]
   \   0000008C   0xF364 0x1045      BFI      R0,R4,#+5,#+1
   \   00000090   0x6030             STR      R0,[R6, #+0]
     60          
     61          	ADCx->__B.CR2.CONT = DISABLE;					// Continuous Conversion
   \   00000092   0x6870             LDR      R0,[R6, #+4]
   \   00000094   0xF020 0x0002      BIC      R0,R0,#0x2
   \   00000098   0x6070             STR      R0,[R6, #+4]
     62          	ADCx->__B.CR2.DMAMODE = DISABLE;				// DMA Mode
   \   0000009A   0x6870             LDR      R0,[R6, #+4]
   \   0000009C   0xF420 0x7080      BIC      R0,R0,#0x100
   \   000000A0   0x6070             STR      R0,[R6, #+4]
     63          	ADCx->__B.CR2.DDS = DISABLE;					// DMA Disable selection (for single ADC mode)
   \   000000A2   0x6870             LDR      R0,[R6, #+4]
   \   000000A4   0xF420 0x7000      BIC      R0,R0,#0x200
   \   000000A8   0x6070             STR      R0,[R6, #+4]
     64          	ADCx->__B.CR2.ALIGN = __ALI_Right;				// Data Alignment
   \   000000AA   0x6870             LDR      R0,[R6, #+4]
   \   000000AC   0xF420 0x6000      BIC      R0,R0,#0x800
   \   000000B0   0x6070             STR      R0,[R6, #+4]
     65          	ADCx->__B.CR2.EXTSEL = __T1_CC1;				// Start conversion of regular channels
   \   000000B2   0x6870             LDR      R0,[R6, #+4]
   \   000000B4   0xF020 0x6070      BIC      R0,R0,#0xF000000
   \   000000B8   0x6070             STR      R0,[R6, #+4]
     66          	ADCx->__B.CR2.EXTEN = DISABLE;					// External Trigger Enable
   \   000000BA   0x6870             LDR      R0,[R6, #+4]
   \   000000BC   0xF020 0x5040      BIC      R0,R0,#0x30000000
   \   000000C0   0x6070             STR      R0,[R6, #+4]
     67          	ADCx->__B.CR2.ADON = ENABLE;					// Enable ADC1
   \   000000C2   0x6870             LDR      R0,[R6, #+4]
   \   000000C4   0xF040 0x0001      ORR      R0,R0,#0x1
   \   000000C8   0x6070             STR      R0,[R6, #+4]
     68          #endif
     69          #if 0
     70          
     71          	ADCy->__B.SQR1.L = 0;	// 1EA
     72          	ADCy->__B.SQR3.SQ1 = 0; // Start Zer0
     73          
     74          	// ADC1 regular channel14 configuration
     75          	ADCy->__B.SMPR1.Data = 0x00FFFFFF;				// ADC_SampleTime_239Cycles5
     76          	ADCy->__B.SMPR2.Data = 0x3FFFFFFF;				// ADC_SampleTime_239Cycles5
     77          
     78          	ADCy->__B.CR1.OVRIE = DISABLE;					// Overrun interrupt
     79          	ADCy->__B.CR1.RES	= __RES_12BIT;				// Resolution
     80          	ADCy->__B.CR1.AWDEN = DISABLE;					// Analog watchdog
     81          	ADCy->__B.CR1.SCAN = DISABLE;					// Scan Mode
     82          	ADCy->__B.CR1.EOCIE = INT_EN;					// interrupt enable
     83          
     84          	ADCy->__B.CR2.CONT = DISABLE;					// Continuous Conversion
     85          	ADCy->__B.CR2.DMAMODE = DISABLE;				// DMA Mode
     86          	ADCy->__B.CR2.DDS = DISABLE;					// DMA Disable selection (for single ADC mode)
     87          	ADCy->__B.CR2.ALIGN = __ALI_Right;				// Data Alignment
     88          	ADCy->__B.CR2.EXTSEL = __T1_CC1;				// Start conversion of regular channels
     89          	ADCy->__B.CR2.EXTEN = DISABLE;					// External Trigger Enable
     90          	ADCy->__B.CR2.ADON = ENABLE;					// Enable ADC1
     91          #endif
     92          	
     93          	// Start ADC1 Software Conversion
     94          	OS_EXIT_CRITICAL();
   \   000000CA   0x4628             MOV      R0,R5
   \   000000CC   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   000000D0   0x.... 0x....      B.W      OS_CPU_SR_Restore
     95          }
     96          
     97          

   \                                 In section .text, align 2, keep-with-next
     98          INT8U ADC_CheckFinish(INT8U channel)
     99          {
    100          	//SerPtr->printf("c111: %d, ADCSTART = %d\n", channel, ADCSTART[channel]);
    101          	if(ADCSTART[channel] == ADCFINISH) return TRUE;
   \                     ADC_CheckFinish:
   \   00000000   0x....             LDR.N    R1,??DataTable12
   \   00000002   0x1840             ADDS     R0,R0,R1
   \   00000004   0x7900             LDRB     R0,[R0, #+4]
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD101             BNE.N    ??ADC_CheckFinish_0
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x4770             BX       LR
    102          	return FALSE;
   \                     ??ADC_CheckFinish_0:
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4770             BX       LR               ;; return
    103          }
    104          

   \                                 In section .text, align 2, keep-with-next
    105          void ADC_ChannelEnable(INT8U channel)
    106          {
    107          	ADCSTART[channel] = ADCIDLE;
   \                     ADC_ChannelEnable:
   \   00000000   0x....             LDR.N    R1,??DataTable12
   \   00000002   0x1840             ADDS     R0,R0,R1
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7101             STRB     R1,[R0, #+4]
    108          }
   \   00000008   0x4770             BX       LR               ;; return
    109          
    110          
    111          
    112          

   \                                 In section .text, align 2, keep-with-next
    113          INT8U ADC3_CheckFinish(INT8U channel)
    114          {
    115          	//SerPtr->printf("c111: %d, ADCSTART = %d\n", channel, ADCSTART[channel]);
    116          	if(ADC3START[channel] == ADCFINISH) return TRUE;
   \                     ADC3_CheckFinish:
   \   00000000   0x....             LDR.N    R1,??DataTable12_3
   \   00000002   0x5C40             LDRB     R0,[R0, R1]
   \   00000004   0x2802             CMP      R0,#+2
   \   00000006   0xD101             BNE.N    ??ADC3_CheckFinish_0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
    117          	return FALSE;
   \                     ??ADC3_CheckFinish_0:
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
    118          }
    119          

   \                                 In section .text, align 2, keep-with-next
    120          void ADC3_ChannelEnable(INT8U channel)
    121          {
    122          	ADC3START[channel] = ADCIDLE;
   \                     ADC3_ChannelEnable:
   \   00000000   0x....             LDR.N    R1,??DataTable12_3
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x5442             STRB     R2,[R0, R1]
    123          }
   \   00000006   0x4770             BX       LR               ;; return
    124          
    125          
    126          /*******************************************************************************
    127          * Function Name  : ADC1_SWStart
    128          * Description    : get ADC Value directly(only case no_interrupt mode
    129          *                  group channel.
    130          * Input          : - channel: where x can be 1 or 2 to select the ADC channel
    131          * Output         : None
    132          * Return         : - direct ADCx channel 12 bit value
    133          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    134          void ADC1_SWStart(void)
    135          {
    136              int i;
    137          
    138          	if(ADC1->__B.CR1.EOCIE && ASTART == RESET)
   \                     ADC1_SWStart:
   \   00000000   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40012004
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x0689             LSLS     R1,R1,#+26
   \   00000006   0xD400             BMI.N    ??ADC1_SWStart_0
   \   00000008   0x4770             BX       LR
   \                     ??ADC1_SWStart_0:
   \   0000000A   0xB4F0             PUSH     {R4-R7}
   \   0000000C   0x....             LDR.N    R1,??DataTable12
   \   0000000E   0x784A             LDRB     R2,[R1, #+1]
   \   00000010   0xBB0A             CBNZ.N   R2,??ADC1_SWStart_1
    139          	{
    140          		for(i = 0; i < __ADCMAX ; i++)
   \   00000012   0x2213             MOVS     R2,#+19
   \   00000014   0xF64F 0x73FF      MOVW     R3,#+65535
   \   00000018   0x2413             MOVS     R4,#+19
    141          		{
    142          			ADCIndex++;
    143          			ADCIndex %= __ADCMAX;
   \                     ??ADC1_SWStart_2:
   \   0000001A   0x780D             LDRB     R5,[R1, #+0]
   \   0000001C   0x1C6D             ADDS     R5,R5,#+1
   \   0000001E   0xB2ED             UXTB     R5,R5
   \   00000020   0xFB95 0xF6F4      SDIV     R6,R5,R4
   \   00000024   0xFB04 0x5516      MLS      R5,R4,R6,R5
   \   00000028   0x700D             STRB     R5,[R1, #+0]
    144          
    145          			if(((AdcEn >> ADCIndex) & 0x01) && ADCSTART[ADCIndex] == ADCIDLE)
   \   0000002A   0x780D             LDRB     R5,[R1, #+0]
   \   0000002C   0xFA23 0xF605      LSR      R6,R3,R5
   \   00000030   0x07F6             LSLS     R6,R6,#+31
   \   00000032   0xD50E             BPL.N    ??ADC1_SWStart_3
   \   00000034   0x186F             ADDS     R7,R5,R1
   \   00000036   0x793E             LDRB     R6,[R7, #+4]
   \   00000038   0xB95E             CBNZ.N   R6,??ADC1_SWStart_3
    146          			{
    147          				ADC_WRCNT[ADCIndex] = 0;
   \   0000003A   0xEB01 0x0245      ADD      R2,R1,R5, LSL #+1
   \   0000003E   0x2300             MOVS     R3,#+0
   \   00000040   0x8313             STRH     R3,[R2, #+24]
    148          				ASTART = SET;
   \   00000042   0x2201             MOVS     R2,#+1
   \   00000044   0x704A             STRB     R2,[R1, #+1]
    149          
    150          				ADCSTART[ADCIndex] = ADCING;
   \   00000046   0x713A             STRB     R2,[R7, #+4]
    151          				ADC1->__B.SQR3.SQ1 = ADCIndex;
   \   00000048   0x6B01             LDR      R1,[R0, #+48]
   \   0000004A   0xF365 0x0104      BFI      R1,R5,#+0,#+5
   \   0000004E   0x6301             STR      R1,[R0, #+48]
    152          				ADC1->__B.CR2.SWSTART = ENABLE;
   \   00000050   0x....             B.N      ?Subroutine0
    153          				break;
    154          			}
    155          		}
   \                     ??ADC1_SWStart_3:
   \   00000052   0x1E52             SUBS     R2,R2,#+1
   \   00000054   0xD1E1             BNE.N    ??ADC1_SWStart_2
    156          	}
    157          
    158          }
   \                     ??ADC1_SWStart_1:
   \   00000056   0xBCF0             POP      {R4-R7}
   \   00000058   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0x6841             LDR      R1,[R0, #+4]
   \   00000002   0xF041 0x4180      ORR      R1,R1,#0x40000000
   \   00000006   0x6041             STR      R1,[R0, #+4]
   \   00000008   0xBCF0             POP      {R4-R7}
   \   0000000A   0x4770             BX       LR
    159          

   \                                 In section .text, align 2, keep-with-next
    160          void ADC3_SWStart(void)
    161          {
    162              int i;
    163          
    164          	if(ADC2->__B.CR1.EOCIE && ASTART3 == RESET)
   \                     ADC3_SWStart:
   \   00000000   0x....             LDR.N    R0,??DataTable12_4  ;; 0x40012104
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x0689             LSLS     R1,R1,#+26
   \   00000006   0xD400             BMI.N    ??ADC3_SWStart_0
   \   00000008   0x4770             BX       LR
   \                     ??ADC3_SWStart_0:
   \   0000000A   0xB4F0             PUSH     {R4-R7}
   \   0000000C   0x....             LDR.N    R1,??DataTable12
   \   0000000E   0x78CA             LDRB     R2,[R1, #+3]
   \   00000010   0xBB12             CBNZ.N   R2,??ADC3_SWStart_1
    165          	{
    166          		for(i = 0; i < __ADCMAX ; i++)
   \   00000012   0x2313             MOVS     R3,#+19
   \   00000014   0x....             LDR.N    R2,??DataTable12_3
   \   00000016   0xF64F 0x74FF      MOVW     R4,#+65535
   \   0000001A   0x2513             MOVS     R5,#+19
    167          		{
    168          			ADC3Index++;
    169          			ADC3Index %= __ADCMAX;
   \                     ??ADC3_SWStart_2:
   \   0000001C   0x788E             LDRB     R6,[R1, #+2]
   \   0000001E   0x1C76             ADDS     R6,R6,#+1
   \   00000020   0xB2F6             UXTB     R6,R6
   \   00000022   0xFB96 0xF7F5      SDIV     R7,R6,R5
   \   00000026   0xFB05 0x6617      MLS      R6,R5,R7,R6
   \   0000002A   0x708E             STRB     R6,[R1, #+2]
    170          
    171          			if(((Adc3En >> ADC3Index) & 0x01) && ADC3START[ADC3Index] == ADCIDLE)
   \   0000002C   0x788E             LDRB     R6,[R1, #+2]
   \   0000002E   0xFA24 0xF706      LSR      R7,R4,R6
   \   00000032   0x07FF             LSLS     R7,R7,#+31
   \   00000034   0xD50E             BPL.N    ??ADC3_SWStart_3
   \   00000036   0x5CB7             LDRB     R7,[R6, R2]
   \   00000038   0xB967             CBNZ.N   R7,??ADC3_SWStart_3
    172          			{
    173          				ADC3_WRCNT[ADC3Index] = 0;
   \   0000003A   0xEB02 0x0346      ADD      R3,R2,R6, LSL #+1
   \   0000003E   0x2400             MOVS     R4,#+0
   \   00000040   0x829C             STRH     R4,[R3, #+20]
    174          				ASTART3 = SET;
   \   00000042   0x2301             MOVS     R3,#+1
   \   00000044   0x70CB             STRB     R3,[R1, #+3]
    175          
    176          				ADC3START[ADCIndex] = ADCING;
   \   00000046   0x7809             LDRB     R1,[R1, #+0]
   \   00000048   0x548B             STRB     R3,[R1, R2]
    177          				ADC2->__B.SQR3.SQ1 = ADCIndex;
   \   0000004A   0x6B02             LDR      R2,[R0, #+48]
   \   0000004C   0xF361 0x0204      BFI      R2,R1,#+0,#+5
   \   00000050   0x6302             STR      R2,[R0, #+48]
    178          				ADC2->__B.CR2.SWSTART = ENABLE;
   \   00000052   0x....             B.N      ?Subroutine0
    179          				break;
    180          			}
    181          		}
   \                     ??ADC3_SWStart_3:
   \   00000054   0x1E5B             SUBS     R3,R3,#+1
   \   00000056   0xD1E1             BNE.N    ??ADC3_SWStart_2
    182          	}
    183          
    184          }
   \                     ??ADC3_SWStart_1:
   \   00000058   0xBCF0             POP      {R4-R7}
   \   0000005A   0x4770             BX       LR               ;; return
    185          
    186          
    187          
    188          /*******************************************************************************
    189          * Function Name  : GetAdcValue
    190          * Description    : get ADC Value directly(only case no_interrupt mode
    191          *                  group channel.
    192          * Input          : - channel: where x can be 1 or 2 to select the ADC channel
    193          * Output         : None
    194          * Return         : - direct ADCx channel 12 bit value
    195          *******************************************************************************/
    196          

   \                                 In section .text, align 2, keep-with-next
    197          INT16U GetAdcValue(INT8U channel)
    198          {
    199          
    200          //	ADC1->__B.CR2.SWSTART = ENABLE;
    201          
    202          	if(!ADC1->__B.CR2.ADON) return 0;
   \                     GetAdcValue:
   \   00000000   0x....             LDR.N    R1,??DataTable12_5  ;; 0x40012000
   \   00000002   0x688A             LDR      R2,[R1, #+8]
   \   00000004   0x07D2             LSLS     R2,R2,#+31
   \   00000006   0xD514             BPL.N    ??GetAdcValue_0
    203          	if(!ADC1->__B.CR1.EOCIE)
   \   00000008   0x684A             LDR      R2,[R1, #+4]
   \   0000000A   0x0692             LSLS     R2,R2,#+26
   \   0000000C   0xD411             BMI.N    ??GetAdcValue_0
    204          	{
    205          		ADC1->__B.SQR3.SQ1 = channel;
   \   0000000E   0x6B4A             LDR      R2,[R1, #+52]
   \   00000010   0xF360 0x0204      BFI      R2,R0,#+0,#+5
   \   00000014   0x634A             STR      R2,[R1, #+52]
    206          		ADC1->__B.CR2.SWSTART = ENABLE;		// ADC1->CONVERTER START
   \   00000016   0x688A             LDR      R2,[R1, #+8]
   \   00000018   0xF042 0x4280      ORR      R2,R2,#0x40000000
   \   0000001C   0x608A             STR      R2,[R1, #+8]
    207          		
    208          		while(!ADC1->__B.SR.EOC);
   \                     ??GetAdcValue_1:
   \   0000001E   0x680A             LDR      R2,[R1, #+0]
   \   00000020   0x0792             LSLS     R2,R2,#+30
   \   00000022   0xD5FC             BPL.N    ??GetAdcValue_1
    209          		ADC_DATA[channel] = ADC1->DR;
   \   00000024   0x....             LDR.N    R2,??DataTable12_6
   \   00000026   0x6CC9             LDR      R1,[R1, #+76]
   \   00000028   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
    210          		return ADC_DATA[channel];
   \   0000002C   0xF832 0x0010      LDRH     R0,[R2, R0, LSL #+1]
   \   00000030   0x4770             BX       LR
    211          	}
    212          	return 0;
   \                     ??GetAdcValue_0:
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x4770             BX       LR               ;; return
    213          }
    214          
    215          
    216          // Return Value는 1000배가 곱한 값이다. ex) 3.403[V]->3403 return 됨..
    217          // 12bit Value
    218          

   \                                 In section .text, align 2, keep-with-next
    219          INT16U AdctoVolt33V(INT16U Data)
    220          {
    221          	INT32U RetVal;
    222          
    223          	RetVal = (((Data)*3300) / (1 << 12));
    224              return (INT16U)RetVal;
   \                     AdctoVolt33V:
   \   00000000   0xF640 0x41E4      MOVW     R1,#+3300
   \   00000004   0x4348             MULS     R0,R1,R0
   \   00000006   0x12C1             ASRS     R1,R0,#+11
   \   00000008   0xEB00 0x5011      ADD      R0,R0,R1, LSR #+20
   \   0000000C   0x....             B.N      ?Subroutine1
    225          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0x0100             LSLS     R0,R0,#+4
   \   00000002   0x0C00             LSRS     R0,R0,#+16
   \   00000004   0x4770             BX       LR               ;; return
    226          

   \                                 In section .text, align 2, keep-with-next
    227          INT16U AdctoVolt5opamp(INT16U Data)
    228          {
    229          	INT32U  RetVal;
    230          
    231          	RetVal = ( (((INT32U)(Data)*3300)/665 )*(665 + 340))/(1 << 12);
    232          
    233              return (INT16U)RetVal;
   \                     AdctoVolt5opamp:
   \   00000000   0xF640 0x41E4      MOVW     R1,#+3300
   \   00000004   0x4348             MULS     R0,R1,R0
   \   00000006   0xF240 0x2199      MOVW     R1,#+665
   \   0000000A   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000000E   0xF240 0x31ED      MOVW     R1,#+1005
   \   00000012   0x4348             MULS     R0,R1,R0
   \   00000014                      REQUIRE ?Subroutine1
   \   00000014                      ;; // Fall through to label ?Subroutine1
    234          }
    235          

   \                                 In section .text, align 2, keep-with-next
    236          void SwapData(INT16U *a, INT16U *b)
    237          {
    238          	INT16U temp = *a;
   \                     SwapData:
   \   00000000   0x8802             LDRH     R2,[R0, #+0]
    239          
    240          	*a = *b;
   \   00000002   0x880B             LDRH     R3,[R1, #+0]
   \   00000004   0x8003             STRH     R3,[R0, #+0]
    241          	
    242          	*b = temp;
   \   00000006   0x800A             STRH     R2,[R1, #+0]
    243          }
   \   00000008   0x4770             BX       LR               ;; return
    244          
    245          
    246          //
    247          
    248          /*******************************************************************************
    249          * Function Name  : SelectSortMax
    250          * Description    : 각 ADC값들을내림차순으로 정리하여, 낮은수치 몇개를 정리하여 높은수로만 평균값함..
    251          *				   GARBAGENO: 버리는 낮은 값들.. 1이면 낮은값 1개를 버린다.
    252          *
    253          *					이 함수는 인터럽트 내에서 average를 취하지 않을 때,
    254          *					메인 호출 함수 내에서 호출하여 사용한다.
    255          * Input          : - aptr: 각 Channel의 ADC DATA들...(ADC_AVR)
    256          * Output         : None
    257          * Return         : 높은수 값들의 평균값.
    258          * Example		 : ADC_DATA[ADC_Channel_0] = SelectSort(ADC_AVR[ADC_Channel_0]);
    259          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    260          INT16U SelectAverage(INT16U *aptr, INT16U nlen)
    261          {
    262          	int i = 0;
    263          	INT32U sum = 0;
   \                     SelectAverage:
   \   00000000   0x2200             MOVS     R2,#+0
    264          	for(i = 0 ; i < nlen; i++)
   \   00000002   0x000B             MOVS     R3,R1
   \   00000004   0xD004             BEQ.N    ??SelectAverage_0
    265          	{
    266          		sum += aptr[i];
   \                     ??SelectAverage_1:
   \   00000006   0xF830 0xCB02      LDRH     R12,[R0], #+2
   \   0000000A   0x4462             ADD      R2,R12,R2
    267          	}
   \   0000000C   0x1E49             SUBS     R1,R1,#+1
   \   0000000E   0xD1FA             BNE.N    ??SelectAverage_1
    268          
    269          	return (INT16U)(sum/nlen);
   \                     ??SelectAverage_0:
   \   00000010   0xFBB2 0xF0F3      UDIV     R0,R2,R3
   \   00000014   0xB280             UXTH     R0,R0
   \   00000016   0x4770             BX       LR               ;; return
    270          	
    271          }
    272          
    273          

   \                                 In section .text, align 2, keep-with-next
    274          INT16U SelectMax(INT16U *aptr, INT16U nlen)
    275          {
    276          	int i = 0;
    277          	INT16U tmpMax = 0;
   \                     SelectMax:
   \   00000000   0x2200             MOVS     R2,#+0
    278          	for(i = 0 ; i < nlen; i++)
   \   00000002   0xB131             CBZ.N    R1,??SelectMax_0
    279          	{
    280          		if(tmpMax < aptr[i]) tmpMax = aptr[i];
   \                     ??SelectMax_1:
   \   00000004   0x8803             LDRH     R3,[R0, #+0]
   \   00000006   0x429A             CMP      R2,R3
   \   00000008   0xBF38             IT       CC 
   \   0000000A   0x461A             MOVCC    R2,R3
    281          	}
   \   0000000C   0x1C80             ADDS     R0,R0,#+2
   \   0000000E   0x1E49             SUBS     R1,R1,#+1
   \   00000010   0xD1F8             BNE.N    ??SelectMax_1
    282          
    283          	return tmpMax;
   \                     ??SelectMax_0:
   \   00000012   0x4610             MOV      R0,R2
   \   00000014   0x4770             BX       LR               ;; return
    284          }
    285          
    286          

   \                                 In section .text, align 2, keep-with-next
    287          INT16U SelectSortMax(INT16U *aptr, INT16U nlen)
    288          {
   \                     SelectSortMax:
   \   00000000   0xB4F0             PUSH     {R4-R7}
    289          	int i, j ;
    290          
    291          	if(nlen > __ADCAVR) nlen = __ADCAVR;
   \   00000002   0x2965             CMP      R1,#+101
   \   00000004   0xBF28             IT       CS 
   \   00000006   0x2164             MOVCS    R1,#+100
    292          
    293          	for(i = 0 ; i < nlen - 1; i++)
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x1E4B             SUBS     R3,R1,#+1
   \   0000000C   0x2B01             CMP      R3,#+1
   \   0000000E   0xDB18             BLT.N    ??SelectSortMax_0
   \   00000010   0x4604             MOV      R4,R0
    294          	{
    295          
    296          		for(j = i+1; j < nlen; j++ )
   \                     ??SelectSortMax_1:
   \   00000012   0x1C52             ADDS     R2,R2,#+1
   \   00000014   0x4615             MOV      R5,R2
   \   00000016   0x428A             CMP      R2,R1
   \   00000018   0xDA10             BGE.N    ??SelectSortMax_2
   \   0000001A   0xEB00 0x0645      ADD      R6,R0,R5, LSL #+1
    297          		{
    298          			if(aptr[i] > aptr[j])
   \                     ??SelectSortMax_3:
   \   0000001E   0x8837             LDRH     R7,[R6, #+0]
   \   00000020   0xF8B4 0xC000      LDRH     R12,[R4, #+0]
   \   00000024   0x4567             CMP      R7,R12
   \   00000026   0xD205             BCS.N    ??SelectSortMax_4
    299          			{
    300          				SwapData( &aptr[i] , &aptr[j]) ;
   \   00000028   0x4667             MOV      R7,R12
   \   0000002A   0xF8B6 0xC000      LDRH     R12,[R6, #+0]
   \   0000002E   0xF8A4 0xC000      STRH     R12,[R4, #+0]
   \   00000032   0x8037             STRH     R7,[R6, #+0]
    301          			}
    302          		}
   \                     ??SelectSortMax_4:
   \   00000034   0x1C6D             ADDS     R5,R5,#+1
   \   00000036   0x1CB6             ADDS     R6,R6,#+2
   \   00000038   0x428D             CMP      R5,R1
   \   0000003A   0xDBF0             BLT.N    ??SelectSortMax_3
    303           	}
   \                     ??SelectSortMax_2:
   \   0000003C   0x1CA4             ADDS     R4,R4,#+2
   \   0000003E   0x429A             CMP      R2,R3
   \   00000040   0xDBE7             BLT.N    ??SelectSortMax_1
    304          	return aptr[nlen-1];
   \                     ??SelectSortMax_0:
   \   00000042   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \   00000046   0xF830 0x0C02      LDRH     R0,[R0, #-2]
   \   0000004A   0xBCF0             POP      {R4-R7}
   \   0000004C   0x4770             BX       LR               ;; return
    305          }
    306          
    307          
    308          /*******************************************************************************
    309          * Function Name  : SelectSort
    310          * Description    : 각 ADC값들을내림차순으로 정리하여, 낮은수치 몇개를 정리하여 높은수로만 평균값함..
    311          *				   GARBAGENO: 버리는 낮은 값들.. 1이면 낮은값 1개를 버린다.
    312          *
    313          *					이 함수는 인터럽트 내에서 average를 취하지 않을 때,
    314          *					메인 호출 함수 내에서 호출하여 사용한다.
    315          * Input          : - aptr: 각 Channel의 ADC DATA들...(ADC_AVR)
    316          * Output         : None
    317          * Return         : 높은수 값들의 평균값.
    318          * Example		 : ADC_DATA[ADC_Channel_0] = SelectSort(ADC_AVR[ADC_Channel_0]);
    319          *******************************************************************************/
    320          
    321          

   \                                 In section .text, align 2, keep-with-next
    322          INT16U SelectSort(INT16U *aptr, INT16U MAXGARBAGENO, INT16U MINGARBAGENO, INT16U nlen)
    323          {
   \                     SelectSort:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB0B2             SUB      SP,SP,#+200
    324          	int sum = 0;
   \   00000006   0x2400             MOVS     R4,#+0
    325          	int i , j ;
    326          	INT32U sumtotal;
    327          	INT16U tbuf[__ADCAVR];
    328          
    329          	if(nlen > __ADCAVR) nlen = __ADCAVR;
   \   00000008   0x2B65             CMP      R3,#+101
   \   0000000A   0xBF28             IT       CS 
   \   0000000C   0x2364             MOVCS    R3,#+100
   \   0000000E   0x....             B.N      ?Subroutine2
    330          
    331          	for(i = 0; i < nlen; i++)
    332          	{
    333          		tbuf[i] = aptr[i];
    334          		sumtotal += aptr[i]; 
    335          	}
    336          
    337          	for(i = 0 ; i < nlen - 1; i++)
    338          	{
    339          
    340          		for(j = i+1; j < nlen; j++ )
    341          		{
    342          			if(tbuf[i] > tbuf[j])
    343          			{
    344          				SwapData( &tbuf[i] , &tbuf[j]) ;
    345          			}
    346          		}
    347           	}
    348          
    349          	for(i = MINGARBAGENO; i < nlen - MAXGARBAGENO; i++)
    350          	{
    351          		sum += tbuf[i];
    352          	}
    353          
    354          	return (INT16U)(sum/(nlen-MAXGARBAGENO-MINGARBAGENO));
    355          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   0xD200             BCS.N    ??Subroutine2_0
   \   00000002   0xB13B             CBZ.N    R3,??Subroutine2_1
   \                     ??Subroutine2_0:
   \   00000004   0xAD00             ADD      R5,SP,#+0
   \   00000006   0x461E             MOV      R6,R3
   \                     ??Subroutine2_2:
   \   00000008   0xF830 0x7B02      LDRH     R7,[R0], #+2
   \   0000000C   0xF825 0x7B02      STRH     R7,[R5], #+2
   \   00000010   0x1E76             SUBS     R6,R6,#+1
   \   00000012   0xD1F9             BNE.N    ??Subroutine2_2
   \                     ??Subroutine2_1:
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x1E5D             SUBS     R5,R3,#+1
   \   00000018   0x2D01             CMP      R5,#+1
   \   0000001A   0xDB1B             BLT.N    ??Subroutine2_3
   \   0000001C   0xAE00             ADD      R6,SP,#+0
   \                     ??Subroutine2_4:
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0x4680             MOV      R8,R0
   \   00000022   0x4298             CMP      R0,R3
   \   00000024   0xDA13             BGE.N    ??Subroutine2_5
   \   00000026   0xAF00             ADD      R7,SP,#+0
   \   00000028   0xEB07 0x0C48      ADD      R12,R7,R8, LSL #+1
   \                     ??Subroutine2_6:
   \   0000002C   0xF8BC 0xE000      LDRH     LR,[R12, #+0]
   \   00000030   0x8837             LDRH     R7,[R6, #+0]
   \   00000032   0x45BE             CMP      LR,R7
   \   00000034   0xD205             BCS.N    ??Subroutine2_7
   \   00000036   0x46BE             MOV      LR,R7
   \   00000038   0xF8BC 0x7000      LDRH     R7,[R12, #+0]
   \   0000003C   0x8037             STRH     R7,[R6, #+0]
   \   0000003E   0xF8AC 0xE000      STRH     LR,[R12, #+0]
   \                     ??Subroutine2_7:
   \   00000042   0xF108 0x0801      ADD      R8,R8,#+1
   \   00000046   0xF10C 0x0C02      ADD      R12,R12,#+2
   \   0000004A   0x4598             CMP      R8,R3
   \   0000004C   0xDBEE             BLT.N    ??Subroutine2_6
   \                     ??Subroutine2_5:
   \   0000004E   0x1CB6             ADDS     R6,R6,#+2
   \   00000050   0x42A8             CMP      R0,R5
   \   00000052   0xDBE4             BLT.N    ??Subroutine2_4
   \                     ??Subroutine2_3:
   \   00000054   0x4610             MOV      R0,R2
   \   00000056   0x1A59             SUBS     R1,R3,R1
   \   00000058   0x428A             CMP      R2,R1
   \   0000005A   0xDA08             BGE.N    ??Subroutine2_8
   \   0000005C   0xAB00             ADD      R3,SP,#+0
   \   0000005E   0xEB03 0x0340      ADD      R3,R3,R0, LSL #+1
   \                     ??Subroutine2_9:
   \   00000062   0xF833 0x5B02      LDRH     R5,[R3], #+2
   \   00000066   0x192C             ADDS     R4,R5,R4
   \   00000068   0x1C40             ADDS     R0,R0,#+1
   \   0000006A   0x4288             CMP      R0,R1
   \   0000006C   0xDBF9             BLT.N    ??Subroutine2_9
   \                     ??Subroutine2_8:
   \   0000006E   0x1A88             SUBS     R0,R1,R2
   \   00000070   0xFB94 0xF0F0      SDIV     R0,R4,R0
   \   00000074   0xB280             UXTH     R0,R0
   \   00000076   0xB032             ADD      SP,SP,#+200
   \   00000078   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    356          
    357          
    358          /*******************************************************************************
    359          * Function Name  : ADC_IRQHandler(period = 40us): 1000= 25
    360          * Description    : Enables or disables the selected ADC software start conversion .
    361          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    362          *                  - NewState: new state of the selected ADC software start conversion.
    363          *                    This parameter can be: ENABLE or DISABLE.
    364          * Output         : None
    365          * Return         : None
    366          *******************************************************************************/
    367          

   \                                 In section .text, align 2, keep-with-next
    368          void ADC_IRQInitHandler(void)
    369          {
   \                     ADC_IRQInitHandler:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    370          //	OSIntEnter();
    371          	INT32U cpu_sr;
    372          
    373          	CPU_CRITICAL_ENTER();										// Tell uC/OS-II that we are starting an ISR
   \   00000002   0x.... 0x....      BL       CPU_SR_Save
    374          	OSIntNesting++;
   \   00000006   0x....             LDR.N    R1,??DataTable12_7
   \   00000008   0x780A             LDRB     R2,[R1, #+0]
   \   0000000A   0x1C52             ADDS     R2,R2,#+1
   \   0000000C   0x700A             STRB     R2,[R1, #+0]
    375          	CPU_CRITICAL_EXIT();
   \   0000000E   0x.... 0x....      BL       CPU_SR_Restore
    376          
    377          //	if (ADC1->__B.SR.EOC)
    378          	{		
    379          		ADC_AVR[ADCIndex][ ADC_WRCNT[ADCIndex] ] = ADC1->DR;
   \   00000012   0x....             LDR.N    R0,??DataTable12
   \   00000014   0x7801             LDRB     R1,[R0, #+0]
   \   00000016   0xEB00 0x0241      ADD      R2,R0,R1, LSL #+1
   \   0000001A   0x....             LDR.N    R3,??DataTable12_8  ;; 0x40012008
   \   0000001C   0x8B14             LDRH     R4,[R2, #+24]
   \   0000001E   0x....             LDR.N    R5,??DataTable12_9
   \   00000020   0xF855 0x5021      LDR      R5,[R5, R1, LSL #+2]
   \   00000024   0x6C5E             LDR      R6,[R3, #+68]
   \   00000026   0xF825 0x6014      STRH     R6,[R5, R4, LSL #+1]
    380          
    381          		if(++ADC_WRCNT[ADCIndex] >= AdcBuffMax[ADCIndex])
   \   0000002A   0x8B14             LDRH     R4,[R2, #+24]
   \   0000002C   0x1C64             ADDS     R4,R4,#+1
   \   0000002E   0x8314             STRH     R4,[R2, #+24]
   \   00000030   0xB2A4             UXTH     R4,R4
   \   00000032   0x.... 0x....      ADR.W    R5,AdcBuffMax
   \   00000036   0xF855 0x5021      LDR      R5,[R5, R1, LSL #+2]
   \   0000003A   0x42AC             CMP      R4,R5
   \   0000003C   0xD306             BCC.N    ??ADC_IRQInitHandler_0
    382          		{
    383          			ADC_WRCNT[ADCIndex] = 0;
   \   0000003E   0x2300             MOVS     R3,#+0
   \   00000040   0x8313             STRH     R3,[R2, #+24]
    384          			ADCSTART[ADCIndex] = ADCFINISH;
   \   00000042   0x1809             ADDS     R1,R1,R0
   \   00000044   0x2202             MOVS     R2,#+2
   \   00000046   0x710A             STRB     R2,[R1, #+4]
    385          			ASTART = FALSE;
   \   00000048   0x7043             STRB     R3,[R0, #+1]
   \   0000004A   0x....             B.N      ?Subroutine3
    386          		}
    387          		else{
    388          			ADC1->__B.CR2.SWSTART = ENABLE;
   \                     ??ADC_IRQInitHandler_0:
   \   0000004C   0x6818             LDR      R0,[R3, #+0]
   \   0000004E   0xF040 0x4080      ORR      R0,R0,#0x40000000
   \   00000052   0x6018             STR      R0,[R3, #+0]
    389          		}
    390          //		RUNLEDSEL ^= 1;
    391          	}
    392          #if 0
    393          	if (ADC2->__B.SR.EOC)
    394          	{		
    395          		ADC_AVR[ADCIndex][ ADC_WRCNT[ADCIndex] ] = ADC2->DR;
    396          
    397          		if(++ADC_WRCNT[ADCIndex] >= AdcBuffMax[ADCIndex])
    398          		{
    399          			ADC_WRCNT[ADCIndex] = 0;
    400          			ADCSTART[ADCIndex] = ADCFINISH;
    401          			ASTART = FALSE;
    402          		}
    403          		else{
    404          			ADC2->__B.CR2.SWSTART = ENABLE;
    405          		}
    406          //		RUNLEDSEL ^= 1;
    407          	}	
    408          #endif	
    409          //	RUNLEDSEL ^= 1;
    410          
    411          	OSIntExit();											// Tell uC/OS-II that we are leaving the ISR
   \   00000054                      REQUIRE ?Subroutine3
   \   00000054                      ;; // Fall through to label ?Subroutine3
    412          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine3:
   \   00000000   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000004   0x.... 0x....      B.W      OSIntExit
    413          
    414          
    415          
    416          

   \                                 In section .text, align 2, keep-with-next
    417          void ADC3_IRQInitHandler(void)
    418          {
   \                     ADC3_IRQInitHandler:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    419          //	OSIntEnter();
    420          	INT32U cpu_sr;
    421          
    422          	CPU_CRITICAL_ENTER();										// Tell uC/OS-II that we are starting an ISR
   \   00000002   0x.... 0x....      BL       CPU_SR_Save
    423          	OSIntNesting++;
   \   00000006   0x....             LDR.N    R1,??DataTable12_7
   \   00000008   0x780A             LDRB     R2,[R1, #+0]
   \   0000000A   0x1C52             ADDS     R2,R2,#+1
   \   0000000C   0x700A             STRB     R2,[R1, #+0]
    424          	CPU_CRITICAL_EXIT();
   \   0000000E   0x.... 0x....      BL       CPU_SR_Restore
    425          
    426          //	if (ADC1->__B.SR.EOC)
    427          	{		
    428          		ADC3_AVR[ADC3Index][ ADC3_WRCNT[ADC3Index] ] = ADC3->DR;
   \   00000012   0x....             LDR.N    R0,??DataTable12
   \   00000014   0x7881             LDRB     R1,[R0, #+2]
   \   00000016   0x....             LDR.N    R2,??DataTable12_3
   \   00000018   0xEB02 0x0441      ADD      R4,R2,R1, LSL #+1
   \   0000001C   0x....             LDR.N    R3,??DataTable12_10  ;; 0x40012208
   \   0000001E   0x8AA5             LDRH     R5,[R4, #+20]
   \   00000020   0x....             LDR.N    R6,??DataTable12_11
   \   00000022   0xF856 0x6021      LDR      R6,[R6, R1, LSL #+2]
   \   00000026   0x6C5F             LDR      R7,[R3, #+68]
   \   00000028   0xF826 0x7015      STRH     R7,[R6, R5, LSL #+1]
    429          
    430          		if(++ADC3_WRCNT[ADC3Index] >= Adc3BuffMax[ADC3Index])
   \   0000002C   0x8AA5             LDRH     R5,[R4, #+20]
   \   0000002E   0x1C6D             ADDS     R5,R5,#+1
   \   00000030   0x82A5             STRH     R5,[R4, #+20]
   \   00000032   0xB2AD             UXTH     R5,R5
   \   00000034   0x.... 0x....      ADR.W    R6,Adc3BuffMax
   \   00000038   0xF856 0x6021      LDR      R6,[R6, R1, LSL #+2]
   \   0000003C   0x42B5             CMP      R5,R6
   \   0000003E   0xD306             BCC.N    ??ADC3_IRQInitHandler_0
    431          		{
    432          			ADC3_WRCNT[ADC3Index] = 0;
   \   00000040   0x2300             MOVS     R3,#+0
   \   00000042   0x82A3             STRH     R3,[R4, #+20]
    433          			ADC3START[ADC3Index] = ADCFINISH;
   \   00000044   0x2302             MOVS     R3,#+2
   \   00000046   0x548B             STRB     R3,[R1, R2]
    434          			ASTART3 = FALSE;
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0x70C1             STRB     R1,[R0, #+3]
   \   0000004C   0xE003             B.N      ??ADC3_IRQInitHandler_1
    435          		}
    436          		else{
    437          			ADC3->__B.CR2.SWSTART = ENABLE;
   \                     ??ADC3_IRQInitHandler_0:
   \   0000004E   0x6818             LDR      R0,[R3, #+0]
   \   00000050   0xF040 0x4080      ORR      R0,R0,#0x40000000
   \   00000054   0x6018             STR      R0,[R3, #+0]
    438          		}
    439          	}
    440          	RUNLEDSEL ^= 1;
   \                     ??ADC3_IRQInitHandler_1:
   \   00000056   0x....             LDR.N    R0,??DataTable12_12  ;; 0x40020414
   \   00000058   0x6801             LDR      R1,[R0, #+0]
   \   0000005A   0xF081 0x0104      EOR      R1,R1,#0x4
   \   0000005E   0x6001             STR      R1,[R0, #+0]
    441          
    442          	OSIntExit();											// Tell uC/OS-II that we are leaving the ISR
   \   00000060   0xE8BD 0x40F1      POP      {R0,R4-R7,LR}
   \   00000064   0x.... 0x....      B.W      OSIntExit
    443          }
    444          

   \                                 In section .text, align 2, keep-with-next
    445          int ReadEnvTempTable(int Adcvalue)
    446          {
    447          	INT32S tmpx10 = AdctoVolt33V(Adcvalue);
    448          
    449          	tmpx10 = (tmpx10 - 500);
    450          
    451          	return tmpx10;	// 10배 값이 return 된다. 
   \                     ReadEnvTempTable:
   \   00000000   0xB280             UXTH     R0,R0
   \   00000002   0xF640 0x41E4      MOVW     R1,#+3300
   \   00000006   0x4348             MULS     R0,R1,R0
   \   00000008   0x12C1             ASRS     R1,R0,#+11
   \   0000000A   0xEB00 0x5011      ADD      R0,R0,R1, LSR #+20
   \   0000000E   0x0100             LSLS     R0,R0,#+4
   \   00000010   0x0C00             LSRS     R0,R0,#+16
   \   00000012   0xF5A0 0x70FA      SUB      R0,R0,#+500
   \   00000016   0x4770             BX       LR               ;; return
    452          }
    453          

   \                                 In section .text, align 2, keep-with-next
    454          void BubbleSort(INT16U array[], INT16U min, INT16U max)
    455          {
    456              // loop through every item in the array
    457              for (int i = min ; i <= max ; i++)
   \                     BubbleSort:
   \   00000000   0x428A             CMP      R2,R1
   \   00000002   0xDA00             BGE.N    ??BubbleSort_0
   \   00000004   0x4770             BX       LR
   \                     ??BubbleSort_0:
   \   00000006   0xB470             PUSH     {R4-R6}
    458              {
    459                  // loop a second time from the back of the array
    460                  for (int j = max ; j > i ; j--)
   \                     ??BubbleSort_1:
   \   00000008   0x4613             MOV      R3,R2
   \   0000000A   0x4291             CMP      R1,R2
   \   0000000C   0xDA0D             BGE.N    ??BubbleSort_2
   \   0000000E   0xEB00 0x0443      ADD      R4,R0,R3, LSL #+1
    461                  {
    462                      // swap the elements if necessary
    463                      if (array[j-1] > array[j])
   \                     ??BubbleSort_3:
   \   00000012   0xF834 0x5C02      LDRH     R5,[R4, #-2]
   \   00000016   0x8826             LDRH     R6,[R4, #+0]
   \   00000018   0x42AE             CMP      R6,R5
   \   0000001A   0xBF3C             ITT      CC 
   \   0000001C   0xF824 0x6C02      STRHCC   R6,[R4, #-2]
   \   00000020   0x8025             STRHCC   R5,[R4, #+0]
    464                      {
    465                          int copy = array[j-1] ;
    466                          array[j-1] = array[j] ;
    467                          array[j] = copy ;
    468                      }
    469                  }
   \   00000022   0x1E5B             SUBS     R3,R3,#+1
   \   00000024   0x1EA4             SUBS     R4,R4,#+2
   \   00000026   0x4299             CMP      R1,R3
   \   00000028   0xDBF3             BLT.N    ??BubbleSort_3
    470              }
   \                     ??BubbleSort_2:
   \   0000002A   0x1C49             ADDS     R1,R1,#+1
   \   0000002C   0x428A             CMP      R2,R1
   \   0000002E   0xDAEB             BGE.N    ??BubbleSort_1
    471          }
   \   00000030   0xBC70             POP      {R4-R6}
   \   00000032   0x4770             BX       LR               ;; return
    472           

   \                                 In section .text, align 2, keep-with-next
    473          INT16U Average_Sum(INT16U *aptr,INT16U AvgMAX, INT16U AvgMIN, INT16U nlen)
    474          {
   \                     Average_Sum:
   \   00000000   0xB430             PUSH     {R4,R5}
    475          	INT32U sum = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    476              int i= 0;
    477          	for(i = AvgMIN; i < (nlen - AvgMAX); i++)
   \   00000004   0x4615             MOV      R5,R2
   \   00000006   0x1A59             SUBS     R1,R3,R1
   \   00000008   0x428A             CMP      R2,R1
   \   0000000A   0xDA07             BGE.N    ??Average_Sum_0
   \   0000000C   0xEB00 0x0045      ADD      R0,R0,R5, LSL #+1
    478          	{
    479          		sum += aptr[i];
   \                     ??Average_Sum_1:
   \   00000010   0xF830 0x3B02      LDRH     R3,[R0], #+2
   \   00000014   0x191C             ADDS     R4,R3,R4
    480          	}
   \   00000016   0x1C6D             ADDS     R5,R5,#+1
   \   00000018   0x428D             CMP      R5,R1
   \   0000001A   0xDBF9             BLT.N    ??Average_Sum_1
    481          	return sum = ((INT16U)(sum/(nlen- AvgMAX-AvgMIN)));
   \                     ??Average_Sum_0:
   \   0000001C   0x1A88             SUBS     R0,R1,R2
   \   0000001E   0xFBB4 0xF0F0      UDIV     R0,R4,R0
   \   00000022   0xB280             UXTH     R0,R0
   \   00000024   0xBC30             POP      {R4,R5}
   \   00000026   0x4770             BX       LR               ;; return
    482          }
    483          
    484          

   \                                 In section .text, align 2, keep-with-next
    485          INT16U SelectSort_1(INT16U *aptr,INT16U *AvgValue, INT16U *PeakValue, INT16U AvgMAX, INT16U AvgMIN, INT16U PeakMAX, INT16U PeakMIN, INT16U nlen)
    486          {
   \                     SelectSort_1:
   \   00000000   0xE92D 0x4FF6      PUSH     {R1,R2,R4-R11,LR}
   \   00000004   0xB0B2             SUB      SP,SP,#+200
   \   00000006   0x461C             MOV      R4,R3
   \   00000008   0x993D             LDR      R1,[SP, #+244]
   \   0000000A   0x9A3E             LDR      R2,[SP, #+248]
   \   0000000C   0x9B3F             LDR      R3,[SP, #+252]
   \   0000000E   0x9F40             LDR      R7,[SP, #+256]
    487          	int sum = 0;
   \   00000010   0xF04F 0x0800      MOV      R8,#+0
    488          	int sum1 = 0;
   \   00000014   0x46C2             MOV      R10,R8
    489          	
    490          	int i= 0 , j = 0;
   \   00000016   0x46C4             MOV      R12,R8
    491          	INT32U sumtotal;
    492          	INT16U tbuf[__ADCAVR];
    493          
    494          	if(nlen > __ADCAVR) nlen = __ADCAVR;
   \   00000018   0xB2BF             UXTH     R7,R7
   \   0000001A   0x2F65             CMP      R7,#+101
   \   0000001C   0xBF28             IT       CS 
   \   0000001E   0x2764             MOVCS    R7,#+100
   \   00000020   0xD201             BCS.N    ??SelectSort_1_0
    495          
    496          	for(i = 0; i < nlen; i++)
   \   00000022   0x2F01             CMP      R7,#+1
   \   00000024   0xDB08             BLT.N    ??SelectSort_1_1
    497          	{
    498          		tbuf[i] = aptr[i];
   \                     ??SelectSort_1_0:
   \   00000026   0xF830 0xE01C      LDRH     LR,[R0, R12, LSL #+1]
   \   0000002A   0xAD00             ADD      R5,SP,#+0
   \   0000002C   0xF825 0xE01C      STRH     LR,[R5, R12, LSL #+1]
    499          		sumtotal += aptr[i]; 
    500          	}
   \   00000030   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   00000034   0x45BC             CMP      R12,R7
   \   00000036   0xDBF6             BLT.N    ??SelectSort_1_0
    501          #if 1
    502          	for(i = 0 ; i < nlen - 1; i++)
   \                     ??SelectSort_1_1:
   \   00000038   0x46C4             MOV      R12,R8
   \   0000003A   0xF1A7 0x0B01      SUB      R11,R7,#+1
   \   0000003E   0xF1BB 0x0F01      CMP      R11,#+1
   \   00000042   0xDB1B             BLT.N    ??SelectSort_1_2
   \   00000044   0xAE00             ADD      R6,SP,#+0
    503          	{
    504          		for(j = i+1; j < nlen; j++ )
   \                     ??SelectSort_1_3:
   \   00000046   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   0000004A   0x46E6             MOV      LR,R12
   \   0000004C   0x45BC             CMP      R12,R7
   \   0000004E   0xDA12             BGE.N    ??SelectSort_1_4
   \   00000050   0xA800             ADD      R0,SP,#+0
   \   00000052   0xEB00 0x004E      ADD      R0,R0,LR, LSL #+1
    505          		{
    506          			if(tbuf[i] > tbuf[j])
   \                     ??SelectSort_1_5:
   \   00000056   0x8805             LDRH     R5,[R0, #+0]
   \   00000058   0xF8B6 0x9000      LDRH     R9,[R6, #+0]
   \   0000005C   0x454D             CMP      R5,R9
   \   0000005E   0xD205             BCS.N    ??SelectSort_1_6
    507          			{
    508          				SwapData( &tbuf[i] , &tbuf[j]) ;
   \   00000060   0x464D             MOV      R5,R9
   \   00000062   0xF8B0 0x9000      LDRH     R9,[R0, #+0]
   \   00000066   0xF8A6 0x9000      STRH     R9,[R6, #+0]
   \   0000006A   0x8005             STRH     R5,[R0, #+0]
    509          			}
    510          		}
   \                     ??SelectSort_1_6:
   \   0000006C   0xF10E 0x0E01      ADD      LR,LR,#+1
   \   00000070   0x1C80             ADDS     R0,R0,#+2
   \   00000072   0x45BE             CMP      LR,R7
   \   00000074   0xDBEF             BLT.N    ??SelectSort_1_5
    511           	}
   \                     ??SelectSort_1_4:
   \   00000076   0x1CB6             ADDS     R6,R6,#+2
   \   00000078   0x45DC             CMP      R12,R11
   \   0000007A   0xDBE4             BLT.N    ??SelectSort_1_3
    512          #endif
    513          	for(i = AvgMIN; i < (nlen - AvgMAX); i++)
   \                     ??SelectSort_1_2:
   \   0000007C   0xB289             UXTH     R1,R1
   \   0000007E   0x468C             MOV      R12,R1
   \   00000080   0x1B38             SUBS     R0,R7,R4
   \   00000082   0x4281             CMP      R1,R0
   \   00000084   0xDA09             BGE.N    ??SelectSort_1_7
   \   00000086   0xAC00             ADD      R4,SP,#+0
   \   00000088   0xEB04 0x044C      ADD      R4,R4,R12, LSL #+1
    514          	{
    515          		sum += tbuf[i];
   \                     ??SelectSort_1_8:
   \   0000008C   0xF834 0xEB02      LDRH     LR,[R4], #+2
   \   00000090   0x44F0             ADD      R8,LR,R8
    516          	}
   \   00000092   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   00000096   0x4584             CMP      R12,R0
   \   00000098   0xDBF8             BLT.N    ??SelectSort_1_8
    517          	*AvgValue = ((INT16U)(sum/(nlen- AvgMAX-AvgMIN)));
   \                     ??SelectSort_1_7:
   \   0000009A   0x1A44             SUBS     R4,R0,R1
   \   0000009C   0xFB98 0xF4F4      SDIV     R4,R8,R4
   \   000000A0   0x9D32             LDR      R5,[SP, #+200]
   \   000000A2   0x802C             STRH     R4,[R5, #+0]
    518          
    519          
    520          	for(i = PeakMIN; i < (nlen - PeakMAX); i++)
   \   000000A4   0xB29B             UXTH     R3,R3
   \   000000A6   0x461C             MOV      R4,R3
   \   000000A8   0xB292             UXTH     R2,R2
   \   000000AA   0x1ABA             SUBS     R2,R7,R2
   \   000000AC   0x4293             CMP      R3,R2
   \   000000AE   0xDA08             BGE.N    ??SelectSort_1_9
   \   000000B0   0xAF00             ADD      R7,SP,#+0
   \   000000B2   0xEB07 0x0744      ADD      R7,R7,R4, LSL #+1
    521          	{
    522          //		SerPtr->printf("Sort[%d][%d]\n",i, tbuf[i]);
    523          
    524          		sum1 += tbuf[i];
   \                     ??SelectSort_1_10:
   \   000000B6   0xF837 0x5B02      LDRH     R5,[R7], #+2
   \   000000BA   0x44AA             ADD      R10,R5,R10
    525          	}
   \   000000BC   0x1C64             ADDS     R4,R4,#+1
   \   000000BE   0x4294             CMP      R4,R2
   \   000000C0   0xDBF9             BLT.N    ??SelectSort_1_10
    526          	*PeakValue = ((INT16U)(sum1/(nlen-PeakMAX-PeakMIN)));
   \                     ??SelectSort_1_9:
   \   000000C2   0x1AD2             SUBS     R2,R2,R3
   \   000000C4   0xFB9A 0xF2F2      SDIV     R2,R10,R2
   \   000000C8   0x9B33             LDR      R3,[SP, #+204]
   \   000000CA   0x801A             STRH     R2,[R3, #+0]
    527          
    528          	return (INT16U)(sum/(nlen-(AvgMAX-AvgMIN)));
   \   000000CC   0x1808             ADDS     R0,R1,R0
   \   000000CE   0xFB98 0xF0F0      SDIV     R0,R8,R0
   \   000000D2   0xB280             UXTH     R0,R0
   \   000000D4   0xB034             ADD      SP,SP,#+208
   \   000000D6   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    529          }
    530          
    531          
    532          

   \                                 In section .text, align 2, keep-with-next
    533          INT16U SelectSort_MinMax(INT16U *aptr, INT16U MAXGARBAGENO, INT16U MINGARBAGENO, INT16U nlen, INT8U Mode)
    534          {
   \                     SelectSort_MinMax:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB0B2             SUB      SP,SP,#+200
    535          	int sum = 0;
   \   00000006   0x2400             MOVS     R4,#+0
    536          	int i , j ;
    537          	INT16U tbuf[__ADCAVR];
    538          
    539          	if(nlen > __ADCAVR) nlen = __ADCAVR;
   \   00000008   0x2B65             CMP      R3,#+101
   \   0000000A   0xBF28             IT       CS 
   \   0000000C   0x2364             MOVCS    R3,#+100
   \   0000000E                      REQUIRE ?Subroutine2
   \   0000000E                      ;; // Fall through to label ?Subroutine2
    540          	
    541          	for(i = 0; i < nlen; i++)
    542          	{
    543          		tbuf[i] = aptr[i];
    544          	}
    545          
    546          	for(i = 0 ; i < nlen - 1; i++)
    547          	{
    548          		for(j = i+1; j < nlen; j++ )
    549          		{
    550          			if(tbuf[i] > tbuf[j])
    551          			{
    552          				SwapData( &tbuf[i] , &tbuf[j]);
    553          			}
    554          		}
    555           	}
    556          
    557          	for(i = MINGARBAGENO; i < (nlen - MAXGARBAGENO); i++)
    558          	{
    559          		sum += tbuf[i];
    560          
    561          		
    562          		#ifdef _DEBUG_Test
    563          		if(AmpSts->ShunDownValue == 2)
    564          		{
    565          			if(Mode == Enable)
    566          			{
    567          				pUSART2.printf("Sort[%d][%d]\n",i, tbuf[i]);
    568          			}
    569          		}
    570          		#endif
    571          	}
    572          
    573          	return (INT16U)(sum/(nlen-MAXGARBAGENO-MINGARBAGENO));
    574          }
    575          
    576          
    577          
    578          
    579          static int quick_sort_partition( INT16U array[], int start_pos, int end_pos)
    580          {
    581          
    582          	float pivot = array[start_pos];       // Smaller than pivot on left; larger on right
    583          	int left_index = start_pos;    // First element
    584          	int right_index = end_pos; // Last element
    585          
    586          	while ( 1 ) // Loop forever; return once partitioning is completed
    587          	{
    588          		// Skip over large elements on right
    589          
    590          		while ( array[right_index] > pivot && right_index >= start_pos )      
    591          		right_index--;
    592          
    593          		// Skip over small elements on left
    594          
    595          		while ( array[left_index] < pivot && left_index <= end_pos )        
    596          		left_index ++;                    
    597          
    598          		if ( left_index < right_index )          // Exchange if halves aren't complete
    599          		{
    600          			INT16U temp = array[left_index];
    601          
    602          			array[left_index] = array[right_index];
    603          
    604          			array[right_index] = temp;
    605          
    606          			left_index ++ ;                         // Skip over exchanged values
    607          			right_index -- ;
    608          		}
    609          	else                                            // Otherwise, return location of pivot
    610          
    611          	return  right_index;
    612          	}
    613          }
    614          
    615           
    616           

   \                                 In section .text, align 2, keep-with-next
    617          void quick_sort( INT16U array[], int start_pos, int end_pos)
    618          {
   \                     quick_sort:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4690             MOV      R8,R2
    619          
    620             if ( start_pos == end_pos ) // Only one element
   \   0000000A   0x4545             CMP      R5,R8
   \   0000000C   0xD031             BEQ.N    ??quick_sort_0
    621             return;
    622          
    623             int middle_pos = quick_sort_partition( array, start_pos, end_pos);  // Reposition elements
   \                     ??quick_sort_1:
   \   0000000E   0xF834 0x0015      LDRH     R0,[R4, R5, LSL #+1]
   \   00000012   0x.... 0x....      BL       __aeabi_ui2f
   \   00000016   0x4681             MOV      R9,R0
   \   00000018   0x462E             MOV      R6,R5
   \   0000001A   0x4647             MOV      R7,R8
   \   0000001C   0xE007             B.N      ??quick_sort_2
   \                     ??quick_sort_3:
   \   0000001E   0xF834 0x0017      LDRH     R0,[R4, R7, LSL #+1]
   \   00000022   0xF824 0x0016      STRH     R0,[R4, R6, LSL #+1]
   \   00000026   0xF824 0xA017      STRH     R10,[R4, R7, LSL #+1]
   \   0000002A   0x1C76             ADDS     R6,R6,#+1
   \                     ??quick_sort_4:
   \   0000002C   0x1E7F             SUBS     R7,R7,#+1
   \                     ??quick_sort_2:
   \   0000002E   0xF834 0x0017      LDRH     R0,[R4, R7, LSL #+1]
   \   00000032   0x.... 0x....      BL       __aeabi_ui2f
   \   00000036   0x4601             MOV      R1,R0
   \   00000038   0x4648             MOV      R0,R9
   \   0000003A   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000003E   0xD203             BCS.N    ??quick_sort_5
   \   00000040   0x42AF             CMP      R7,R5
   \   00000042   0xDB01             BLT.N    ??quick_sort_5
   \   00000044   0xE7F2             B.N      ??quick_sort_4
   \                     ??quick_sort_6:
   \   00000046   0x1C76             ADDS     R6,R6,#+1
   \                     ??quick_sort_5:
   \   00000048   0xF834 0xA016      LDRH     R10,[R4, R6, LSL #+1]
   \   0000004C   0x4650             MOV      R0,R10
   \   0000004E   0x.... 0x....      BL       __aeabi_ui2f
   \   00000052   0x4649             MOV      R1,R9
   \   00000054   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000058   0xD201             BCS.N    ??quick_sort_7
   \   0000005A   0x45B0             CMP      R8,R6
   \   0000005C   0xDAF3             BGE.N    ??quick_sort_6
   \                     ??quick_sort_7:
   \   0000005E   0x42BE             CMP      R6,R7
   \   00000060   0xDBDD             BLT.N    ??quick_sort_3
    624          
    625             quick_sort( array, start_pos, middle_pos);          // Sort left half
   \   00000062   0x463A             MOV      R2,R7
   \   00000064   0x4629             MOV      R1,R5
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0xF7FF 0xFFCA      BL       quick_sort
    626             quick_sort( array, middle_pos + 1, end_pos);     	// Sort right half
   \   0000006C   0x1C7D             ADDS     R5,R7,#+1
    627          }
   \   0000006E   0x4545             CMP      R5,R8
   \   00000070   0xD1CD             BNE.N    ??quick_sort_1
   \                     ??quick_sort_0:
   \   00000072   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    628          
    629           
    630          
    631          

   \                                 In section .text, align 2, keep-with-next
    632          void SortSelect(INT16U *aptr, int start_pos, int end_pos)
    633          {
    634          	BubbleSort(aptr,start_pos,end_pos-1);
   \                     SortSelect:
   \   00000000   0x1E52             SUBS     R2,R2,#+1
   \   00000002   0xB292             UXTH     R2,R2
   \   00000004   0xB289             UXTH     R1,R1
   \   00000006   0x....             B.N      BubbleSort
    635          //	quick_sort(aptr,start_pos, end_pos-1);
    636          //	mergeSort(aptr,start_pos, end_pos-1);
    637          }
    638          

   \                                 In section .text, align 2, keep-with-next
    639          INT32U average_rssi(INT16U rssi[], int array_size)
    640          {
   \                     average_rssi:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    641          
    642          	INT16U sum = 0;
    643          	int i;
    644          
    645          	if(array_size > __ADCAVR) array_size = __ADCAVR;
   \   00000006   0x2D65             CMP      R5,#+101
   \   00000008   0xBFAE             ITEE     GE 
   \   0000000A   0x2564             MOVGE    R5,#+100
   \   0000000C   0x2600             MOVLT    R6,#+0
   \   0000000E   0x2D01             CMPLT    R5,#+1
    646          
    647          	for(i=0; i<array_size; i++)
   \   00000010   0xDB00             BLT.N    ??average_rssi_0
   \   00000012   0x462E             MOV      R6,R5
    648          	{
    649          	//	   SerPtr->printf("0 : array_size[%d][%d]>[%d]\n", i,rssi[i],array_size);
    650          	}
    651          
    652          	quick_sort(rssi, 0, array_size-1);
   \                     ??average_rssi_0:
   \   00000014   0x1E6A             SUBS     R2,R5,#+1
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x.... 0x....      BL       quick_sort
    653          
    654          	sum += rssi[i];
    655          
    656          	sum /= (array_size-20);
    657          
    658          	return sum;
   \   0000001C   0xF834 0x0016      LDRH     R0,[R4, R6, LSL #+1]
   \   00000020   0xF1A5 0x0114      SUB      R1,R5,#+20
   \   00000024   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000028   0xB280             UXTH     R0,R0
   \   0000002A   0xBD70             POP      {R4-R6,PC}       ;; return
    659          }
    660           

   \                                 In section .text, align 2, keep-with-next
    661          void insertionSort(INT16U array[], INT16U min, INT16U max)
    662          {
    663          	int key ;
    664          	// we loop through all elements in the original array from the second element
    665          	for (int j = 1 ; j <= max ; j++)
   \                     insertionSort:
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xB902             CBNZ.N   R2,??insertionSort_0
   \   00000004   0x4770             BX       LR
   \                     ??insertionSort_0:
   \   00000006   0xB4F0             PUSH     {R4-R7}
   \   00000008   0x1C83             ADDS     R3,R0,#+2
    666          	{
    667          		// store the current element as the key
    668          		key = array[j] ;
   \                     ??insertionSort_1:
   \   0000000A   0x881C             LDRH     R4,[R3, #+0]
    669          		// get the element just before the current element
    670          		int i = j - 1 ;
   \   0000000C   0x1E4D             SUBS     R5,R1,#+1
   \   0000000E   0xEB00 0x0645      ADD      R6,R0,R5, LSL #+1
   \                     ??insertionSort_2:
   \   00000012   0x8837             LDRH     R7,[R6, #+0]
   \   00000014   0x42BC             CMP      R4,R7
   \   00000016   0xDA04             BGE.N    ??insertionSort_3
    671          		// loop through all elements from the key to the start
    672          		// check if the current element is smaller than the key
    673          		while (i >= 0 && array[i] > key)
    674          		{
    675          		 // we move the current element backward
    676          		 array[i+1] = array[i] ;
   \   00000018   0x8077             STRH     R7,[R6, #+2]
    677          		 i-- ;
   \   0000001A   0x1E6D             SUBS     R5,R5,#+1
   \   0000001C   0x1EB6             SUBS     R6,R6,#+2
    678          		}
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD5F7             BPL.N    ??insertionSort_2
    679          		// we finally move the key
    680          		array[i+1] = key ;
   \                     ??insertionSort_3:
   \   00000022   0xEB00 0x0545      ADD      R5,R0,R5, LSL #+1
   \   00000026   0x806C             STRH     R4,[R5, #+2]
    681          	}
   \   00000028   0x1C49             ADDS     R1,R1,#+1
   \   0000002A   0x1C9B             ADDS     R3,R3,#+2
   \   0000002C   0x428A             CMP      R2,R1
   \   0000002E   0xDAEC             BGE.N    ??insertionSort_1
    682          }
   \   00000030   0xBCF0             POP      {R4-R7}
   \   00000032   0x4770             BX       LR               ;; return
    683          
    684          

   \                                 In section .text, align 2, keep-with-next
    685          void mergeSort(INT16U array[], INT16U min, INT16U max)
    686          {
   \                     mergeSort:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    687          	int i;
    688          	
    689          	for(i=0; i<max; i++)
    690          	{
    691          //	   SerPtr->printf("0 : array_size[%d][%d]>[%d]\n", i,array[i],max);
    692          	}
    693          
    694              // prerequisite
    695              if (min < max)
   \   00000008   0x42B5             CMP      R5,R6
   \   0000000A   0xD21D             BCS.N    ??mergeSort_0
    696              {
    697                  // get the middle point
    698                  int mid = (int)floor((max+min)/2) ;
   \   0000000C   0x19A8             ADDS     R0,R5,R6
   \   0000000E   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   00000012   0x1040             ASRS     R0,R0,#+1
   \   00000014   0x.... 0x....      BL       __aeabi_i2d
   \   00000018   0x.... 0x....      BL       floor
   \   0000001C   0x.... 0x....      BL       __aeabi_d2iz
   \   00000020   0x4607             MOV      R7,R0
    699                  
    700                  // apply merge sort to both parts of this
    701                  mergeSort(array, min, mid) ;
   \   00000022   0xB2BA             UXTH     R2,R7
   \   00000024   0x4629             MOV      R1,R5
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0xF7FF 0xFFEA      BL       mergeSort
    702                  mergeSort(array, mid+1, max) ;
   \   0000002C   0x4632             MOV      R2,R6
   \   0000002E   0x1C79             ADDS     R1,R7,#+1
   \   00000030   0xB289             UXTH     R1,R1
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0xF7FF 0xFFE4      BL       mergeSort
    703                  
    704                  // and finally merge all that sorted stuff
    705                  merge(array, min, max, mid) ;
   \   00000038   0xB2BB             UXTH     R3,R7
   \   0000003A   0x4632             MOV      R2,R6
   \   0000003C   0x4629             MOV      R1,R5
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0xB001             ADD      SP,SP,#+4
   \   00000042   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \   00000046   0x....             B.N      merge
    706              }
    707          
    708          
    709          }
   \                     ??mergeSort_0:
   \   00000048   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    710          

   \                                 In section .text, align 2, keep-with-next
    711          void merge(INT16U array[], INT16U min, INT16U max, INT16U mid)
    712          {
   \                     merge:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB0E4             SUB      SP,SP,#+400
    713              int firstIndex = min ;
   \   00000006   0x460E             MOV      R6,R1
    714              int secondIndex = mid + 1 ;
   \   00000008   0x1C5D             ADDS     R5,R3,#+1
    715              int index = min ;
   \   0000000A   0x460C             MOV      R4,R1
   \   0000000C   0xAF00             ADD      R7,SP,#+0
   \   0000000E   0xE011             B.N      ??merge_0
    716          //    int tempArray[max] ;
    717              int tempArray[__ADCAVR] ;
    718              // if there are still objects in both arrays
    719              while ((firstIndex <= mid) && (secondIndex <= max))
    720              {
    721                  if (array[firstIndex] < array[secondIndex])
    722                  {
    723                      tempArray[index] = array[firstIndex] ;
    724                      index++ ;
    725                      firstIndex++ ;
    726                  }
    727                  else
    728                  {
    729                      tempArray[index] = array[secondIndex] ;
   \                     ??merge_1:
   \   00000010   0xF847 0xC024      STR      R12,[R7, R4, LSL #+2]
    730                      index++ ;
   \   00000014   0x4674             MOV      R4,LR
    731                      secondIndex++ ;
   \   00000016   0x1C6D             ADDS     R5,R5,#+1
   \                     ??merge_2:
   \   00000018   0x42AA             CMP      R2,R5
   \   0000001A   0xDB2D             BLT.N    ??merge_3
    732                  }
   \   0000001C   0xF830 0xC015      LDRH     R12,[R0, R5, LSL #+1]
   \   00000020   0xF830 0x8016      LDRH     R8,[R0, R6, LSL #+1]
   \   00000024   0xF104 0x0E01      ADD      LR,R4,#+1
   \   00000028   0x45E0             CMP      R8,R12
   \   0000002A   0xD2F1             BCS.N    ??merge_1
   \   0000002C   0xF847 0x8024      STR      R8,[R7, R4, LSL #+2]
   \   00000030   0x4674             MOV      R4,LR
   \   00000032   0x1C76             ADDS     R6,R6,#+1
    733              }
   \                     ??merge_0:
   \   00000034   0x42B3             CMP      R3,R6
   \   00000036   0xDAEF             BGE.N    ??merge_2
   \   00000038   0x42AA             CMP      R2,R5
   \   0000003A   0xDB0C             BLT.N    ??merge_4
   \   0000003C   0xEB00 0x0345      ADD      R3,R0,R5, LSL #+1
   \   00000040   0xAE00             ADD      R6,SP,#+0
   \   00000042   0xEB06 0x0684      ADD      R6,R6,R4, LSL #+2
    734              
    735              // terminates the object of the lower array
    736              while (firstIndex <= mid)
    737              {
    738                  tempArray[index] = array[firstIndex] ;
    739                  index++ ;
    740                  firstIndex++ ;
    741              }
    742              
    743              // terminates the object of the upper array
    744              while (secondIndex <= max)
    745              {
    746                  tempArray[index] = array[secondIndex] ;
   \                     ??merge_5:
   \   00000046   0xF833 0x7B02      LDRH     R7,[R3], #+2
   \   0000004A   0xF846 0x7B04      STR      R7,[R6], #+4
    747                  index++ ;
   \   0000004E   0x1C64             ADDS     R4,R4,#+1
    748                  secondIndex++ ;
   \   00000050   0x1C6D             ADDS     R5,R5,#+1
   \   00000052   0x42AA             CMP      R2,R5
   \   00000054   0xDAF7             BGE.N    ??merge_5
    749              }
    750              
    751              // transfer to the initial array
    752              for (int i = min ; i < index ; i++)
   \                     ??merge_4:
   \   00000056   0x42A1             CMP      R1,R4
   \   00000058   0xDA0B             BGE.N    ??merge_6
   \   0000005A   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \   0000005E   0xAA00             ADD      R2,SP,#+0
   \   00000060   0xEB02 0x0281      ADD      R2,R2,R1, LSL #+2
    753                  array[i] = tempArray[i] ;
   \                     ??merge_7:
   \   00000064   0xF852 0x3B04      LDR      R3,[R2], #+4
   \   00000068   0xF820 0x3B02      STRH     R3,[R0], #+2
   \   0000006C   0x1C49             ADDS     R1,R1,#+1
   \   0000006E   0x42A1             CMP      R1,R4
   \   00000070   0xDBF8             BLT.N    ??merge_7
    754          }
   \                     ??merge_6:
   \   00000072   0xB064             ADD      SP,SP,#+400
   \   00000074   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??merge_3:
   \   00000078   0xF830 0x2016      LDRH     R2,[R0, R6, LSL #+1]
   \   0000007C   0xF847 0x2024      STR      R2,[R7, R4, LSL #+2]
   \   00000080   0x1C64             ADDS     R4,R4,#+1
   \   00000082   0x1C76             ADDS     R6,R6,#+1
   \   00000084   0x42B3             CMP      R3,R6
   \   00000086   0xDAF7             BGE.N    ??merge_3
   \   00000088   0xE7E5             B.N      ??merge_4
    755          

   \                                 In section .text, align 2, keep-with-next
    756          FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
    757          {
    758            FlagStatus bitstatus = RESET;
   \                     ADC_GetFlagStatus:
   \   00000000   0x2200             MOVS     R2,#+0
    759            /* Check the parameters */
    760            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    761            assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
    762          
    763            /* Check the status of the specified ADC flag */
    764            if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xB2C0             UXTB     R0,R0
   \   00000006   0x4208             TST      R0,R1
   \   00000008   0xBF18             IT       NE 
   \   0000000A   0x2201             MOVNE    R2,#+1
    765            {
    766              /* ADC_FLAG is set */
    767              bitstatus = SET;
    768            }
    769            else
    770            {
    771              /* ADC_FLAG is reset */
    772              bitstatus = RESET;
    773            }
    774            /* Return the ADC_FLAG status */
    775            return  bitstatus;
   \   0000000C   0x4610             MOV      R0,R2
   \   0000000E   0x4770             BX       LR               ;; return
    776          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     ADCIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x40012004         DC32     0x40012004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x40012304         DC32     0x40012304

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x........         DC32     ADC3START

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x40012104         DC32     0x40012104

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x40012000         DC32     0x40012000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   0x........         DC32     ADC_DATA

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \   00000000   0x40012008         DC32     0x40012008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \   00000000   0x........         DC32     ADC_AVR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_10:
   \   00000000   0x40012208         DC32     0x40012208

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_11:
   \   00000000   0x........         DC32     ADC3_AVR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_12:
   \   00000000   0x40020414         DC32     0x40020414
    777          
    778          
    779          /******************* (C) COPYRIGHT 2007 STMicroelectronics *****END OF FILE****/
    780          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  ADC1_SWStart
        0  ADC3_ChannelEnable
        0  ADC3_CheckFinish
       24  ADC3_IRQInitHandler
             24 -> CPU_SR_Restore
             24 -> CPU_SR_Save
              0 -> OSIntExit
       16  ADC3_SWStart
       16  ADCInit
             16 -> NVIC_Init
              0 -> OS_CPU_SR_Restore
             16 -> OS_CPU_SR_Save
        0  ADC_ChannelEnable
        0  ADC_CheckFinish
        0  ADC_GetFlagStatus
       16  ADC_IRQInitHandler
             16 -> CPU_SR_Restore
             16 -> CPU_SR_Save
              0 -> OSIntExit
        0  AdctoVolt33V
        0  AdctoVolt5opamp
        8  Average_Sum
       12  BubbleSort
        0  GetAdcValue
        0  ReadEnvTempTable
        0  SelectAverage
        0  SelectMax
      224  SelectSort
       16  SelectSortMax
      244  SelectSort_1
      224  SelectSort_MinMax
        0  SortSelect
              0 -> BubbleSort
        0  SwapData
       16  average_rssi
             16 -> quick_sort
       16  insertionSort
      424  merge
       24  mergeSort
             24 -> __aeabi_d2iz
             24 -> __aeabi_i2d
             24 -> floor
              0 -> merge
             24 -> mergeSort
       32  quick_sort
             32 -> __aeabi_cfcmple
             32 -> __aeabi_ui2f
             32 -> quick_sort


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_12
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
      12  ?Subroutine0
       6  ?Subroutine1
     124  ?Subroutine2
       8  ?Subroutine3
      90  ADC1_SWStart
      60  ADC3START
          ADC3_WRCNT
      76  ADC3_AVR
       8  ADC3_ChannelEnable
      16  ADC3_CheckFinish
     104  ADC3_IRQInitHandler
      92  ADC3_SWStart
      64  ADCIndex
          ASTART
          ADC3Index
          ASTART3
          ADCSTART
          ADC_WRCNT
     212  ADCInit
      76  ADC_AVR
     200  ADC_AVR_VALUE0
     200  ADC_AVR_VALUE1
     200  ADC_AVR_VALUE10
     200  ADC_AVR_VALUE11
      20  ADC_AVR_VALUE12
      20  ADC_AVR_VALUE13
      20  ADC_AVR_VALUE14
      20  ADC_AVR_VALUE15
     200  ADC_AVR_VALUE2
     200  ADC_AVR_VALUE3
     200  ADC_AVR_VALUE4
     200  ADC_AVR_VALUE5
     200  ADC_AVR_VALUE6
     200  ADC_AVR_VALUE7
     200  ADC_AVR_VALUE8
     200  ADC_AVR_VALUE9
      10  ADC_ChannelEnable
      18  ADC_CheckFinish
      40  ADC_DATA
      60  ADC_DATA1
      16  ADC_GetFlagStatus
      84  ADC_IRQInitHandler
      76  ADC_SUM
      76  Adc3BuffMax
       4  Adc3En
      76  AdcBuffMax
       4  AdcEn
      14  AdctoVolt33V
      20  AdctoVolt5opamp
      40  Average_Sum
      52  BubbleSort
      54  GetAdcValue
      24  ReadEnvTempTable
      24  SelectAverage
      22  SelectMax
      16  SelectSort
      78  SelectSortMax
     218  SelectSort_1
      14  SelectSort_MinMax
       8  SortSelect
      10  SwapData
      44  average_rssi
      52  insertionSort
     138  merge
      74  mergeSort
     118  quick_sort

 
 2 780 bytes in section .bss
   152 bytes in section .data
     8 bytes in section .rodata
 2 024 bytes in section .text
 
 2 024 bytes of CODE  memory
     8 bytes of CONST memory
 2 932 bytes of DATA  memory

Errors: none
Warnings: none

###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     08/Feb/2018  09:39:59 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uCOS-II\Source\os_sem.c                           #
#    Command line =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uCOS-II\Source\os_sem.c -lC                       #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\out\ -o D:\Project\TRIO\2.TRIO-MR\appl_stm207_201 #
#                    41204_RvsALC_20151223\out\ --endian=little               #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "D:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\include\ -I D:\Project\TRIO\2.TRIO-MR\appl_stm207 #
#                    _20141204_RvsALC_20151223\STM32F2xx_StdPeriph_Driver_v12 #
#                    12\ -I D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_Rv #
#                    sALC_20151223\STM32F2xx_StdPeriph_Driver_v1212\inc\ -I   #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uC-CPU\ -I D:\Project\TRIO\2.TRIO-MR\appl_stm207_ #
#                    20141204_RvsALC_20151223\uC-LIB\ -I                      #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uCOS-II\Ports\ -I D:\Project\TRIO\2.TRIO-MR\appl_ #
#                    stm207_20141204_RvsALC_20151223\uCOS-II\Source\ -I       #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uC-Probe\ -Oh --use_c++_inline                    #
#    List file    =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\out\os_sem.lst                                    #
#    Object file  =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\out\os_sem.o                                      #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20151223\uCOS-II\Source\os_sem.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                          SEMAPHORE MANAGEMENT
      6          *
      7          *                          (c) Copyright 1992-2007, Jean J. Labrosse, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_SEM.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.85
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license 
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience 
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          
     26          #include <ucos_ii.h>
     27          #endif
     28          
     29          #if OS_SEM_EN > 0
     30          /*$PAGE*/
     31          /*
     32          *********************************************************************************************************
     33          *                                           ACCEPT SEMAPHORE
     34          *
     35          * Description: This function checks the semaphore to see if a resource is available or, if an event
     36          *              occurred.  Unlike OSSemPend(), OSSemAccept() does not suspend the calling task if the
     37          *              resource is not available or the event did not occur.
     38          *
     39          * Arguments  : pevent     is a pointer to the event control block
     40          *
     41          * Returns    : >  0       if the resource is available or the event did not occur the semaphore is
     42          *                         decremented to obtain the resource.
     43          *              == 0       if the resource is not available or the event did not occur or,
     44          *                         if 'pevent' is a NULL pointer or,
     45          *                         if you didn't pass a pointer to a semaphore
     46          *********************************************************************************************************
     47          */
     48          
     49          #if OS_SEM_ACCEPT_EN > 0

   \                                 In section .text, align 2, keep-with-next
     50          INT16U  OSSemAccept (OS_EVENT *pevent)
     51          {
   \                     OSSemAccept:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
     52              INT16U     cnt;
     53          #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
     54              OS_CPU_SR  cpu_sr = 0;
     55          #endif
     56          
     57          
     58          
     59          #if OS_ARG_CHK_EN > 0
     60              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
     61                  return (0);
     62              }
     63          #endif
     64              if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x2803             CMP      R0,#+3
   \   00000008   0xD001             BEQ.N    ??OSSemAccept_0
     65                  return (0);
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD32             POP      {R1,R4,R5,PC}
     66              }
     67              OS_ENTER_CRITICAL();
   \                     ??OSSemAccept_0:
   \   0000000E   0x.... 0x....      BL       OS_CPU_SR_Save
     68              cnt = pevent->OSEventCnt;
   \   00000012   0x8921             LDRH     R1,[R4, #+8]
   \   00000014   0x000D             MOVS     R5,R1
     69              if (cnt > 0) {                                    /* See if resource is available                  */
   \   00000016   0xBF1C             ITT      NE 
   \   00000018   0x1E49             SUBNE    R1,R1,#+1
   \   0000001A   0x8121             STRHNE   R1,[R4, #+8]
     70                  pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
     71              }
     72              OS_EXIT_CRITICAL();
   \   0000001C   0x.... 0x....      BL       OS_CPU_SR_Restore
     73              return (cnt);                                     /* Return semaphore count                        */
   \   00000020   0x4628             MOV      R0,R5
   \   00000022   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     74          }
     75          #endif
     76          
     77          /*$PAGE*/
     78          /*
     79          *********************************************************************************************************
     80          *                                           CREATE A SEMAPHORE
     81          *
     82          * Description: This function creates a semaphore.
     83          *
     84          * Arguments  : cnt           is the initial value for the semaphore.  If the value is 0, no resource is
     85          *                            available (or no event has occurred).  You initialize the semaphore to a
     86          *                            non-zero value to specify how many resources are available (e.g. if you have
     87          *                            10 resources, you would initialize the semaphore to 10).
     88          *
     89          * Returns    : != (void *)0  is a pointer to the event control block (OS_EVENT) associated with the
     90          *                            created semaphore
     91          *              == (void *)0  if no event control blocks were available
     92          *********************************************************************************************************
     93          */
     94          

   \                                 In section .text, align 2, keep-with-next
     95          OS_EVENT  *OSSemCreate (INT16U cnt)
     96          {
   \                     OSSemCreate:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
     97              OS_EVENT  *pevent;
     98          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
     99              OS_CPU_SR  cpu_sr = 0;
    100          #endif
    101          
    102          
    103          
    104              if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
   \   00000004   0x....             LDR.N    R0,??DataTable2
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xB108             CBZ.N    R0,??OSSemCreate_0
    105                  return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD32             POP      {R1,R4,R5,PC}
    106              }
    107              OS_ENTER_CRITICAL();
   \                     ??OSSemCreate_0:
   \   0000000E   0x.... 0x....      BL       OS_CPU_SR_Save
    108              pevent = OSEventFreeList;                              /* Get next free event control block        */
   \   00000012   0x....             LDR.N    R1,??DataTable2_1
   \   00000014   0x680A             LDR      R2,[R1, #+0]
   \   00000016   0x0015             MOVS     R5,R2
    109              if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
   \   00000018   0xBF1C             ITT      NE 
   \   0000001A   0x6852             LDRNE    R2,[R2, #+4]
   \   0000001C   0x600A             STRNE    R2,[R1, #+0]
    110                  OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
    111              }
    112              OS_EXIT_CRITICAL();
   \   0000001E   0x.... 0x....      BL       OS_CPU_SR_Restore
    113              if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
   \   00000022   0xB13D             CBZ.N    R5,??OSSemCreate_1
    114                  pevent->OSEventType    = OS_EVENT_TYPE_SEM;
   \   00000024   0x2003             MOVS     R0,#+3
   \   00000026   0x7028             STRB     R0,[R5, #+0]
    115                  pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
   \   00000028   0x812C             STRH     R4,[R5, #+8]
    116                  pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x6068             STR      R0,[R5, #+4]
    117          #if OS_EVENT_NAME_SIZE > 1
    118                  pevent->OSEventName[0] = '?';                      /* Unknown name                             */
    119                  pevent->OSEventName[1] = OS_ASCII_NUL;
    120          #endif
    121                  OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0x.... 0x....      BL       OS_EventWaitListInit
    122              }
    123              return (pevent);
   \                     ??OSSemCreate_1:
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    124          }
    125          
    126          /*$PAGE*/
    127          /*
    128          *********************************************************************************************************
    129          *                                         DELETE A SEMAPHORE
    130          *
    131          * Description: This function deletes a semaphore and readies all tasks pending on the semaphore.
    132          *
    133          * Arguments  : pevent        is a pointer to the event control block associated with the desired
    134          *                            semaphore.
    135          *
    136          *              opt           determines delete options as follows:
    137          *                            opt == OS_DEL_NO_PEND   Delete semaphore ONLY if no task pending
    138          *                            opt == OS_DEL_ALWAYS    Deletes the semaphore even if tasks are waiting.
    139          *                                                    In this case, all the tasks pending will be readied.
    140          *
    141          *              perr          is a pointer to an error code that can contain one of the following values:
    142          *                            OS_ERR_NONE             The call was successful and the semaphore was deleted
    143          *                            OS_ERR_DEL_ISR          If you attempted to delete the semaphore from an ISR
    144          *                            OS_ERR_INVALID_OPT      An invalid option was specified
    145          *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the semaphore
    146          *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a semaphore
    147          *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
    148          *
    149          * Returns    : pevent        upon error
    150          *              (OS_EVENT *)0 if the semaphore was successfully deleted.
    151          *
    152          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
    153          *                 the semaphore MUST check the return code of OSSemPend().
    154          *              2) OSSemAccept() callers will not know that the intended semaphore has been deleted unless
    155          *                 they check 'pevent' to see that it's a NULL pointer.
    156          *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
    157          *                 time is directly proportional to the number of tasks waiting on the semaphore.
    158          *              4) Because ALL tasks pending on the semaphore will be readied, you MUST be careful in
    159          *                 applications where the semaphore is used for mutual exclusion because the resource(s)
    160          *                 will no longer be guarded by the semaphore.
    161          *********************************************************************************************************
    162          */
    163          
    164          #if OS_SEM_DEL_EN > 0

   \                                 In section .text, align 2, keep-with-next
    165          OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
    166          {
   \                     OSSemDel:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4615             MOV      R5,R2
    167              BOOLEAN    tasks_waiting;
    168              OS_EVENT  *pevent_return;
    169          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    170              OS_CPU_SR  cpu_sr = 0;
    171          #endif
    172          
    173          
    174          
    175          #if OS_ARG_CHK_EN > 0
    176              if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
    177                  return (pevent);
    178              }
    179              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    180                  *perr = OS_ERR_PEVENT_NULL;
    181                  return (pevent);
    182              }
    183          #endif
    184              if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0x2803             CMP      R0,#+3
   \   0000000E   0xBF18             IT       NE 
   \   00000010   0x2001             MOVNE    R0,#+1
    185                  *perr = OS_ERR_EVENT_TYPE;
   \   00000012   0xD141             BNE.N    ??OSSemDel_0
    186                  return (pevent);
    187              }
    188              if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
   \   00000014   0x....             LDR.N    R0,??DataTable2
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0xB108             CBZ.N    R0,??OSSemDel_1
    189                  *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
   \   0000001A   0x200F             MOVS     R0,#+15
   \   0000001C   0xE03C             B.N      ??OSSemDel_0
    190                  return (pevent);
    191              }
    192              OS_ENTER_CRITICAL();
   \                     ??OSSemDel_1:
   \   0000001E   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000022   0x4680             MOV      R8,R0
    193              if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
   \   00000024   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000026   0x1E47             SUBS     R7,R0,#+1
   \   00000028   0x41BF             SBCS     R7,R7,R7
   \   0000002A   0x43F9             MVNS     R1,R7
   \   0000002C   0x0FCF             LSRS     R7,R1,#+31
    194                  tasks_waiting = OS_TRUE;                           /* Yes                                      */
    195              } else {
    196                  tasks_waiting = OS_FALSE;                          /* No                                       */
    197              }
    198              switch (opt) {
   \   0000002E   0xB116             CBZ.N    R6,??OSSemDel_2
   \   00000030   0x2E01             CMP      R6,#+1
   \   00000032   0xD012             BEQ.N    ??OSSemDel_3
   \   00000034   0xE02C             B.N      ??OSSemDel_4
    199                  case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
    200                       if (tasks_waiting == OS_FALSE) {
   \                     ??OSSemDel_2:
   \   00000036   0xB95F             CBNZ.N   R7,??OSSemDel_5
    201          #if OS_EVENT_NAME_SIZE > 1
    202                           pevent->OSEventName[0] = '?';             /* Unknown name                             */
    203                           pevent->OSEventName[1] = OS_ASCII_NUL;
    204          #endif
    205                           pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x7020             STRB     R0,[R4, #+0]
    206                           pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
   \   0000003C   0x....             LDR.N    R0,??DataTable2_1
   \   0000003E   0x6801             LDR      R1,[R0, #+0]
   \   00000040   0x6061             STR      R1,[R4, #+4]
    207                           pevent->OSEventCnt     = 0;
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x8121             STRH     R1,[R4, #+8]
    208                           OSEventFreeList        = pevent;          /* Get next free event control block        */
   \   00000046   0x6004             STR      R4,[R0, #+0]
    209                           OS_EXIT_CRITICAL();
   \   00000048   0x4640             MOV      R0,R8
   \   0000004A   0x.... 0x....      BL       OS_CPU_SR_Restore
    210                           *perr                  = OS_ERR_NONE;
   \   0000004E   0xE01C             B.N      ??OSSemDel_6
    211                           pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
    212                       } else {
    213                           OS_EXIT_CRITICAL();
   \                     ??OSSemDel_5:
   \   00000050   0x4640             MOV      R0,R8
   \   00000052   0x.... 0x....      BL       OS_CPU_SR_Restore
    214                           *perr                  = OS_ERR_TASK_WAITING;
   \   00000056   0x2049             MOVS     R0,#+73
    215                           pevent_return          = pevent;
   \   00000058   0xE01E             B.N      ??OSSemDel_0
    216                       }
    217                       break;
    218          
    219                  case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
    220                       while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
   \                     ??OSSemDel_3:
   \   0000005A   0xB140             CBZ.N    R0,??OSSemDel_7
    221                           (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
   \                     ??OSSemDel_8:
   \   0000005C   0x2300             MOVS     R3,#+0
   \   0000005E   0x2201             MOVS     R2,#+1
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x.... 0x....      BL       OS_EventTaskRdy
   \   00000068   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD1F6             BNE.N    ??OSSemDel_8
    222                       }
    223          #if OS_EVENT_NAME_SIZE > 1
    224                       pevent->OSEventName[0] = '?';                 /* Unknown name                             */
    225                       pevent->OSEventName[1] = OS_ASCII_NUL;
    226          #endif
    227                       pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
   \                     ??OSSemDel_7:
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x7020             STRB     R0,[R4, #+0]
    228                       pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
   \   00000072   0x....             LDR.N    R0,??DataTable2_1
   \   00000074   0x6801             LDR      R1,[R0, #+0]
   \   00000076   0x6061             STR      R1,[R4, #+4]
    229                       pevent->OSEventCnt     = 0;
   \   00000078   0x2100             MOVS     R1,#+0
   \   0000007A   0x8121             STRH     R1,[R4, #+8]
    230                       OSEventFreeList        = pevent;              /* Get next free event control block        */
   \   0000007C   0x6004             STR      R4,[R0, #+0]
    231                       OS_EXIT_CRITICAL();
   \   0000007E   0x4640             MOV      R0,R8
   \   00000080   0x.... 0x....      BL       OS_CPU_SR_Restore
    232                       if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
   \   00000084   0xB10F             CBZ.N    R7,??OSSemDel_6
    233                           OS_Sched();                               /* Find highest priority task ready to run  */
   \   00000086   0x.... 0x....      BL       OS_Sched
    234                       }
    235                       *perr                  = OS_ERR_NONE;
   \                     ??OSSemDel_6:
   \   0000008A   0x2000             MOVS     R0,#+0
    236                       pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
   \   0000008C   0x2400             MOVS     R4,#+0
    237                       break;
   \   0000008E   0xE003             B.N      ??OSSemDel_0
    238          
    239                  default:
    240                       OS_EXIT_CRITICAL();
   \                     ??OSSemDel_4:
   \   00000090   0x4640             MOV      R0,R8
   \   00000092   0x.... 0x....      BL       OS_CPU_SR_Restore
    241                       *perr                  = OS_ERR_INVALID_OPT;
   \   00000096   0x2007             MOVS     R0,#+7
    242                       pevent_return          = pevent;
    243                       break;
   \                     ??OSSemDel_0:
   \   00000098   0x7028             STRB     R0,[R5, #+0]
    244              }
    245              return (pevent_return);
   \   0000009A   0x4620             MOV      R0,R4
   \   0000009C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    246          }
    247          #endif
    248          
    249          /*$PAGE*/
    250          /*
    251          *********************************************************************************************************
    252          *                                           PEND ON SEMAPHORE
    253          *
    254          * Description: This function waits for a semaphore.
    255          *
    256          * Arguments  : pevent        is a pointer to the event control block associated with the desired
    257          *                            semaphore.
    258          *
    259          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
    260          *                            wait for the resource up to the amount of time specified by this argument.
    261          *                            If you specify 0, however, your task will wait forever at the specified
    262          *                            semaphore or, until the resource becomes available (or the event occurs).
    263          *
    264          *              perr          is a pointer to where an error message will be deposited.  Possible error
    265          *                            messages are:
    266          *
    267          *                            OS_ERR_NONE         The call was successful and your task owns the resource
    268          *                                                or, the event you are waiting for occurred.
    269          *                            OS_ERR_TIMEOUT      The semaphore was not received within the specified
    270          *                                                'timeout'.
    271          *                            OS_ERR_PEND_ABORT   The wait on the semaphore was aborted.
    272          *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
    273          *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
    274          *                                                would lead to a suspension.
    275          *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
    276          *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
    277          *
    278          * Returns    : none
    279          *********************************************************************************************************
    280          */
    281          

   \                                 In section .text, align 2, keep-with-next
    282          void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
    283          {
   \                     OSSemPend:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460F             MOV      R7,R1
   \   00000008   0x4615             MOV      R5,R2
    284              INT8U      pend_stat;
    285          #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    286              OS_CPU_SR  cpu_sr = 0;
    287          #endif
    288          
    289          
    290          
    291          #if OS_ARG_CHK_EN > 0
    292              if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
    293                  return;
    294              }
    295              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    296                  *perr = OS_ERR_PEVENT_NULL;
    297                  return;
    298              }
    299          #endif
    300              if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0x2803             CMP      R0,#+3
   \   0000000E   0xBF18             IT       NE 
   \   00000010   0x2001             MOVNE    R0,#+1
    301                  *perr = OS_ERR_EVENT_TYPE;
   \   00000012   0xD13B             BNE.N    ??OSSemPend_0
    302                  return;
    303              }
    304              if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
   \   00000014   0x....             LDR.N    R0,??DataTable2
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0xB108             CBZ.N    R0,??OSSemPend_1
    305                  *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xE036             B.N      ??OSSemPend_0
    306                  return;
    307              }
    308              if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
   \                     ??OSSemPend_1:
   \   0000001E   0x....             LDR.N    R0,??DataTable2_2
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0xB108             CBZ.N    R0,??OSSemPend_2
    309                  *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
   \   00000024   0x200D             MOVS     R0,#+13
   \   00000026   0xE031             B.N      ??OSSemPend_0
    310                  return;
    311              }
    312              OS_ENTER_CRITICAL();
   \                     ??OSSemPend_2:
   \   00000028   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000002C   0x4680             MOV      R8,R0
    313              if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
   \   0000002E   0x8920             LDRH     R0,[R4, #+8]
   \   00000030   0xB110             CBZ.N    R0,??OSSemPend_3
    314                  pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
   \   00000032   0x1E40             SUBS     R0,R0,#+1
   \   00000034   0x8120             STRH     R0,[R4, #+8]
    315                  OS_EXIT_CRITICAL();
   \   00000036   0xE025             B.N      ??OSSemPend_4
    316                  *perr = OS_ERR_NONE;
    317                  return;
    318              }
    319                                                                /* Otherwise, must wait until event occurs       */
    320              OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
   \                     ??OSSemPend_3:
   \   00000038   0x....             LDR.N    R6,??DataTable2_3
   \   0000003A   0x6830             LDR      R0,[R6, #+0]
   \   0000003C   0x7F01             LDRB     R1,[R0, #+28]
   \   0000003E   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000042   0x7701             STRB     R1,[R0, #+28]
    321              OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
   \   00000044   0x6830             LDR      R0,[R6, #+0]
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x7741             STRB     R1,[R0, #+29]
    322              OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
   \   0000004A   0x6830             LDR      R0,[R6, #+0]
   \   0000004C   0x8347             STRH     R7,[R0, #+26]
    323              OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       OS_EventTaskWait
    324              OS_EXIT_CRITICAL();
   \   00000054   0x4640             MOV      R0,R8
   \   00000056   0x.... 0x....      BL       OS_CPU_SR_Restore
    325              OS_Sched();                                       /* Find next highest priority task ready         */
   \   0000005A   0x.... 0x....      BL       OS_Sched
    326              OS_ENTER_CRITICAL();
   \   0000005E   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000062   0x4680             MOV      R8,R0
    327              if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) { /* See if we timed-out or aborted                */
   \   00000064   0x6830             LDR      R0,[R6, #+0]
   \   00000066   0x7F47             LDRB     R7,[R0, #+29]
   \   00000068   0xB157             CBZ.N    R7,??OSSemPend_5
    328                  pend_stat = OSTCBCur->OSTCBStatPend;
    329                  OS_EventTOAbort(pevent);
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x.... 0x....      BL       OS_EventTOAbort
    330                  OS_EXIT_CRITICAL();
   \   00000070   0x4640             MOV      R0,R8
   \   00000072   0x.... 0x....      BL       OS_CPU_SR_Restore
    331                  switch (pend_stat) {
   \   00000076   0x2F02             CMP      R7,#+2
   \   00000078   0xBF0C             ITE      EQ 
   \   0000007A   0x200E             MOVEQ    R0,#+14
   \   0000007C   0x200A             MOVNE    R0,#+10
    332                      case OS_STAT_PEND_TO:
    333                      default:
    334                           *perr = OS_ERR_TIMEOUT;              /* Indicate that didn't get event within TO      */
   \   0000007E   0xE005             B.N      ??OSSemPend_0
    335                           break;
    336          
    337                      case OS_STAT_PEND_ABORT:
    338                           *perr = OS_ERR_PEND_ABORT;           /* Indicate that we aborted                      */
    339                           break;
    340                  }
    341                  return;
    342              }
    343              OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;
   \                     ??OSSemPend_5:
   \   00000080   0x2100             MOVS     R1,#+0
   \   00000082   0x60C1             STR      R1,[R0, #+12]
    344              OS_EXIT_CRITICAL();
   \                     ??OSSemPend_4:
   \   00000084   0x4640             MOV      R0,R8
   \   00000086   0x.... 0x....      BL       OS_CPU_SR_Restore
    345              *perr = OS_ERR_NONE;
   \   0000008A   0x2000             MOVS     R0,#+0
   \                     ??OSSemPend_0:
   \   0000008C   0x7028             STRB     R0,[R5, #+0]
    346          }
   \   0000008E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    347          
    348          /*$PAGE*/
    349          /*
    350          *********************************************************************************************************
    351          *                                      ABORT WAITING ON A SEMAPHORE
    352          *
    353          * Description: This function aborts & readies any tasks currently waiting on a semaphore.  This function 
    354          *              should be used to fault-abort the wait on the semaphore, rather than to normally signal
    355          *              the semaphore via OSSemPost().
    356          *
    357          * Arguments  : pevent        is a pointer to the event control block associated with the desired
    358          *                            semaphore.
    359          *
    360          *              opt           determines the type of ABORT performed:
    361          *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
    362          *                                                     semaphore
    363          *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
    364          *                                                     semaphore
    365          *
    366          *              perr          is a pointer to where an error message will be deposited.  Possible error
    367          *                            messages are:
    368          *
    369          *                            OS_ERR_NONE         No tasks were     waiting on the semaphore.
    370          *                            OS_ERR_PEND_ABORT   At least one task waiting on the semaphore was readied
    371          *                                                and informed of the aborted wait; check return value 
    372          *                                                for the number of tasks whose wait on the semaphore 
    373          *                                                was aborted.
    374          *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore.
    375          *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
    376          *
    377          * Returns    : == 0          if no tasks were waiting on the semaphore, or upon error.
    378          *              >  0          if one or more tasks waiting on the semaphore are now readied and informed.
    379          *********************************************************************************************************
    380          */
    381          
    382          #if OS_SEM_PEND_ABORT_EN > 0

   \                                 In section .text, align 2, keep-with-next
    383          INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
    384          {
   \                     OSSemPendAbort:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4614             MOV      R4,R2
    385              INT8U      nbr_tasks;
    386          #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    387              OS_CPU_SR  cpu_sr = 0;
    388          #endif
    389          
    390          
    391          
    392          #if OS_ARG_CHK_EN > 0
    393              if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
    394                  return (0);
    395              }
    396              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    397                  *perr = OS_ERR_PEVENT_NULL;
    398                  return (0);
    399              }
    400          #endif
    401              if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
   \   0000000A   0x7828             LDRB     R0,[R5, #+0]
   \   0000000C   0x2803             CMP      R0,#+3
   \   0000000E   0xBF1E             ITTT     NE 
   \   00000010   0x2001             MOVNE    R0,#+1
   \   00000012   0x7020             STRBNE   R0,[R4, #+0]
   \   00000014   0x2000             MOVNE    R0,#+0
    402                  *perr = OS_ERR_EVENT_TYPE;
    403                  return (0);
   \   00000016   0xD127             BNE.N    ??OSSemPendAbort_0
    404              }
    405              OS_ENTER_CRITICAL();
   \   00000018   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001C   0x4680             MOV      R8,R0
    406              if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
   \   0000001E   0x7AA8             LDRB     R0,[R5, #+10]
   \   00000020   0xB1E8             CBZ.N    R0,??OSSemPendAbort_1
    407                  nbr_tasks = 0;
   \   00000022   0x2700             MOVS     R7,#+0
    408                  switch (opt) {
   \   00000024   0x2E01             CMP      R6,#+1
   \   00000026   0xD10A             BNE.N    ??OSSemPendAbort_2
    409                      case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
    410                           while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
    411                               (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
   \                     ??OSSemPendAbort_3:
   \   00000028   0x2302             MOVS     R3,#+2
   \   0000002A   0x2201             MOVS     R2,#+1
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0x.... 0x....      BL       OS_EventTaskRdy
    412                               nbr_tasks++;
   \   00000034   0x1C7F             ADDS     R7,R7,#+1
   \   00000036   0x7AA8             LDRB     R0,[R5, #+10]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD1F5             BNE.N    ??OSSemPendAbort_3
   \   0000003C   0xE006             B.N      ??OSSemPendAbort_4
    413                           }
    414                           break;
    415                           
    416                      case OS_PEND_OPT_NONE:                    /* No,  ready HPT       waiting on semaphore     */
    417                      default:
    418                           (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
   \                     ??OSSemPendAbort_2:
   \   0000003E   0x2302             MOVS     R3,#+2
   \   00000040   0x2201             MOVS     R2,#+1
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       OS_EventTaskRdy
    419                           nbr_tasks++;
   \   0000004A   0x2701             MOVS     R7,#+1
    420                           break;
    421                  }
    422                  OS_EXIT_CRITICAL();
   \                     ??OSSemPendAbort_4:
   \   0000004C   0x4640             MOV      R0,R8
   \   0000004E   0x.... 0x....      BL       OS_CPU_SR_Restore
    423                  OS_Sched();                                   /* Find HPT ready to run                         */
   \   00000052   0x.... 0x....      BL       OS_Sched
    424                  *perr = OS_ERR_PEND_ABORT;
   \   00000056   0x200E             MOVS     R0,#+14
   \   00000058   0x7020             STRB     R0,[R4, #+0]
    425                  return (nbr_tasks);
   \   0000005A   0xB2F8             UXTB     R0,R7
   \   0000005C   0xE004             B.N      ??OSSemPendAbort_0
    426              }
    427              OS_EXIT_CRITICAL();
   \                     ??OSSemPendAbort_1:
   \   0000005E   0x4640             MOV      R0,R8
   \   00000060   0x.... 0x....      BL       OS_CPU_SR_Restore
    428              *perr = OS_ERR_NONE;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x7020             STRB     R0,[R4, #+0]
    429              return (0);                                       /* No tasks waiting on semaphore                 */
   \                     ??OSSemPendAbort_0:
   \   00000068   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    430          }
    431          #endif
    432          
    433          /*$PAGE*/
    434          /*
    435          *********************************************************************************************************
    436          *                                         POST TO A SEMAPHORE
    437          *
    438          * Description: This function signals a semaphore
    439          *
    440          * Arguments  : pevent        is a pointer to the event control block associated with the desired
    441          *                            semaphore.
    442          *
    443          * Returns    : OS_ERR_NONE         The call was successful and the semaphore was signaled.
    444          *              OS_ERR_SEM_OVF      If the semaphore count exceeded its limit.  In other words, you have
    445          *                                  signalled the semaphore more often than you waited on it with either
    446          *                                  OSSemAccept() or OSSemPend().
    447          *              OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a semaphore
    448          *              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
    449          *********************************************************************************************************
    450          */
    451          

   \                                 In section .text, align 2, keep-with-next
    452          INT8U  OSSemPost (OS_EVENT *pevent)
    453          {
   \                     OSSemPost:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    454          #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    455              OS_CPU_SR  cpu_sr = 0;
    456          #endif
    457          
    458          
    459          
    460          #if OS_ARG_CHK_EN > 0
    461              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    462                  return (OS_ERR_PEVENT_NULL);
    463              }
    464          #endif
    465              if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x2803             CMP      R0,#+3
   \   00000008   0xD001             BEQ.N    ??OSSemPost_0
    466                  return (OS_ERR_EVENT_TYPE);
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0xBD32             POP      {R1,R4,R5,PC}
    467              }
    468              OS_ENTER_CRITICAL();
   \                     ??OSSemPost_0:
   \   0000000E   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000012   0x4605             MOV      R5,R0
    469              if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
   \   00000014   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000016   0xB160             CBZ.N    R0,??OSSemPost_1
    470                                                                /* Ready HPT waiting on event                    */
    471                  (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
   \   00000018   0x2300             MOVS     R3,#+0
   \   0000001A   0x2201             MOVS     R2,#+1
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       OS_EventTaskRdy
    472                  OS_EXIT_CRITICAL();
   \   00000024   0x4628             MOV      R0,R5
   \   00000026   0x.... 0x....      BL       OS_CPU_SR_Restore
    473                  OS_Sched();                                   /* Find HPT ready to run                         */
   \   0000002A   0x.... 0x....      BL       OS_Sched
    474                  return (OS_ERR_NONE);
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD32             POP      {R1,R4,R5,PC}
    475              }
    476              if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
   \                     ??OSSemPost_1:
   \   00000032   0x8920             LDRH     R0,[R4, #+8]
   \   00000034   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD003             BEQ.N    ??OSSemPost_2
    477                  pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
   \   0000003C   0x1C40             ADDS     R0,R0,#+1
   \   0000003E   0x8120             STRH     R0,[R4, #+8]
    478                  OS_EXIT_CRITICAL();
   \   00000040   0x4628             MOV      R0,R5
   \   00000042   0x....             B.N      ?Subroutine0
    479                  return (OS_ERR_NONE);
    480              }
    481              OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
   \                     ??OSSemPost_2:
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       OS_CPU_SR_Restore
    482              return (OS_ERR_SEM_OVF);
   \   0000004A   0x2032             MOVS     R0,#+50
   \   0000004C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    483          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xBD32             POP      {R1,R4,R5,PC}
    484          
    485          /*$PAGE*/
    486          /*
    487          *********************************************************************************************************
    488          *                                          QUERY A SEMAPHORE
    489          *
    490          * Description: This function obtains information about a semaphore
    491          *
    492          * Arguments  : pevent        is a pointer to the event control block associated with the desired
    493          *                            semaphore
    494          *
    495          *              p_sem_data    is a pointer to a structure that will contain information about the
    496          *                            semaphore.
    497          *
    498          * Returns    : OS_ERR_NONE         The call was successful and the message was sent
    499          *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non semaphore.
    500          *              OS_ERR_PEVENT_NULL  If 'pevent'     is a NULL pointer.
    501          *              OS_ERR_PDATA_NULL   If 'p_sem_data' is a NULL pointer
    502          *********************************************************************************************************
    503          */
    504          
    505          #if OS_SEM_QUERY_EN > 0

   \                                 In section .text, align 2, keep-with-next
    506          INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
    507          {
   \                     OSSemQuery:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    508          #if OS_LOWEST_PRIO <= 63
    509              INT8U     *psrc;
    510              INT8U     *pdest;
    511          #else
    512              INT16U    *psrc;
    513              INT16U    *pdest;
    514          #endif
    515              INT8U      i;
    516          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    517              OS_CPU_SR  cpu_sr = 0;
    518          #endif
    519          
    520          
    521          
    522          #if OS_ARG_CHK_EN > 0
    523              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    524                  return (OS_ERR_PEVENT_NULL);
    525              }
    526              if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
    527                  return (OS_ERR_PDATA_NULL);
    528              }
    529          #endif
    530              if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2803             CMP      R0,#+3
   \   0000000A   0xD001             BEQ.N    ??OSSemQuery_0
    531                  return (OS_ERR_EVENT_TYPE);
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}
    532              }
    533              OS_ENTER_CRITICAL();
   \                     ??OSSemQuery_0:
   \   00000010   0x.... 0x....      BL       OS_CPU_SR_Save
    534              p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
   \   00000014   0x7AA1             LDRB     R1,[R4, #+10]
   \   00000016   0x71A9             STRB     R1,[R5, #+6]
    535              psrc                   = &pevent->OSEventTbl[0];
   \   00000018   0xF204 0x010B      ADDW     R1,R4,#+11
    536              pdest                  = &p_sem_data->OSEventTbl[0];
   \   0000001C   0x1CAA             ADDS     R2,R5,#+2
    537              for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
    538                  *pdest++ = *psrc++;
   \   0000001E   0x780B             LDRB     R3,[R1, #+0]
   \   00000020   0x7013             STRB     R3,[R2, #+0]
   \   00000022   0xF811 0x3F01      LDRB     R3,[R1, #+1]!
   \   00000026   0xF802 0x3F01      STRB     R3,[R2, #+1]!
   \   0000002A   0xF811 0x3F01      LDRB     R3,[R1, #+1]!
   \   0000002E   0xF802 0x3F01      STRB     R3,[R2, #+1]!
   \   00000032   0xF811 0x3F01      LDRB     R3,[R1, #+1]!
   \   00000036   0xF802 0x3F01      STRB     R3,[R2, #+1]!
    539              }
    540              p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
   \   0000003A   0x8921             LDRH     R1,[R4, #+8]
   \   0000003C   0x8029             STRH     R1,[R5, #+0]
    541              OS_EXIT_CRITICAL();
   \   0000003E                      REQUIRE ?Subroutine0
   \   0000003E                      ;; // Fall through to label ?Subroutine0
    542              return (OS_ERR_NONE);
    543          }
    544          #endif                                                     /* OS_SEM_QUERY_EN                          */
    545          
    546          /*$PAGE*/
    547          /*
    548          *********************************************************************************************************
    549          *                                              SET SEMAPHORE
    550          *
    551          * Description: This function sets the semaphore count to the value specified as an argument.  Typically,
    552          *              this value would be 0.
    553          *
    554          *              You would typically use this function when a semaphore is used as a signaling mechanism
    555          *              and, you want to reset the count value.
    556          *
    557          * Arguments  : pevent     is a pointer to the event control block
    558          *
    559          *              cnt        is the new value for the semaphore count.  You would pass 0 to reset the
    560          *                         semaphore count.
    561          *
    562          *              perr       is a pointer to an error code returned by the function as follows:
    563          *
    564          *                            OS_ERR_NONE          The call was successful and the semaphore value was set.
    565          *                            OS_ERR_EVENT_TYPE    If you didn't pass a pointer to a semaphore.
    566          *                            OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer.
    567          *                            OS_ERR_TASK_WAITING  If tasks are waiting on the semaphore.
    568          *********************************************************************************************************
    569          */
    570          
    571          #if OS_SEM_SET_EN > 0

   \                                 In section .text, align 2, keep-with-next
    572          void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
    573          {
   \                     OSSemSet:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4614             MOV      R4,R2
    574          #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    575              OS_CPU_SR  cpu_sr = 0;
    576          #endif
    577          
    578          
    579          
    580          #if OS_ARG_CHK_EN > 0
    581              if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
    582                  return;
    583              }
    584              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    585                  *perr = OS_ERR_PEVENT_NULL;
    586                  return;
    587              }
    588          #endif
    589              if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
   \   00000008   0x7828             LDRB     R0,[R5, #+0]
   \   0000000A   0x2803             CMP      R0,#+3
   \   0000000C   0xD002             BEQ.N    ??OSSemSet_0
    590                  *perr = OS_ERR_EVENT_TYPE;
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x7020             STRB     R0,[R4, #+0]
    591                  return;
   \   00000012   0xBD70             POP      {R4-R6,PC}
    592              }
    593              OS_ENTER_CRITICAL();
   \                     ??OSSemSet_0:
   \   00000014   0x.... 0x....      BL       OS_CPU_SR_Save
    594              *perr = OS_ERR_NONE;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x7021             STRB     R1,[R4, #+0]
    595              if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
   \   0000001C   0x8929             LDRH     R1,[R5, #+8]
   \   0000001E   0xB909             CBNZ.N   R1,??OSSemSet_1
    596                  pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
    597              } else {                                          /* No                                            */
    598                  if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
   \   00000020   0x7AA9             LDRB     R1,[R5, #+10]
   \   00000022   0xB909             CBNZ.N   R1,??OSSemSet_2
    599                      pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
   \                     ??OSSemSet_1:
   \   00000024   0x812E             STRH     R6,[R5, #+8]
    600                  } else {
   \   00000026   0x....             B.N      ?Subroutine1
    601                      *perr              = OS_ERR_TASK_WAITING;
   \                     ??OSSemSet_2:
   \   00000028   0x2149             MOVS     R1,#+73
   \   0000002A   0x7021             STRB     R1,[R4, #+0]
    602                  }
    603              }
    604              OS_EXIT_CRITICAL();
   \   0000002C                      REQUIRE ?Subroutine1
   \   0000002C                      ;; // Fall through to label ?Subroutine1
    605          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000004   0x.... 0x....      B.W      OS_CPU_SR_Restore

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     OSEventFreeList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     OSLockNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     OSTCBCur
    606          #endif
    607          
    608          #endif                                                /* OS_SEM_EN                                     */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  OSSemAccept
             16 -> OS_CPU_SR_Restore
             16 -> OS_CPU_SR_Save
       16  OSSemCreate
             16 -> OS_CPU_SR_Restore
             16 -> OS_CPU_SR_Save
             16 -> OS_EventWaitListInit
       24  OSSemDel
             24 -> OS_CPU_SR_Restore
             24 -> OS_CPU_SR_Save
             24 -> OS_EventTaskRdy
             24 -> OS_Sched
       24  OSSemPend
             24 -> OS_CPU_SR_Restore
             24 -> OS_CPU_SR_Save
             24 -> OS_EventTOAbort
             24 -> OS_EventTaskWait
             24 -> OS_Sched
       24  OSSemPendAbort
             24 -> OS_CPU_SR_Restore
             24 -> OS_CPU_SR_Save
             24 -> OS_EventTaskRdy
             24 -> OS_Sched
       16  OSSemPost
             16 -> OS_CPU_SR_Restore
             16 -> OS_CPU_SR_Save
             16 -> OS_EventTaskRdy
             16 -> OS_Sched
       16  OSSemQuery
             16 -> OS_CPU_SR_Restore
             16 -> OS_CPU_SR_Save
       16  OSSemSet
              0 -> OS_CPU_SR_Restore
             16 -> OS_CPU_SR_Save


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       8  ?Subroutine0
       8  ?Subroutine1
      36  OSSemAccept
      56  OSSemCreate
     160  OSSemDel
     146  OSSemPend
     108  OSSemPendAbort
      78  OSSemPost
      62  OSSemQuery
      44  OSSemSet

 
 722 bytes in section .text
 
 722 bytes of CODE memory

Errors: none
Warnings: none

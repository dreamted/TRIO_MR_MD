###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     08/Feb/2018  09:39:57 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uCOS-II\Source\os_mutex.c                         #
#    Command line =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uCOS-II\Source\os_mutex.c -lC                     #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\out\ -o D:\Project\TRIO\2.TRIO-MR\appl_stm207_201 #
#                    41204_RvsALC_20151223\out\ --endian=little               #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "D:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\include\ -I D:\Project\TRIO\2.TRIO-MR\appl_stm207 #
#                    _20141204_RvsALC_20151223\STM32F2xx_StdPeriph_Driver_v12 #
#                    12\ -I D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_Rv #
#                    sALC_20151223\STM32F2xx_StdPeriph_Driver_v1212\inc\ -I   #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uC-CPU\ -I D:\Project\TRIO\2.TRIO-MR\appl_stm207_ #
#                    20141204_RvsALC_20151223\uC-LIB\ -I                      #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uCOS-II\Ports\ -I D:\Project\TRIO\2.TRIO-MR\appl_ #
#                    stm207_20141204_RvsALC_20151223\uCOS-II\Source\ -I       #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uC-Probe\ -Oh --use_c++_inline                    #
#    List file    =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\out\os_mutex.lst                                  #
#    Object file  =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\out\os_mutex.o                                    #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20151223\uCOS-II\Source\os_mutex.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                  MUTUAL EXCLUSION SEMAPHORE MANAGEMENT
      6          *
      7          *                          (c) Copyright 1992-2007, Jean J. Labrosse, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_MUTEX.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.85
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license 
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience 
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          
     26          #include <ucos_ii.h>
     27          #endif
     28          
     29          
     30          #if OS_MUTEX_EN > 0
     31          /*
     32          *********************************************************************************************************
     33          *                                            LOCAL CONSTANTS
     34          *********************************************************************************************************
     35          */
     36          
     37          #define  OS_MUTEX_KEEP_LOWER_8   (INT16U)0x00FFu
     38          #define  OS_MUTEX_KEEP_UPPER_8   (INT16U)0xFF00u
     39          
     40          #define  OS_MUTEX_AVAILABLE      (INT16U)0x00FFu
     41          
     42          /*
     43          *********************************************************************************************************
     44          *                                            LOCAL CONSTANTS
     45          *********************************************************************************************************
     46          */
     47          
     48          static  void  OSMutex_RdyAtPrio(OS_TCB *ptcb, INT8U prio);
     49          
     50          /*$PAGE*/
     51          /*
     52          *********************************************************************************************************
     53          *                                   ACCEPT MUTUAL EXCLUSION SEMAPHORE
     54          *
     55          * Description: This  function checks the mutual exclusion semaphore to see if a resource is available.
     56          *              Unlike OSMutexPend(), OSMutexAccept() does not suspend the calling task if the resource is
     57          *              not available or the event did not occur.
     58          *
     59          * Arguments  : pevent     is a pointer to the event control block
     60          *
     61          *              perr       is a pointer to an error code which will be returned to your application:
     62          *                            OS_ERR_NONE         if the call was successful.
     63          *                            OS_ERR_EVENT_TYPE   if 'pevent' is not a pointer to a mutex
     64          *                            OS_ERR_PEVENT_NULL  'pevent' is a NULL pointer
     65          *                            OS_ERR_PEND_ISR     if you called this function from an ISR
     66          *                            OS_ERR_PIP_LOWER    If the priority of the task that owns the Mutex is
     67          *                                                HIGHER (i.e. a lower number) than the PIP.  This error
     68          *                                                indicates that you did not set the PIP higher (lower
     69          *                                                number) than ALL the tasks that compete for the Mutex.
     70          *                                                Unfortunately, this is something that could not be
     71          *                                                detected when the Mutex is created because we don't know
     72          *                                                what tasks will be using the Mutex.
     73          *
     74          * Returns    : == OS_TRUE    if the resource is available, the mutual exclusion semaphore is acquired
     75          *              == OS_FALSE   a) if the resource is not available
     76          *                            b) you didn't pass a pointer to a mutual exclusion semaphore
     77          *                            c) you called this function from an ISR
     78          *
     79          * Warning(s) : This function CANNOT be called from an ISR because mutual exclusion semaphores are
     80          *              intended to be used by tasks only.
     81          *********************************************************************************************************
     82          */
     83          
     84          #if OS_MUTEX_ACCEPT_EN > 0

   \                                 In section .text, align 2, keep-with-next
     85          BOOLEAN  OSMutexAccept (OS_EVENT *pevent, INT8U *perr)
     86          {
   \                     OSMutexAccept:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
     87              INT8U      pip;                                    /* Priority Inheritance Priority (PIP)          */
     88          #if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
     89              OS_CPU_SR  cpu_sr = 0;
     90          #endif
     91          
     92          
     93          
     94          #if OS_ARG_CHK_EN > 0
     95              if (perr == (INT8U *)0) {                          /* Validate 'perr'                              */
     96                  return (OS_FALSE);
     97              }
     98              if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
     99                  *perr = OS_ERR_PEVENT_NULL;
    100                  return (OS_FALSE);
    101              }
    102          #endif
    103              if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {  /* Validate event block type                    */
   \   00000006   0x7828             LDRB     R0,[R5, #+0]
   \   00000008   0x2804             CMP      R0,#+4
   \   0000000A   0xBF18             IT       NE 
   \   0000000C   0x2001             MOVNE    R0,#+1
    104                  *perr = OS_ERR_EVENT_TYPE;
   \   0000000E   0xD104             BNE.N    ??OSMutexAccept_0
    105                  return (OS_FALSE);
    106              }
    107              if (OSIntNesting > 0) {                            /* Make sure it's not called from an ISR        */
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable5
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0xB118             CBZ.N    R0,??OSMutexAccept_1
    108                  *perr = OS_ERR_PEND_ISR;
   \   00000018   0x2002             MOVS     R0,#+2
   \                     ??OSMutexAccept_0:
   \   0000001A   0x7020             STRB     R0,[R4, #+0]
    109                  return (OS_FALSE);
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBD70             POP      {R4-R6,PC}
    110              }
    111              OS_ENTER_CRITICAL();                               /* Get value (0 or 1) of Mutex                  */
   \                     ??OSMutexAccept_1:
   \   00000020   0x.... 0x....      BL       OS_CPU_SR_Save
    112              pip = (INT8U)(pevent->OSEventCnt >> 8);            /* Get PIP from mutex                           */
   \   00000024   0x8929             LDRH     R1,[R5, #+8]
   \   00000026   0x0A0A             LSRS     R2,R1,#+8
    113              if ((pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
   \   00000028   0xB2C9             UXTB     R1,R1
   \   0000002A   0x29FF             CMP      R1,#+255
   \   0000002C   0xD117             BNE.N    ??OSMutexAccept_2
    114                  pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;   /*      Mask off LSByte (Acquire Mutex)         */
   \   0000002E   0x8929             LDRH     R1,[R5, #+8]
   \   00000030   0xF401 0x417F      AND      R1,R1,#0xFF00
   \   00000034   0x8129             STRH     R1,[R5, #+8]
    115                  pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;     /*      Save current task priority in LSByte    */
   \   00000036   0x.... 0x....      LDR.W    R3,??DataTable5_1
   \   0000003A   0x681B             LDR      R3,[R3, #+0]
   \   0000003C   0x7F9E             LDRB     R6,[R3, #+30]
   \   0000003E   0x4331             ORRS     R1,R6,R1
   \   00000040   0x8129             STRH     R1,[R5, #+8]
    116                  pevent->OSEventPtr  = (void *)OSTCBCur;        /*      Link TCB of task owning Mutex           */
   \   00000042   0x606B             STR      R3,[R5, #+4]
    117                  if (OSTCBCur->OSTCBPrio <= pip) {              /*      PIP 'must' have a SMALLER prio ...      */
   \   00000044   0x7F99             LDRB     R1,[R3, #+30]
   \   00000046   0x428A             CMP      R2,R1
   \   00000048   0xD303             BCC.N    ??OSMutexAccept_3
    118                      OS_EXIT_CRITICAL();                        /*      ... than current task!                  */
   \   0000004A   0x.... 0x....      BL       OS_CPU_SR_Restore
    119                      *perr = OS_ERR_PIP_LOWER;
   \   0000004E   0x2078             MOVS     R0,#+120
   \   00000050   0xE002             B.N      ??OSMutexAccept_4
    120                  } else {
    121                      OS_EXIT_CRITICAL();
   \                     ??OSMutexAccept_3:
   \   00000052   0x.... 0x....      BL       OS_CPU_SR_Restore
    122                      *perr = OS_ERR_NONE;
   \   00000056   0x2000             MOVS     R0,#+0
   \                     ??OSMutexAccept_4:
   \   00000058   0x7020             STRB     R0,[R4, #+0]
    123                  }
    124                  return (OS_TRUE);
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0xBD70             POP      {R4-R6,PC}
    125              }
    126              OS_EXIT_CRITICAL();
   \                     ??OSMutexAccept_2:
   \   0000005E   0x.... 0x....      BL       OS_CPU_SR_Restore
    127              *perr = OS_ERR_NONE;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x7020             STRB     R0,[R4, #+0]
    128              return (OS_FALSE);
   \   00000066   0xBD70             POP      {R4-R6,PC}       ;; return
    129          }
    130          #endif
    131          
    132          /*$PAGE*/
    133          /*
    134          *********************************************************************************************************
    135          *                                  CREATE A MUTUAL EXCLUSION SEMAPHORE
    136          *
    137          * Description: This function creates a mutual exclusion semaphore.
    138          *
    139          * Arguments  : prio          is the priority to use when accessing the mutual exclusion semaphore.  In
    140          *                            other words, when the semaphore is acquired and a higher priority task
    141          *                            attempts to obtain the semaphore then the priority of the task owning the
    142          *                            semaphore is raised to this priority.  It is assumed that you will specify
    143          *                            a priority that is LOWER in value than ANY of the tasks competing for the
    144          *                            mutex.
    145          *
    146          *              perr          is a pointer to an error code which will be returned to your application:
    147          *                               OS_ERR_NONE         if the call was successful.
    148          *                               OS_ERR_CREATE_ISR   if you attempted to create a MUTEX from an ISR
    149          *                               OS_ERR_PRIO_EXIST   if a task at the priority inheritance priority
    150          *                                                   already exist.
    151          *                               OS_ERR_PEVENT_NULL  No more event control blocks available.
    152          *                               OS_ERR_PRIO_INVALID if the priority you specify is higher that the
    153          *                                                   maximum allowed (i.e. > OS_LOWEST_PRIO)
    154          *
    155          * Returns    : != (void *)0  is a pointer to the event control clock (OS_EVENT) associated with the
    156          *                            created mutex.
    157          *              == (void *)0  if an error is detected.
    158          *
    159          * Note(s)    : 1) The LEAST significant 8 bits of '.OSEventCnt' are used to hold the priority number
    160          *                 of the task owning the mutex or 0xFF if no task owns the mutex.
    161          *
    162          *              2) The MOST  significant 8 bits of '.OSEventCnt' are used to hold the priority number
    163          *                 to use to reduce priority inversion.
    164          *********************************************************************************************************
    165          */
    166          

   \                                 In section .text, align 2, keep-with-next
    167          OS_EVENT  *OSMutexCreate (INT8U prio, INT8U *perr)
    168          {
   \                     OSMutexCreate:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    169              OS_EVENT  *pevent;
    170          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    171              OS_CPU_SR  cpu_sr = 0;
    172          #endif
    173          
    174          
    175          
    176          #if OS_ARG_CHK_EN > 0
    177              if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
    178                  return ((OS_EVENT *)0);
    179              }
    180              if (prio >= OS_LOWEST_PRIO) {                          /* Validate PIP                             */
    181                  *perr = OS_ERR_PRIO_INVALID;
    182                  return ((OS_EVENT *)0);
    183              }
    184          #endif
    185              if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable5
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0xB108             CBZ.N    R0,??OSMutexCreate_0
    186                  *perr = OS_ERR_CREATE_ISR;                         /* ... can't CREATE mutex from an ISR       */
   \   0000000E   0x2010             MOVS     R0,#+16
   \   00000010   0xE019             B.N      ??OSMutexCreate_1
    187                  return ((OS_EVENT *)0);
    188              }
    189              OS_ENTER_CRITICAL();
   \                     ??OSMutexCreate_0:
   \   00000012   0x.... 0x....      BL       OS_CPU_SR_Save
    190              if (OSTCBPrioTbl[prio] != (OS_TCB *)0) {               /* Mutex priority must not already exist    */
   \   00000016   0x4621             MOV      R1,R4
   \   00000018   0x.... 0x....      LDR.W    R2,??DataTable5_2
   \   0000001C   0xF852 0x3021      LDR      R3,[R2, R1, LSL #+2]
   \   00000020   0xB11B             CBZ.N    R3,??OSMutexCreate_2
    191                  OS_EXIT_CRITICAL();                                /* Task already exist at priority ...       */
   \   00000022   0x.... 0x....      BL       OS_CPU_SR_Restore
    192                  *perr = OS_ERR_PRIO_EXIST;                         /* ... inheritance priority                 */
   \   00000026   0x2028             MOVS     R0,#+40
   \   00000028   0xE00D             B.N      ??OSMutexCreate_1
    193                  return ((OS_EVENT *)0);
    194              }
    195              OSTCBPrioTbl[prio] = OS_TCB_RESERVED;                  /* Reserve the table entry                  */
   \                     ??OSMutexCreate_2:
   \   0000002A   0x2301             MOVS     R3,#+1
   \   0000002C   0xF842 0x3021      STR      R3,[R2, R1, LSL #+2]
    196              pevent             = OSEventFreeList;                  /* Get next free event control block        */
   \   00000030   0x.... 0x....      LDR.W    R3,??DataTable5_3
   \   00000034   0x681F             LDR      R7,[R3, #+0]
   \   00000036   0x003E             MOVS     R6,R7
    197              if (pevent == (OS_EVENT *)0) {                         /* See if an ECB was available              */
   \   00000038   0xD108             BNE.N    ??OSMutexCreate_3
    198                  OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* No, Release the table entry              */
   \   0000003A   0x2300             MOVS     R3,#+0
   \   0000003C   0xF842 0x3021      STR      R3,[R2, R1, LSL #+2]
    199                  OS_EXIT_CRITICAL();
   \   00000040   0x.... 0x....      BL       OS_CPU_SR_Restore
    200                  *perr              = OS_ERR_PEVENT_NULL;           /* No more event control blocks             */
   \   00000044   0x2004             MOVS     R0,#+4
   \                     ??OSMutexCreate_1:
   \   00000046   0x7028             STRB     R0,[R5, #+0]
    201                  return (pevent);
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xBDF2             POP      {R1,R4-R7,PC}
    202              }
    203              OSEventFreeList        = (OS_EVENT *)OSEventFreeList->OSEventPtr;   /* Adjust the free list        */
   \                     ??OSMutexCreate_3:
   \   0000004C   0x6879             LDR      R1,[R7, #+4]
   \   0000004E   0x6019             STR      R1,[R3, #+0]
    204              OS_EXIT_CRITICAL();
   \   00000050   0x.... 0x....      BL       OS_CPU_SR_Restore
    205              pevent->OSEventType    = OS_EVENT_TYPE_MUTEX;
   \   00000054   0x2004             MOVS     R0,#+4
   \   00000056   0x7038             STRB     R0,[R7, #+0]
    206              pevent->OSEventCnt     = (INT16U)((INT16U)prio << 8) | OS_MUTEX_AVAILABLE; /* Resource is avail.   */
   \   00000058   0x0220             LSLS     R0,R4,#+8
   \   0000005A   0xF040 0x00FF      ORR      R0,R0,#0xFF
   \   0000005E   0x8138             STRH     R0,[R7, #+8]
    207              pevent->OSEventPtr     = (void *)0;                                 /* No task owning the mutex    */
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x6078             STR      R0,[R7, #+4]
    208          #if OS_EVENT_NAME_SIZE > 1
    209              pevent->OSEventName[0] = '?';
    210              pevent->OSEventName[1] = OS_ASCII_NUL;
    211          #endif
    212              OS_EventWaitListInit(pevent);
   \   00000064   0x4638             MOV      R0,R7
   \   00000066   0x.... 0x....      BL       OS_EventWaitListInit
    213              *perr                  = OS_ERR_NONE;
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x7028             STRB     R0,[R5, #+0]
    214              return (pevent);
   \   0000006E   0x4638             MOV      R0,R7
   \   00000070   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    215          }
    216          
    217          /*$PAGE*/
    218          /*
    219          *********************************************************************************************************
    220          *                                          DELETE A MUTEX
    221          *
    222          * Description: This function deletes a mutual exclusion semaphore and readies all tasks pending on the it.
    223          *
    224          * Arguments  : pevent        is a pointer to the event control block associated with the desired mutex.
    225          *
    226          *              opt           determines delete options as follows:
    227          *                            opt == OS_DEL_NO_PEND   Delete mutex ONLY if no task pending
    228          *                            opt == OS_DEL_ALWAYS    Deletes the mutex even if tasks are waiting.
    229          *                                                    In this case, all the tasks pending will be readied.
    230          *
    231          *              perr          is a pointer to an error code that can contain one of the following values:
    232          *                            OS_ERR_NONE             The call was successful and the mutex was deleted
    233          *                            OS_ERR_DEL_ISR          If you attempted to delete the MUTEX from an ISR
    234          *                            OS_ERR_INVALID_OPT      An invalid option was specified
    235          *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mutex
    236          *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
    237          *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
    238          *
    239          * Returns    : pevent        upon error
    240          *              (OS_EVENT *)0 if the mutex was successfully deleted.
    241          *
    242          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
    243          *                 the mutex MUST check the return code of OSMutexPend().
    244          *
    245          *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
    246          *                 time is directly proportional to the number of tasks waiting on the mutex.
    247          *
    248          *              3) Because ALL tasks pending on the mutex will be readied, you MUST be careful because the
    249          *                 resource(s) will no longer be guarded by the mutex.
    250          *
    251          *              4) IMPORTANT: In the 'OS_DEL_ALWAYS' case, we assume that the owner of the Mutex (if there
    252          *                            is one) is ready-to-run and is thus NOT pending on another kernel object or
    253          *                            has delayed itself.  In other words, if a task owns the mutex being deleted,
    254          *                            that task will be made ready-to-run at its original priority.
    255          *********************************************************************************************************
    256          */
    257          
    258          #if OS_MUTEX_DEL_EN

   \                                 In section .text, align 2, keep-with-next
    259          OS_EVENT  *OSMutexDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
    260          {
   \                     OSMutexDel:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4615             MOV      R5,R2
    261              BOOLEAN    tasks_waiting;
    262              OS_EVENT  *pevent_return;
    263              INT8U      pip;                                        /* Priority inheritance priority            */
    264              INT8U      prio;
    265              OS_TCB    *ptcb;
    266          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    267              OS_CPU_SR  cpu_sr = 0;
    268          #endif
    269          
    270          
    271          
    272          #if OS_ARG_CHK_EN > 0
    273              if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
    274                  return (pevent);
    275              }
    276              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    277                  *perr = OS_ERR_PEVENT_NULL;
    278                  return (pevent);
    279              }
    280          #endif
    281              if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xBF18             IT       NE 
   \   00000010   0x2001             MOVNE    R0,#+1
    282                  *perr = OS_ERR_EVENT_TYPE;
   \   00000012   0xD104             BNE.N    ??OSMutexDel_0
    283                  return (pevent);
    284              }
    285              if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable5
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0xB118             CBZ.N    R0,??OSMutexDel_1
    286                  *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
   \   0000001C   0x200F             MOVS     R0,#+15
   \                     ??OSMutexDel_0:
   \   0000001E   0x7028             STRB     R0,[R5, #+0]
    287                  return (pevent);
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0xE08C             B.N      ??OSMutexDel_2
    288              }
    289              OS_ENTER_CRITICAL();
   \                     ??OSMutexDel_1:
   \   00000024   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000028   0x4680             MOV      R8,R0
    290              if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mutex        */
   \   0000002A   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000002C   0x1E47             SUBS     R7,R0,#+1
   \   0000002E   0x41BF             SBCS     R7,R7,R7
   \   00000030   0x43FF             MVNS     R7,R7
   \   00000032   0x0FFF             LSRS     R7,R7,#+31
    291                  tasks_waiting = OS_TRUE;                           /* Yes                                      */
    292              } else {
    293                  tasks_waiting = OS_FALSE;                          /* No                                       */
    294              }
    295              switch (opt) {
   \   00000034   0xB116             CBZ.N    R6,??OSMutexDel_3
   \   00000036   0x2E01             CMP      R6,#+1
   \   00000038   0xD019             BEQ.N    ??OSMutexDel_4
   \   0000003A   0xE07A             B.N      ??OSMutexDel_5
    296                  case OS_DEL_NO_PEND:                               /* DELETE MUTEX ONLY IF NO TASK WAITING --- */
    297                       if (tasks_waiting == OS_FALSE) {
   \                     ??OSMutexDel_3:
   \   0000003C   0xB997             CBNZ.N   R7,??OSMutexDel_6
    298          #if OS_EVENT_NAME_SIZE > 1
    299                           pevent->OSEventName[0] = '?';             /* Unknown name                             */
    300                           pevent->OSEventName[1] = OS_ASCII_NUL;
    301          #endif
    302                           pip                 = (INT8U)(pevent->OSEventCnt >> 8);
    303                           OSTCBPrioTbl[pip]   = (OS_TCB *)0;        /* Free up the PIP                          */
   \   0000003E   0x8920             LDRH     R0,[R4, #+8]
   \   00000040   0x0400             LSLS     R0,R0,#+16
   \   00000042   0x0E00             LSRS     R0,R0,#+24
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable5_2
   \   00000048   0x2200             MOVS     R2,#+0
   \   0000004A   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    304                           pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
   \   0000004E   0x7022             STRB     R2,[R4, #+0]
    305                           pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
   \   00000050   0x.... 0x....      LDR.W    R0,??DataTable5_3
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0x6061             STR      R1,[R4, #+4]
    306                           pevent->OSEventCnt  = 0;
   \   00000058   0x8122             STRH     R2,[R4, #+8]
    307                           OSEventFreeList     = pevent;
   \   0000005A   0x6004             STR      R4,[R0, #+0]
    308                           OS_EXIT_CRITICAL();
   \   0000005C   0x4640             MOV      R0,R8
   \   0000005E   0x.... 0x....      BL       OS_CPU_SR_Restore
    309                           *perr               = OS_ERR_NONE;
   \   00000062   0xE063             B.N      ??OSMutexDel_7
    310                           pevent_return       = (OS_EVENT *)0;      /* Mutex has been deleted                   */
    311                       } else {
    312                           OS_EXIT_CRITICAL();
   \                     ??OSMutexDel_6:
   \   00000064   0x4640             MOV      R0,R8
   \   00000066   0x.... 0x....      BL       OS_CPU_SR_Restore
    313                           *perr               = OS_ERR_TASK_WAITING;
   \   0000006A   0x2149             MOVS     R1,#+73
    314                           pevent_return       = pevent;
   \   0000006C   0xE065             B.N      ??OSMutexDel_8
    315                       }
    316                       break;
    317          
    318                  case OS_DEL_ALWAYS:                                /* ALWAYS DELETE THE MUTEX ---------------- */
    319                       pip  = (INT8U)(pevent->OSEventCnt >> 8);                     /* Get PIP of mutex          */
    320                       prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original prio */
   \                     ??OSMutexDel_4:
   \   0000006E   0x8922             LDRH     R2,[R4, #+8]
   \   00000070   0x4610             MOV      R0,R2
    321                       ptcb = (OS_TCB *)pevent->OSEventPtr;
   \   00000072   0x6861             LDR      R1,[R4, #+4]
    322                       if (ptcb != (OS_TCB *)0) {                    /* See if any task owns the mutex           */
   \   00000074   0x2900             CMP      R1,#+0
   \   00000076   0xD03B             BEQ.N    ??OSMutexDel_9
    323                           if (ptcb->OSTCBPrio == pip) {             /* See if original prio was changed         */
   \   00000078   0x7F8B             LDRB     R3,[R1, #+30]
   \   0000007A   0xEBB3 0x2F12      CMP      R3,R2, LSR #+8
   \   0000007E   0xD137             BNE.N    ??OSMutexDel_9
    324                               OSMutex_RdyAtPrio(ptcb, prio);        /* Yes, Restore the task's original prio    */
   \   00000080   0xF891 0x3020      LDRB     R3,[R1, #+32]
   \   00000084   0x.... 0x....      LDR.W    R2,??DataTable5_4
   \   00000088   0xF813 0xC002      LDRB     R12,[R3, R2]
   \   0000008C   0xF891 0xE021      LDRB     LR,[R1, #+33]
   \   00000090   0xEA3C 0x0C0E      BICS     R12,R12,LR
   \   00000094   0xF803 0xC002      STRB     R12,[R3, R2]
   \   00000098   0x.... 0x....      LDR.W    R3,??DataTable5_5
   \   0000009C   0xD107             BNE.N    ??OSMutexDel_10
   \   0000009E   0xF893 0xC000      LDRB     R12,[R3, #+0]
   \   000000A2   0xF891 0xE022      LDRB     LR,[R1, #+34]
   \   000000A6   0xEA2C 0x0C0E      BIC      R12,R12,LR
   \   000000AA   0xF883 0xC000      STRB     R12,[R3, #+0]
   \                     ??OSMutexDel_10:
   \   000000AE   0x7788             STRB     R0,[R1, #+30]
   \   000000B0   0xF3C0 0x0CC2      UBFX     R12,R0,#+3,#+3
   \   000000B4   0xF881 0xC020      STRB     R12,[R1, #+32]
   \   000000B8   0xF000 0x0E07      AND      LR,R0,#0x7
   \   000000BC   0xF881 0xE01F      STRB     LR,[R1, #+31]
   \   000000C0   0xFA06 0xFC0C      LSL      R12,R6,R12
   \   000000C4   0xF881 0xC022      STRB     R12,[R1, #+34]
   \   000000C8   0xFA06 0xF60E      LSL      R6,R6,LR
   \   000000CC   0xF881 0x6021      STRB     R6,[R1, #+33]
   \   000000D0   0x781E             LDRB     R6,[R3, #+0]
   \   000000D2   0xEA4C 0x0606      ORR      R6,R12,R6
   \   000000D6   0x701E             STRB     R6,[R3, #+0]
   \   000000D8   0xF891 0x3020      LDRB     R3,[R1, #+32]
   \   000000DC   0x5C9E             LDRB     R6,[R3, R2]
   \   000000DE   0xF891 0xE021      LDRB     LR,[R1, #+33]
   \   000000E2   0xEA4E 0x0606      ORR      R6,LR,R6
   \   000000E6   0x549E             STRB     R6,[R3, R2]
   \   000000E8   0xB2C0             UXTB     R0,R0
   \   000000EA   0x....             LDR.N    R2,??DataTable5_2
   \   000000EC   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
    325                           }
    326                       }
    327                       while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mutex        */
   \                     ??OSMutexDel_9:
   \   000000F0   0x7AA0             LDRB     R0,[R4, #+10]
   \   000000F2   0xB140             CBZ.N    R0,??OSMutexDel_11
    328                           (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
   \                     ??OSMutexDel_12:
   \   000000F4   0x2300             MOVS     R3,#+0
   \   000000F6   0x2210             MOVS     R2,#+16
   \   000000F8   0x2100             MOVS     R1,#+0
   \   000000FA   0x4620             MOV      R0,R4
   \   000000FC   0x.... 0x....      BL       OS_EventTaskRdy
   \   00000100   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000102   0x2800             CMP      R0,#+0
   \   00000104   0xD1F6             BNE.N    ??OSMutexDel_12
    329                       }
    330          #if OS_EVENT_NAME_SIZE > 1
    331                       pevent->OSEventName[0] = '?';                 /* Unknown name                             */
    332                       pevent->OSEventName[1] = OS_ASCII_NUL;
    333          #endif
    334                       pip                 = (INT8U)(pevent->OSEventCnt >> 8);
    335                       OSTCBPrioTbl[pip]   = (OS_TCB *)0;            /* Free up the PIP                          */
   \                     ??OSMutexDel_11:
   \   00000106   0x8920             LDRH     R0,[R4, #+8]
   \   00000108   0x0400             LSLS     R0,R0,#+16
   \   0000010A   0x0E00             LSRS     R0,R0,#+24
   \   0000010C   0x....             LDR.N    R1,??DataTable5_2
   \   0000010E   0x2200             MOVS     R2,#+0
   \   00000110   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    336                       pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
   \   00000114   0x7022             STRB     R2,[R4, #+0]
    337                       pevent->OSEventPtr  = OSEventFreeList;        /* Return Event Control Block to free list  */
   \   00000116   0x....             LDR.N    R0,??DataTable5_3
   \   00000118   0x6801             LDR      R1,[R0, #+0]
   \   0000011A   0x6061             STR      R1,[R4, #+4]
    338                       pevent->OSEventCnt  = 0;
   \   0000011C   0x8122             STRH     R2,[R4, #+8]
    339                       OSEventFreeList     = pevent;                 /* Get next free event control block        */
   \   0000011E   0x6004             STR      R4,[R0, #+0]
    340                       OS_EXIT_CRITICAL();
   \   00000120   0x4640             MOV      R0,R8
   \   00000122   0x.... 0x....      BL       OS_CPU_SR_Restore
    341                       if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
   \   00000126   0xB10F             CBZ.N    R7,??OSMutexDel_7
    342                           OS_Sched();                               /* Find highest priority task ready to run  */
   \   00000128   0x.... 0x....      BL       OS_Sched
    343                       }
    344                       *perr         = OS_ERR_NONE;
   \                     ??OSMutexDel_7:
   \   0000012C   0x2100             MOVS     R1,#+0
    345                       pevent_return = (OS_EVENT *)0;                /* Mutex has been deleted                   */
   \   0000012E   0x2000             MOVS     R0,#+0
    346                       break;
   \   00000130   0xE004             B.N      ??OSMutexDel_13
    347          
    348                  default:
    349                       OS_EXIT_CRITICAL();
   \                     ??OSMutexDel_5:
   \   00000132   0x4640             MOV      R0,R8
   \   00000134   0x.... 0x....      BL       OS_CPU_SR_Restore
    350                       *perr         = OS_ERR_INVALID_OPT;
   \   00000138   0x2107             MOVS     R1,#+7
    351                       pevent_return = pevent;
   \                     ??OSMutexDel_8:
   \   0000013A   0x4620             MOV      R0,R4
    352                       break;
   \                     ??OSMutexDel_13:
   \   0000013C   0x7029             STRB     R1,[R5, #+0]
    353              }
    354              return (pevent_return);
   \                     ??OSMutexDel_2:
   \   0000013E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    355          }
    356          #endif
    357          
    358          /*$PAGE*/
    359          /*
    360          *********************************************************************************************************
    361          *                                  PEND ON MUTUAL EXCLUSION SEMAPHORE
    362          *
    363          * Description: This function waits for a mutual exclusion semaphore.
    364          *
    365          * Arguments  : pevent        is a pointer to the event control block associated with the desired
    366          *                            mutex.
    367          *
    368          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
    369          *                            wait for the resource up to the amount of time specified by this argument.
    370          *                            If you specify 0, however, your task will wait forever at the specified
    371          *                            mutex or, until the resource becomes available.
    372          *
    373          *              perr          is a pointer to where an error message will be deposited.  Possible error
    374          *                            messages are:
    375          *                               OS_ERR_NONE        The call was successful and your task owns the mutex
    376          *                               OS_ERR_TIMEOUT     The mutex was not available within the specified 'timeout'.
    377          *                               OS_ERR_PEND_ABORT  The wait on the mutex was aborted.
    378          *                               OS_ERR_EVENT_TYPE  If you didn't pass a pointer to a mutex
    379          *                               OS_ERR_PEVENT_NULL 'pevent' is a NULL pointer
    380          *                               OS_ERR_PEND_ISR    If you called this function from an ISR and the result
    381          *                                                  would lead to a suspension.
    382          *                               OS_ERR_PIP_LOWER   If the priority of the task that owns the Mutex is
    383          *                                                  HIGHER (i.e. a lower number) than the PIP.  This error
    384          *                                                  indicates that you did not set the PIP higher (lower
    385          *                                                  number) than ALL the tasks that compete for the Mutex.
    386          *                                                  Unfortunately, this is something that could not be
    387          *                                                  detected when the Mutex is created because we don't know
    388          *                                                  what tasks will be using the Mutex.
    389          *                               OS_ERR_PEND_LOCKED If you called this function when the scheduler is locked
    390          *
    391          * Returns    : none
    392          *
    393          * Note(s)    : 1) The task that owns the Mutex MUST NOT pend on any other event while it owns the mutex.
    394          *
    395          *              2) You MUST NOT change the priority of the task that owns the mutex
    396          *********************************************************************************************************
    397          */

   \                                 In section .text, align 2, keep-with-next
    398          void  OSMutexPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
    399          {
   \                     OSMutexPend:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    400              INT8U      pip;                                        /* Priority Inheritance Priority (PIP)      */
    401              INT8U      mprio;                                      /* Mutex owner priority                     */
    402              BOOLEAN    rdy;                                        /* Flag indicating task was ready           */
    403              OS_TCB    *ptcb;
    404              OS_EVENT  *pevent2;
    405              INT8U      y;
    406              INT8U      pend_stat;
    407          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    408              OS_CPU_SR  cpu_sr = 0;
    409          #endif
    410          
    411          
    412          
    413          #if OS_ARG_CHK_EN > 0
    414              if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
    415                  return;
    416              }
    417              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    418                  *perr = OS_ERR_PEVENT_NULL;
    419                  return;
    420              }
    421          #endif
    422              if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0x2804             CMP      R0,#+4
   \   0000000E   0xBF18             IT       NE 
   \   00000010   0x2001             MOVNE    R0,#+1
    423                  *perr = OS_ERR_EVENT_TYPE;
   \   00000012   0xF040 0x80C6      BNE.W    ??OSMutexPend_0
    424                  return;
    425              }
    426              if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
   \   00000016   0x....             LDR.N    R0,??DataTable5
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0xB108             CBZ.N    R0,??OSMutexPend_1
    427                  *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
   \   0000001C   0x2002             MOVS     R0,#+2
   \   0000001E   0xE0C0             B.N      ??OSMutexPend_0
    428                  return;
    429              }
    430              if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
   \                     ??OSMutexPend_1:
   \   00000020   0x....             LDR.N    R0,??DataTable5_6
   \   00000022   0x7800             LDRB     R0,[R0, #+0]
   \   00000024   0xB108             CBZ.N    R0,??OSMutexPend_2
    431                  *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
   \   00000026   0x200D             MOVS     R0,#+13
   \   00000028   0xE0BB             B.N      ??OSMutexPend_0
    432                  return;
    433              }
    434              OS_ENTER_CRITICAL();                                
   \                     ??OSMutexPend_2:
   \   0000002A   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000002E   0x4680             MOV      R8,R0
    435              pip = (INT8U)(pevent->OSEventCnt >> 8);                /* Get PIP from mutex                       */
   \   00000030   0x8920             LDRH     R0,[R4, #+8]
   \   00000032   0x0A01             LSRS     R1,R0,#+8
    436                                                                     /* Is Mutex available?                      */
    437              if ((INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8) == OS_MUTEX_AVAILABLE) {
   \   00000034   0x....             LDR.N    R7,??DataTable5_1
   \   00000036   0xB2C2             UXTB     R2,R0
   \   00000038   0x2AFF             CMP      R2,#+255
   \   0000003A   0xD110             BNE.N    ??OSMutexPend_3
    438                  pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;       /* Yes, Acquire the resource                */
   \   0000003C   0xF400 0x407F      AND      R0,R0,#0xFF00
   \   00000040   0x8120             STRH     R0,[R4, #+8]
    439                  pevent->OSEventCnt |= OSTCBCur->OSTCBPrio;         /*      Save priority of owning task        */
   \   00000042   0x683A             LDR      R2,[R7, #+0]
   \   00000044   0x7F93             LDRB     R3,[R2, #+30]
   \   00000046   0x4318             ORRS     R0,R3,R0
   \   00000048   0x8120             STRH     R0,[R4, #+8]
    440                  pevent->OSEventPtr  = (void *)OSTCBCur;            /*      Point to owning task's OS_TCB       */
   \   0000004A   0x6062             STR      R2,[R4, #+4]
    441                  if (OSTCBCur->OSTCBPrio <= pip) {                  /*      PIP 'must' have a SMALLER prio ...  */
   \   0000004C   0x7F90             LDRB     R0,[R2, #+30]
   \   0000004E   0x4281             CMP      R1,R0
   \   00000050   0x4640             MOV      R0,R8
   \   00000052   0xF2C0 0x80A3      BLT.W    ??OSMutexPend_4
    442                      OS_EXIT_CRITICAL();                            /*      ... than current task!              */
   \   00000056   0x.... 0x....      BL       OS_CPU_SR_Restore
    443                      *perr = OS_ERR_PIP_LOWER;
   \   0000005A   0x2078             MOVS     R0,#+120
   \   0000005C   0xE0A1             B.N      ??OSMutexPend_0
    444                  } else {
    445                      OS_EXIT_CRITICAL();
    446                      *perr = OS_ERR_NONE;
    447                  }
    448                  return;
    449              }
    450              mprio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* No, Get priority of mutex owner   */
    451              ptcb  = (OS_TCB *)(pevent->OSEventPtr);                       /*     Point to TCB of mutex owner   */
   \                     ??OSMutexPend_3:
   \   0000005E   0x6862             LDR      R2,[R4, #+4]
    452              if (ptcb->OSTCBPrio > pip) {                                  /*     Need to promote prio of owner?*/
   \   00000060   0x7F93             LDRB     R3,[R2, #+30]
   \   00000062   0x4299             CMP      R1,R3
   \   00000064   0xDA74             BGE.N    ??OSMutexPend_5
    453                  if (mprio > OSTCBCur->OSTCBPrio) {
   \   00000066   0x683B             LDR      R3,[R7, #+0]
   \   00000068   0x7F9B             LDRB     R3,[R3, #+30]
   \   0000006A   0xB2C0             UXTB     R0,R0
   \   0000006C   0x4283             CMP      R3,R0
   \   0000006E   0xD26F             BCS.N    ??OSMutexPend_5
    454                      y = ptcb->OSTCBY;
   \   00000070   0xF892 0xE020      LDRB     LR,[R2, #+32]
    455                      if ((OSRdyTbl[y] & ptcb->OSTCBBitX) != 0) {           /*     See if mutex owner is ready   */
   \   00000074   0x....             LDR.N    R3,??DataTable5_4
   \   00000076   0xF81E 0x9003      LDRB     R9,[LR, R3]
   \   0000007A   0xF892 0xC021      LDRB     R12,[R2, #+33]
   \   0000007E   0xEA19 0x0F0C      TST      R9,R12
   \   00000082   0xD00F             BEQ.N    ??OSMutexPend_6
   \   00000084   0xEA39 0x000C      BICS     R0,R9,R12
   \   00000088   0xF80E 0x0003      STRB     R0,[LR, R3]
    456                          OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                  /*     Yes, Remove owner from Rdy ...*/
    457                          if (OSRdyTbl[y] == 0) {                           /*          ... list at current prio */
   \   0000008C   0xD108             BNE.N    ??OSMutexPend_7
    458                              OSRdyGrp &= ~ptcb->OSTCBBitY;
   \   0000008E   0x....             LDR.N    R0,??DataTable5_5
   \   00000090   0xF890 0xC000      LDRB     R12,[R0, #+0]
   \   00000094   0xF892 0xE022      LDRB     LR,[R2, #+34]
   \   00000098   0xEA2C 0x0C0E      BIC      R12,R12,LR
   \   0000009C   0xF880 0xC000      STRB     R12,[R0, #+0]
    459                          }
    460                          rdy = OS_TRUE;
   \                     ??OSMutexPend_7:
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0xE019             B.N      ??OSMutexPend_8
    461                      } else {
    462                          pevent2 = ptcb->OSTCBEventPtr;
   \                     ??OSMutexPend_6:
   \   000000A4   0x68D0             LDR      R0,[R2, #+12]
    463                          if (pevent2 != (OS_EVENT *)0) {                   /* Remove from event wait list       */
   \   000000A6   0xB1B0             CBZ.N    R0,??OSMutexPend_9
    464                              if ((pevent2->OSEventTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX) == 0) {
   \   000000A8   0x4486             ADD      LR,LR,R0
   \   000000AA   0xF89E 0x900B      LDRB     R9,[LR, #+11]
   \   000000AE   0xEA29 0x0C0C      BIC      R12,R9,R12
   \   000000B2   0xF88E 0xC00B      STRB     R12,[LR, #+11]
   \   000000B6   0xF892 0xC020      LDRB     R12,[R2, #+32]
   \   000000BA   0x4484             ADD      R12,R12,R0
   \   000000BC   0xF89C 0xC00B      LDRB     R12,[R12, #+11]
   \   000000C0   0xF1BC 0x0F00      CMP      R12,#+0
   \   000000C4   0xD107             BNE.N    ??OSMutexPend_9
    465                                  pevent2->OSEventGrp &= ~ptcb->OSTCBBitY;
   \   000000C6   0xF890 0xC00A      LDRB     R12,[R0, #+10]
   \   000000CA   0xF892 0xE022      LDRB     LR,[R2, #+34]
   \   000000CE   0xEA2C 0x0C0E      BIC      R12,R12,LR
   \   000000D2   0xF880 0xC00A      STRB     R12,[R0, #+10]
    466                              }
    467                          }
    468                          rdy = OS_FALSE;                            /* No                                       */
   \                     ??OSMutexPend_9:
   \   000000D6   0x2000             MOVS     R0,#+0
    469                      }
    470                      ptcb->OSTCBPrio = pip;                         /* Change owner task prio to PIP            */
   \                     ??OSMutexPend_8:
   \   000000D8   0x7791             STRB     R1,[R2, #+30]
    471          #if OS_LOWEST_PRIO <= 63
    472                      ptcb->OSTCBY    = (INT8U)( ptcb->OSTCBPrio >> 3);
   \   000000DA   0xEA4F 0x0ED1      LSR      LR,R1,#+3
   \   000000DE   0xF882 0xE020      STRB     LR,[R2, #+32]
    473                      ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x07);
   \   000000E2   0xF001 0x0C07      AND      R12,R1,#0x7
   \   000000E6   0xF882 0xC01F      STRB     R12,[R2, #+31]
    474                      ptcb->OSTCBBitY = (INT8U)(1 << ptcb->OSTCBY);
   \   000000EA   0xF04F 0x0901      MOV      R9,#+1
   \   000000EE   0xFA09 0xFE0E      LSL      LR,R9,LR
   \   000000F2   0xF882 0xE022      STRB     LR,[R2, #+34]
    475                      ptcb->OSTCBBitX = (INT8U)(1 << ptcb->OSTCBX);
   \   000000F6   0xFA09 0xFC0C      LSL      R12,R9,R12
   \   000000FA   0xF882 0xC021      STRB     R12,[R2, #+33]
    476          #else
    477                      ptcb->OSTCBY    = (INT8U)((ptcb->OSTCBPrio >> 4) & 0xFF);
    478                      ptcb->OSTCBX    = (INT8U)( ptcb->OSTCBPrio & 0x0F);
    479                      ptcb->OSTCBBitY = (INT16U)(1 << ptcb->OSTCBY);
    480                      ptcb->OSTCBBitX = (INT16U)(1 << ptcb->OSTCBX);
    481          #endif
    482                      if (rdy == OS_TRUE) {                          /* If task was ready at owner's priority ...*/
   \   000000FE   0xB198             CBZ.N    R0,??OSMutexPend_10
    483                          OSRdyGrp               |= ptcb->OSTCBBitY; /* ... make it ready at new priority.       */
   \   00000100   0x....             LDR.N    R0,??DataTable5_5
   \   00000102   0xF890 0xC000      LDRB     R12,[R0, #+0]
   \   00000106   0xF892 0xE022      LDRB     LR,[R2, #+34]
   \   0000010A   0xEA4E 0x0C0C      ORR      R12,LR,R12
   \   0000010E   0xF880 0xC000      STRB     R12,[R0, #+0]
    484                          OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   00000112   0xF892 0x0020      LDRB     R0,[R2, #+32]
   \   00000116   0xF810 0xC003      LDRB     R12,[R0, R3]
   \   0000011A   0xF892 0xE021      LDRB     LR,[R2, #+33]
   \   0000011E   0xEA4E 0x0C0C      ORR      R12,LR,R12
   \   00000122   0xF800 0xC003      STRB     R12,[R0, R3]
   \   00000126   0xE010             B.N      ??OSMutexPend_11
    485                      } else {
    486                          pevent2 = ptcb->OSTCBEventPtr;
   \                     ??OSMutexPend_10:
   \   00000128   0x68D0             LDR      R0,[R2, #+12]
    487                          if (pevent2 != (OS_EVENT *)0) {            /* Add to event wait list                   */
   \   0000012A   0xB170             CBZ.N    R0,??OSMutexPend_11
    488                              pevent2->OSEventGrp               |= ptcb->OSTCBBitY;
   \   0000012C   0x7A83             LDRB     R3,[R0, #+10]
   \   0000012E   0xF892 0xC022      LDRB     R12,[R2, #+34]
   \   00000132   0xEA4C 0x0303      ORR      R3,R12,R3
   \   00000136   0x7283             STRB     R3,[R0, #+10]
    489                              pevent2->OSEventTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   00000138   0xF892 0x3020      LDRB     R3,[R2, #+32]
   \   0000013C   0x1818             ADDS     R0,R3,R0
   \   0000013E   0x7AC3             LDRB     R3,[R0, #+11]
   \   00000140   0xF892 0xC021      LDRB     R12,[R2, #+33]
   \   00000144   0xEA4C 0x0303      ORR      R3,R12,R3
   \   00000148   0x72C3             STRB     R3,[R0, #+11]
    490                          }
    491                      }
    492                      OSTCBPrioTbl[pip] = ptcb;
   \                     ??OSMutexPend_11:
   \   0000014A   0x....             LDR.N    R0,??DataTable5_2
   \   0000014C   0xF840 0x2021      STR      R2,[R0, R1, LSL #+2]
    493                  }
    494              }
    495              OSTCBCur->OSTCBStat     |= OS_STAT_MUTEX;         /* Mutex not available, pend current task        */
   \                     ??OSMutexPend_5:
   \   00000150   0x6838             LDR      R0,[R7, #+0]
   \   00000152   0x7F01             LDRB     R1,[R0, #+28]
   \   00000154   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000158   0x7701             STRB     R1,[R0, #+28]
    496              OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
   \   0000015A   0x6838             LDR      R0,[R7, #+0]
   \   0000015C   0x2100             MOVS     R1,#+0
   \   0000015E   0x7741             STRB     R1,[R0, #+29]
    497              OSTCBCur->OSTCBDly       = timeout;               /* Store timeout in current task's TCB           */
   \   00000160   0x6838             LDR      R0,[R7, #+0]
   \   00000162   0x8345             STRH     R5,[R0, #+26]
    498              OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
   \   00000164   0x4620             MOV      R0,R4
   \   00000166   0x.... 0x....      BL       OS_EventTaskWait
    499              OS_EXIT_CRITICAL();
   \   0000016A   0x4640             MOV      R0,R8
   \   0000016C   0x.... 0x....      BL       OS_CPU_SR_Restore
    500              OS_Sched();                                       /* Find next highest priority task ready         */
   \   00000170   0x.... 0x....      BL       OS_Sched
    501              OS_ENTER_CRITICAL();
   \   00000174   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000178   0x4680             MOV      R8,R0
    502              if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) { /* See if we timed out during the pend           */
   \   0000017A   0x6838             LDR      R0,[R7, #+0]
   \   0000017C   0x7F45             LDRB     R5,[R0, #+29]
   \   0000017E   0xB155             CBZ.N    R5,??OSMutexPend_12
    503                  pend_stat = OSTCBCur->OSTCBStatPend;
    504                  OS_EventTOAbort(pevent);
   \   00000180   0x4620             MOV      R0,R4
   \   00000182   0x.... 0x....      BL       OS_EventTOAbort
    505                  OS_EXIT_CRITICAL();
   \   00000186   0x4640             MOV      R0,R8
   \   00000188   0x.... 0x....      BL       OS_CPU_SR_Restore
    506                  switch (pend_stat) {
   \   0000018C   0x2D02             CMP      R5,#+2
   \   0000018E   0xBF0C             ITE      EQ 
   \   00000190   0x200E             MOVEQ    R0,#+14
   \   00000192   0x200A             MOVNE    R0,#+10
    507                      case OS_STAT_PEND_TO:
    508                      default:
    509                           *perr = OS_ERR_TIMEOUT;              /* Indicate that we didn't get mutex within TO   */
   \   00000194   0xE005             B.N      ??OSMutexPend_0
    510                           break;
    511          
    512                      case OS_STAT_PEND_ABORT:
    513                           *perr = OS_ERR_PEND_ABORT;           /* Indicate that we aborted getting mutex        */
    514                           break;
    515                  }
    516                  return;
    517              }
    518              OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;
   \                     ??OSMutexPend_12:
   \   00000196   0x2100             MOVS     R1,#+0
   \   00000198   0x60C1             STR      R1,[R0, #+12]
    519              OS_EXIT_CRITICAL();
   \   0000019A   0x4640             MOV      R0,R8
   \                     ??OSMutexPend_4:
   \   0000019C   0x.... 0x....      BL       OS_CPU_SR_Restore
    520              *perr = OS_ERR_NONE;
   \   000001A0   0x2000             MOVS     R0,#+0
   \                     ??OSMutexPend_0:
   \   000001A2   0x7030             STRB     R0,[R6, #+0]
    521          }
   \   000001A4   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
    522          /*$PAGE*/
    523          /*
    524          *********************************************************************************************************
    525          *                                  POST TO A MUTUAL EXCLUSION SEMAPHORE
    526          *
    527          * Description: This function signals a mutual exclusion semaphore
    528          *
    529          * Arguments  : pevent              is a pointer to the event control block associated with the desired
    530          *                                  mutex.
    531          *
    532          * Returns    : OS_ERR_NONE             The call was successful and the mutex was signaled.
    533          *              OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mutex
    534          *              OS_ERR_PEVENT_NULL      'pevent' is a NULL pointer
    535          *              OS_ERR_POST_ISR         Attempted to post from an ISR (not valid for MUTEXes)
    536          *              OS_ERR_NOT_MUTEX_OWNER  The task that did the post is NOT the owner of the MUTEX.
    537          *              OS_ERR_PIP_LOWER        If the priority of the new task that owns the Mutex is
    538          *                                      HIGHER (i.e. a lower number) than the PIP.  This error
    539          *                                      indicates that you did not set the PIP higher (lower
    540          *                                      number) than ALL the tasks that compete for the Mutex.
    541          *                                      Unfortunately, this is something that could not be
    542          *                                      detected when the Mutex is created because we don't know
    543          *                                      what tasks will be using the Mutex.
    544          *********************************************************************************************************
    545          */
    546          

   \                                 In section .text, align 2, keep-with-next
    547          INT8U  OSMutexPost (OS_EVENT *pevent)
    548          {
   \                     OSMutexPost:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
    549              INT8U      pip;                                   /* Priority inheritance priority                 */
    550              INT8U      prio;
    551          #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    552              OS_CPU_SR  cpu_sr = 0;
    553          #endif
    554          
    555          
    556          
    557              if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
   \   00000006   0x....             LDR.N    R0,??DataTable5
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0xB108             CBZ.N    R0,??OSMutexPost_0
    558                  return (OS_ERR_POST_ISR);                     /* ... can't POST mutex from an ISR              */
   \   0000000C   0x2005             MOVS     R0,#+5
   \   0000000E   0xE073             B.N      ??OSMutexPost_1
    559              }
    560          #if OS_ARG_CHK_EN > 0
    561              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    562                  return (OS_ERR_PEVENT_NULL);
    563              }
    564          #endif
    565              if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) { /* Validate event block type                     */
   \                     ??OSMutexPost_0:
   \   00000010   0x7820             LDRB     R0,[R4, #+0]
   \   00000012   0x2804             CMP      R0,#+4
   \   00000014   0xBF18             IT       NE 
   \   00000016   0x2001             MOVNE    R0,#+1
    566                  return (OS_ERR_EVENT_TYPE);
   \   00000018   0xD16E             BNE.N    ??OSMutexPost_1
    567              }
    568              OS_ENTER_CRITICAL();
   \   0000001A   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001E   0x4680             MOV      R8,R0
    569              pip  = (INT8U)(pevent->OSEventCnt >> 8);          /* Get priority inheritance priority of mutex    */
   \   00000020   0x8920             LDRH     R0,[R4, #+8]
   \   00000022   0x0A06             LSRS     R6,R0,#+8
    570              prio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);  /* Get owner's original priority      */
   \   00000024   0xB2C0             UXTB     R0,R0
    571              if (OSTCBCur != (OS_TCB *)pevent->OSEventPtr) {   /* See if posting task owns the MUTEX            */
   \   00000026   0x....             LDR.N    R1,??DataTable5_1
   \   00000028   0x680B             LDR      R3,[R1, #+0]
   \   0000002A   0x6861             LDR      R1,[R4, #+4]
   \   0000002C   0x428B             CMP      R3,R1
   \   0000002E   0xD004             BEQ.N    ??OSMutexPost_2
    572                  OS_EXIT_CRITICAL();
   \   00000030   0x4640             MOV      R0,R8
   \   00000032   0x.... 0x....      BL       OS_CPU_SR_Restore
    573                  return (OS_ERR_NOT_MUTEX_OWNER);
   \   00000036   0x2064             MOVS     R0,#+100
   \   00000038   0xE05E             B.N      ??OSMutexPost_1
    574              }
    575              if (OSTCBCur->OSTCBPrio == pip) {                 /* Did we have to raise current task's priority? */
   \                     ??OSMutexPost_2:
   \   0000003A   0x7F99             LDRB     R1,[R3, #+30]
   \   0000003C   0x42B1             CMP      R1,R6
   \   0000003E   0xD130             BNE.N    ??OSMutexPost_3
    576                  OSMutex_RdyAtPrio(OSTCBCur, prio);            /* Restore the task's original priority          */
   \   00000040   0xF893 0x7020      LDRB     R7,[R3, #+32]
   \   00000044   0xF103 0x0120      ADD      R1,R3,#+32
   \   00000048   0x....             LDR.N    R2,??DataTable5_4
   \   0000004A   0x5CBD             LDRB     R5,[R7, R2]
   \   0000004C   0xF891 0xE001      LDRB     LR,[R1, #+1]
   \   00000050   0xEA35 0x050E      BICS     R5,R5,LR
   \   00000054   0x54BD             STRB     R5,[R7, R2]
   \   00000056   0x....             LDR.N    R7,??DataTable5_5
   \   00000058   0xD105             BNE.N    ??OSMutexPost_4
   \   0000005A   0x783D             LDRB     R5,[R7, #+0]
   \   0000005C   0xF891 0xE002      LDRB     LR,[R1, #+2]
   \   00000060   0xEA25 0x050E      BIC      R5,R5,LR
   \   00000064   0x703D             STRB     R5,[R7, #+0]
   \                     ??OSMutexPost_4:
   \   00000066   0x7798             STRB     R0,[R3, #+30]
   \   00000068   0xF3C0 0x0CC2      UBFX     R12,R0,#+3,#+3
   \   0000006C   0xF883 0xC020      STRB     R12,[R3, #+32]
   \   00000070   0xF000 0x0E07      AND      LR,R0,#0x7
   \   00000074   0xF883 0xE01F      STRB     LR,[R3, #+31]
   \   00000078   0x2501             MOVS     R5,#+1
   \   0000007A   0xFA05 0xFC0C      LSL      R12,R5,R12
   \   0000007E   0xF881 0xC002      STRB     R12,[R1, #+2]
   \   00000082   0xFA05 0xF50E      LSL      R5,R5,LR
   \   00000086   0x704D             STRB     R5,[R1, #+1]
   \   00000088   0x783D             LDRB     R5,[R7, #+0]
   \   0000008A   0xEA4C 0x0505      ORR      R5,R12,R5
   \   0000008E   0x703D             STRB     R5,[R7, #+0]
   \   00000090   0xF893 0x7020      LDRB     R7,[R3, #+32]
   \   00000094   0x5CBD             LDRB     R5,[R7, R2]
   \   00000096   0x7849             LDRB     R1,[R1, #+1]
   \   00000098   0x4329             ORRS     R1,R1,R5
   \   0000009A   0x54B9             STRB     R1,[R7, R2]
   \   0000009C   0x....             LDR.N    R1,??DataTable5_2
   \   0000009E   0xF841 0x3020      STR      R3,[R1, R0, LSL #+2]
    577              }
    578              OSTCBPrioTbl[pip] = OS_TCB_RESERVED;              /* Reserve table entry                           */
   \                     ??OSMutexPost_3:
   \   000000A2   0x....             LDR.N    R7,??DataTable5_2
   \   000000A4   0x2001             MOVS     R0,#+1
   \   000000A6   0xF847 0x0026      STR      R0,[R7, R6, LSL #+2]
    579              if (pevent->OSEventGrp != 0) {                    /* Any task waiting for the mutex?               */
   \   000000AA   0x7AA0             LDRB     R0,[R4, #+10]
   \   000000AC   0xB1D0             CBZ.N    R0,??OSMutexPost_5
    580                                                                /* Yes, Make HPT waiting for mutex ready         */
    581                  prio                = OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MUTEX, OS_STAT_PEND_OK);
   \   000000AE   0x2300             MOVS     R3,#+0
   \   000000B0   0x2210             MOVS     R2,#+16
   \   000000B2   0x2100             MOVS     R1,#+0
   \   000000B4   0x4620             MOV      R0,R4
   \   000000B6   0x.... 0x....      BL       OS_EventTaskRdy
    582                  pevent->OSEventCnt &= OS_MUTEX_KEEP_UPPER_8;  /*      Save priority of mutex's new owner       */
    583                  pevent->OSEventCnt |= prio;
   \   000000BA   0x8922             LDRH     R2,[R4, #+8]
   \   000000BC   0xF360 0x0207      BFI      R2,R0,#+0,#+8
   \   000000C0   0x8122             STRH     R2,[R4, #+8]
    584                  pevent->OSEventPtr  = OSTCBPrioTbl[prio];     /*      Link to new mutex owner's OS_TCB         */
   \   000000C2   0xF857 0x1020      LDR      R1,[R7, R0, LSL #+2]
   \   000000C6   0x6061             STR      R1,[R4, #+4]
    585                  if (prio <= pip) {                            /*      PIP 'must' have a SMALLER prio ...       */
   \   000000C8   0x4286             CMP      R6,R0
   \   000000CA   0x4640             MOV      R0,R8
   \   000000CC   0xDB05             BLT.N    ??OSMutexPost_6
    586                      OS_EXIT_CRITICAL();                       /*      ... than current task!                   */
   \   000000CE   0x.... 0x....      BL       OS_CPU_SR_Restore
    587                      OS_Sched();                               /*      Find highest priority task ready to run  */
   \   000000D2   0x.... 0x....      BL       OS_Sched
    588                      return (OS_ERR_PIP_LOWER);
   \   000000D6   0x2078             MOVS     R0,#+120
   \   000000D8   0xE00E             B.N      ??OSMutexPost_1
    589                  } else {
    590                      OS_EXIT_CRITICAL();
   \                     ??OSMutexPost_6:
   \   000000DA   0x.... 0x....      BL       OS_CPU_SR_Restore
    591                      OS_Sched();                               /*      Find highest priority task ready to run  */
   \   000000DE   0x.... 0x....      BL       OS_Sched
    592                      return (OS_ERR_NONE);
   \   000000E2   0xE008             B.N      ??OSMutexPost_7
    593                  }
    594              }
    595              pevent->OSEventCnt |= OS_MUTEX_AVAILABLE;         /* No,  Mutex is now available                   */
   \                     ??OSMutexPost_5:
   \   000000E4   0x8920             LDRH     R0,[R4, #+8]
   \   000000E6   0xF040 0x00FF      ORR      R0,R0,#0xFF
   \   000000EA   0x8120             STRH     R0,[R4, #+8]
    596              pevent->OSEventPtr  = (void *)0;
   \   000000EC   0x2000             MOVS     R0,#+0
   \   000000EE   0x6060             STR      R0,[R4, #+4]
    597              OS_EXIT_CRITICAL();
   \   000000F0   0x4640             MOV      R0,R8
   \   000000F2   0x.... 0x....      BL       OS_CPU_SR_Restore
    598              return (OS_ERR_NONE);
   \                     ??OSMutexPost_7:
   \   000000F6   0x2000             MOVS     R0,#+0
   \                     ??OSMutexPost_1:
   \   000000F8   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    599          }
    600          /*$PAGE*/
    601          /*
    602          *********************************************************************************************************
    603          *                                     QUERY A MUTUAL EXCLUSION SEMAPHORE
    604          *
    605          * Description: This function obtains information about a mutex
    606          *
    607          * Arguments  : pevent          is a pointer to the event control block associated with the desired mutex
    608          *
    609          *              p_mutex_data    is a pointer to a structure that will contain information about the mutex
    610          *
    611          * Returns    : OS_ERR_NONE          The call was successful and the message was sent
    612          *              OS_ERR_QUERY_ISR     If you called this function from an ISR
    613          *              OS_ERR_PEVENT_NULL   If 'pevent'       is a NULL pointer
    614          *              OS_ERR_PDATA_NULL    If 'p_mutex_data' is a NULL pointer
    615          *              OS_ERR_EVENT_TYPE    If you are attempting to obtain data from a non mutex.
    616          *********************************************************************************************************
    617          */
    618          
    619          #if OS_MUTEX_QUERY_EN > 0

   \                                 In section .text, align 2, keep-with-next
    620          INT8U  OSMutexQuery (OS_EVENT *pevent, OS_MUTEX_DATA *p_mutex_data)
    621          {
   \                     OSMutexQuery:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
    622              INT8U      i;
    623          #if OS_LOWEST_PRIO <= 63
    624              INT8U     *psrc;
    625              INT8U     *pdest;
    626          #else
    627              INT16U    *psrc;
    628              INT16U    *pdest;
    629          #endif
    630          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    631              OS_CPU_SR  cpu_sr = 0;
    632          #endif
    633          
    634          
    635          
    636              if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
   \   00000006   0x....             LDR.N    R0,??DataTable5
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0xB108             CBZ.N    R0,??OSMutexQuery_0
    637                  return (OS_ERR_QUERY_ISR);                         /* ... can't QUERY mutex from an ISR        */
   \   0000000C   0x2006             MOVS     R0,#+6
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}
    638              }
    639          #if OS_ARG_CHK_EN > 0
    640              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    641                  return (OS_ERR_PEVENT_NULL);
    642              }
    643              if (p_mutex_data == (OS_MUTEX_DATA *)0) {              /* Validate 'p_mutex_data'                  */
    644                  return (OS_ERR_PDATA_NULL);
    645              }
    646          #endif
    647              if (pevent->OSEventType != OS_EVENT_TYPE_MUTEX) {      /* Validate event block type                */
   \                     ??OSMutexQuery_0:
   \   00000010   0x7828             LDRB     R0,[R5, #+0]
   \   00000012   0x2804             CMP      R0,#+4
   \   00000014   0xD001             BEQ.N    ??OSMutexQuery_1
    648                  return (OS_ERR_EVENT_TYPE);
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xBD32             POP      {R1,R4,R5,PC}
    649              }
    650              OS_ENTER_CRITICAL();
   \                     ??OSMutexQuery_1:
   \   0000001A   0x.... 0x....      BL       OS_CPU_SR_Save
    651              p_mutex_data->OSMutexPIP  = (INT8U)(pevent->OSEventCnt >> 8);
   \   0000001E   0x8929             LDRH     R1,[R5, #+8]
   \   00000020   0x0A09             LSRS     R1,R1,#+8
   \   00000022   0x71E1             STRB     R1,[R4, #+7]
    652              p_mutex_data->OSOwnerPrio = (INT8U)(pevent->OSEventCnt & OS_MUTEX_KEEP_LOWER_8);
   \   00000024   0x8929             LDRH     R1,[R5, #+8]
   \   00000026   0x71A1             STRB     R1,[R4, #+6]
    653              if (p_mutex_data->OSOwnerPrio == 0xFF) {
   \   00000028   0x79A1             LDRB     R1,[R4, #+6]
   \   0000002A   0x29FF             CMP      R1,#+255
   \   0000002C   0xBF0C             ITE      EQ 
   \   0000002E   0x2101             MOVEQ    R1,#+1
   \   00000030   0x2100             MOVNE    R1,#+0
    654                  p_mutex_data->OSValue = OS_TRUE;
    655              } else {
    656                  p_mutex_data->OSValue = OS_FALSE;
   \   00000032   0x7161             STRB     R1,[R4, #+5]
    657              }
    658              p_mutex_data->OSEventGrp  = pevent->OSEventGrp;        /* Copy wait list                           */
   \   00000034   0x7AA9             LDRB     R1,[R5, #+10]
   \   00000036   0x7121             STRB     R1,[R4, #+4]
    659              psrc                      = &pevent->OSEventTbl[0];
   \   00000038   0xF205 0x010B      ADDW     R1,R5,#+11
    660              pdest                     = &p_mutex_data->OSEventTbl[0];
    661              for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
    662                  *pdest++ = *psrc++;
   \   0000003C   0x780A             LDRB     R2,[R1, #+0]
   \   0000003E   0x7022             STRB     R2,[R4, #+0]
   \   00000040   0xF811 0x2F01      LDRB     R2,[R1, #+1]!
   \   00000044   0xF804 0x2F01      STRB     R2,[R4, #+1]!
   \   00000048   0xF811 0x2F01      LDRB     R2,[R1, #+1]!
   \   0000004C   0xF804 0x2F01      STRB     R2,[R4, #+1]!
   \   00000050   0xF811 0x2F01      LDRB     R2,[R1, #+1]!
   \   00000054   0xF804 0x2F01      STRB     R2,[R4, #+1]!
    663              }
    664              OS_EXIT_CRITICAL();
   \   00000058   0x.... 0x....      BL       OS_CPU_SR_Restore
    665              return (OS_ERR_NONE);
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    666          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x........         DC32     OSTCBCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     OSTCBPrioTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     OSEventFreeList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     OSRdyTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     OSRdyGrp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     OSLockNesting
    667          #endif                                                     /* OS_MUTEX_QUERY_EN                        */
    668          
    669          /*$PAGE*/
    670          /*
    671          *********************************************************************************************************
    672          *                                RESTORE A TASK BACK TO ITS ORIGINAL PRIORITY
    673          *
    674          * Description: This function makes a task ready at the specified priority
    675          *
    676          * Arguments  : ptcb            is a pointer to OS_TCB of the task to make ready
    677          *
    678          *              prio            is the desired priority
    679          *
    680          * Returns    : none
    681          *********************************************************************************************************
    682          */
    683          
    684          static  void  OSMutex_RdyAtPrio (OS_TCB *ptcb, INT8U prio)
    685          {
    686              INT8U   y;
    687          
    688          
    689              y            =  ptcb->OSTCBY;                          /* Remove owner from ready list at 'pip'    */
    690              OSRdyTbl[y] &= ~ptcb->OSTCBBitX;
    691              if (OSRdyTbl[y] == 0) {
    692                  OSRdyGrp &= ~ptcb->OSTCBBitY;
    693              }
    694              ptcb->OSTCBPrio         = prio;
    695          #if OS_LOWEST_PRIO <= 63
    696              ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)3) & (INT8U)0x07);
    697              ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x07);
    698              ptcb->OSTCBBitY         = (INT8U)(1 << ptcb->OSTCBY);
    699              ptcb->OSTCBBitX         = (INT8U)(1 << ptcb->OSTCBX);
    700          #else
    701              ptcb->OSTCBY            = (INT8U)((prio >> (INT8U)4) & (INT8U)0x0F);
    702              ptcb->OSTCBX            = (INT8U) (prio & (INT8U)0x0F);
    703              ptcb->OSTCBBitY         = (INT16U)(1 << ptcb->OSTCBY);
    704              ptcb->OSTCBBitX         = (INT16U)(1 << ptcb->OSTCBX);
    705          #endif
    706              OSRdyGrp               |= ptcb->OSTCBBitY;             /* Make task ready at original priority     */
    707              OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
    708              OSTCBPrioTbl[prio]      = ptcb;
    709          }
    710          
    711          
    712          #endif                                                     /* OS_MUTEX_EN                              */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  OSMutexAccept
             16 -> OS_CPU_SR_Restore
             16 -> OS_CPU_SR_Save
       24  OSMutexCreate
             24 -> OS_CPU_SR_Restore
             24 -> OS_CPU_SR_Save
             24 -> OS_EventWaitListInit
       24  OSMutexDel
             24 -> OS_CPU_SR_Restore
             24 -> OS_CPU_SR_Save
             24 -> OS_EventTaskRdy
             24 -> OS_Sched
       32  OSMutexPend
             32 -> OS_CPU_SR_Restore
             32 -> OS_CPU_SR_Save
             32 -> OS_EventTOAbort
             32 -> OS_EventTaskWait
             32 -> OS_Sched
       24  OSMutexPost
             24 -> OS_CPU_SR_Restore
             24 -> OS_CPU_SR_Save
             24 -> OS_EventTaskRdy
             24 -> OS_Sched
       16  OSMutexQuery
             16 -> OS_CPU_SR_Restore
             16 -> OS_CPU_SR_Save


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
     104  OSMutexAccept
     114  OSMutexCreate
     322  OSMutexDel
     424  OSMutexPend
     252  OSMutexPost
      96  OSMutexQuery

 
 1 340 bytes in section .text
 
 1 340 bytes of CODE memory

Errors: none
Warnings: none

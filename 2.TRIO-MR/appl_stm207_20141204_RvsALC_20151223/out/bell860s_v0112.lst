###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     08/Feb/2018  09:39:50 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\dev\bellwave\bell860s_v0112.c                     #
#    Command line =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\dev\bellwave\bell860s_v0112.c -lC                 #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\out\ -o D:\Project\TRIO\2.TRIO-MR\appl_stm207_201 #
#                    41204_RvsALC_20151223\out\ --endian=little               #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "D:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\include\ -I D:\Project\TRIO\2.TRIO-MR\appl_stm207 #
#                    _20141204_RvsALC_20151223\STM32F2xx_StdPeriph_Driver_v12 #
#                    12\ -I D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_Rv #
#                    sALC_20151223\STM32F2xx_StdPeriph_Driver_v1212\inc\ -I   #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uC-CPU\ -I D:\Project\TRIO\2.TRIO-MR\appl_stm207_ #
#                    20141204_RvsALC_20151223\uC-LIB\ -I                      #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uCOS-II\Ports\ -I D:\Project\TRIO\2.TRIO-MR\appl_ #
#                    stm207_20141204_RvsALC_20151223\uCOS-II\Source\ -I       #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uC-Probe\ -Oh --use_c++_inline                    #
#    List file    =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\out\bell860s_v0112.lst                            #
#    Object file  =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\out\bell860s_v0112.o                              #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20151223\dev\bellwave\bell860s_v0112.c
      1          /*******************************************************************************
      2           *
      3           * This module contains the function 7092 original header file, a function
      4           * whole things  initializations - global, include function and so on
      5           *
      6           *
      7           * Note that this function is called before the data segments are
      8           * initialized, this means that this function cannot rely on the
      9           * values of global or static variables.
     10           *
     11           *
     12           *
     13           * &Revision:
     14           * &Revision date: 
     15           ******************************************************************************/
     16          
     17          #define __BELL_C
     18           
     19          
     20          #include <stdarg.h>
     21          #include <stdlib.h>
     22          #include <stdio.h>
     23          #include <string.h>
     24          #include "../include/main.h"

   \                                 In section .bss, align 4
   \   __absolute INT8U RxCdmaData[1025]
   \                     RxCdmaData:
   \   00000000                      DS8 1028
   \   __absolute INT8U TxCdmaData[1025]
   \                     TxCdmaData:
   \   00000404                      DS8 1028

   \                                 In section .bss, align 4
   \   __absolute INT8U RxBcMData[1025]
   \                     RxBcMData:
   \   00000000                      DS8 1028

   \                                 In section .bss, align 4
   \   __absolute INT8U Send2Buf[256]
   \                     Send2Buf:
   \   00000000                      DS8 256

   \                                 In section .bss, align 1
   \   __absolute INT8U LockOrder
   \                     LockOrder:
   \   00000000                      DS8 1
   \   __absolute INT8U GMMLockOrder
   \                     GMMLockOrder:
   \   00000001                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute INT8S PN0_Vaule[3]
   \                     PN0_Vaule:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute INT8S PN1_Vaule[3]
   \                     PN1_Vaule:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute INT8S PN2_Vaule[3]
   \                     PN2_Vaule:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute INT8S PN3_Vaule[3]
   \                     PN3_Vaule:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute INT8S EcIo0_Vaule[3]
   \                     EcIo0_Vaule:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute INT8S EcIo1_Vaule[3]
   \                     EcIo1_Vaule:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute INT8S EcIo2_Vaule[3]
   \                     EcIo2_Vaule:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute INT8S EcIo3_Vaule[3]
   \                     EcIo3_Vaule:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute INT8S ModemVersion[50]
   \                     ModemVersion:
   \   00000000                      DS8 52

   \                                 In section .bss, align 4
   \   __absolute BcMTimeStr BcMpresentTimeB
   \                     BcMpresentTimeB:
   \   00000000                      DS8 20

   \                                 In section .bss, align 4
   \   __absolute BcMRfStsStr BcMRfStatusB
   \                     BcMRfStatusB:
   \   00000000                      DS8 68

   \                                 In section .data, align 4
   \   __absolute INT8S BcMVerNum[3]
   \                     BcMVerNum:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   __absolute INT8U BcMdebug
   \                     BcMdebug:
   \   00000004   0x00               DC8 0
   \   __absolute INT8U TimeReqCnt
   \                     TimeReqCnt:
   \   00000005   0x00               DC8 0
   \   __absolute INT8U BcMRtryNo
   \                     BcMRtryNo:
   \   00000006   0x00               DC8 0
   \   __absolute INT8U BcMMaker
   \                     BcMMaker:
   \   00000007   0x00               DC8 0
   \   __absolute INT8U BcMType
   \                     BcMType:
   \   00000008   0x00               DC8 0
   \   __absolute INT8U ModemType
   \                     ModemType:
   \   00000009   0x00               DC8 0
   \   0000000A   0x00 0x00          DC8 0, 0
   \   __absolute INT8U BcMSrcTel[11]
   \                     BcMSrcTel:
   \   0000000C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   __absolute INT8U BcMEsnNum[8]
   \                     BcMEsnNum:
   \   00000018   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   __absolute INT8U ICCIDNum[19]
   \                     ICCIDNum:
   \   00000020   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   __absolute INT16U BcMTimerRx
   \                     BcMTimerRx:
   \   00000034   0x0000             DC16 0
   \   00000036   0x00 0x00          DC8 0, 0
   \   __absolute __SerStrPtr *dUartPtr
   \                     dUartPtr:
   \   00000038   0x........         DC32 pUSART1
   \   __absolute __SerStrPtr *eUartPtr
   \                     eUartPtr:
   \   0000003C   0x00000000         DC32 0H
   \   __absolute BcMTimeStr *BcMpresentTime
   \                     BcMpresentTime:
   \   00000040   0x........         DC32 BcMpresentTimeB
   \   __absolute BcMRfStsStr *BcMRfStatus
   \                     BcMRfStatus:
   \   00000044   0x........         DC32 BcMRfStatusB

   \                                 In section .bss, align 4
   \   __absolute BcMPilotStsStr BcMPilotStatusB
   \                     BcMPilotStatusB:
   \   00000000                      DS8 16

   \                                 In section .data, align 4
   \   __absolute BcMPilotStsStr *BcMPilotStatus
   \                     BcMPilotStatus:
   \   00000000   0x........         DC32 BcMPilotStatusB

   \                                 In section .bss, align 1
   \   __absolute INT8U MsgCheckCnt
   \                     MsgCheckCnt:
   \   00000000                      DS8 1
     25          
     26          #define ____	USART1Printf("%s %d\n", __FUNCTION__, __LINE__);
     27          
     28          

   \                                 In section .text, align 2, keep-with-next
     29          void BcMdemDebug(INT32U nDebug, INT32S *DebugPtr)
     30          {
     31          	BcMdebug = nDebug;
   \                     BcMdemDebug:
   \   00000000   0x.... 0x....      LDR.W    R2,??DataTable77_4
   \   00000004   0x7110             STRB     R0,[R2, #+4]
     32          	if(DebugPtr != NULL) dUartPtr = (__SerStrPtr *)(DebugPtr);
   \   00000006   0xB909             CBNZ.N   R1,??BcMdemDebug_0
     33          	else				 dUartPtr = (__SerStrPtr *)(&pUSART1);
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable77_5
   \                     ??BcMdemDebug_0:
   \   0000000C   0x6391             STR      R1,[R2, #+56]
     34          
     35          }
   \   0000000E   0x4770             BX       LR               ;; return
     36          

   \                                 In section .text, align 4, keep-with-next
     37          INT8S BcMdemInit(__SerStrPtr *uPtr, INT16U TimerRx)
     38          {
   \                     BcMdemInit:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB099             SUB      SP,SP,#+100
     39              INT8U CmdStep = RstCmd;
   \   00000004   0x2400             MOVS     R4,#+0
     40          	INT8U result = 0;
     41          	INT16U i = 0;
     42          	INT8U Ptr[100];
     43          	
     44          
     45          	// memory Allocation
     46          	if(dUartPtr == NULL)				return -1;			// error: debuguart not allocated --> BcMDebug excuted befor
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable77_4
   \   0000000A   0x6BAA             LDR      R2,[R5, #+56]
   \   0000000C   0xB912             CBNZ.N   R2,??BcMdemInit_1
   \   0000000E   0xF04F 0x30FF      MOV      R0,#-1
   \   00000012   0xE04F             B.N      ??BcMdemInit_2
     47          	if( (eUartPtr = uPtr) == NULL)		return -2;			// error: Excution Ptr not allocated --> 
   \                     ??BcMdemInit_1:
   \   00000014   0x63E8             STR      R0,[R5, #+60]
   \   00000016   0xB910             CBNZ.N   R0,??BcMdemInit_3
   \   00000018   0xF06F 0x0001      MVN      R0,#+1
   \   0000001C   0xE04A             B.N      ??BcMdemInit_2
     48          	
     49          	if( (BcMTimerRx = TimerRx) == NULL)	return -3;			// error: TimerValue Error
   \                     ??BcMdemInit_3:
   \   0000001E   0x86A9             STRH     R1,[R5, #+52]
   \   00000020   0x2900             CMP      R1,#+0
   \   00000022   0x.... 0x....      LDR.W    R6,??DataTable77_6
   \   00000026   0xD109             BNE.N    ??BcMdemInit_4
   \   00000028   0xF06F 0x0002      MVN      R0,#+2
   \   0000002C   0xE042             B.N      ??BcMdemInit_2
     50          	
     51          INIT_SEQUENCE : 
     52          
     53          //	USART1Printf("0 : CmdStep[%d][%d]>[%d] \n",CmdStep,ModemType,BcMRtryNo);
     54          
     55          	switch(CmdStep)
   \                     ??BcMdemInit_5:
   \   0000002E   0x2C05             CMP      R4,#+5
   \   00000030   0xD850             BHI.N    ??BcMdemInit_6
   \   00000032   0xE8DF 0xF004      TBB      [PC, R4]
   \                     ??BcMdemInit_0:
   \   00000036   0x03 0x09          DC8      0x3,0x9,0x20,0x41
   \              0x20 0x41    
   \   0000003A   0x44 0x4C          DC8      0x44,0x4C
     56          	{
     57          		case RstCmd: 				BcMdemXmit(CdmaRstCmd); 			result = 0; break;
   \                     ??BcMdemInit_4:
   \   0000003C   0x.... 0x....      ADR.W    R0,`?<Constant "ATE0">`
   \   00000040   0x.... 0x....      BL       BcMdemXmit
   \   00000044   0x2700             MOVS     R7,#+0
   \   00000046   0xE04C             B.N      ??BcMdemInit_7
     58          		case ModemHangUpCmd : 		BcMdemXmit(CdmaModemHangUpCmd); 	result = 3; break;
   \                     ??BcMdemInit_8:
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable77_7
   \   0000004C   0x.... 0x....      BL       BcMdemXmit
   \   00000050   0x2703             MOVS     R7,#+3
     59          //		case ModemRptModeSetCmd :	BcMdemXmit(CdmaRptModeSetCmd); 		result = 1; break;
     60          		case VersionCmd : 			BcMdemXmit(CdmaVersionCmd); 		result = 2; break;
     61          		case ModemMinNumCmd : 		BcMdemXmit(CdmaModemMinNumCmd); 	result = 2; break;
     62          		case ModemEsnCmd :			
     63          		{
     64          //			if((BcMType == 0x0C)||(BcMType == 0x0D))
     65          				
     66          			if( ModemType == _WCMDA_Modem)
     67          			{
     68          				BcMdemXmit(WcdmaModemICCIDCmd); 	result = 2; break;
     69          			}
     70          			else
     71          			{
     72          				BcMdemXmit(CdmaModemEsnCmd);		result = 2; break;
     73          			}
     74          		}
     75          		case ModemTimeCmd : 		BcMdemXmit(CdmaModemTimeCmd); 		result = 2; break;
     76          
     77           	}
     78          		
     79          	switch(result)
     80          	{
     81          		case 0:
     82          			if(BcMdemSyncProtocolCheck())
     83          			{
     84          				if(BcMdemSyncCheck((char *)RxCdmaData) == 14) break;
     85          			}	
     86          			else return FALSE;
     87          			
     88          			if(BcMdemSyncProtocolCheck())
     89          			{
     90          				if(BcMdemSyncCheck((char *)RxCdmaData) != 14) return FALSE;
     91          			}
     92          			else return FALSE;
     93          		break;
     94          
     95          		case 1:
     96          			if(BcMdemSyncProtocolCheck())
     97          			{
     98          				if(BcMdemSyncCheck((char *)RxCdmaData) != 14) return FALSE;
     99          			}
    100          			else return FALSE;
    101          		break;
    102          
    103          		case 2:
    104          			if(BcMdemSyncProtocolCheck())
    105          			{
    106          				if(!BcMdemDataProtocolCheck(CmdStep))return FALSE;
    107          
    108          				if(CmdStep == ModemMinNumCmd)break;
    109          				
    110          				if(!BcMdemSyncProtocolCheck())							 return FALSE;
    111          				if(BcMdemSyncCheck((char *)RxCdmaData) != 14)			 return FALSE;
    112          			}
    113          			else return FALSE;
    114          		break;
    115          
    116          		case 3:
    117          			if(BcMdemSyncProtocolCheck())
   \                     ??BcMdemInit_9:
   \   00000052   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   00000056   0xB160             CBZ.N    R0,??BcMdemInit_10
    118          			{
    119          				for(i = 0; i < strlen(RspmsgHangup);i++)Ptr[i] = RxCdmaData[i];
   \   00000058   0x2209             MOVS     R2,#+9
   \   0000005A   0x4631             MOV      R1,R6
   \   0000005C   0xA800             ADD      R0,SP,#+0
   \   0000005E   0x.... 0x....      BL       __aeabi_memcpy4
    120          				Ptr[i] = 0;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0xF88D 0x0009      STRB     R0,[SP, #+9]
    121          				if(BcMdemSyncCheck((char *)Ptr) != 30)return FALSE;
   \   00000068   0xA800             ADD      R0,SP,#+0
   \   0000006A   0x.... 0x....      BL       BcMdemSyncCheck
   \   0000006E   0x281E             CMP      R0,#+30
   \   00000070   0xD01A             BEQ.N    ??BcMdemInit_11
    122          				
    123          //				if(RxCdmaData[i] != '1')return FALSE;
    124          //				if(RxCdmaData[i] != '1')return TRUE;
    125          			}
    126          			else return FALSE;
   \                     ??BcMdemInit_10:
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0xE01E             B.N      ??BcMdemInit_2
   \                     ??BcMdemInit_12:
   \   00000076   0x.... 0x....      ADR.W    R0,`?<Constant "AT+GMR">`
   \                     ??BcMdemInit_13:
   \   0000007A   0x.... 0x....      BL       BcMdemXmit
   \   0000007E   0x2702             MOVS     R7,#+2
   \                     ??BcMdemInit_14:
   \   00000080   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD0F4             BEQ.N    ??BcMdemInit_10
   \   00000088   0xB260             SXTB     R0,R4
   \   0000008A   0x.... 0x....      BL       BcMdemDataProtocolCheck
   \   0000008E   0x2800             CMP      R0,#+0
   \   00000090   0xD0EF             BEQ.N    ??BcMdemInit_10
   \   00000092   0x2C03             CMP      R4,#+3
   \   00000094   0xD008             BEQ.N    ??BcMdemInit_11
   \   00000096   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   0000009A   0x2800             CMP      R0,#+0
   \   0000009C   0xD0E9             BEQ.N    ??BcMdemInit_10
   \   0000009E   0x4630             MOV      R0,R6
   \   000000A0   0x.... 0x....      BL       BcMdemSyncCheck
   \   000000A4   0x280E             CMP      R0,#+14
   \   000000A6   0xD1E4             BNE.N    ??BcMdemInit_10
    127          		break;
    128          		
    129          	}
    130          
    131          	if(CmdStep++ == ModemTimeCmd)	return TRUE;
   \                     ??BcMdemInit_11:
   \   000000A8   0x4620             MOV      R0,R4
   \   000000AA   0x1C44             ADDS     R4,R0,#+1
   \   000000AC   0xB2E4             UXTB     R4,R4
   \   000000AE   0x2805             CMP      R0,#+5
   \   000000B0   0xD1BD             BNE.N    ??BcMdemInit_5
   \   000000B2   0x2001             MOVS     R0,#+1
   \                     ??BcMdemInit_2:
   \   000000B4   0xB019             ADD      SP,SP,#+100
   \   000000B6   0xBDF0             POP      {R4-R7,PC}       ;; return
   \                     ??BcMdemInit_15:
   \   000000B8   0x.... 0x....      ADR.W    R0,`?<Constant "AT*SKT*DIAL">`
   \   000000BC   0xE7DD             B.N      ??BcMdemInit_13
   \                     ??BcMdemInit_16:
   \   000000BE   0x7A68             LDRB     R0,[R5, #+9]
   \   000000C0   0x2801             CMP      R0,#+1
   \   000000C2   0xBF14             ITE      NE 
   \   000000C4   0x.... 0x....      ADRNE.W  R0,`?<Constant "AT*SKTR*ESN?">`
   \   000000C8   0x.... 0x....      ADREQ.W  R0,`?<Constant "AT*SKTR*ICCID?">`
   \   000000CC   0xE7D5             B.N      ??BcMdemInit_13
   \                     ??BcMdemInit_17:
   \   000000CE   0x.... 0x....      LDR.W    R0,??DataTable77_8
   \   000000D2   0xE7D2             B.N      ??BcMdemInit_13
   \                     ??BcMdemInit_6:
   \   000000D4   0xB12F             CBZ.N    R7,??BcMdemInit_7
   \   000000D6   0x2F02             CMP      R7,#+2
   \   000000D8   0xD0D2             BEQ.N    ??BcMdemInit_14
   \   000000DA   0xD30B             BCC.N    ??BcMdemInit_18
   \   000000DC   0x2F03             CMP      R7,#+3
   \   000000DE   0xD0B8             BEQ.N    ??BcMdemInit_9
   \   000000E0   0xE7E2             B.N      ??BcMdemInit_11
   \                     ??BcMdemInit_7:
   \   000000E2   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD0C3             BEQ.N    ??BcMdemInit_10
   \   000000EA   0x4630             MOV      R0,R6
   \   000000EC   0x.... 0x....      BL       BcMdemSyncCheck
   \   000000F0   0x280E             CMP      R0,#+14
   \   000000F2   0xD0D9             BEQ.N    ??BcMdemInit_11
   \                     ??BcMdemInit_18:
   \   000000F4   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   000000F8   0x2800             CMP      R0,#+0
   \   000000FA   0xD0BA             BEQ.N    ??BcMdemInit_10
   \   000000FC   0x4630             MOV      R0,R6
   \   000000FE   0x.... 0x....      BL       BcMdemSyncCheck
   \   00000102   0x280E             CMP      R0,#+14
   \   00000104   0xD1B5             BNE.N    ??BcMdemInit_10
   \   00000106   0xE7CF             B.N      ??BcMdemInit_11
    132          
    133          	goto INIT_SEQUENCE;
    134          }
    135          

   \                                 In section .text, align 2, keep-with-next
    136          void BcMdemXmit(INT8U *dataPtr)
    137          {	
   \                     BcMdemXmit:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
    138          	if(!eUartPtr) return;
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable77_4
   \   00000008   0x6BE8             LDR      R0,[R5, #+60]
   \   0000000A   0xB180             CBZ.N    R0,??BcMdemXmit_0
    139          	eUartPtr->BuffClear();
   \   0000000C   0x6A00             LDR      R0,[R0, #+32]
   \   0000000E   0x4780             BLX      R0
    140          	eUartPtr->printf("%s\n", (char *)dataPtr);
   \   00000010   0x....             ADR.N    R6,??DataTable74  ;; "%s\n"
   \   00000012   0x4621             MOV      R1,R4
   \   00000014   0x4630             MOV      R0,R6
   \   00000016   0x6BEA             LDR      R2,[R5, #+60]
   \   00000018   0x6912             LDR      R2,[R2, #+16]
   \   0000001A   0x4790             BLX      R2
    141          	if(BcMdebug) dUartPtr->printf("%s\n", (char *)dataPtr);
   \   0000001C   0x7928             LDRB     R0,[R5, #+4]
   \   0000001E   0xB130             CBZ.N    R0,??BcMdemXmit_0
   \   00000020   0x4621             MOV      R1,R4
   \   00000022   0x4630             MOV      R0,R6
   \   00000024   0x6BAA             LDR      R2,[R5, #+56]
   \   00000026   0x6912             LDR      R2,[R2, #+16]
   \   00000028   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000002C   0x4710             BX       R2
   \                     ??BcMdemXmit_0:
   \   0000002E   0xBD70             POP      {R4-R6,PC}       ;; return
    142          }
    143          

   \                                 In section .text, align 2, keep-with-next
    144          INT32S BcMdemMSGTx(char *DstTel, char *dataPtr, INT16U nlen)
    145          {
   \                     BcMdemMSGTx:
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB0B3             SUB      SP,SP,#+204
   \   00000006   0x4603             MOV      R3,R0
   \   00000008   0x460E             MOV      R6,R1
   \   0000000A   0x4617             MOV      R7,R2
    146          	INT16U i = 0;
   \   0000000C   0x2500             MOVS     R5,#+0
    147          	
    148          	INT8U Ptr[200];
    149          	INT32S nRet = TRUE;
   \   0000000E   0x2401             MOVS     R4,#+1
    150          
    151          	if(nlen > SmsMaxLen) return -3;
   \   00000010   0x2F65             CMP      R7,#+101
   \   00000012   0xBF28             IT       CS 
   \   00000014   0xF06F 0x0002      MVNCS    R0,#+2
   \   00000018   0xD25A             BCS.N    ??BcMdemMSGTx_0
    152          	if(nlen > SmsWanLen) nRet = 3;	
   \   0000001A   0x2F51             CMP      R7,#+81
   \   0000001C   0xBF28             IT       CS 
   \   0000001E   0x2403             MOVCS    R4,#+3
    153          
    154          
    155            	if(ModemType == _WCMDA_Modem)
   \   00000020   0x.... 0x....      LDR.W    R8,??DataTable77_6
   \   00000024   0xF208 0x4904      ADDW     R9,R8,#+1028
   \   00000028   0x.... 0x....      ADR.W    R2,`?<Constant "AT*SKTR*SMSMO=">`
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable77_4
   \   00000030   0x7A41             LDRB     R1,[R0, #+9]
   \   00000032   0x2901             CMP      R1,#+1
   \   00000034   0xBF02             ITTT     EQ 
   \   00000036   0x300C             ADDEQ    R0,R0,#+12
   \   00000038   0x9000             STREQ    R0,[SP, #+0]
   \   0000003A   0x.... 0x....      ADREQ.W  R1,`?<Constant "%s%s,%s,4098,0,0,0,">`
    156          	{
    157          		sprintf((char *)TxCdmaData, "%s%s,%s,4098,0,0,0,", CdmaTxDataToSMSCmd, DstTel, BcMSrcTel);
   \   0000003E   0xD003             BEQ.N    ??BcMdemMSGTx_1
    158           	}
    159           	else
    160          	{
    161          		sprintf((char *)TxCdmaData, "%s%s,%s,4098,,,,", CdmaTxDataToSMSCmd, DstTel, BcMSrcTel);
   \   00000040   0x300C             ADDS     R0,R0,#+12
   \   00000042   0x9000             STR      R0,[SP, #+0]
   \   00000044   0x.... 0x....      ADR.W    R1,`?<Constant "%s%s,%s,4098,,,,">`
   \                     ??BcMdemMSGTx_1:
   \   00000048   0x4648             MOV      R0,R9
   \   0000004A   0x.... 0x....      BL       sprintf
    162          	}
    163          
    164          	for(i = 0; i < nlen; i++)
   \   0000004E   0xB16F             CBZ.N    R7,??BcMdemMSGTx_2
    165          	{
    166          		sprintf((char *)Ptr, "%02X", dataPtr[i]);
   \                     ??BcMdemMSGTx_3:
   \   00000050   0x5DAA             LDRB     R2,[R5, R6]
   \   00000052   0x.... 0x....      ADR.W    R1,`?<Constant "%02X">`
   \   00000056   0xA801             ADD      R0,SP,#+4
   \   00000058   0x.... 0x....      BL       sprintf
    167          		strcat((char *)TxCdmaData, (const char *)Ptr);
   \   0000005C   0xA901             ADD      R1,SP,#+4
   \   0000005E   0x4648             MOV      R0,R9
   \   00000060   0x.... 0x....      BL       strcat
    168          	}
   \   00000064   0x1C68             ADDS     R0,R5,#+1
   \   00000066   0xB285             UXTH     R5,R0
   \   00000068   0x42BD             CMP      R5,R7
   \   0000006A   0xD3F1             BCC.N    ??BcMdemMSGTx_3
    169          
    170          	BcMdemXmit((INT8U *)TxCdmaData);
   \                     ??BcMdemMSGTx_2:
   \   0000006C   0x4648             MOV      R0,R9
   \   0000006E   0x.... 0x....      BL       BcMdemXmit
    171          	if(BcMdemSyncProtocolCheck())
   \   00000072   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   00000076   0xB358             CBZ.N    R0,??BcMdemMSGTx_0
    172          	{
    173              	if(BcMdemSyncCheck((char *)RxCdmaData) == 14)
   \   00000078   0x4640             MOV      R0,R8
   \   0000007A   0x.... 0x....      BL       BcMdemSyncCheck
   \   0000007E   0x280E             CMP      R0,#+14
   \   00000080   0xD104             BNE.N    ??BcMdemMSGTx_4
    174              	{
    175              	    if(nRet == 3) nRet = 4;
   \   00000082   0x2C03             CMP      R4,#+3
   \   00000084   0xBF14             ITE      NE 
   \   00000086   0x2402             MOVNE    R4,#+2
   \   00000088   0x2404             MOVEQ    R4,#+4
   \   0000008A   0xE001             B.N      ??BcMdemMSGTx_5
    176              	    else          nRet = 2;
    177              	} 
    178          		else  nRet = -2;
   \                     ??BcMdemMSGTx_4:
   \   0000008C   0xF06F 0x0401      MVN      R4,#+1
    179          		
    180          	}	
    181          	else return FALSE;
    182          
    183          	OSTimeDly(Time100mSec);
   \                     ??BcMdemMSGTx_5:
   \   00000090   0x2064             MOVS     R0,#+100
   \   00000092   0x.... 0x....      BL       OSTimeDly
    184          	for(i = 0 ;i < 4; i++)
   \   00000096   0x2604             MOVS     R6,#+4
    185          		{
    186          			if(BcMdemSyncProtocolCheck())
   \                     ??BcMdemMSGTx_6:
   \   00000098   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   0000009C   0xB180             CBZ.N    R0,??BcMdemMSGTx_7
    187          			{
    188          				if(BcMdemSyncCheck((char *)RxCdmaData) == 10)
   \   0000009E   0x4640             MOV      R0,R8
   \   000000A0   0x.... 0x....      BL       BcMdemSyncCheck
   \   000000A4   0x280A             CMP      R0,#+10
   \   000000A6   0xD108             BNE.N    ??BcMdemMSGTx_8
    189          				{
    190          				         if(nRet == 4) nRet = 5;
   \   000000A8   0x2C04             CMP      R4,#+4
   \   000000AA   0xBF08             IT       EQ 
   \   000000AC   0x2405             MOVEQ    R4,#+5
   \   000000AE   0xD00E             BEQ.N    ??BcMdemMSGTx_9
    191          				    else if(nRet == 2) nRet = 6;
   \   000000B0   0x2C02             CMP      R4,#+2
   \   000000B2   0xBF14             ITE      NE 
   \   000000B4   0x2401             MOVNE    R4,#+1
   \   000000B6   0x2406             MOVEQ    R4,#+6
   \   000000B8   0xE009             B.N      ??BcMdemMSGTx_9
    192          				    else nRet = TRUE;
    193          				}
    194          				else  nRet = -1;
   \                     ??BcMdemMSGTx_8:
   \   000000BA   0xF04F 0x34FF      MOV      R4,#-1
   \   000000BE   0xE006             B.N      ??BcMdemMSGTx_9
    195          			}
    196          			if( nRet != 2) break;
   \                     ??BcMdemMSGTx_7:
   \   000000C0   0x2C02             CMP      R4,#+2
   \   000000C2   0xD104             BNE.N    ??BcMdemMSGTx_9
    197          			OSTimeDly(Time100mSec*2L);
   \   000000C4   0x20C8             MOVS     R0,#+200
   \   000000C6   0x.... 0x....      BL       OSTimeDly
    198          		}
   \   000000CA   0x1E76             SUBS     R6,R6,#+1
   \   000000CC   0xD1E4             BNE.N    ??BcMdemMSGTx_6
    199          	
    200          	//  6: Sms Len Over 80 Bytes(Waringin), But Success, 1st Response OK, but 1st resonse data error, 2nd Response Data NOK
    201              //  5: Sms Len Over 80 Bytes(Waringin), But Success, 1st Response OK, but 1st resonse data error, 2nd Response Data OK
    202          	//  4: Sms Len over 80 Bytes(Warning) But Success, 1st Response OK, but 1st resonse data error, 2nd Rsponse No response
    203          	//  2: 1st Response OK, but 1st resonse data error, 2nd Rsponse No response
    204          	//  1: Modem Send Success
    205          	//  0: Modem No Response
    206          	// -1: 2nd Response Data Error
    207          	// -2: 1st Response Data Error, 2nd Response No response
    208          	// -3: Max Buffer Error
    209          	return nRet;
   \                     ??BcMdemMSGTx_9:
   \   000000CE   0x4620             MOV      R0,R4
   \                     ??BcMdemMSGTx_0:
   \   000000D0   0x....             B.N      ?Subroutine0
    210          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0xB033             ADD      SP,SP,#+204
   \   00000002   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return
    211          
    212          

   \                                 In section .text, align 2, keep-with-next
    213          INT32S BcMdemMSGSentTx(char *DstTel,char *SentTel, char *dataPtr, INT16U nlen)
    214          {
   \                     BcMdemMSGSentTx:
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB0B3             SUB      SP,SP,#+204
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0x461F             MOV      R7,R3
    215          	INT16U i = 0;
   \   0000000A   0x2400             MOVS     R4,#+0
    216          	
    217          	INT8U Ptr[200];
    218          	INT32S nRet = TRUE;
   \   0000000C   0x2501             MOVS     R5,#+1
    219          
    220          	if(nlen > SmsMaxLen) return -3;
   \   0000000E   0x2F65             CMP      R7,#+101
   \   00000010   0xBF28             IT       CS 
   \   00000012   0xF06F 0x0002      MVNCS    R0,#+2
   \   00000016   0xD25C             BCS.N    ??BcMdemMSGSentTx_0
    221          	if(nlen > SmsWanLen) nRet = 3;	
   \   00000018   0x2F51             CMP      R7,#+81
   \   0000001A   0xBF28             IT       CS 
   \   0000001C   0x2503             MOVCS    R5,#+3
    222          
    223          
    224          //	if((BcMType == 0x0C)||(BcMType == 0x0D))
    225          //	if( ModemType == _WCMDA_Modem)
    226          
    227          
    228          	if(ModemType == _WCMDA_Modem)
   \   0000001E   0x.... 0x....      LDR.W    R8,??DataTable77_6
   \   00000022   0xF208 0x4904      ADDW     R9,R8,#+1028
   \   00000026   0x.... 0x....      ADR.W    R2,`?<Constant "AT*SKTR*SMSMO=">`
   \   0000002A   0x.... 0x....      LDR.W    R1,??DataTable77_4
   \   0000002E   0x7A4B             LDRB     R3,[R1, #+9]
   \   00000030   0x2B01             CMP      R3,#+1
   \   00000032   0xD105             BNE.N    ??BcMdemMSGSentTx_1
    229          	{
    230          		sprintf((char *)TxCdmaData, "%s%s,%s,4098,0,0,0,", CdmaTxDataToSMSCmd, DstTel, BcMSrcTel);
   \   00000034   0x310C             ADDS     R1,R1,#+12
   \   00000036   0x9100             STR      R1,[SP, #+0]
   \   00000038   0x4603             MOV      R3,R0
   \   0000003A   0x.... 0x....      ADR.W    R1,`?<Constant "%s%s,%s,4098,0,0,0,">`
   \   0000003E   0xE004             B.N      ??BcMdemMSGSentTx_2
    231          	}
    232          	else
    233          	{
    234          		sprintf((char *)TxCdmaData, "%s%s,%s,4098,,,,", CdmaTxDataToSMSCmd, DstTel, BcMSrcTel);
   \                     ??BcMdemMSGSentTx_1:
   \   00000040   0x310C             ADDS     R1,R1,#+12
   \   00000042   0x9100             STR      R1,[SP, #+0]
   \   00000044   0x4603             MOV      R3,R0
   \   00000046   0x.... 0x....      ADR.W    R1,`?<Constant "%s%s,%s,4098,,,,">`
   \                     ??BcMdemMSGSentTx_2:
   \   0000004A   0x4648             MOV      R0,R9
   \   0000004C   0x.... 0x....      BL       sprintf
    235          	}
    236          
    237          	for(i = 0; i < nlen; i++)
   \   00000050   0xB16F             CBZ.N    R7,??BcMdemMSGSentTx_3
    238          	{
    239          		sprintf((char *)Ptr, "%02X", dataPtr[i]);
   \                     ??BcMdemMSGSentTx_4:
   \   00000052   0x5DA2             LDRB     R2,[R4, R6]
   \   00000054   0x.... 0x....      ADR.W    R1,`?<Constant "%02X">`
   \   00000058   0xA801             ADD      R0,SP,#+4
   \   0000005A   0x.... 0x....      BL       sprintf
    240          		strcat((char *)TxCdmaData, (const char *)Ptr);
   \   0000005E   0xA901             ADD      R1,SP,#+4
   \   00000060   0x4648             MOV      R0,R9
   \   00000062   0x.... 0x....      BL       strcat
    241          	}
   \   00000066   0x1C60             ADDS     R0,R4,#+1
   \   00000068   0xB284             UXTH     R4,R0
   \   0000006A   0x42BC             CMP      R4,R7
   \   0000006C   0xD3F1             BCC.N    ??BcMdemMSGSentTx_4
    242          
    243          	BcMdemXmit((INT8U *)TxCdmaData);
   \                     ??BcMdemMSGSentTx_3:
   \   0000006E   0x4648             MOV      R0,R9
   \   00000070   0x.... 0x....      BL       BcMdemXmit
    244          
    245          	if(BcMdemSyncProtocolCheck())
   \   00000074   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   00000078   0xB358             CBZ.N    R0,??BcMdemMSGSentTx_0
    246          	{
    247              	if(BcMdemSyncCheck((char *)RxCdmaData) == 14)
   \   0000007A   0x4640             MOV      R0,R8
   \   0000007C   0x.... 0x....      BL       BcMdemSyncCheck
   \   00000080   0x280E             CMP      R0,#+14
   \   00000082   0xD104             BNE.N    ??BcMdemMSGSentTx_5
    248              	{
    249              	    if(nRet == 3) nRet = 4;
   \   00000084   0x2D03             CMP      R5,#+3
   \   00000086   0xBF14             ITE      NE 
   \   00000088   0x2502             MOVNE    R5,#+2
   \   0000008A   0x2504             MOVEQ    R5,#+4
   \   0000008C   0xE001             B.N      ??BcMdemMSGSentTx_6
    250              	    else          nRet = 2;
    251              	} 
    252          		else  nRet = -2;
   \                     ??BcMdemMSGSentTx_5:
   \   0000008E   0xF06F 0x0501      MVN      R5,#+1
    253          		
    254          	}	
    255          	else return FALSE;
    256          
    257          	OSTimeDly(Time100mSec);
   \                     ??BcMdemMSGSentTx_6:
   \   00000092   0x2064             MOVS     R0,#+100
   \   00000094   0x.... 0x....      BL       OSTimeDly
    258          
    259          	for(i = 0 ;i < 4; i++)
   \   00000098   0x2604             MOVS     R6,#+4
    260          		{
    261          			if(BcMdemSyncProtocolCheck())
   \                     ??BcMdemMSGSentTx_7:
   \   0000009A   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   0000009E   0xB180             CBZ.N    R0,??BcMdemMSGSentTx_8
    262          			{
    263          				if(BcMdemSyncCheck((char *)RxCdmaData) == 10)
   \   000000A0   0x4640             MOV      R0,R8
   \   000000A2   0x.... 0x....      BL       BcMdemSyncCheck
   \   000000A6   0x280A             CMP      R0,#+10
   \   000000A8   0xD108             BNE.N    ??BcMdemMSGSentTx_9
    264          				{
    265          				         if(nRet == 4) nRet = 5;
   \   000000AA   0x2D04             CMP      R5,#+4
   \   000000AC   0xBF08             IT       EQ 
   \   000000AE   0x2505             MOVEQ    R5,#+5
   \   000000B0   0xD00E             BEQ.N    ??BcMdemMSGSentTx_10
    266          				    else if(nRet == 2) nRet = 6;
   \   000000B2   0x2D02             CMP      R5,#+2
   \   000000B4   0xBF14             ITE      NE 
   \   000000B6   0x2501             MOVNE    R5,#+1
   \   000000B8   0x2506             MOVEQ    R5,#+6
   \   000000BA   0xE009             B.N      ??BcMdemMSGSentTx_10
    267          				    else nRet = TRUE;
    268          				}
    269          				else  nRet = -1;
   \                     ??BcMdemMSGSentTx_9:
   \   000000BC   0xF04F 0x35FF      MOV      R5,#-1
   \   000000C0   0xE006             B.N      ??BcMdemMSGSentTx_10
    270          			}
    271          			if( nRet != 2) break;
   \                     ??BcMdemMSGSentTx_8:
   \   000000C2   0x2D02             CMP      R5,#+2
   \   000000C4   0xD104             BNE.N    ??BcMdemMSGSentTx_10
    272          			OSTimeDly(Time100mSec*2L);
   \   000000C6   0x20C8             MOVS     R0,#+200
   \   000000C8   0x.... 0x....      BL       OSTimeDly
    273          		}
   \   000000CC   0x1E76             SUBS     R6,R6,#+1
   \   000000CE   0xD1E4             BNE.N    ??BcMdemMSGSentTx_7
    274          	return nRet;
   \                     ??BcMdemMSGSentTx_10:
   \   000000D0   0x4628             MOV      R0,R5
   \                     ??BcMdemMSGSentTx_0:
   \   000000D2                      REQUIRE ?Subroutine0
   \   000000D2                      ;; // Fall through to label ?Subroutine0
    275          }
    276          
    277          
    278          

   \                                 In section .text, align 2, keep-with-next
    279          INT32S BcMdemTCPTx(char *dataPtr, INT16U nlen)
    280          {
   \                     BcMdemTCPTx:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB0B2             SUB      SP,SP,#+200
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
    281          
    282              INT16U i;
    283          	INT8U Ptr[200];
    284          	INT32S nRet = TRUE;
    285          
    286          	sprintf((char *)TxCdmaData, "%s", CdmaModemTcpWrCmd);
   \   0000000A   0x.... 0x....      LDR.W    R6,??DataTable77_6
   \   0000000E   0xF206 0x4704      ADDW     R7,R6,#+1028
   \   00000012   0x.... 0x....      ADR.W    R2,`?<Constant "AT$TCPWRITE=">`
   \   00000016   0x....             ADR.N    R1,??DataTable75  ;; 0x25, 0x73, 0x00, 0x00
   \   00000018   0x4638             MOV      R0,R7
   \   0000001A   0x.... 0x....      BL       sprintf
    287          
    288          	for(i = 0; i < nlen; i++)
   \   0000001E   0xB16D             CBZ.N    R5,??BcMdemTCPTx_0
   \   00000020   0x.... 0x....      ADR.W    R8,`?<Constant "%02X">`
    289          	{
    290          		sprintf((char *)Ptr, "%02X", dataPtr[i]);
   \                     ??BcMdemTCPTx_1:
   \   00000024   0xF814 0x2B01      LDRB     R2,[R4], #+1
   \   00000028   0x4641             MOV      R1,R8
   \   0000002A   0xA800             ADD      R0,SP,#+0
   \   0000002C   0x.... 0x....      BL       sprintf
    291          		strcat((char *)TxCdmaData, (const char *)Ptr);
   \   00000030   0xA900             ADD      R1,SP,#+0
   \   00000032   0x4638             MOV      R0,R7
   \   00000034   0x.... 0x....      BL       strcat
    292          	}
   \   00000038   0x1E6D             SUBS     R5,R5,#+1
   \   0000003A   0xD1F3             BNE.N    ??BcMdemTCPTx_1
    293          
    294          	BcMdemXmit((INT8U *)TxCdmaData);
   \                     ??BcMdemTCPTx_0:
   \   0000003C   0x4638             MOV      R0,R7
   \   0000003E   0x.... 0x....      BL       BcMdemXmit
    295          
    296          	if(BcMdemSyncProtocolCheck())
   \   00000042   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   00000046   0xB148             CBZ.N    R0,??BcMdemTCPTx_2
    297          	{
    298          		if(BcMdemSyncCheck((char *)RxCdmaData) != 14) return FALSE;
   \   00000048   0x4630             MOV      R0,R6
   \   0000004A   0x.... 0x....      BL       BcMdemSyncCheck
   \   0000004E   0x280E             CMP      R0,#+14
   \   00000050   0xD001             BEQ.N    ??BcMdemTCPTx_3
   \                     ??BcMdemTCPTx_4:
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xE002             B.N      ??BcMdemTCPTx_2
    299          	}	
    300          	else return FALSE;
    301          
    302          	if(BcMdemSyncProtocolCheck())
   \                     ??BcMdemTCPTx_3:
   \   00000056   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   0000005A   0xB910             CBNZ.N   R0,??BcMdemTCPTx_5
   \                     ??BcMdemTCPTx_2:
   \   0000005C   0xB032             ADD      SP,SP,#+200
   \   0000005E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    303          	{
    304          		if(BcMdemSyncCheck((char *)RxCdmaData) != 24) return FALSE;
   \                     ??BcMdemTCPTx_5:
   \   00000062   0x4630             MOV      R0,R6
   \   00000064   0x.... 0x....      BL       BcMdemSyncCheck
   \   00000068   0x2818             CMP      R0,#+24
   \   0000006A   0xD1F2             BNE.N    ??BcMdemTCPTx_4
    305          	}
    306          	else return FALSE;
    307          
    308          	return nRet;
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0xE7F5             B.N      ??BcMdemTCPTx_2
    309          }
    310          

   \                                 In section .text, align 2, keep-with-next
    311          INT32S BcMdemTCPRxCheck(INT8U *rbuf)
    312          {	
   \                     BcMdemTCPRxCheck:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x4604             MOV      R4,R0
    313          	INT32S nRet = 0;
   \   00000008   0x2700             MOVS     R7,#+0
    314          	INT32U i = 0, j = 0, len = 0;
   \   0000000A   0x2500             MOVS     R5,#+0
    315          	INT8S CheckDataBuff[20];
    316          	INT8U *tPtr = RxCdmaData;
   \   0000000C   0x.... 0x....      LDR.W    R6,??DataTable77_6
    317          
    318          	if(BcMdemSyncProtocolCheck())
   \   00000010   0x.... 0x....      LDR.W    R8,??DataTable77_4
   \   00000014   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xF8D8 0x003C      LDR      R0,[R8, #+60]
   \   0000001E   0x6A00             LDR      R0,[R0, #+32]
   \   00000020   0xD023             BEQ.N    ??BcMdemTCPRxCheck_0
    319          	{
    320          		eUartPtr->BuffClear();
   \   00000022   0x4780             BLX      R0
    321          		
    322          		for(i = 0; i < strlen(CdmaModemTcpRdCmd); i++)CheckDataBuff[i] = *tPtr++;
   \   00000024   0x220D             MOVS     R2,#+13
   \   00000026   0x4631             MOV      R1,R6
   \   00000028   0xA800             ADD      R0,SP,#+0
   \   0000002A   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000002E   0xF206 0x060D      ADDW     R6,R6,#+13
    323          
    324          		CheckDataBuff[i] = 0;
   \   00000032   0xF88D 0x500D      STRB     R5,[SP, #+13]
    325          
    326          		if(BcMdemSyncCheck((char *)CheckDataBuff) != 25)return FALSE;
   \   00000036   0xA800             ADD      R0,SP,#+0
   \   00000038   0x.... 0x....      BL       BcMdemSyncCheck
   \   0000003C   0x2819             CMP      R0,#+25
   \   0000003E   0xD00E             BEQ.N    ??BcMdemTCPRxCheck_1
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0xE014             B.N      ??BcMdemTCPRxCheck_2
    327          		
    328          		for(j = 0; *tPtr != 0; j++)
    329          		{
    330          			INT8U temp;
    331          
    332          			//if((*tPtr == 0x0D)||(*tPtr == 0x0A)) break;
    333          			
    334          			temp = atoh(*tPtr++);
   \                     ??BcMdemTCPRxCheck_3:
   \   00000044   0xF816 0x0B01      LDRB     R0,[R6], #+1
   \   00000048   0x.... 0x....      BL       atoh
   \   0000004C   0x4607             MOV      R7,R0
    335          			temp = atoh(*tPtr++) + ( temp << 4 );
    336          			
    337          			rbuf[len++] = temp;
   \   0000004E   0xF816 0x0B01      LDRB     R0,[R6], #+1
   \   00000052   0x.... 0x....      BL       atoh
   \   00000056   0xEB00 0x1007      ADD      R0,R0,R7, LSL #+4
   \   0000005A   0x5528             STRB     R0,[R5, R4]
   \   0000005C   0x1C6D             ADDS     R5,R5,#+1
    338          		}
   \                     ??BcMdemTCPRxCheck_1:
   \   0000005E   0x7830             LDRB     R0,[R6, #+0]
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD1EF             BNE.N    ??BcMdemTCPRxCheck_3
    339          				
    340          		nRet = len;
   \   00000064   0x462F             MOV      R7,R5
    341          		rbuf[len++] = 0;	// null data insert
   \   00000066   0x5528             STRB     R0,[R5, R4]
   \   00000068   0xE000             B.N      ??BcMdemTCPRxCheck_4
    342          				
    343          	}	
    344          	else
    345          	{
    346          		nRet = FALSE;
    347          		eUartPtr->BuffClear();
   \                     ??BcMdemTCPRxCheck_0:
   \   0000006A   0x4780             BLX      R0
    348          	}
    349          	
    350          	return nRet;
   \                     ??BcMdemTCPRxCheck_4:
   \   0000006C   0x4638             MOV      R0,R7
   \                     ??BcMdemTCPRxCheck_2:
   \   0000006E                      REQUIRE ?Subroutine1
   \   0000006E                      ;; // Fall through to label ?Subroutine1
    351          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0xB006             ADD      SP,SP,#+24
   \   00000002   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    352          

   \                                 In section .text, align 2, keep-with-next
    353          INT32S BcMdemSyncProtocolCheck(void)
    354          {
   \                     BcMdemSyncProtocolCheck:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    355          	INT16U	Recv;
    356          	INT32S  DataCnt = 0;
   \   00000004   0x2400             MOVS     R4,#+0
    357          
    358          	TimerRegist(BcMTimerRx, Time1Sec * 15L);
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable77_4
   \   0000000A   0xF643 0x2198      MOVW     R1,#+15000
   \   0000000E   0x8EA8             LDRH     R0,[R5, #+52]
   \   00000010   0x.... 0x....      BL       TimerRegist
   \   00000014   0x.... 0x....      LDR.W    R6,??DataTable77_6
   \   00000018   0xE002             B.N      ??BcMdemSyncProtocolCheck_0
    359          	//TimerRegist(BcMTimerRx, 600L*100L); // 1
    360          
    361          	while(1)
    362          	{
    363          		if(TimeOverCheck(BcMTimerRx)) return FALSE;
    364          		/*
    365          		if(eUartPtr->CheckByte(1, &Recv))
    366          		{
    367          			RxCdmaData[DataCnt] = eUartPtr->RxGetByte();
    368          
    369          			if(BcMdebug) dUartPtr->PutChar(RxCdmaData[DataCnt]);	// debug
    370          
    371          			if ((DataCnt == 0)&&((RxCdmaData[DataCnt] == 0x0d)||(RxCdmaData[DataCnt] == 0x0a))) continue;
    372          		
    373          			if ( RxCdmaData[DataCnt++] == 0x0d )
    374          			{
    375          				RxCdmaData[DataCnt++] = 0x0a;
    376          				RxCdmaData[DataCnt++] = 0;		// insert null point
    377          
    378          				//if(RxCdmaData[0] == '$')
    379          				//{
    380          				//	Ret = BcMdemSyncCheck((char *)RxCdmaData);
    381          					
    382          				//	if((Ret == 15)||(Ret == 16))
    383          				//	{
    384          				//		DataCnt = 0;
    385          				//		continue;
    386          				//	}
    387          				//}
    388          				//Ser0Printf("DataCnt: %d, DataCnt - 3, %d \n", DataCnt, DataCnt-3);
    389          				return(DataCnt - 3);	// received length(2005.05.17 by bgyoon)
    390          			}
    391          			if(DataCnt > CdmaBuffLen ) return FALSE;
    392          		
    393          		}
    394          		else OSTimeDly(_OS_1ms);
    395          		*/
    396          
    397          		while(eUartPtr->CheckByte(1, &Recv))
    398          		{
    399          			RxCdmaData[DataCnt] = eUartPtr->RxGetByte();
    400          
    401          			if(BcMdebug) dUartPtr->PutChar(RxCdmaData[DataCnt]);	// debug
    402          
    403          			if ((DataCnt == 0)&&((RxCdmaData[DataCnt] == 0x0d)||(RxCdmaData[DataCnt] == 0x0a))) continue;
    404          		
    405          			if ( RxCdmaData[DataCnt++] == 0x0d )
    406          			{
    407          				RxCdmaData[DataCnt++] = 0x0a;
    408          				RxCdmaData[DataCnt++] = 0;		// insert null point
    409          
    410          				//if(RxCdmaData[0] == '$')
    411          				//{
    412          				//	Ret = BcMdemSyncCheck((char *)RxCdmaData);
    413          					
    414          				//	if((Ret == 15)||(Ret == 16))
    415          				//	{
    416          				//		DataCnt = 0;
    417          				//		continue;
    418          				//	}
    419          				//}
    420          //				USART1Printf("DataCnt: %d, DataCnt - 3, %d \n", DataCnt, DataCnt-3);
    421          				return(DataCnt - 3);	// received length(2005.05.17 by bgyoon)
    422          			}
    423          #if 0
    424          			RxCdmaData[DataCnt + 1] = 0x0A;
    425          			RxCdmaData[DataCnt + 2] = 0x00;
    426          			
    427          			if(BcMdebug) pPrintf(WaveDebugMode, "%s\r\n ", RxCdmaData);
    428          #endif			
    429          			
    430          			if(DataCnt >= CdmaBuffLen ) return FALSE;
    431          
    432          		}
    433          		OSTimeDly(1);
   \                     ??BcMdemSyncProtocolCheck_1:
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x.... 0x....      BL       OSTimeDly
   \                     ??BcMdemSyncProtocolCheck_0:
   \   00000020   0x8EA8             LDRH     R0,[R5, #+52]
   \   00000022   0x.... 0x....      BL       TimeOverCheck
   \   00000026   0xBB28             CBNZ.N   R0,??BcMdemSyncProtocolCheck_2
   \                     ??BcMdemSyncProtocolCheck_3:
   \   00000028   0xA900             ADD      R1,SP,#+0
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x6BEA             LDR      R2,[R5, #+60]
   \   0000002E   0x6852             LDR      R2,[R2, #+4]
   \   00000030   0x4790             BLX      R2
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD0F1             BEQ.N    ??BcMdemSyncProtocolCheck_1
   \   00000036   0x6BE8             LDR      R0,[R5, #+60]
   \   00000038   0x6880             LDR      R0,[R0, #+8]
   \   0000003A   0x4780             BLX      R0
   \   0000003C   0x55A0             STRB     R0,[R4, R6]
   \   0000003E   0x7928             LDRB     R0,[R5, #+4]
   \   00000040   0xB118             CBZ.N    R0,??BcMdemSyncProtocolCheck_4
   \   00000042   0x5DA0             LDRB     R0,[R4, R6]
   \   00000044   0x6BA9             LDR      R1,[R5, #+56]
   \   00000046   0x6949             LDR      R1,[R1, #+20]
   \   00000048   0x4788             BLX      R1
   \                     ??BcMdemSyncProtocolCheck_4:
   \   0000004A   0xB924             CBNZ.N   R4,??BcMdemSyncProtocolCheck_5
   \   0000004C   0x7830             LDRB     R0,[R6, #+0]
   \   0000004E   0x280D             CMP      R0,#+13
   \   00000050   0xBF18             IT       NE 
   \   00000052   0x280A             CMPNE    R0,#+10
   \   00000054   0xD0E8             BEQ.N    ??BcMdemSyncProtocolCheck_3
   \                     ??BcMdemSyncProtocolCheck_5:
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x1C44             ADDS     R4,R0,#+1
   \   0000005A   0x5D80             LDRB     R0,[R0, R6]
   \   0000005C   0x280D             CMP      R0,#+13
   \   0000005E   0xD106             BNE.N    ??BcMdemSyncProtocolCheck_6
   \   00000060   0x200A             MOVS     R0,#+10
   \   00000062   0x55A0             STRB     R0,[R4, R6]
   \   00000064   0x1C64             ADDS     R4,R4,#+1
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x55A0             STRB     R0,[R4, R6]
   \   0000006A   0x1EA0             SUBS     R0,R4,#+2
   \   0000006C   0xBD76             POP      {R1,R2,R4-R6,PC}
   \                     ??BcMdemSyncProtocolCheck_6:
   \   0000006E   0xF5B4 0x6F80      CMP      R4,#+1024
   \   00000072   0xDBD9             BLT.N    ??BcMdemSyncProtocolCheck_3
   \                     ??BcMdemSyncProtocolCheck_2:
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    434          	}
    435          }
    436          

   \                                 In section .text, align 2, keep-with-next
    437          INT32S BcMdemSyncCheck(char *Ptr)
    438          {
   \                     BcMdemSyncCheck:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    439          
    440          	if(Ptr == NULL || strlen(Ptr) == 0) 						return 0;
   \   00000004   0xD002             BEQ.N    ??BcMdemSyncCheck_0
   \   00000006   0x.... 0x....      BL       strlen
   \   0000000A   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_1
   \                     ??BcMdemSyncCheck_0:
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD10             POP      {R4,PC}
    441          
    442          	if(!strncmp(Ptr, RspTxAckmsg, strlen(RspTxAckmsg))) 		return 10;
   \                     ??BcMdemSyncCheck_1:
   \   00000010   0x2210             MOVS     R2,#+16
   \   00000012   0x.... 0x....      ADR.W    R1,`?<Constant "*SKTR*SMSMOACK:1">`
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       strncmp
   \   0000001C   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_2
   \   0000001E   0x200A             MOVS     R0,#+10
   \   00000020   0xBD10             POP      {R4,PC}
    443          	if(!strncmp(Ptr, Rspconnect, strlen(Rspconnect))) 			return 11;
   \                     ??BcMdemSyncCheck_2:
   \   00000022   0x2207             MOVS     R2,#+7
   \   00000024   0x.... 0x....      ADR.W    R1,`?<Constant "CONNECT">`
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       strncmp
   \   0000002E   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_3
   \   00000030   0x200B             MOVS     R0,#+11
   \   00000032   0xBD10             POP      {R4,PC}
    444          	if(!strncmp(Ptr, Rspnocarr, strlen(Rspnocarr))) 			return 12;
   \                     ??BcMdemSyncCheck_3:
   \   00000034   0x220A             MOVS     R2,#+10
   \   00000036   0x.... 0x....      ADR.W    R1,`?<Constant "NO CARRIER">`
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       strncmp
   \   00000040   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_4
   \   00000042   0x200C             MOVS     R0,#+12
   \   00000044   0xBD10             POP      {R4,PC}
    445          
    446          	if(!strncmp(Ptr, CdmaErr, strlen(CdmaErr))) 				return 13;
   \                     ??BcMdemSyncCheck_4:
   \   00000046   0x2205             MOVS     R2,#+5
   \   00000048   0x.... 0x....      ADR.W    R1,`?<Constant "ERROR">`
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       strncmp
   \   00000052   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_5
   \   00000054   0x200D             MOVS     R0,#+13
   \   00000056   0xBD10             POP      {R4,PC}
    447          	if(!strncmp(Ptr, CdmaOk, strlen(CdmaOk))) 					return 14;
   \                     ??BcMdemSyncCheck_5:
   \   00000058   0x2202             MOVS     R2,#+2
   \   0000005A   0x....             ADR.N    R1,??DataTable76  ;; 0x4F, 0x4B, 0x00, 0x00
   \   0000005C   0x4620             MOV      R0,R4
   \   0000005E   0x.... 0x....      BL       strncmp
   \   00000062   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_6
   \   00000064   0x200E             MOVS     R0,#+14
   \   00000066   0xBD10             POP      {R4,PC}
    448          
    449          	if(!strncmp(Ptr, Rspmsg0Rx, strlen(Rspmsg0Rx))) 			return 15;
   \                     ??BcMdemSyncCheck_6:
   \   00000068   0x2206             MOVS     R2,#+6
   \   0000006A   0x.... 0x....      ADR.W    R1,`?<Constant "$008:0">`
   \   0000006E   0x4620             MOV      R0,R4
   \   00000070   0x.... 0x....      BL       strncmp
   \   00000074   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_7
   \   00000076   0x200F             MOVS     R0,#+15
   \   00000078   0xBD10             POP      {R4,PC}
    450          	if(!strncmp(Ptr, Rspmsg1Rx, strlen(Rspmsg1Rx))) 			return 16;
   \                     ??BcMdemSyncCheck_7:
   \   0000007A   0x2206             MOVS     R2,#+6
   \   0000007C   0x.... 0x....      ADR.W    R1,`?<Constant "$008:1">`
   \   00000080   0x4620             MOV      R0,R4
   \   00000082   0x.... 0x....      BL       strncmp
   \   00000086   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_8
   \   00000088   0x2010             MOVS     R0,#+16
   \   0000008A   0xBD10             POP      {R4,PC}
    451          
    452          	if(!strncmp(Ptr, RspTxmsg, strlen(RspTxmsg))) 				return 17;
   \                     ??BcMdemSyncCheck_8:
   \   0000008C   0x2204             MOVS     R2,#+4
   \   0000008E   0x.... 0x....      ADR.W    R1,`?<Constant "$006">`
   \   00000092   0x4620             MOV      R0,R4
   \   00000094   0x.... 0x....      BL       strncmp
   \   00000098   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_9
   \   0000009A   0x2011             MOVS     R0,#+17
   \   0000009C   0xBD10             POP      {R4,PC}
    453          
    454          	if(!strncmp(Ptr, RspTcpOpenOk, strlen(RspTcpOpenOk))) 		return 18;
   \                     ??BcMdemSyncCheck_9:
   \   0000009E   0x2208             MOVS     R2,#+8
   \   000000A0   0x.... 0x....      ADR.W    R1,`?<Constant "$TCPOPEN">`
   \   000000A4   0x4620             MOV      R0,R4
   \   000000A6   0x.... 0x....      BL       strncmp
   \   000000AA   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_10
   \   000000AC   0x2012             MOVS     R0,#+18
   \   000000AE   0xBD10             POP      {R4,PC}
    455          	if(!strncmp(Ptr, RspmsgRxCnt,  strlen(RspmsgRxCnt))) 		return 19;
   \                     ??BcMdemSyncCheck_10:
   \   000000B0   0x220D             MOVS     R2,#+13
   \   000000B2   0x.... 0x....      ADR.W    R1,`?<Constant "*SKTR*SMSCNT:">`
   \   000000B6   0x4620             MOV      R0,R4
   \   000000B8   0x.... 0x....      BL       strncmp
   \   000000BC   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_11
   \   000000BE   0x2013             MOVS     R0,#+19
   \   000000C0   0xBD10             POP      {R4,PC}
    456          	if(!strncmp(Ptr, RspmsgRxMsg,  strlen(RspmsgRxMsg))) 		return 20;
   \                     ??BcMdemSyncCheck_11:
   \   000000C2   0x220C             MOVS     R2,#+12
   \   000000C4   0x.... 0x....      ADR.W    R1,`?<Constant "*SKTR*SMSMT:">`
   \   000000C8   0x4620             MOV      R0,R4
   \   000000CA   0x.... 0x....      BL       strncmp
   \   000000CE   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_12
   \   000000D0   0x2014             MOVS     R0,#+20
   \   000000D2   0xBD10             POP      {R4,PC}
    457          	if(!strncmp(Ptr, RspmsgRxEsn,  strlen(RspmsgRxEsn))) 		return 21;
   \                     ??BcMdemSyncCheck_12:
   \   000000D4   0x220A             MOVS     R2,#+10
   \   000000D6   0x.... 0x....      ADR.W    R1,`?<Constant "*SKTR*ESN:">`
   \   000000DA   0x4620             MOV      R0,R4
   \   000000DC   0x.... 0x....      BL       strncmp
   \   000000E0   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_13
   \   000000E2   0x2015             MOVS     R0,#+21
   \   000000E4   0xBD10             POP      {R4,PC}
    458          	if(!strncmp(Ptr, RspmsgRxRfSts,  strlen(RspmsgRxRfSts))) 	return 22;
   \                     ??BcMdemSyncCheck_13:
   \   000000E6   0x220C             MOVS     R2,#+12
   \   000000E8   0x.... 0x....      ADR.W    R1,`?<Constant "*SKTR*RFSTS:">`
   \   000000EC   0x4620             MOV      R0,R4
   \   000000EE   0x.... 0x....      BL       strncmp
   \   000000F2   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_14
   \   000000F4   0x2016             MOVS     R0,#+22
   \   000000F6   0xBD10             POP      {R4,PC}
    459          	if(!strncmp(Ptr, RspmsgTraffic,  strlen(RspmsgTraffic)))	return 23;
   \                     ??BcMdemSyncCheck_14:
   \   000000F8   0x220A             MOVS     R2,#+10
   \   000000FA   0x.... 0x....      ADR.W    R1,`?<Constant "*SKT*PONG:">`
   \   000000FE   0x4620             MOV      R0,R4
   \   00000100   0x.... 0x....      BL       strncmp
   \   00000104   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_15
   \   00000106   0x2017             MOVS     R0,#+23
   \   00000108   0xBD10             POP      {R4,PC}
    460          	
    461          	if(!strncmp(Ptr, CdmaModemTcpSendDone, strlen(CdmaModemTcpSendDone)))return 24;
   \                     ??BcMdemSyncCheck_15:
   \   0000010A   0x220C             MOVS     R2,#+12
   \   0000010C   0x.... 0x....      ADR.W    R1,`?<Constant "$TCPSENDDONE">`
   \   00000110   0x4620             MOV      R0,R4
   \   00000112   0x.... 0x....      BL       strncmp
   \   00000116   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_16
   \   00000118   0x2018             MOVS     R0,#+24
   \   0000011A   0xBD10             POP      {R4,PC}
    462          	if(!strncmp(Ptr, CdmaModemTcpRdCmd,  strlen(CdmaModemTcpRdCmd)))	return 25;
   \                     ??BcMdemSyncCheck_16:
   \   0000011C   0x220D             MOVS     R2,#+13
   \   0000011E   0x.... 0x....      ADR.W    R1,`?<Constant "$TCPREADDATA=">`
   \   00000122   0x4620             MOV      R0,R4
   \   00000124   0x.... 0x....      BL       strncmp
   \   00000128   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_17
   \   0000012A   0x2019             MOVS     R0,#+25
   \   0000012C   0xBD10             POP      {R4,PC}
    463          	if(!strncmp(Ptr, RspTcpCloseOk,  strlen(RspTcpCloseOk)))			return 26;
   \                     ??BcMdemSyncCheck_17:
   \   0000012E   0x220A             MOVS     R2,#+10
   \   00000130   0x.... 0x....      ADR.W    R1,`?<Constant "$TCPCLOSED">`
   \   00000134   0x4620             MOV      R0,R4
   \   00000136   0x.... 0x....      BL       strncmp
   \   0000013A   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_18
   \   0000013C   0x201A             MOVS     R0,#+26
   \   0000013E   0xBD10             POP      {R4,PC}
    464          	if(!strncmp(Ptr, RspmsgSwRst,  strlen(RspmsgSwRst)))				return 27;
   \                     ??BcMdemSyncCheck_18:
   \   00000140   0x220C             MOVS     R2,#+12
   \   00000142   0x.... 0x....      ADR.W    R1,`?<Constant "*SKT*RESET:1">`
   \   00000146   0x4620             MOV      R0,R4
   \   00000148   0x.... 0x....      BL       strncmp
   \   0000014C   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_19
   \   0000014E   0x201B             MOVS     R0,#+27
   \   00000150   0xBD10             POP      {R4,PC}
    465          	if(!strncmp(Ptr, RspmsgCallAck,  strlen(RspmsgCallAck)))			return 28;
   \                     ??BcMdemSyncCheck_19:
   \   00000152   0x220B             MOVS     R2,#+11
   \   00000154   0x.... 0x....      ADR.W    R1,`?<Constant "*SKT*VCALL:">`
   \   00000158   0x4620             MOV      R0,R4
   \   0000015A   0x.... 0x....      BL       strncmp
   \   0000015E   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_20
   \   00000160   0x201C             MOVS     R0,#+28
   \   00000162   0xBD10             POP      {R4,PC}
    466          	if(!strncmp(Ptr, RspmsgCallConnect,  strlen(RspmsgCallConnect)))	return 29;
   \                     ??BcMdemSyncCheck_20:
   \   00000164   0x2211             MOVS     R2,#+17
   \   00000166   0x.... 0x....      ADR.W    R1,`?<Constant "*SKT*VOICECONNECT">`
   \   0000016A   0x4620             MOV      R0,R4
   \   0000016C   0x.... 0x....      BL       strncmp
   \   00000170   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_21
   \   00000172   0x201D             MOVS     R0,#+29
   \   00000174   0xBD10             POP      {R4,PC}
    467          	if(!strncmp(Ptr, RspmsgHangup,  strlen(RspmsgHangup)))				return 30;
   \                     ??BcMdemSyncCheck_21:
   \   00000176   0x2209             MOVS     R2,#+9
   \   00000178   0x.... 0x....      ADR.W    R1,`?<Constant "*SKT*REL:">`
   \   0000017C   0x4620             MOV      R0,R4
   \   0000017E   0x.... 0x....      BL       strncmp
   \   00000182   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_22
   \   00000184   0x201E             MOVS     R0,#+30
   \   00000186   0xBD10             POP      {R4,PC}
    468          	if(!strncmp(Ptr, RspmsgPilot,  strlen(RspmsgPilot)))				return 31;
   \                     ??BcMdemSyncCheck_22:
   \   00000188   0x220C             MOVS     R2,#+12
   \   0000018A   0x.... 0x....      ADR.W    R1,`?<Constant "*SKTR*PILOT:">`
   \   0000018E   0x4620             MOV      R0,R4
   \   00000190   0x.... 0x....      BL       strncmp
   \   00000194   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_23
   \   00000196   0x201F             MOVS     R0,#+31
   \   00000198   0xBD10             POP      {R4,PC}
    469          	if(!strncmp(Ptr, RspmsgMinNum,  strlen(RspmsgMinNum)))				return 32;
   \                     ??BcMdemSyncCheck_23:
   \   0000019A   0x220A             MOVS     R2,#+10
   \   0000019C   0x.... 0x....      ADR.W    R1,`?<Constant "*SKT*DIAL:">`
   \   000001A0   0x4620             MOV      R0,R4
   \   000001A2   0x.... 0x....      BL       strncmp
   \   000001A6   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_24
   \   000001A8   0x2020             MOVS     R0,#+32
   \   000001AA   0xBD10             POP      {R4,PC}
    470          	if(!strncmp(Ptr, RspmsgCallingCmd,  strlen(RspmsgCallingCmd)))		return 33;
   \                     ??BcMdemSyncCheck_24:
   \   000001AC   0x2209             MOVS     R2,#+9
   \   000001AE   0x.... 0x....      ADR.W    R1,`?<Constant "*SKT*ORI:">`
   \   000001B2   0x4620             MOV      R0,R4
   \   000001B4   0x.... 0x....      BL       strncmp
   \   000001B8   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_25
   \   000001BA   0x2021             MOVS     R0,#+33
   \   000001BC   0xBD10             POP      {R4,PC}
    471          
    472          	if(!strncmp(Ptr, RspICCID,  strlen(RspICCID)))						return 34;
   \                     ??BcMdemSyncCheck_25:
   \   000001BE   0x220C             MOVS     R2,#+12
   \   000001C0   0x.... 0x....      ADR.W    R1,`?<Constant "*SKTR*ICCID:">`
   \   000001C4   0x4620             MOV      R0,R4
   \   000001C6   0x.... 0x....      BL       strncmp
   \   000001CA   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_26
   \   000001CC   0x2022             MOVS     R0,#+34
   \   000001CE   0xBD10             POP      {R4,PC}
    473          
    474          	if(!strncmp(Ptr, RspLockOrder,	strlen(RspLockOrder)))				return 35;
   \                     ??BcMdemSyncCheck_26:
   \   000001D0   0x2207             MOVS     R2,#+7
   \   000001D2   0x.... 0x....      ADR.W    R1,`?<Constant "+CGREG:">`
   \   000001D6   0x4620             MOV      R0,R4
   \   000001D8   0x.... 0x....      BL       strncmp
   \   000001DC   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_27
   \   000001DE   0x2023             MOVS     R0,#+35
   \   000001E0   0xBD10             POP      {R4,PC}
    475          	
    476          	if(!strncmp(Ptr, RspGMMLockOrder, strlen(RspGMMLockOrder)))			return 36;
   \                     ??BcMdemSyncCheck_27:
   \   000001E2   0x220A             MOVS     R2,#+10
   \   000001E4   0x.... 0x....      ADR.W    R1,`?<Constant "$$GMM_REJ:">`
   \   000001E8   0x4620             MOV      R0,R4
   \   000001EA   0x.... 0x....      BL       strncmp
   \   000001EE   0xB908             CBNZ.N   R0,??BcMdemSyncCheck_28
   \   000001F0   0x2024             MOVS     R0,#+36
   \   000001F2   0xBD10             POP      {R4,PC}
    477          	return -1;	// Normal Data
   \                     ??BcMdemSyncCheck_28:
   \   000001F4   0xF04F 0x30FF      MOV      R0,#-1
   \   000001F8   0xBD10             POP      {R4,PC}          ;; return
    478          }
    479          
    480          	

   \                                 In section .text, align 4, keep-with-next
    481          INT8S  BcMdemDataProtocolCheck(INT8S Command)
    482          {
   \                     BcMdemDataProtocolCheck:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
    483          	INT8S nRet = 0;
   \   00000006   0x2700             MOVS     R7,#+0
    484          	INT8U i = 0, j = 0 ;
   \   00000008   0x2500             MOVS     R5,#+0
   \   0000000A   0x462E             MOV      R6,R5
    485          	INT8S CheckDataBuff[20];
    486          	
    487          	INT8U DataCnt=0, DataCnt2=0 ;
   \   0000000C   0x46A8             MOV      R8,R5
    488          
    489          	switch(Command)
   \   0000000E   0x1E80             SUBS     R0,R0,#+2
   \   00000010   0x2811             CMP      R0,#+17
   \   00000012   0xF200 0x81AB      BHI.W    ??BcMdemDataProtocolCheck_1
   \   00000016   0xE8DF 0xF010      TBH      [PC, R0, LSL #+1]
   \                     ??BcMdemDataProtocolCheck_0:
   \   0000001A   0x0012 0x0089      DC16     0x12,0x89,0xD9,0x146
   \              0x00D9 0x0146
   \   00000022   0x0164 0x017A      DC16     0x164,0x17A,0x10E,0x128
   \              0x010E 0x0128
   \   0000002A   0x01A9 0x01A9      DC16     0x1A9,0x1A9,0x1A9,0x1A9
   \              0x01A9 0x01A9
   \   00000032   0x01A9 0x01A9      DC16     0x1A9,0x1A9,0x1A9,0x1A9
   \              0x01A9 0x01A9
   \   0000003A   0x018A 0x019C      DC16     0x18A,0x19C
    490          	{
    491          		case VersionCmd:
    492          
    493          			for(i = 0; RxCdmaData[i] != 0x0d; i++) {}
   \                     ??BcMdemDataProtocolCheck_2:
   \   0000003E   0x.... 0x....      LDR.W    R4,??DataTable77_6
   \   00000042   0x7820             LDRB     R0,[R4, #+0]
   \   00000044   0x280D             CMP      R0,#+13
   \   00000046   0xF000 0x8191      BEQ.W    ??BcMdemDataProtocolCheck_1
   \                     ??BcMdemDataProtocolCheck_3:
   \   0000004A   0x1C6D             ADDS     R5,R5,#+1
   \   0000004C   0xB2ED             UXTB     R5,R5
   \   0000004E   0x5D28             LDRB     R0,[R5, R4]
   \   00000050   0x280D             CMP      R0,#+13
   \   00000052   0xD1FA             BNE.N    ??BcMdemDataProtocolCheck_3
    494          
    495          			if(i < 6)return FALSE;
   \   00000054   0x2D06             CMP      R5,#+6
   \   00000056   0xF0C0 0x8189      BCC.W    ??BcMdemDataProtocolCheck_1
    496          
    497          			//////////////////////////////////////////////////////////////////////////
    498          			 //  
    499          			if( (strstr(((char*)RxCdmaData), ((char*)"SAT"))) != NULL )
   \   0000005A   0xA1C5             ADR.N    R1,??BcMdemDataProtocolCheck_4  ;; "SAT"
   \   0000005C   0x4620             MOV      R0,R4
   \   0000005E   0x.... 0x....      BL       __iar_Strstr
   \   00000062   0xB110             CBZ.N    R0,??BcMdemDataProtocolCheck_5
    500          			{
    501          				BcMMaker = 0x04;
   \   00000064   0x....             LDR.N    R0,??DataTable77_4
   \   00000066   0x2104             MOVS     R1,#+4
   \   00000068   0xE01E             B.N      ??BcMdemDataProtocolCheck_6
    502          			}
    503          			else if( (strstr(((char*)RxCdmaData), ((char*)"KST"))) != NULL )
   \                     ??BcMdemDataProtocolCheck_5:
   \   0000006A   0x....             ADR.N    R1,??DataTable77  ;; "KST"
   \   0000006C   0x4620             MOV      R0,R4
   \   0000006E   0x.... 0x....      BL       __iar_Strstr
   \   00000072   0xB110             CBZ.N    R0,??BcMdemDataProtocolCheck_7
    504          			{
    505          				BcMMaker = 0x02;
   \   00000074   0x....             LDR.N    R0,??DataTable77_4
   \   00000076   0x2102             MOVS     R1,#+2
   \   00000078   0xE016             B.N      ??BcMdemDataProtocolCheck_6
    506          			}
    507          			else if( (strstr(((char*)RxCdmaData), ((char*)"ATS"))) != NULL )
   \                     ??BcMdemDataProtocolCheck_7:
   \   0000007A   0x....             ADR.N    R1,??DataTable77_1  ;; "ATS"
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0x.... 0x....      BL       __iar_Strstr
   \   00000082   0xB110             CBZ.N    R0,??BcMdemDataProtocolCheck_8
    508          			{
    509          				BcMMaker = 0x03;
   \   00000084   0x....             LDR.N    R0,??DataTable77_4
   \   00000086   0x2103             MOVS     R1,#+3
   \   00000088   0xE00E             B.N      ??BcMdemDataProtocolCheck_6
    510          			}
    511          			else if( (strstr(((char*)RxCdmaData), ((char*)"x05"))) != NULL )
   \                     ??BcMdemDataProtocolCheck_8:
   \   0000008A   0x....             ADR.N    R1,??DataTable77_2  ;; "x05"
   \   0000008C   0x4620             MOV      R0,R4
   \   0000008E   0x.... 0x....      BL       __iar_Strstr
   \   00000092   0xB110             CBZ.N    R0,??BcMdemDataProtocolCheck_9
    512          			{
    513          				BcMMaker = 0x05;
   \   00000094   0x....             LDR.N    R0,??DataTable77_4
   \   00000096   0x2105             MOVS     R1,#+5
   \   00000098   0xE006             B.N      ??BcMdemDataProtocolCheck_6
    514          			}
    515          			else if( (strstr(((char*)RxCdmaData), ((char*)"x06"))) != NULL )
   \                     ??BcMdemDataProtocolCheck_9:
   \   0000009A   0x....             ADR.N    R1,??DataTable77_3  ;; "x06"
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0x.... 0x....      BL       __iar_Strstr
   \   000000A2   0xB110             CBZ.N    R0,??BcMdemDataProtocolCheck_10
    516          			{
    517          				BcMMaker = 0x06;////ANTS
   \   000000A4   0x....             LDR.N    R0,??DataTable77_4
   \   000000A6   0x2106             MOVS     R1,#+6
   \                     ??BcMdemDataProtocolCheck_6:
   \   000000A8   0x71C1             STRB     R1,[R0, #+7]
    518          			}
    519          			else
    520          			{
    521          
    522          
    523          			}
    524          			//////////////////////////////////////////////////////////////////////////
    525          			//  Type
    526          			if( (strstr(((char*)RxCdmaData), ((char*)"ZZB3"))) != NULL )
   \                     ??BcMdemDataProtocolCheck_10:
   \   000000AA   0x.... 0x....      ADR.W    R1,`?<Constant "ZZB3">`
   \   000000AE   0x4620             MOV      R0,R4
   \   000000B0   0x.... 0x....      BL       __iar_Strstr
   \   000000B4   0xB110             CBZ.N    R0,??BcMdemDataProtocolCheck_11
    527          			{
    528          				BcMType = 0x05;
   \   000000B6   0x....             LDR.N    R0,??DataTable77_4
   \   000000B8   0x2105             MOVS     R1,#+5
   \   000000BA   0xE010             B.N      ??BcMdemDataProtocolCheck_12
    529          				ModemType = _CMDA_Modem;
    530          			}
    531          			else if( (strstr(((char*)RxCdmaData), ((char*)"ZZB4"))) != NULL )
   \                     ??BcMdemDataProtocolCheck_11:
   \   000000BC   0x.... 0x....      ADR.W    R1,`?<Constant "ZZB4">`
   \   000000C0   0x4620             MOV      R0,R4
   \   000000C2   0x.... 0x....      BL       __iar_Strstr
   \   000000C6   0xB110             CBZ.N    R0,??BcMdemDataProtocolCheck_13
    532          			{
    533          				//SXC-2080
    534          				BcMType = 0x04;
   \   000000C8   0x....             LDR.N    R0,??DataTable77_4
   \   000000CA   0x2104             MOVS     R1,#+4
   \   000000CC   0xE007             B.N      ??BcMdemDataProtocolCheck_12
    535          				ModemType = _CMDA_Modem;
    536          			}
    537          			else if( (strstr(((char*)RxCdmaData), ((char*)"ZZB5"))) != NULL )
   \                     ??BcMdemDataProtocolCheck_13:
   \   000000CE   0x.... 0x....      ADR.W    R1,`?<Constant "ZZB5">`
   \   000000D2   0x4620             MOV      R0,R4
   \   000000D4   0x.... 0x....      BL       __iar_Strstr
   \   000000D8   0xB120             CBZ.N    R0,??BcMdemDataProtocolCheck_14
    538          			{
    539          				BcMType = 0x06;
   \   000000DA   0x....             LDR.N    R0,??DataTable77_4
   \   000000DC   0x2106             MOVS     R1,#+6
   \                     ??BcMdemDataProtocolCheck_12:
   \   000000DE   0x7201             STRB     R1,[R0, #+8]
    540          				ModemType = _CMDA_Modem;
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0xE013             B.N      ??BcMdemDataProtocolCheck_15
    541          			}
    542          			else if( (strstr(((char*)RxCdmaData), ((char*)"0x0C"))) != NULL )
   \                     ??BcMdemDataProtocolCheck_14:
   \   000000E4   0x.... 0x....      ADR.W    R1,`?<Constant "0x0C">`
   \   000000E8   0x4620             MOV      R0,R4
   \   000000EA   0x.... 0x....      BL       __iar_Strstr
   \   000000EE   0xB118             CBZ.N    R0,??BcMdemDataProtocolCheck_16
    543          			{
    544          				BcMType = 0x0C;
   \   000000F0   0x....             LDR.N    R0,??DataTable77_4
   \   000000F2   0x210C             MOVS     R1,#+12
   \   000000F4   0x7201             STRB     R1,[R0, #+8]
    545          				ModemType = _WCMDA_Modem;
   \   000000F6   0xE008             B.N      ??BcMdemDataProtocolCheck_17
    546          			}
    547          			else if( (strstr(((char*)RxCdmaData), ((char*)"0x0D"))) != NULL )
   \                     ??BcMdemDataProtocolCheck_16:
   \   000000F8   0x.... 0x....      ADR.W    R1,`?<Constant "0x0D">`
   \   000000FC   0x4620             MOV      R0,R4
   \   000000FE   0x.... 0x....      BL       __iar_Strstr
   \   00000102   0xB110             CBZ.N    R0,??BcMdemDataProtocolCheck_17
    548          			{
    549          				BcMType = 0x0D;   //////0x0D : ANTS-E300SWA(WCDMA)
   \   00000104   0x....             LDR.N    R0,??DataTable77_4
   \   00000106   0x210D             MOVS     R1,#+13
   \   00000108   0x7201             STRB     R1,[R0, #+8]
    550          				ModemType = _WCMDA_Modem;
    551          			}
    552          			else
    553          			{
    554          				ModemType = _WCMDA_Modem;
   \                     ??BcMdemDataProtocolCheck_17:
   \   0000010A   0x2001             MOVS     R0,#+1
   \                     ??BcMdemDataProtocolCheck_15:
   \   0000010C   0x....             LDR.N    R7,??DataTable77_4
   \   0000010E   0x7278             STRB     R0,[R7, #+9]
    555          			}
    556          
    557          			BcMVerNum[0] = RxCdmaData[i-3];
   \   00000110   0x1928             ADDS     R0,R5,R4
   \   00000112   0xF910 0x1C03      LDRSB    R1,[R0, #-3]
   \   00000116   0x7039             STRB     R1,[R7, #+0]
    558          			BcMVerNum[1] = RxCdmaData[i-2];
   \   00000118   0x1EC0             SUBS     R0,R0,#+3
   \   0000011A   0xF990 0x1001      LDRSB    R1,[R0, #+1]
   \   0000011E   0x7079             STRB     R1,[R7, #+1]
    559          			BcMVerNum[2] = RxCdmaData[i-1];
   \   00000120   0xF990 0x0002      LDRSB    R0,[R0, #+2]
   \   00000124   0x70B8             STRB     R0,[R7, #+2]
    560          
    561          			nRet = TRUE;
   \                     ??BcMdemDataProtocolCheck_18:
   \   00000126   0x2701             MOVS     R7,#+1
    562          		break;
    563          		
    564          		case ModemMinNumCmd:
    565          			for(i = 0; i < strlen(RspmsgMinNum);i++)
    566          			{
    567          				CheckDataBuff[i] = RxCdmaData[i];
    568          			}
    569          			CheckDataBuff[i] = 0;
    570          
    571          			if(BcMdemSyncCheck((char *)CheckDataBuff) != 32)return FALSE;
    572          		
    573          			nRet = TRUE;
    574          
    575          			for ( i=0; i<TelNo; i++ ) if ( RxCdmaData[strlen(RspmsgMinNum)+ (DataCnt++)] == '-' ) break;
    576            			{
    577          				INT8U Data,k = 0;
    578           				for ( j=0; j < TelNo; j++ )
    579          				{
    580          					Data = RxCdmaData[strlen(RspmsgMinNum)+ j];
    581           					if ( Data == 0x0d ) break;
    582          					if('-' == Data) 
    583          					{
    584          //						BcMSrcTel[j] = RxCdmaData[strlen(RspmsgMinNum)+ j];
    585          					}
    586          					else
    587          					{
    588          
    589          						BcMSrcTel[k++] = Data;
    590          					}
    591          					DataCnt2 = k;
    592           				}
    593           				DataCnt2 = DataCnt2;
    594           			}
    595            		break;
    596          
    597          		case ModemEsnCmd:
    598           			if( ModemType == _WCMDA_Modem)
    599          			{
    600          
    601          				for(i = 0; i < strlen(RspICCID);i++)CheckDataBuff[i] = RxCdmaData[i];
    602          
    603          				CheckDataBuff[i] = 0;
    604          				
    605          				if(BcMdemSyncCheck((char *)CheckDataBuff) != 34)return FALSE;
    606          				
    607          				for(j = 0; j < 19; j++, i++)ICCIDNum[j] = RxCdmaData[i];
    608          			
    609          				nRet = TRUE;
    610          			}
    611          			else
    612          			{
    613          				for(i = 0; i < strlen(RspmsgRxEsn);i++)CheckDataBuff[i] = RxCdmaData[i];
    614          
    615          				CheckDataBuff[i] = 0;
    616          				
    617          				if(BcMdemSyncCheck((char *)CheckDataBuff) != 21)return FALSE;
    618          				
    619          				for(j = 0; j < 8; j++, i++)BcMEsnNum[j] = RxCdmaData[i];
    620          			
    621          				nRet = TRUE;
    622          			}
    623          		break;
    624          		
    625          		case MsgCheckCmd:
    626          		{
    627          			for(i = 0; i < strlen(RspmsgRxCnt);i++)CheckDataBuff[i] = RxCdmaData[i];
    628          			
    629          			CheckDataBuff[i] = 0;
    630          
    631          			if(BcMdemSyncCheck((char *)CheckDataBuff) != 19) return FALSE;
    632          #if 0
    633          			if((RxCdmaData[i] < '0')||(RxCdmaData[i] > '9')) nRet = FALSE;
    634          			else if(RxCdmaData[i] == '0')					 nRet = NOT_DATA;
    635          			else 											 nRet = TRUE;
    636          #endif		
    637          
    638          #if 1
    639          			if(RxCdmaData[i] == '0')					 			 nRet = NOT_DATA;
    640          			else if((RxCdmaData[i] < '0')||(RxCdmaData[i] > '9'))	 nRet = FALSE;
    641          			else 													 nRet = TRUE;
    642          #endif		
    643          //			if(BcMdebug) dUartPtr->printf("1: MsgCheckCnt[%d]> %d\n", MsgCheckCnt,nRet);
    644          		}
    645          		break;
    646          		
    647          		case MsgReciveCmd:
    648          			for(i = 0; i < strlen(RspmsgRxMsg);i++)CheckDataBuff[i] = RxCdmaData[i];
    649          
    650          			CheckDataBuff[i] = 0;
    651          
    652          			if(BcMdemSyncCheck((char *)CheckDataBuff) != 20)return FALSE;
    653          			
    654          			if((RxCdmaData[i] < '0')||(RxCdmaData[i] > '9'))nRet = FALSE;
    655          			//else if(RxCdmaData[i] == '0')	nRet = NOT_DATA;			
    656          			else nRet = TRUE;
    657          
    658          			//if(RxCdmaData[i] == 0x22)i++;
    659          							
    660          			for(j = 0; RxCdmaData[i] != 0; j++,i++) RxBcMData[j] = RxCdmaData[i];
    661          			RxBcMData[j] = 0;
    662          
    663          		break;
    664          		
    665          		case ModemTimeCmd:
    666          
    667          			for(i = 0; i < strlen(RspmsgTraffic);i++)CheckDataBuff[i] = RxCdmaData[i];
    668          
    669          			CheckDataBuff[i] = 0;
    670          
    671          			if(BcMdemSyncCheck((char *)CheckDataBuff) != 23)return FALSE;
    672          			
    673          			i += 2; // Traffic Status skip
    674          
    675          			// Init
    676          			for(j = 0; j < sizeof(BcMTimeStr); j++) *((INT8U *)BcMpresentTime + j) = 0;
    677          
    678          			for(j = 0; j < 14; j++, i++) *((char *)BcMpresentTime + j) = RxCdmaData[i];
    679          			
    680          			nRet = TRUE;
    681          			
    682          		break;
    683          
    684          		case ModemRfStsCmd:
    685          			
    686          			for(i = 0; i < strlen(RspmsgRxRfSts);i++)CheckDataBuff[i] = RxCdmaData[i];
    687          
    688          			CheckDataBuff[i] = 0;
    689          
    690          			if(BcMdemSyncCheck((char *)CheckDataBuff) != 22)return FALSE;
    691          			
    692          			if((RxCdmaData[i] < '0')||(RxCdmaData[i] > '9'))return FALSE;
    693          
    694          			nRet = BcMFreqStateCheck( (INT8U *)&RxCdmaData[i] );
    695          			
    696          		break;
    697          
    698          		case ModemTrafficCmd:
    699          			
    700          			for(i = 0; i < strlen(RspmsgTraffic);i++)CheckDataBuff[i] = RxCdmaData[i];
    701          
    702          			CheckDataBuff[i] = 0;
    703          
    704          			if(BcMdemSyncCheck((char *)CheckDataBuff) != 23)return FALSE;
    705          
    706          			nRet = RxCdmaData[i];
    707            		break;
    708          
    709          		case ModemPilotCmd:
    710          			
    711          			for(i = 0; i < strlen(RspmsgPilot);i++)CheckDataBuff[i] = RxCdmaData[i];
    712          
    713          			CheckDataBuff[i] = 0;
    714          
    715           			if(BcMdemSyncCheck((char *)CheckDataBuff) != 31)return FALSE;
    716          			nRet = BcMPilotStateCheck( (INT8U *)&RxCdmaData[i]);
    717          		break;
    718          
    719          		case ModemLockOrderCmd:
    720           			{
    721          				for(i = 0; i < strlen(RspLockOrder);i++)CheckDataBuff[i] = RxCdmaData[i];
    722          
    723          				CheckDataBuff[i] = 0;
    724          				
    725          				if(BcMdemSyncCheck((char *)CheckDataBuff) != 35)return FALSE;
    726           			
    727          				nRet = TRUE;
    728          			}
    729           		break;
    730          		
    731          		
    732          		default : return FALSE;
    733          	}	
    734          
    735          	return nRet;
   \                     ??BcMdemDataProtocolCheck_19:
   \   00000128   0x4638             MOV      R0,R7
   \                     ??BcMdemDataProtocolCheck_20:
   \   0000012A   0x....             B.N      ?Subroutine1
   \                     ??BcMdemDataProtocolCheck_21:
   \   0000012C   0x....             LDR.N    R4,??DataTable77_6
   \   0000012E   0x220A             MOVS     R2,#+10
   \   00000130   0x4621             MOV      R1,R4
   \   00000132   0xA800             ADD      R0,SP,#+0
   \   00000134   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000138   0xF88D 0x500A      STRB     R5,[SP, #+10]
   \   0000013C   0xA800             ADD      R0,SP,#+0
   \   0000013E   0x.... 0x....      BL       BcMdemSyncCheck
   \   00000142   0x2820             CMP      R0,#+32
   \   00000144   0xF040 0x8112      BNE.W    ??BcMdemDataProtocolCheck_1
   \   00000148   0x2701             MOVS     R7,#+1
   \   0000014A   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000014C   0x282D             CMP      R0,#+45
   \   0000014E   0xBF1C             ITT      NE 
   \   00000150   0x46B8             MOVNE    R8,R7
   \   00000152   0x2501             MOVNE    R5,#+1
   \                     ??BcMdemDataProtocolCheck_22:
   \   00000154   0xFA5F 0xF188      UXTB     R1,R8
   \   00000158   0x1908             ADDS     R0,R1,R4
   \   0000015A   0x7A80             LDRB     R0,[R0, #+10]
   \   0000015C   0x282D             CMP      R0,#+45
   \   0000015E   0xD023             BEQ.N    ??BcMdemDataProtocolCheck_23
   \   00000160   0x1C48             ADDS     R0,R1,#+1
   \   00000162   0xB2C1             UXTB     R1,R0
   \   00000164   0x1908             ADDS     R0,R1,R4
   \   00000166   0x7A80             LDRB     R0,[R0, #+10]
   \   00000168   0x282D             CMP      R0,#+45
   \   0000016A   0xD01D             BEQ.N    ??BcMdemDataProtocolCheck_23
   \   0000016C   0x1C48             ADDS     R0,R1,#+1
   \   0000016E   0xB2C1             UXTB     R1,R0
   \   00000170   0x1908             ADDS     R0,R1,R4
   \   00000172   0x7A80             LDRB     R0,[R0, #+10]
   \   00000174   0x282D             CMP      R0,#+45
   \   00000176   0xD017             BEQ.N    ??BcMdemDataProtocolCheck_23
   \   00000178   0x1C48             ADDS     R0,R1,#+1
   \   0000017A   0xB2C1             UXTB     R1,R0
   \   0000017C   0x1908             ADDS     R0,R1,R4
   \   0000017E   0x7A80             LDRB     R0,[R0, #+10]
   \   00000180   0x282D             CMP      R0,#+45
   \   00000182   0xD011             BEQ.N    ??BcMdemDataProtocolCheck_23
   \   00000184   0x1C48             ADDS     R0,R1,#+1
   \   00000186   0xB2C1             UXTB     R1,R0
   \   00000188   0x1908             ADDS     R0,R1,R4
   \   0000018A   0x7A80             LDRB     R0,[R0, #+10]
   \   0000018C   0x282D             CMP      R0,#+45
   \   0000018E   0xD00B             BEQ.N    ??BcMdemDataProtocolCheck_23
   \   00000190   0x1C48             ADDS     R0,R1,#+1
   \   00000192   0xB2C1             UXTB     R1,R0
   \   00000194   0x1908             ADDS     R0,R1,R4
   \   00000196   0x7A80             LDRB     R0,[R0, #+10]
   \   00000198   0x282D             CMP      R0,#+45
   \   0000019A   0xD005             BEQ.N    ??BcMdemDataProtocolCheck_23
   \   0000019C   0xF101 0x0801      ADD      R8,R1,#+1
   \   000001A0   0x1DAD             ADDS     R5,R5,#+6
   \   000001A2   0xB2ED             UXTB     R5,R5
   \   000001A4   0x2D0D             CMP      R5,#+13
   \   000001A6   0xD3D5             BCC.N    ??BcMdemDataProtocolCheck_22
   \                     ??BcMdemDataProtocolCheck_23:
   \   000001A8   0x2000             MOVS     R0,#+0
   \   000001AA   0xF204 0x010A      ADDW     R1,R4,#+10
   \   000001AE   0x220D             MOVS     R2,#+13
   \                     ??BcMdemDataProtocolCheck_24:
   \   000001B0   0x780B             LDRB     R3,[R1, #+0]
   \   000001B2   0x2B0D             CMP      R3,#+13
   \   000001B4   0xD0B8             BEQ.N    ??BcMdemDataProtocolCheck_19
   \   000001B6   0x2B2D             CMP      R3,#+45
   \   000001B8   0xD004             BEQ.N    ??BcMdemDataProtocolCheck_25
   \   000001BA   0xB2C0             UXTB     R0,R0
   \   000001BC   0x....             LDR.N    R4,??DataTable77_4
   \   000001BE   0x1904             ADDS     R4,R0,R4
   \   000001C0   0x7323             STRB     R3,[R4, #+12]
   \   000001C2   0x1C40             ADDS     R0,R0,#+1
   \                     ??BcMdemDataProtocolCheck_25:
   \   000001C4   0x1C49             ADDS     R1,R1,#+1
   \   000001C6   0x1E52             SUBS     R2,R2,#+1
   \   000001C8   0xD1F2             BNE.N    ??BcMdemDataProtocolCheck_24
   \   000001CA   0xE7AD             B.N      ??BcMdemDataProtocolCheck_19
   \                     ??BcMdemDataProtocolCheck_26:
   \   000001CC   0x....             LDR.N    R7,??DataTable77_4
   \   000001CE   0x....             LDR.N    R4,??DataTable77_6
   \   000001D0   0xF10D 0x0800      ADD      R8,SP,#+0
   \   000001D4   0x7A78             LDRB     R0,[R7, #+9]
   \   000001D6   0x2801             CMP      R0,#+1
   \   000001D8   0xD116             BNE.N    ??BcMdemDataProtocolCheck_27
   \   000001DA   0xA800             ADD      R0,SP,#+0
   \   000001DC   0xCC0E             LDM      R4!,{R1-R3}
   \   000001DE   0xC00E             STM      R0!,{R1-R3}
   \   000001E0   0x3C0C             SUBS     R4,R4,#+12
   \   000001E2   0x250C             MOVS     R5,#+12
   \   000001E4   0xF888 0x600C      STRB     R6,[R8, #+12]
   \   000001E8   0xA800             ADD      R0,SP,#+0
   \   000001EA   0x.... 0x....      BL       BcMdemSyncCheck
   \   000001EE   0x2822             CMP      R0,#+34
   \   000001F0   0xF040 0x80BC      BNE.W    ??BcMdemDataProtocolCheck_1
   \                     ??BcMdemDataProtocolCheck_28:
   \   000001F4   0x19F0             ADDS     R0,R6,R7
   \   000001F6   0xB2ED             UXTB     R5,R5
   \   000001F8   0x5D29             LDRB     R1,[R5, R4]
   \   000001FA   0xF880 0x1020      STRB     R1,[R0, #+32]
   \   000001FE   0x1C76             ADDS     R6,R6,#+1
   \   00000200   0x1C6D             ADDS     R5,R5,#+1
   \   00000202   0x2E13             CMP      R6,#+19
   \   00000204   0xD3F6             BCC.N    ??BcMdemDataProtocolCheck_28
   \   00000206   0xE78E             B.N      ??BcMdemDataProtocolCheck_18
   \                     ??BcMdemDataProtocolCheck_27:
   \   00000208   0x220A             MOVS     R2,#+10
   \   0000020A   0x4621             MOV      R1,R4
   \   0000020C   0xA800             ADD      R0,SP,#+0
   \   0000020E   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000212   0x250A             MOVS     R5,#+10
   \   00000214   0xF888 0x600A      STRB     R6,[R8, #+10]
   \   00000218   0xA800             ADD      R0,SP,#+0
   \   0000021A   0x.... 0x....      BL       BcMdemSyncCheck
   \   0000021E   0x2815             CMP      R0,#+21
   \   00000220   0xF040 0x80A4      BNE.W    ??BcMdemDataProtocolCheck_1
   \                     ??BcMdemDataProtocolCheck_29:
   \   00000224   0x19F0             ADDS     R0,R6,R7
   \   00000226   0xB2ED             UXTB     R5,R5
   \   00000228   0x5D29             LDRB     R1,[R5, R4]
   \   0000022A   0x7601             STRB     R1,[R0, #+24]
   \   0000022C   0x1C76             ADDS     R6,R6,#+1
   \   0000022E   0x1C6D             ADDS     R5,R5,#+1
   \   00000230   0x2E08             CMP      R6,#+8
   \   00000232   0xD3F7             BCC.N    ??BcMdemDataProtocolCheck_29
   \   00000234   0xE777             B.N      ??BcMdemDataProtocolCheck_18
   \                     ??BcMdemDataProtocolCheck_30:
   \   00000236   0x....             LDR.N    R4,??DataTable77_6
   \   00000238   0x220D             MOVS     R2,#+13
   \   0000023A   0x4621             MOV      R1,R4
   \   0000023C   0xA800             ADD      R0,SP,#+0
   \   0000023E   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000242   0xF88D 0x500D      STRB     R5,[SP, #+13]
   \   00000246   0xA800             ADD      R0,SP,#+0
   \   00000248   0x.... 0x....      BL       BcMdemSyncCheck
   \   0000024C   0x2813             CMP      R0,#+19
   \   0000024E   0xF040 0x808D      BNE.W    ??BcMdemDataProtocolCheck_1
   \   00000252   0x7B60             LDRB     R0,[R4, #+13]
   \   00000254   0x2830             CMP      R0,#+48
   \   00000256   0xBF08             IT       EQ 
   \   00000258   0xF04F 0x37FF      MOVEQ    R7,#-1
   \   0000025C   0xF43F 0xAF64      BEQ.W    ??BcMdemDataProtocolCheck_19
   \   00000260   0x3830             SUBS     R0,R0,#+48
   \   00000262   0x280A             CMP      R0,#+10
   \   00000264   0xF4BF 0xAF60      BCS.W    ??BcMdemDataProtocolCheck_19
   \   00000268   0xE75D             B.N      ??BcMdemDataProtocolCheck_18
   \                     ??BcMdemDataProtocolCheck_31:
   \   0000026A   0x....             LDR.N    R4,??DataTable77_6
   \   0000026C   0xA800             ADD      R0,SP,#+0
   \   0000026E   0xCC0E             LDM      R4!,{R1-R3}
   \   00000270   0xC00E             STM      R0!,{R1-R3}
   \   00000272   0x3C0C             SUBS     R4,R4,#+12
   \   00000274   0x250C             MOVS     R5,#+12
   \   00000276   0xF88D 0x600C      STRB     R6,[SP, #+12]
   \   0000027A   0xA800             ADD      R0,SP,#+0
   \   0000027C   0x.... 0x....      BL       BcMdemSyncCheck
   \   00000280   0x2814             CMP      R0,#+20
   \   00000282   0xD173             BNE.N    ??BcMdemDataProtocolCheck_1
   \   00000284   0x7B20             LDRB     R0,[R4, #+12]
   \   00000286   0x3830             SUBS     R0,R0,#+48
   \   00000288   0x280A             CMP      R0,#+10
   \   0000028A   0xD203             BCS.N    ??BcMdemDataProtocolCheck_32
   \   0000028C   0x2701             MOVS     R7,#+1
   \   0000028E   0xE001             B.N      ??BcMdemDataProtocolCheck_32
   \                     ??BcMdemDataProtocolCheck_33:
   \   00000290   0x1C76             ADDS     R6,R6,#+1
   \   00000292   0x1C6D             ADDS     R5,R5,#+1
   \                     ??BcMdemDataProtocolCheck_32:
   \   00000294   0xB2ED             UXTB     R5,R5
   \   00000296   0x5D2A             LDRB     R2,[R5, R4]
   \   00000298   0xB2F6             UXTB     R6,R6
   \   0000029A   0x.... 0x....      LDR.W    R0,??DataTable78
   \   0000029E   0x2A00             CMP      R2,#+0
   \   000002A0   0x5432             STRB     R2,[R6, R0]
   \   000002A2   0xD1F5             BNE.N    ??BcMdemDataProtocolCheck_33
   \   000002A4   0xE740             B.N      ??BcMdemDataProtocolCheck_19
   \                     ??BcMdemDataProtocolCheck_34:
   \   000002A6   0x....             LDR.N    R4,??DataTable77_6
   \   000002A8   0x220A             MOVS     R2,#+10
   \   000002AA   0x4621             MOV      R1,R4
   \   000002AC   0xA800             ADD      R0,SP,#+0
   \   000002AE   0x.... 0x....      BL       __aeabi_memcpy4
   \   000002B2   0xF88D 0x500A      STRB     R5,[SP, #+10]
   \   000002B6   0xA800             ADD      R0,SP,#+0
   \   000002B8   0x.... 0x....      BL       BcMdemSyncCheck
   \   000002BC   0x2817             CMP      R0,#+23
   \   000002BE   0x....             LDR.N    R7,??DataTable77_4
   \   000002C0   0xD154             BNE.N    ??BcMdemDataProtocolCheck_1
   \                     ??BcMdemDataProtocolCheck_35:
   \   000002C2   0x6C38             LDR      R0,[R7, #+64]
   \   000002C4   0x5435             STRB     R5,[R6, R0]
   \   000002C6   0x1C76             ADDS     R6,R6,#+1
   \   000002C8   0x2E12             CMP      R6,#+18
   \   000002CA   0xD3FA             BCC.N    ??BcMdemDataProtocolCheck_35
   \   000002CC   0x2600             MOVS     R6,#+0
   \   000002CE   0xF204 0x000C      ADDW     R0,R4,#+12
   \                     ??BcMdemDataProtocolCheck_36:
   \   000002D2   0x6C39             LDR      R1,[R7, #+64]
   \   000002D4   0xF810 0x2B01      LDRB     R2,[R0], #+1
   \   000002D8   0x5472             STRB     R2,[R6, R1]
   \   000002DA   0x1C76             ADDS     R6,R6,#+1
   \   000002DC   0x2E0E             CMP      R6,#+14
   \   000002DE   0xD3F8             BCC.N    ??BcMdemDataProtocolCheck_36
   \   000002E0   0xE721             B.N      ??BcMdemDataProtocolCheck_18
   \                     ??BcMdemDataProtocolCheck_37:
   \   000002E2   0x....             LDR.N    R4,??DataTable77_6
   \   000002E4   0xA800             ADD      R0,SP,#+0
   \   000002E6   0xCC0E             LDM      R4!,{R1-R3}
   \   000002E8   0xC00E             STM      R0!,{R1-R3}
   \   000002EA   0x3C0C             SUBS     R4,R4,#+12
   \   000002EC   0xF88D 0x500C      STRB     R5,[SP, #+12]
   \   000002F0   0xA800             ADD      R0,SP,#+0
   \   000002F2   0x.... 0x....      BL       BcMdemSyncCheck
   \   000002F6   0x2816             CMP      R0,#+22
   \   000002F8   0xD138             BNE.N    ??BcMdemDataProtocolCheck_1
   \   000002FA   0x7B20             LDRB     R0,[R4, #+12]
   \   000002FC   0x3830             SUBS     R0,R0,#+48
   \   000002FE   0x280A             CMP      R0,#+10
   \   00000300   0xD234             BCS.N    ??BcMdemDataProtocolCheck_1
   \   00000302   0xF104 0x000C      ADD      R0,R4,#+12
   \   00000306   0x.... 0x....      BL       BcMFreqStateCheck
   \   0000030A   0x4607             MOV      R7,R0
   \   0000030C   0xE70C             B.N      ??BcMdemDataProtocolCheck_19
   \                     ??BcMdemDataProtocolCheck_38:
   \   0000030E   0x....             LDR.N    R4,??DataTable77_6
   \   00000310   0x220A             MOVS     R2,#+10
   \   00000312   0x4621             MOV      R1,R4
   \   00000314   0xA800             ADD      R0,SP,#+0
   \   00000316   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000031A   0xF88D 0x500A      STRB     R5,[SP, #+10]
   \   0000031E   0xA800             ADD      R0,SP,#+0
   \   00000320   0x.... 0x....      BL       BcMdemSyncCheck
   \   00000324   0x2817             CMP      R0,#+23
   \   00000326   0xD121             BNE.N    ??BcMdemDataProtocolCheck_1
   \   00000328   0xF994 0x700A      LDRSB    R7,[R4, #+10]
   \   0000032C   0xE6FC             B.N      ??BcMdemDataProtocolCheck_19
   \                     ??BcMdemDataProtocolCheck_39:
   \   0000032E   0x....             LDR.N    R4,??DataTable77_6
   \   00000330   0xA800             ADD      R0,SP,#+0
   \   00000332   0xCC0E             LDM      R4!,{R1-R3}
   \   00000334   0xC00E             STM      R0!,{R1-R3}
   \   00000336   0x3C0C             SUBS     R4,R4,#+12
   \   00000338   0xF88D 0x500C      STRB     R5,[SP, #+12]
   \   0000033C   0xA800             ADD      R0,SP,#+0
   \   0000033E   0x.... 0x....      BL       BcMdemSyncCheck
   \   00000342   0x281F             CMP      R0,#+31
   \   00000344   0xD112             BNE.N    ??BcMdemDataProtocolCheck_1
   \   00000346   0xF104 0x000C      ADD      R0,R4,#+12
   \   0000034A   0x.... 0x....      BL       BcMPilotStateCheck
   \   0000034E   0x4607             MOV      R7,R0
   \   00000350   0xE6EA             B.N      ??BcMdemDataProtocolCheck_19
   \                     ??BcMdemDataProtocolCheck_40:
   \   00000352   0x2207             MOVS     R2,#+7
   \   00000354   0x....             LDR.N    R1,??DataTable77_6
   \   00000356   0xA800             ADD      R0,SP,#+0
   \   00000358   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000035C   0xF88D 0x5007      STRB     R5,[SP, #+7]
   \   00000360   0xA800             ADD      R0,SP,#+0
   \   00000362   0x.... 0x....      BL       BcMdemSyncCheck
   \   00000366   0x2823             CMP      R0,#+35
   \   00000368   0xF43F 0xAEDD      BEQ.W    ??BcMdemDataProtocolCheck_18
   \                     ??BcMdemDataProtocolCheck_1:
   \   0000036C   0x2000             MOVS     R0,#+0
   \   0000036E   0xE6DC             B.N      ??BcMdemDataProtocolCheck_20
   \                     ??BcMdemDataProtocolCheck_4:
   \   00000370   0x53 0x41          DC8      "SAT"
   \              0x54 0x00    
    736          	
    737          }
    738          

   \                                 In section .text, align 2, keep-with-next
    739          INT8S BcMFreqStateCheck ( INT8U *DataBuff )
    740          {
   \                     BcMFreqStateCheck:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0x4601             MOV      R1,R0
    741           	if( ModemType == _WCMDA_Modem)
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable78_1
   \   0000000A   0x7A42             LDRB     R2,[R0, #+9]
   \   0000000C   0x2A01             CMP      R2,#+1
   \   0000000E   0xF040 0x8308      BNE.W    ??BcMFreqStateCheck_0
    742          	{
    743          		INT8U	i, j, k = 0, DataCnt=0, DataCnt2=0, pw;
   \   00000012   0x2400             MOVS     R4,#+0
    744          		INT16S	TempCopy, Power, Actch = 0, chlist = 0;
    745          		INT16S	PSClist = 0;
    746          
    747          
    748                  k = k;
    749                  Actch = Actch;
    750                  chlist = chlist;
    751          		//================//
    752          		// Active Channel //
    753          		//========================================================================//
    754          		DataCnt2 = DataCnt;
    755          		TempCopy = 0;
   \   00000014   0x2600             MOVS     R6,#+0
    756          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   \   00000016   0x4627             MOV      R7,R4
   \   00000018   0x460A             MOV      R2,R1
   \                     ??BcMFreqStateCheck_1:
   \   0000001A   0xF812 0x3B01      LDRB     R3,[R2], #+1
   \   0000001E   0x2B2C             CMP      R3,#+44
   \   00000020   0xD101             BNE.N    ??BcMFreqStateCheck_2
   \                     ??BcMFreqStateCheck_3:
   \   00000022   0x1C64             ADDS     R4,R4,#+1
   \   00000024   0xE01B             B.N      ??BcMFreqStateCheck_4
   \                     ??BcMFreqStateCheck_2:
   \   00000026   0x1C64             ADDS     R4,R4,#+1
   \   00000028   0x1C7F             ADDS     R7,R7,#+1
   \   0000002A   0xF812 0x3B01      LDRB     R3,[R2], #+1
   \   0000002E   0x2B2C             CMP      R3,#+44
   \   00000030   0xBF1F             ITTTT    NE 
   \   00000032   0x1C64             ADDNE    R4,R4,#+1
   \   00000034   0x1C7F             ADDNE    R7,R7,#+1
   \   00000036   0xF812 0x3B01      LDRBNE   R3,[R2], #+1
   \   0000003A   0x2B2C             CMPNE    R3,#+44
   \   0000003C   0xBF1F             ITTTT    NE 
   \   0000003E   0x1C64             ADDNE    R4,R4,#+1
   \   00000040   0x1C7F             ADDNE    R7,R7,#+1
   \   00000042   0xF812 0x3B01      LDRBNE   R3,[R2], #+1
   \   00000046   0x2B2C             CMPNE    R3,#+44
   \   00000048   0xBF1F             ITTTT    NE 
   \   0000004A   0x1C64             ADDNE    R4,R4,#+1
   \   0000004C   0x1C7F             ADDNE    R7,R7,#+1
   \   0000004E   0xF812 0x3B01      LDRBNE   R3,[R2], #+1
   \   00000052   0x2B2C             CMPNE    R3,#+44
   \   00000054   0xD0E5             BEQ.N    ??BcMFreqStateCheck_3
   \   00000056   0x1C64             ADDS     R4,R4,#+1
   \   00000058   0x1C7F             ADDS     R7,R7,#+1
   \   0000005A   0x2F0A             CMP      R7,#+10
   \   0000005C   0xDBDD             BLT.N    ??BcMFreqStateCheck_1
    757          		for ( j=0; j<i; j++ )
   \                     ??BcMFreqStateCheck_4:
   \   0000005E   0x46B4             MOV      R12,R6
   \   00000060   0x460A             MOV      R2,R1
   \   00000062   0x1E7B             SUBS     R3,R7,#+1
   \   00000064   0xE01C             B.N      ??BcMFreqStateCheck_5
    758          		{
    759          			if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   \                     ??BcMFreqStateCheck_6:
   \   00000066   0x7815             LDRB     R5,[R2, #+0]
   \   00000068   0xF1A5 0x0E30      SUB      LR,R5,#+48
   \   0000006C   0xF1BE 0x0F0A      CMP      LR,#+10
   \   00000070   0xF080 0x85C3      BCS.W    ??BcMFreqStateCheck_7
    760          			for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   \   00000074   0xF04F 0x0E01      MOV      LR,#+1
   \   00000078   0x46E0             MOV      R8,R12
   \   0000007A   0x459C             CMP      R12,R3
   \   0000007C   0xDA09             BGE.N    ??BcMFreqStateCheck_8
   \                     ??BcMFreqStateCheck_9:
   \   0000007E   0xEB0E 0x058E      ADD      R5,LR,LR, LSL #+2
   \   00000082   0xEA4F 0x0E45      LSL      LR,R5,#+1
   \   00000086   0xF108 0x0501      ADD      R5,R8,#+1
   \   0000008A   0xFA5F 0xF885      UXTB     R8,R5
   \   0000008E   0x4598             CMP      R8,R3
   \   00000090   0xDBF5             BLT.N    ??BcMFreqStateCheck_9
    761          			TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   \                     ??BcMFreqStateCheck_8:
   \   00000092   0xF812 0x5B01      LDRB     R5,[R2], #+1
   \   00000096   0x3D30             SUBS     R5,R5,#+48
   \   00000098   0xFB0E 0x6605      MLA      R6,LR,R5,R6
    762          		}
   \   0000009C   0xF10C 0x0C01      ADD      R12,R12,#+1
   \                     ??BcMFreqStateCheck_5:
   \   000000A0   0xFA5F 0xFC8C      UXTB     R12,R12
   \   000000A4   0x45BC             CMP      R12,R7
   \   000000A6   0xDBDE             BLT.N    ??BcMFreqStateCheck_6
    763          		
    764          		Actch = TempCopy;
    765          		BcMRfStatus->ActChannel = TempCopy;
   \   000000A8   0x6C43             LDR      R3,[R0, #+68]
   \   000000AA   0x801E             STRH     R6,[R3, #+0]
    766          
    767          //		USART1Printf("BcMRfStatus->ActChannel : %d \n", BcMRfStatus->ActChannel);
    768          
    769          		//=====================//
    770          		// Number Of Channel //
    771          		//========================================================================//
    772          		DataCnt2 = DataCnt;
   \   000000AC   0xB2E4             UXTB     R4,R4
   \   000000AE   0x4620             MOV      R0,R4
    773          		TempCopy = 0;
   \   000000B0   0x2600             MOVS     R6,#+0
    774          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   \   000000B2   0x2700             MOVS     R7,#+0
   \                     ??BcMFreqStateCheck_10:
   \   000000B4   0x1C62             ADDS     R2,R4,#+1
   \   000000B6   0xB2E4             UXTB     R4,R4
   \   000000B8   0x5C64             LDRB     R4,[R4, R1]
   \   000000BA   0x2C2C             CMP      R4,#+44
   \   000000BC   0x4614             MOV      R4,R2
   \   000000BE   0xD002             BEQ.N    ??BcMFreqStateCheck_11
   \   000000C0   0x1C7F             ADDS     R7,R7,#+1
   \   000000C2   0x2F0A             CMP      R7,#+10
   \   000000C4   0xDBF6             BLT.N    ??BcMFreqStateCheck_10
    775          		for ( j=0; j<i; j++ )
   \                     ??BcMFreqStateCheck_11:
   \   000000C6   0x46B4             MOV      R12,R6
   \   000000C8   0x2F01             CMP      R7,#+1
   \   000000CA   0xDB20             BLT.N    ??BcMFreqStateCheck_12
   \   000000CC   0x1E7A             SUBS     R2,R7,#+1
    776          		{
    777          			if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   \                     ??BcMFreqStateCheck_13:
   \   000000CE   0x5C45             LDRB     R5,[R0, R1]
   \   000000D0   0x3D30             SUBS     R5,R5,#+48
   \   000000D2   0x2D0A             CMP      R5,#+10
   \   000000D4   0xF080 0x8591      BCS.W    ??BcMFreqStateCheck_7
    778          			for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   \   000000D8   0xF04F 0x0E01      MOV      LR,#+1
   \   000000DC   0x46E0             MOV      R8,R12
   \   000000DE   0x4594             CMP      R12,R2
   \   000000E0   0xDA09             BGE.N    ??BcMFreqStateCheck_14
   \                     ??BcMFreqStateCheck_15:
   \   000000E2   0xEB0E 0x058E      ADD      R5,LR,LR, LSL #+2
   \   000000E6   0xEA4F 0x0E45      LSL      LR,R5,#+1
   \   000000EA   0xF108 0x0501      ADD      R5,R8,#+1
   \   000000EE   0xFA5F 0xF885      UXTB     R8,R5
   \   000000F2   0x4590             CMP      R8,R2
   \   000000F4   0xDBF5             BLT.N    ??BcMFreqStateCheck_15
    779          			TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   \                     ??BcMFreqStateCheck_14:
   \   000000F6   0x5C45             LDRB     R5,[R0, R1]
   \   000000F8   0x3D30             SUBS     R5,R5,#+48
   \   000000FA   0xFB0E 0x6605      MLA      R6,LR,R5,R6
   \   000000FE   0x1C40             ADDS     R0,R0,#+1
   \   00000100   0xB2C0             UXTB     R0,R0
    780          		}
   \   00000102   0xF10C 0x0501      ADD      R5,R12,#+1
   \   00000106   0xFA5F 0xFC85      UXTB     R12,R5
   \   0000010A   0x45BC             CMP      R12,R7
   \   0000010C   0xDBDF             BLT.N    ??BcMFreqStateCheck_13
    781          		
    782          		BcMRfStatus->NumberOfChannel = TempCopy;
   \                     ??BcMFreqStateCheck_12:
   \   0000010E   0x805E             STRH     R6,[R3, #+2]
    783          		
    784          		if ( TempCopy == 0 ) return(FALSE);
   \   00000110   0xB230             SXTH     R0,R6
   \   00000112   0x2800             CMP      R0,#+0
   \   00000114   0xF000 0x8571      BEQ.W    ??BcMFreqStateCheck_7
    785          		
    786          		//SWaveStatus->ChannelList = ( ((TempCopy/10)<<4) + (TempCopy%10) );
    787          		chlist = TempCopy;
   \   00000118   0xB232             SXTH     R2,R6
    788          
    789          //		USART1Printf("chlist : %d \n", chlist);
    790          		//==============//
    791          		// Channel List //
    792          		//========================================================================//
    793          		for ( k=0; k<chlist; k++ )
   \   0000011A   0x2500             MOVS     R5,#+0
   \   0000011C   0xE034             B.N      ??BcMFreqStateCheck_16
    794          		{
    795          			DataCnt2 = DataCnt;
    796          			TempCopy = 0;
    797          			for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   \                     ??BcMFreqStateCheck_17:
   \   0000011E   0x1C7F             ADDS     R7,R7,#+1
   \   00000120   0x2F0A             CMP      R7,#+10
   \   00000122   0xDB37             BLT.N    ??BcMFreqStateCheck_18
    798          			
    799          //			USART1Printf("0: PN_Vaule : [%d][%d][%d] \n", i,k,BcMRfStatus->PN_Vaule[k]);
    800          			if ( i > 6 ) return(FALSE);
   \                     ??BcMFreqStateCheck_19:
   \   00000124   0x2F07             CMP      R7,#+7
   \   00000126   0xF280 0x8568      BGE.W    ??BcMFreqStateCheck_7
    801          
    802          			for ( j=0; j<i; j++ )
   \   0000012A   0x46B4             MOV      R12,R6
   \   0000012C   0x2F01             CMP      R7,#+1
   \   0000012E   0xDB26             BLT.N    ??BcMFreqStateCheck_20
   \   00000130   0xF1A7 0x0901      SUB      R9,R7,#+1
    803          			{
    804          //				USART1Printf("1: PN_Vaule : [%d][%d] \n", k,BcMRfStatus->PN_Vaule[k]);
    805          
    806          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   \                     ??BcMFreqStateCheck_21:
   \   00000134   0xF810 0xE001      LDRB     LR,[R0, R1]
   \   00000138   0xF1AE 0x0E30      SUB      LR,LR,#+48
   \   0000013C   0xF1BE 0x0F0A      CMP      LR,#+10
   \   00000140   0xF080 0x855B      BCS.W    ??BcMFreqStateCheck_7
    807          				for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   \   00000144   0xF04F 0x0E01      MOV      LR,#+1
   \   00000148   0x46E0             MOV      R8,R12
   \   0000014A   0x45CC             CMP      R12,R9
   \   0000014C   0xDA09             BGE.N    ??BcMFreqStateCheck_22
   \                     ??BcMFreqStateCheck_23:
   \   0000014E   0xEB0E 0x0A8E      ADD      R10,LR,LR, LSL #+2
   \   00000152   0xEA4F 0x0E4A      LSL      LR,R10,#+1
   \   00000156   0xF108 0x0801      ADD      R8,R8,#+1
   \   0000015A   0xFA5F 0xF888      UXTB     R8,R8
   \   0000015E   0x45C8             CMP      R8,R9
   \   00000160   0xDBF5             BLT.N    ??BcMFreqStateCheck_23
    808          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   \                     ??BcMFreqStateCheck_22:
   \   00000162   0xF810 0x8001      LDRB     R8,[R0, R1]
   \   00000166   0xF1A8 0x0830      SUB      R8,R8,#+48
   \   0000016A   0xFB0E 0x6608      MLA      R6,LR,R8,R6
   \   0000016E   0x1C40             ADDS     R0,R0,#+1
   \   00000170   0xB2C0             UXTB     R0,R0
    809          			}
   \   00000172   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   00000176   0xFA5F 0xFC8C      UXTB     R12,R12
   \   0000017A   0x45BC             CMP      R12,R7
   \   0000017C   0xDBDA             BLT.N    ??BcMFreqStateCheck_21
    810          			
    811          			BcMRfStatus->PN_Vaule[k] = TempCopy;
   \                     ??BcMFreqStateCheck_20:
   \   0000017E   0xEB03 0x0045      ADD      R0,R3,R5, LSL #+1
   \   00000182   0x8246             STRH     R6,[R0, #+18]
    812          			if ( Actch == TempCopy ){}
   \   00000184   0x1C6D             ADDS     R5,R5,#+1
   \   00000186   0xB2ED             UXTB     R5,R5
   \                     ??BcMFreqStateCheck_16:
   \   00000188   0xB2E4             UXTB     R4,R4
   \   0000018A   0x4620             MOV      R0,R4
   \   0000018C   0x4295             CMP      R5,R2
   \   0000018E   0xDA09             BGE.N    ??BcMFreqStateCheck_24
   \   00000190   0x2600             MOVS     R6,#+0
   \   00000192   0x2700             MOVS     R7,#+0
   \                     ??BcMFreqStateCheck_18:
   \   00000194   0xF104 0x0C01      ADD      R12,R4,#+1
   \   00000198   0xB2E4             UXTB     R4,R4
   \   0000019A   0x5C64             LDRB     R4,[R4, R1]
   \   0000019C   0x2C2C             CMP      R4,#+44
   \   0000019E   0x4664             MOV      R4,R12
   \   000001A0   0xD1BD             BNE.N    ??BcMFreqStateCheck_17
   \   000001A2   0xE7BF             B.N      ??BcMFreqStateCheck_19
    813          
    814          //			USART1Printf("2: PN_Vaule : [%d][%d] \n", k,BcMRfStatus->PN_Vaule[k]);
    815          		}		
    816          
    817          		//================//
    818          		// Active PSC     //
    819          		//========================================================================//
    820          		DataCnt2 = DataCnt;
    821          		TempCopy = 0;
   \                     ??BcMFreqStateCheck_24:
   \   000001A4   0x2600             MOVS     R6,#+0
    822          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   \   000001A6   0x2700             MOVS     R7,#+0
   \                     ??BcMFreqStateCheck_25:
   \   000001A8   0x1C62             ADDS     R2,R4,#+1
   \   000001AA   0xB2E4             UXTB     R4,R4
   \   000001AC   0x5C64             LDRB     R4,[R4, R1]
   \   000001AE   0x2C2C             CMP      R4,#+44
   \   000001B0   0x4614             MOV      R4,R2
   \   000001B2   0xD002             BEQ.N    ??BcMFreqStateCheck_26
   \   000001B4   0x1C7F             ADDS     R7,R7,#+1
   \   000001B6   0x2F0A             CMP      R7,#+10
   \   000001B8   0xDBF6             BLT.N    ??BcMFreqStateCheck_25
    823          		for ( j=0; j<i; j++ )
   \                     ??BcMFreqStateCheck_26:
   \   000001BA   0x46B4             MOV      R12,R6
   \   000001BC   0x2F01             CMP      R7,#+1
   \   000001BE   0xDB20             BLT.N    ??BcMFreqStateCheck_27
   \   000001C0   0x1E7A             SUBS     R2,R7,#+1
    824          		{
    825          			if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   \                     ??BcMFreqStateCheck_28:
   \   000001C2   0x5C45             LDRB     R5,[R0, R1]
   \   000001C4   0x3D30             SUBS     R5,R5,#+48
   \   000001C6   0x2D0A             CMP      R5,#+10
   \   000001C8   0xF080 0x8517      BCS.W    ??BcMFreqStateCheck_7
    826          			for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   \   000001CC   0xF04F 0x0E01      MOV      LR,#+1
   \   000001D0   0x46E0             MOV      R8,R12
   \   000001D2   0x4594             CMP      R12,R2
   \   000001D4   0xDA09             BGE.N    ??BcMFreqStateCheck_29
   \                     ??BcMFreqStateCheck_30:
   \   000001D6   0xEB0E 0x058E      ADD      R5,LR,LR, LSL #+2
   \   000001DA   0xEA4F 0x0E45      LSL      LR,R5,#+1
   \   000001DE   0xF108 0x0501      ADD      R5,R8,#+1
   \   000001E2   0xFA5F 0xF885      UXTB     R8,R5
   \   000001E6   0x4590             CMP      R8,R2
   \   000001E8   0xDBF5             BLT.N    ??BcMFreqStateCheck_30
    827          			TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   \                     ??BcMFreqStateCheck_29:
   \   000001EA   0x5C45             LDRB     R5,[R0, R1]
   \   000001EC   0x3D30             SUBS     R5,R5,#+48
   \   000001EE   0xFB0E 0x6605      MLA      R6,LR,R5,R6
   \   000001F2   0x1C40             ADDS     R0,R0,#+1
   \   000001F4   0xB2C0             UXTB     R0,R0
    828          		}
   \   000001F6   0xF10C 0x0501      ADD      R5,R12,#+1
   \   000001FA   0xFA5F 0xFC85      UXTB     R12,R5
   \   000001FE   0x45BC             CMP      R12,R7
   \   00000200   0xDBDF             BLT.N    ??BcMFreqStateCheck_28
    829          		
    830          		BcMRfStatus->PSClist = TempCopy;
   \                     ??BcMFreqStateCheck_27:
   \   00000202   0x865E             STRH     R6,[R3, #+50]
    831          		
    832          		if ( TempCopy == 0 ) return(FALSE);
   \   00000204   0xB230             SXTH     R0,R6
   \   00000206   0x2800             CMP      R0,#+0
   \   00000208   0xF000 0x84F7      BEQ.W    ??BcMFreqStateCheck_7
    833          		
    834          		//SWaveStatus->ChannelList = ( ((TempCopy/10)<<4) + (TempCopy%10) );
    835          		PSClist = TempCopy;
   \   0000020C   0xB232             SXTH     R2,R6
    836          
    837          //		USART1Printf("PSClist : %d \n", PSClist);
    838          
    839          		//==============//
    840          		// PSC List //
    841          		//========================================================================//
    842          		for ( k=0; k<PSClist; k++ )
   \   0000020E   0x2500             MOVS     R5,#+0
   \   00000210   0xE02D             B.N      ??BcMFreqStateCheck_31
    843          		{
    844          			DataCnt2 = DataCnt;
    845          			TempCopy = 0;
    846          		
    847          			for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == '(' ) break;
    848          			
    849          			if ( i > 6 ) return(FALSE);
    850          			for ( j=0; j<i; j++ )
    851          			{
    852          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
    853          				for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
    854          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
    855          			}
    856          			
    857          			BcMRfStatus->PSC_Vaule[k] = TempCopy;
    858          //			USART1Printf("0: PSC_Vaule : [%d][%d] \n", k,BcMRfStatus->PSC_Vaule[k]);
    859          			DataCnt2 = DataCnt;
    860          			TempCopy = 0;
    861          			for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ')' ) break;
    862          			DataCnt++;		// Remove ','
    863          			
    864          			if ( DataBuff[DataCnt2] == '-' )
    865          			{
    866          				DataCnt2++;
    867          				for ( j=0; j<i-1; j++ )
    868          				{
    869          					if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
    870          					for ( Power=1,pw=j; pw<i-2; pw++ ) Power *= 10;
    871          					TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
    872          				}
    873          				TempCopy = -TempCopy;
    874          				BcMRfStatus->EcIo[k] = TempCopy;
    875          			}
    876          			else
    877          			{
    878          				for ( j=0; j<i; j++ )
   \                     ??BcMFreqStateCheck_32:
   \   00000212   0x46B4             MOV      R12,R6
   \   00000214   0x2F01             CMP      R7,#+1
   \   00000216   0xDB26             BLT.N    ??BcMFreqStateCheck_33
   \   00000218   0xF1A7 0x0A01      SUB      R10,R7,#+1
    879          				{
    880          					if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   \                     ??BcMFreqStateCheck_34:
   \   0000021C   0xF810 0xE001      LDRB     LR,[R0, R1]
   \   00000220   0xF1AE 0x0E30      SUB      LR,LR,#+48
   \   00000224   0xF1BE 0x0F0A      CMP      LR,#+10
   \   00000228   0xF080 0x84E7      BCS.W    ??BcMFreqStateCheck_7
    881          					for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   \   0000022C   0xF04F 0x0E01      MOV      LR,#+1
   \   00000230   0x46E0             MOV      R8,R12
   \   00000232   0x45D4             CMP      R12,R10
   \   00000234   0xDA09             BGE.N    ??BcMFreqStateCheck_35
   \                     ??BcMFreqStateCheck_36:
   \   00000236   0xEB0E 0x0B8E      ADD      R11,LR,LR, LSL #+2
   \   0000023A   0xEA4F 0x0E4B      LSL      LR,R11,#+1
   \   0000023E   0xF108 0x0801      ADD      R8,R8,#+1
   \   00000242   0xFA5F 0xF888      UXTB     R8,R8
   \   00000246   0x45D0             CMP      R8,R10
   \   00000248   0xDBF5             BLT.N    ??BcMFreqStateCheck_36
    882          					TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   \                     ??BcMFreqStateCheck_35:
   \   0000024A   0xF810 0x8001      LDRB     R8,[R0, R1]
   \   0000024E   0xF1A8 0x0830      SUB      R8,R8,#+48
   \   00000252   0xFB0E 0x6608      MLA      R6,LR,R8,R6
   \   00000256   0x1C40             ADDS     R0,R0,#+1
   \   00000258   0xB2C0             UXTB     R0,R0
    883          				}
   \   0000025A   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   0000025E   0xFA5F 0xFC8C      UXTB     R12,R12
   \   00000262   0x45BC             CMP      R12,R7
   \   00000264   0xDBDA             BLT.N    ??BcMFreqStateCheck_34
    884          				BcMRfStatus->EcIo[k] = TempCopy;
   \                     ??BcMFreqStateCheck_33:
   \   00000266   0xF8A9 0x601E      STRH     R6,[R9, #+30]
    885          			}
   \                     ??BcMFreqStateCheck_37:
   \   0000026A   0x1C6D             ADDS     R5,R5,#+1
   \   0000026C   0xB2ED             UXTB     R5,R5
   \                     ??BcMFreqStateCheck_31:
   \   0000026E   0xB2E4             UXTB     R4,R4
   \   00000270   0x4620             MOV      R0,R4
   \   00000272   0x4295             CMP      R5,R2
   \   00000274   0xF280 0x8084      BGE.W    ??BcMFreqStateCheck_38
   \   00000278   0x2600             MOVS     R6,#+0
   \   0000027A   0x2700             MOVS     R7,#+0
   \                     ??BcMFreqStateCheck_39:
   \   0000027C   0xF104 0x0C01      ADD      R12,R4,#+1
   \   00000280   0xB2E4             UXTB     R4,R4
   \   00000282   0x5C64             LDRB     R4,[R4, R1]
   \   00000284   0x2C28             CMP      R4,#+40
   \   00000286   0x4664             MOV      R4,R12
   \   00000288   0xD002             BEQ.N    ??BcMFreqStateCheck_40
   \   0000028A   0x1C7F             ADDS     R7,R7,#+1
   \   0000028C   0x2F0A             CMP      R7,#+10
   \   0000028E   0xDBF5             BLT.N    ??BcMFreqStateCheck_39
   \                     ??BcMFreqStateCheck_40:
   \   00000290   0x2F07             CMP      R7,#+7
   \   00000292   0xF280 0x84B2      BGE.W    ??BcMFreqStateCheck_7
   \   00000296   0x46B4             MOV      R12,R6
   \   00000298   0x2F01             CMP      R7,#+1
   \   0000029A   0xDB26             BLT.N    ??BcMFreqStateCheck_41
   \   0000029C   0xF1A7 0x0901      SUB      R9,R7,#+1
   \                     ??BcMFreqStateCheck_42:
   \   000002A0   0xF810 0xE001      LDRB     LR,[R0, R1]
   \   000002A4   0xF1AE 0x0E30      SUB      LR,LR,#+48
   \   000002A8   0xF1BE 0x0F0A      CMP      LR,#+10
   \   000002AC   0xF080 0x84A5      BCS.W    ??BcMFreqStateCheck_7
   \   000002B0   0xF04F 0x0E01      MOV      LR,#+1
   \   000002B4   0x46E0             MOV      R8,R12
   \   000002B6   0x45CC             CMP      R12,R9
   \   000002B8   0xDA09             BGE.N    ??BcMFreqStateCheck_43
   \                     ??BcMFreqStateCheck_44:
   \   000002BA   0xEB0E 0x0A8E      ADD      R10,LR,LR, LSL #+2
   \   000002BE   0xEA4F 0x0E4A      LSL      LR,R10,#+1
   \   000002C2   0xF108 0x0801      ADD      R8,R8,#+1
   \   000002C6   0xFA5F 0xF888      UXTB     R8,R8
   \   000002CA   0x45C8             CMP      R8,R9
   \   000002CC   0xDBF5             BLT.N    ??BcMFreqStateCheck_44
   \                     ??BcMFreqStateCheck_43:
   \   000002CE   0xF810 0x8001      LDRB     R8,[R0, R1]
   \   000002D2   0xF1A8 0x0830      SUB      R8,R8,#+48
   \   000002D6   0xFB0E 0x6608      MLA      R6,LR,R8,R6
   \   000002DA   0x1C40             ADDS     R0,R0,#+1
   \   000002DC   0xB2C0             UXTB     R0,R0
   \   000002DE   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   000002E2   0xFA5F 0xFC8C      UXTB     R12,R12
   \   000002E6   0x45BC             CMP      R12,R7
   \   000002E8   0xDBDA             BLT.N    ??BcMFreqStateCheck_42
   \                     ??BcMFreqStateCheck_41:
   \   000002EA   0xEB03 0x0945      ADD      R9,R3,R5, LSL #+1
   \   000002EE   0xF8A9 0x6034      STRH     R6,[R9, #+52]
   \   000002F2   0xB2E4             UXTB     R4,R4
   \   000002F4   0x4620             MOV      R0,R4
   \   000002F6   0x2600             MOVS     R6,#+0
   \   000002F8   0x2700             MOVS     R7,#+0
   \                     ??BcMFreqStateCheck_45:
   \   000002FA   0xF104 0x0C01      ADD      R12,R4,#+1
   \   000002FE   0xB2E4             UXTB     R4,R4
   \   00000300   0x5C64             LDRB     R4,[R4, R1]
   \   00000302   0x2C29             CMP      R4,#+41
   \   00000304   0x4664             MOV      R4,R12
   \   00000306   0xD002             BEQ.N    ??BcMFreqStateCheck_46
   \   00000308   0x1C7F             ADDS     R7,R7,#+1
   \   0000030A   0x2F0A             CMP      R7,#+10
   \   0000030C   0xDBF5             BLT.N    ??BcMFreqStateCheck_45
   \                     ??BcMFreqStateCheck_46:
   \   0000030E   0x1C64             ADDS     R4,R4,#+1
   \   00000310   0xF810 0xC001      LDRB     R12,[R0, R1]
   \   00000314   0xF1BC 0x0F2D      CMP      R12,#+45
   \   00000318   0xF47F 0xAF7B      BNE.W    ??BcMFreqStateCheck_32
   \   0000031C   0x1C40             ADDS     R0,R0,#+1
   \   0000031E   0xB2C0             UXTB     R0,R0
   \   00000320   0x46B4             MOV      R12,R6
   \   00000322   0xF1A7 0x0A01      SUB      R10,R7,#+1
   \   00000326   0xF1BA 0x0F01      CMP      R10,#+1
   \   0000032A   0xDB25             BLT.N    ??BcMFreqStateCheck_47
   \   0000032C   0x1EBF             SUBS     R7,R7,#+2
   \                     ??BcMFreqStateCheck_48:
   \   0000032E   0xF810 0xE001      LDRB     LR,[R0, R1]
   \   00000332   0xF1AE 0x0E30      SUB      LR,LR,#+48
   \   00000336   0xF1BE 0x0F0A      CMP      LR,#+10
   \   0000033A   0xF080 0x845E      BCS.W    ??BcMFreqStateCheck_7
   \   0000033E   0xF04F 0x0E01      MOV      LR,#+1
   \   00000342   0x46E0             MOV      R8,R12
   \   00000344   0x45BC             CMP      R12,R7
   \   00000346   0xDA09             BGE.N    ??BcMFreqStateCheck_49
   \                     ??BcMFreqStateCheck_50:
   \   00000348   0xEB0E 0x0B8E      ADD      R11,LR,LR, LSL #+2
   \   0000034C   0xEA4F 0x0E4B      LSL      LR,R11,#+1
   \   00000350   0xF108 0x0801      ADD      R8,R8,#+1
   \   00000354   0xFA5F 0xF888      UXTB     R8,R8
   \   00000358   0x45B8             CMP      R8,R7
   \   0000035A   0xDBF5             BLT.N    ??BcMFreqStateCheck_50
   \                     ??BcMFreqStateCheck_49:
   \   0000035C   0xF810 0x8001      LDRB     R8,[R0, R1]
   \   00000360   0xF1A8 0x0830      SUB      R8,R8,#+48
   \   00000364   0xFB0E 0x6608      MLA      R6,LR,R8,R6
   \   00000368   0x1C40             ADDS     R0,R0,#+1
   \   0000036A   0xB2C0             UXTB     R0,R0
   \   0000036C   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   00000370   0xFA5F 0xFC8C      UXTB     R12,R12
   \   00000374   0x45D4             CMP      R12,R10
   \   00000376   0xDBDA             BLT.N    ??BcMFreqStateCheck_48
   \                     ??BcMFreqStateCheck_47:
   \   00000378   0x4270             RSBS     R0,R6,#+0
   \   0000037A   0xF8A9 0x001E      STRH     R0,[R9, #+30]
   \   0000037E   0xE774             B.N      ??BcMFreqStateCheck_37
    886          //			USART1Printf("2: EcIo : [%d][%d][%d] \n", i,k,BcMRfStatus->EcIo[k]);
    887          		}
    888          
    889          //		FER_VAULE:
    890          		//===========//
    891          		// BER Value //
    892          		//========================================================================//
    893          		DataCnt2 = DataCnt;
    894          		TempCopy = 0;
   \                     ??BcMFreqStateCheck_38:
   \   00000380   0x2600             MOVS     R6,#+0
    895          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   \   00000382   0x2700             MOVS     R7,#+0
   \                     ??BcMFreqStateCheck_51:
   \   00000384   0x1C62             ADDS     R2,R4,#+1
   \   00000386   0xB2E4             UXTB     R4,R4
   \   00000388   0x5C64             LDRB     R4,[R4, R1]
   \   0000038A   0x2C2C             CMP      R4,#+44
   \   0000038C   0x4614             MOV      R4,R2
   \   0000038E   0xD002             BEQ.N    ??BcMFreqStateCheck_52
   \   00000390   0x1C7F             ADDS     R7,R7,#+1
   \   00000392   0x2F0A             CMP      R7,#+10
   \   00000394   0xDBF6             BLT.N    ??BcMFreqStateCheck_51
    896          		for ( j=0; j<i; j++ )
   \                     ??BcMFreqStateCheck_52:
   \   00000396   0x46B4             MOV      R12,R6
   \   00000398   0x2F01             CMP      R7,#+1
   \   0000039A   0xDB20             BLT.N    ??BcMFreqStateCheck_53
   \   0000039C   0x1E7A             SUBS     R2,R7,#+1
    897          		{
    898          			if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   \                     ??BcMFreqStateCheck_54:
   \   0000039E   0x5C45             LDRB     R5,[R0, R1]
   \   000003A0   0x3D30             SUBS     R5,R5,#+48
   \   000003A2   0x2D0A             CMP      R5,#+10
   \   000003A4   0xF080 0x8429      BCS.W    ??BcMFreqStateCheck_7
    899          			for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   \   000003A8   0xF04F 0x0E01      MOV      LR,#+1
   \   000003AC   0x46E0             MOV      R8,R12
   \   000003AE   0x4594             CMP      R12,R2
   \   000003B0   0xDA09             BGE.N    ??BcMFreqStateCheck_55
   \                     ??BcMFreqStateCheck_56:
   \   000003B2   0xEB0E 0x058E      ADD      R5,LR,LR, LSL #+2
   \   000003B6   0xEA4F 0x0E45      LSL      LR,R5,#+1
   \   000003BA   0xF108 0x0501      ADD      R5,R8,#+1
   \   000003BE   0xFA5F 0xF885      UXTB     R8,R5
   \   000003C2   0x4590             CMP      R8,R2
   \   000003C4   0xDBF5             BLT.N    ??BcMFreqStateCheck_56
    900          			TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   \                     ??BcMFreqStateCheck_55:
   \   000003C6   0x5C45             LDRB     R5,[R0, R1]
   \   000003C8   0x3D30             SUBS     R5,R5,#+48
   \   000003CA   0xFB0E 0x6605      MLA      R6,LR,R5,R6
   \   000003CE   0x1C40             ADDS     R0,R0,#+1
   \   000003D0   0xB2C0             UXTB     R0,R0
    901          		}
   \   000003D2   0xF10C 0x0501      ADD      R5,R12,#+1
   \   000003D6   0xFA5F 0xFC85      UXTB     R12,R5
   \   000003DA   0x45BC             CMP      R12,R7
   \   000003DC   0xDBDF             BLT.N    ??BcMFreqStateCheck_54
    902          		
    903          		BcMRfStatus->BER = TempCopy;
   \                     ??BcMFreqStateCheck_53:
   \   000003DE   0xF8A3 0x6040      STRH     R6,[R3, #+64]
    904          //		USART1Printf("2: BER : [%d] \n",BcMRfStatus->BER);
    905          		//==========//
    906          		// RX Value //
    907          		//========================================================================//
    908          		DataCnt2 = DataCnt;
   \   000003E2   0xB2E4             UXTB     R4,R4
   \   000003E4   0x4620             MOV      R0,R4
    909          		TempCopy = 0;
   \   000003E6   0x2600             MOVS     R6,#+0
    910          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   \   000003E8   0x2700             MOVS     R7,#+0
   \                     ??BcMFreqStateCheck_57:
   \   000003EA   0x1C62             ADDS     R2,R4,#+1
   \   000003EC   0xB2E4             UXTB     R4,R4
   \   000003EE   0x5C64             LDRB     R4,[R4, R1]
   \   000003F0   0x2C2C             CMP      R4,#+44
   \   000003F2   0x4614             MOV      R4,R2
   \   000003F4   0xD002             BEQ.N    ??BcMFreqStateCheck_58
   \   000003F6   0x1C7F             ADDS     R7,R7,#+1
   \   000003F8   0x2F0A             CMP      R7,#+10
   \   000003FA   0xDBF6             BLT.N    ??BcMFreqStateCheck_57
    911          		if ( DataBuff[DataCnt2] == '-' )
   \                     ??BcMFreqStateCheck_58:
   \   000003FC   0x5C42             LDRB     R2,[R0, R1]
   \   000003FE   0x2A2D             CMP      R2,#+45
   \   00000400   0xD128             BNE.N    ??BcMFreqStateCheck_59
    912          		{
    913          			DataCnt2++;
   \   00000402   0x1C40             ADDS     R0,R0,#+1
   \   00000404   0xB2C0             UXTB     R0,R0
    914          			for ( j=0; j<i-1; j++ )
   \   00000406   0x46B4             MOV      R12,R6
   \   00000408   0x1E7A             SUBS     R2,R7,#+1
   \   0000040A   0x2A01             CMP      R2,#+1
   \   0000040C   0xDB20             BLT.N    ??BcMFreqStateCheck_60
   \   0000040E   0x1EBD             SUBS     R5,R7,#+2
    915          			{
    916          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   \                     ??BcMFreqStateCheck_61:
   \   00000410   0x5C47             LDRB     R7,[R0, R1]
   \   00000412   0x3F30             SUBS     R7,R7,#+48
   \   00000414   0x2F0A             CMP      R7,#+10
   \   00000416   0xF080 0x83F0      BCS.W    ??BcMFreqStateCheck_7
    917          				for ( Power=1,pw=j; pw<i-2; pw++ ) Power *= 10;
   \   0000041A   0xF04F 0x0E01      MOV      LR,#+1
   \   0000041E   0x46E0             MOV      R8,R12
   \   00000420   0x45AC             CMP      R12,R5
   \   00000422   0xDA09             BGE.N    ??BcMFreqStateCheck_62
   \                     ??BcMFreqStateCheck_63:
   \   00000424   0xEB0E 0x078E      ADD      R7,LR,LR, LSL #+2
   \   00000428   0xEA4F 0x0E47      LSL      LR,R7,#+1
   \   0000042C   0xF108 0x0701      ADD      R7,R8,#+1
   \   00000430   0xFA5F 0xF887      UXTB     R8,R7
   \   00000434   0x45A8             CMP      R8,R5
   \   00000436   0xDBF5             BLT.N    ??BcMFreqStateCheck_63
    918          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   \                     ??BcMFreqStateCheck_62:
   \   00000438   0x5C47             LDRB     R7,[R0, R1]
   \   0000043A   0x3F30             SUBS     R7,R7,#+48
   \   0000043C   0xFB0E 0x6607      MLA      R6,LR,R7,R6
   \   00000440   0x1C40             ADDS     R0,R0,#+1
   \   00000442   0xB2C0             UXTB     R0,R0
    919          			}
   \   00000444   0xF10C 0x0701      ADD      R7,R12,#+1
   \   00000448   0xFA5F 0xFC87      UXTB     R12,R7
   \   0000044C   0x4594             CMP      R12,R2
   \   0000044E   0xDBDF             BLT.N    ??BcMFreqStateCheck_61
    920          			TempCopy = -TempCopy;
   \                     ??BcMFreqStateCheck_60:
   \   00000450   0x4276             RSBS     R6,R6,#+0
    921          			BcMRfStatus->RxValue = TempCopy;
   \   00000452   0xE023             B.N      ??BcMFreqStateCheck_64
    922          		}
    923          		else
    924          		{
    925          			for ( j=0; j<i; j++ )
   \                     ??BcMFreqStateCheck_59:
   \   00000454   0x46B4             MOV      R12,R6
   \   00000456   0x2F01             CMP      R7,#+1
   \   00000458   0xDB20             BLT.N    ??BcMFreqStateCheck_64
   \   0000045A   0x1E7A             SUBS     R2,R7,#+1
    926          			{
    927          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   \                     ??BcMFreqStateCheck_65:
   \   0000045C   0x5C45             LDRB     R5,[R0, R1]
   \   0000045E   0x3D30             SUBS     R5,R5,#+48
   \   00000460   0x2D0A             CMP      R5,#+10
   \   00000462   0xF080 0x83CA      BCS.W    ??BcMFreqStateCheck_7
    928          				for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   \   00000466   0xF04F 0x0E01      MOV      LR,#+1
   \   0000046A   0x46E0             MOV      R8,R12
   \   0000046C   0x4594             CMP      R12,R2
   \   0000046E   0xDA09             BGE.N    ??BcMFreqStateCheck_66
   \                     ??BcMFreqStateCheck_67:
   \   00000470   0xEB0E 0x058E      ADD      R5,LR,LR, LSL #+2
   \   00000474   0xEA4F 0x0E45      LSL      LR,R5,#+1
   \   00000478   0xF108 0x0501      ADD      R5,R8,#+1
   \   0000047C   0xFA5F 0xF885      UXTB     R8,R5
   \   00000480   0x4590             CMP      R8,R2
   \   00000482   0xDBF5             BLT.N    ??BcMFreqStateCheck_67
    929          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   \                     ??BcMFreqStateCheck_66:
   \   00000484   0x5C45             LDRB     R5,[R0, R1]
   \   00000486   0x3D30             SUBS     R5,R5,#+48
   \   00000488   0xFB0E 0x6605      MLA      R6,LR,R5,R6
   \   0000048C   0x1C40             ADDS     R0,R0,#+1
   \   0000048E   0xB2C0             UXTB     R0,R0
    930          			}
   \   00000490   0xF10C 0x0501      ADD      R5,R12,#+1
   \   00000494   0xFA5F 0xFC85      UXTB     R12,R5
   \   00000498   0x45BC             CMP      R12,R7
   \   0000049A   0xDBDF             BLT.N    ??BcMFreqStateCheck_65
    931          			BcMRfStatus->RxValue = TempCopy;
   \                     ??BcMFreqStateCheck_64:
   \   0000049C   0x859E             STRH     R6,[R3, #+44]
    932          		}
    933          //		USART1Printf("2: RxValue : [%d] \n",BcMRfStatus->RxValue);
    934          
    935          		//========================================================================//
    936          		if ( TempCopy > 0 ) return(FALSE);
   \   0000049E   0xB236             SXTH     R6,R6
   \   000004A0   0x2E01             CMP      R6,#+1
   \   000004A2   0xF280 0x83AA      BGE.W    ??BcMFreqStateCheck_7
    937          
    938          		//==========//
    939          		// TX Value //
    940          		//========================================================================//
    941          		DataCnt2 = DataCnt;
   \   000004A6   0xB2E4             UXTB     R4,R4
   \   000004A8   0x4620             MOV      R0,R4
    942          		TempCopy = 0;
   \   000004AA   0x2600             MOVS     R6,#+0
    943          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   \   000004AC   0x2700             MOVS     R7,#+0
   \                     ??BcMFreqStateCheck_68:
   \   000004AE   0x1C62             ADDS     R2,R4,#+1
   \   000004B0   0xB2E4             UXTB     R4,R4
   \   000004B2   0x5C64             LDRB     R4,[R4, R1]
   \   000004B4   0x2C2C             CMP      R4,#+44
   \   000004B6   0x4614             MOV      R4,R2
   \   000004B8   0xD002             BEQ.N    ??BcMFreqStateCheck_69
   \   000004BA   0x1C7F             ADDS     R7,R7,#+1
   \   000004BC   0x2F0A             CMP      R7,#+10
   \   000004BE   0xDBF6             BLT.N    ??BcMFreqStateCheck_68
    944          		if ( DataBuff[DataCnt2] == '-' )
   \                     ??BcMFreqStateCheck_69:
   \   000004C0   0x5C42             LDRB     R2,[R0, R1]
   \   000004C2   0x2A2D             CMP      R2,#+45
   \   000004C4   0xD129             BNE.N    ??BcMFreqStateCheck_70
    945          		{
    946          			DataCnt2++;
   \   000004C6   0x1C40             ADDS     R0,R0,#+1
   \   000004C8   0xB2C0             UXTB     R0,R0
    947          			for ( j=0; j<i-1; j++ )
   \   000004CA   0x46B4             MOV      R12,R6
   \   000004CC   0x1E7A             SUBS     R2,R7,#+1
   \   000004CE   0x2A01             CMP      R2,#+1
   \   000004D0   0xDB20             BLT.N    ??BcMFreqStateCheck_71
   \   000004D2   0x1EBD             SUBS     R5,R7,#+2
    948          			{
    949          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   \                     ??BcMFreqStateCheck_72:
   \   000004D4   0x5C47             LDRB     R7,[R0, R1]
   \   000004D6   0x3F30             SUBS     R7,R7,#+48
   \   000004D8   0x2F0A             CMP      R7,#+10
   \   000004DA   0xF080 0x838E      BCS.W    ??BcMFreqStateCheck_7
    950          				for ( Power=1,pw=j; pw<i-2; pw++ ) Power *= 10;
   \   000004DE   0xF04F 0x0E01      MOV      LR,#+1
   \   000004E2   0x46E0             MOV      R8,R12
   \   000004E4   0x45AC             CMP      R12,R5
   \   000004E6   0xDA09             BGE.N    ??BcMFreqStateCheck_73
   \                     ??BcMFreqStateCheck_74:
   \   000004E8   0xEB0E 0x078E      ADD      R7,LR,LR, LSL #+2
   \   000004EC   0xEA4F 0x0E47      LSL      LR,R7,#+1
   \   000004F0   0xF108 0x0701      ADD      R7,R8,#+1
   \   000004F4   0xFA5F 0xF887      UXTB     R8,R7
   \   000004F8   0x45A8             CMP      R8,R5
   \   000004FA   0xDBF5             BLT.N    ??BcMFreqStateCheck_74
    951          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   \                     ??BcMFreqStateCheck_73:
   \   000004FC   0x5C47             LDRB     R7,[R0, R1]
   \   000004FE   0x3F30             SUBS     R7,R7,#+48
   \   00000500   0xFB0E 0x6607      MLA      R6,LR,R7,R6
   \   00000504   0x1C40             ADDS     R0,R0,#+1
   \   00000506   0xB2C0             UXTB     R0,R0
    952          			}
   \   00000508   0xF10C 0x0701      ADD      R7,R12,#+1
   \   0000050C   0xFA5F 0xFC87      UXTB     R12,R7
   \   00000510   0x4594             CMP      R12,R2
   \   00000512   0xDBDF             BLT.N    ??BcMFreqStateCheck_72
    953          			TempCopy = -TempCopy;
    954          			BcMRfStatus->TxValue = TempCopy;
   \                     ??BcMFreqStateCheck_71:
   \   00000514   0x4270             RSBS     R0,R6,#+0
   \   00000516   0x85D8             STRH     R0,[R3, #+46]
   \   00000518   0xE024             B.N      ??BcMFreqStateCheck_75
    955          		}
    956          		else
    957          		{
    958          			for ( j=0; j<i; j++ )
   \                     ??BcMFreqStateCheck_70:
   \   0000051A   0x46B4             MOV      R12,R6
   \   0000051C   0x2F01             CMP      R7,#+1
   \   0000051E   0xDB20             BLT.N    ??BcMFreqStateCheck_76
   \   00000520   0x1E7A             SUBS     R2,R7,#+1
    959          			{
    960          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   \                     ??BcMFreqStateCheck_77:
   \   00000522   0x5C45             LDRB     R5,[R0, R1]
   \   00000524   0x3D30             SUBS     R5,R5,#+48
   \   00000526   0x2D0A             CMP      R5,#+10
   \   00000528   0xF080 0x8367      BCS.W    ??BcMFreqStateCheck_7
    961          				for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   \   0000052C   0xF04F 0x0E01      MOV      LR,#+1
   \   00000530   0x46E0             MOV      R8,R12
   \   00000532   0x4594             CMP      R12,R2
   \   00000534   0xDA09             BGE.N    ??BcMFreqStateCheck_78
   \                     ??BcMFreqStateCheck_79:
   \   00000536   0xEB0E 0x058E      ADD      R5,LR,LR, LSL #+2
   \   0000053A   0xEA4F 0x0E45      LSL      LR,R5,#+1
   \   0000053E   0xF108 0x0501      ADD      R5,R8,#+1
   \   00000542   0xFA5F 0xF885      UXTB     R8,R5
   \   00000546   0x4590             CMP      R8,R2
   \   00000548   0xDBF5             BLT.N    ??BcMFreqStateCheck_79
    962          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   \                     ??BcMFreqStateCheck_78:
   \   0000054A   0x5C45             LDRB     R5,[R0, R1]
   \   0000054C   0x3D30             SUBS     R5,R5,#+48
   \   0000054E   0xFB0E 0x6605      MLA      R6,LR,R5,R6
   \   00000552   0x1C40             ADDS     R0,R0,#+1
   \   00000554   0xB2C0             UXTB     R0,R0
    963          			}
   \   00000556   0xF10C 0x0501      ADD      R5,R12,#+1
   \   0000055A   0xFA5F 0xFC85      UXTB     R12,R5
   \   0000055E   0x45BC             CMP      R12,R7
   \   00000560   0xDBDF             BLT.N    ??BcMFreqStateCheck_77
    964          			BcMRfStatus->TxValue = TempCopy;
   \                     ??BcMFreqStateCheck_76:
   \   00000562   0x85DE             STRH     R6,[R3, #+46]
    965          		}
    966          
    967          //		USART1Printf("2: TxValue : [%d] \n",BcMRfStatus->TxValue);
    968           	
    969          		//===========//
    970          		// ADJ Value //
    971          		//========================================================================//
    972          		DataCnt2 = DataCnt;
   \                     ??BcMFreqStateCheck_75:
   \   00000564   0xB2E4             UXTB     R4,R4
   \   00000566   0x4620             MOV      R0,R4
    973          		TempCopy = 0;
   \   00000568   0x2600             MOVS     R6,#+0
    974          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == 0x0d ) break;
   \   0000056A   0x2700             MOVS     R7,#+0
   \                     ??BcMFreqStateCheck_80:
   \   0000056C   0xB2E4             UXTB     R4,R4
   \   0000056E   0x5C62             LDRB     R2,[R4, R1]
   \   00000570   0x2A0D             CMP      R2,#+13
   \   00000572   0xD003             BEQ.N    ??BcMFreqStateCheck_81
   \   00000574   0x1C64             ADDS     R4,R4,#+1
   \   00000576   0x1C7F             ADDS     R7,R7,#+1
   \   00000578   0x2F0A             CMP      R7,#+10
   \   0000057A   0xDBF7             BLT.N    ??BcMFreqStateCheck_80
    975          		if ( DataBuff[DataCnt2] == '-' )
   \                     ??BcMFreqStateCheck_81:
   \   0000057C   0x5C42             LDRB     R2,[R0, R1]
   \   0000057E   0x2A2D             CMP      R2,#+45
   \   00000580   0xD129             BNE.N    ??BcMFreqStateCheck_82
    976          		{
    977          			DataCnt2++;
   \   00000582   0x1C40             ADDS     R0,R0,#+1
   \   00000584   0xB2C0             UXTB     R0,R0
    978          			for ( j=0; j<i-1; j++ )
   \   00000586   0x46B4             MOV      R12,R6
   \   00000588   0x1E7A             SUBS     R2,R7,#+1
   \   0000058A   0x2A01             CMP      R2,#+1
   \   0000058C   0xDB20             BLT.N    ??BcMFreqStateCheck_83
   \   0000058E   0x1EBC             SUBS     R4,R7,#+2
    979          			{
    980          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   \                     ??BcMFreqStateCheck_84:
   \   00000590   0x5C45             LDRB     R5,[R0, R1]
   \   00000592   0x3D30             SUBS     R5,R5,#+48
   \   00000594   0x2D0A             CMP      R5,#+10
   \   00000596   0xF080 0x8330      BCS.W    ??BcMFreqStateCheck_7
    981          				for ( Power=1,pw=j; pw<i-2; pw++ ) Power *= 10;
   \   0000059A   0xF04F 0x0E01      MOV      LR,#+1
   \   0000059E   0x46E0             MOV      R8,R12
   \   000005A0   0x45A4             CMP      R12,R4
   \   000005A2   0xDA09             BGE.N    ??BcMFreqStateCheck_85
   \                     ??BcMFreqStateCheck_86:
   \   000005A4   0xEB0E 0x058E      ADD      R5,LR,LR, LSL #+2
   \   000005A8   0xEA4F 0x0E45      LSL      LR,R5,#+1
   \   000005AC   0xF108 0x0501      ADD      R5,R8,#+1
   \   000005B0   0xFA5F 0xF885      UXTB     R8,R5
   \   000005B4   0x45A0             CMP      R8,R4
   \   000005B6   0xDBF5             BLT.N    ??BcMFreqStateCheck_86
    982          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   \                     ??BcMFreqStateCheck_85:
   \   000005B8   0x5C45             LDRB     R5,[R0, R1]
   \   000005BA   0x3D30             SUBS     R5,R5,#+48
   \   000005BC   0xFB0E 0x6605      MLA      R6,LR,R5,R6
   \   000005C0   0x1C40             ADDS     R0,R0,#+1
   \   000005C2   0xB2C0             UXTB     R0,R0
    983          			}
   \   000005C4   0xF10C 0x0501      ADD      R5,R12,#+1
   \   000005C8   0xFA5F 0xFC85      UXTB     R12,R5
   \   000005CC   0x4594             CMP      R12,R2
   \   000005CE   0xDBDF             BLT.N    ??BcMFreqStateCheck_84
    984          			TempCopy = -TempCopy;
    985          			BcMRfStatus->AdjValue = TempCopy;
   \                     ??BcMFreqStateCheck_83:
   \   000005D0   0x4270             RSBS     R0,R6,#+0
   \   000005D2   0x8618             STRH     R0,[R3, #+48]
   \   000005D4   0xE32E             B.N      ??BcMFreqStateCheck_87
    986          			
    987          		}
    988          		else
    989          		{
    990          			for ( j=0; j<i; j++ )
   \                     ??BcMFreqStateCheck_82:
   \   000005D6   0x46B4             MOV      R12,R6
   \   000005D8   0x2F01             CMP      R7,#+1
   \   000005DA   0xDB20             BLT.N    ??BcMFreqStateCheck_88
   \   000005DC   0x1E7A             SUBS     R2,R7,#+1
    991          			{
    992          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   \                     ??BcMFreqStateCheck_89:
   \   000005DE   0x5C44             LDRB     R4,[R0, R1]
   \   000005E0   0x3C30             SUBS     R4,R4,#+48
   \   000005E2   0x2C0A             CMP      R4,#+10
   \   000005E4   0xF080 0x8309      BCS.W    ??BcMFreqStateCheck_7
    993          				for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   \   000005E8   0xF04F 0x0E01      MOV      LR,#+1
   \   000005EC   0x46E0             MOV      R8,R12
   \   000005EE   0x4594             CMP      R12,R2
   \   000005F0   0xDA09             BGE.N    ??BcMFreqStateCheck_90
   \                     ??BcMFreqStateCheck_91:
   \   000005F2   0xEB0E 0x048E      ADD      R4,LR,LR, LSL #+2
   \   000005F6   0xEA4F 0x0E44      LSL      LR,R4,#+1
   \   000005FA   0xF108 0x0401      ADD      R4,R8,#+1
   \   000005FE   0xFA5F 0xF884      UXTB     R8,R4
   \   00000602   0x4590             CMP      R8,R2
   \   00000604   0xDBF5             BLT.N    ??BcMFreqStateCheck_91
    994          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   \                     ??BcMFreqStateCheck_90:
   \   00000606   0x5C44             LDRB     R4,[R0, R1]
   \   00000608   0x3C30             SUBS     R4,R4,#+48
   \   0000060A   0xFB0E 0x6604      MLA      R6,LR,R4,R6
   \   0000060E   0x1C40             ADDS     R0,R0,#+1
   \   00000610   0xB2C0             UXTB     R0,R0
    995          			}
   \   00000612   0xF10C 0x0401      ADD      R4,R12,#+1
   \   00000616   0xFA5F 0xFC84      UXTB     R12,R4
   \   0000061A   0x45BC             CMP      R12,R7
   \   0000061C   0xDBDF             BLT.N    ??BcMFreqStateCheck_89
    996          			BcMRfStatus->AdjValue = TempCopy;
   \                     ??BcMFreqStateCheck_88:
   \   0000061E   0x861E             STRH     R6,[R3, #+48]
   \   00000620   0xE308             B.N      ??BcMFreqStateCheck_87
    997          		}
    998          //		USART1Printf("2: AdjValue : [%d] \n",BcMRfStatus->AdjValue);
    999           	}
   1000          	else
   1001          	{
   1002          		INT8U	i, j, k, DataCnt=0, DataCnt2=0, pw;
   \                     ??BcMFreqStateCheck_0:
   \   00000622   0x2200             MOVS     R2,#+0
   1003          		INT16S		TempCopy, Power, Actch, chlist;
   1004          		//================//
   1005          		// Active Channel //
   1006          		//========================================================================//
   1007          		DataCnt2 = DataCnt;
   1008          		TempCopy = 0;
   \   00000624   0x2400             MOVS     R4,#+0
   1009          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   \   00000626   0x4615             MOV      R5,R2
   \   00000628   0x460B             MOV      R3,R1
   \                     ??BcMFreqStateCheck_92:
   \   0000062A   0xF813 0x6B01      LDRB     R6,[R3], #+1
   \   0000062E   0x2E2C             CMP      R6,#+44
   \   00000630   0xD101             BNE.N    ??BcMFreqStateCheck_93
   \                     ??BcMFreqStateCheck_94:
   \   00000632   0x1C52             ADDS     R2,R2,#+1
   \   00000634   0xE01B             B.N      ??BcMFreqStateCheck_95
   \                     ??BcMFreqStateCheck_93:
   \   00000636   0x1C52             ADDS     R2,R2,#+1
   \   00000638   0x1C6D             ADDS     R5,R5,#+1
   \   0000063A   0xF813 0x6B01      LDRB     R6,[R3], #+1
   \   0000063E   0x2E2C             CMP      R6,#+44
   \   00000640   0xBF1F             ITTTT    NE 
   \   00000642   0x1C52             ADDNE    R2,R2,#+1
   \   00000644   0x1C6D             ADDNE    R5,R5,#+1
   \   00000646   0xF813 0x6B01      LDRBNE   R6,[R3], #+1
   \   0000064A   0x2E2C             CMPNE    R6,#+44
   \   0000064C   0xBF1F             ITTTT    NE 
   \   0000064E   0x1C52             ADDNE    R2,R2,#+1
   \   00000650   0x1C6D             ADDNE    R5,R5,#+1
   \   00000652   0xF813 0x6B01      LDRBNE   R6,[R3], #+1
   \   00000656   0x2E2C             CMPNE    R6,#+44
   \   00000658   0xBF1F             ITTTT    NE 
   \   0000065A   0x1C52             ADDNE    R2,R2,#+1
   \   0000065C   0x1C6D             ADDNE    R5,R5,#+1
   \   0000065E   0xF813 0x6B01      LDRBNE   R6,[R3], #+1
   \   00000662   0x2E2C             CMPNE    R6,#+44
   \   00000664   0xD0E5             BEQ.N    ??BcMFreqStateCheck_94
   \   00000666   0x1C52             ADDS     R2,R2,#+1
   \   00000668   0x1C6D             ADDS     R5,R5,#+1
   \   0000066A   0x2D0A             CMP      R5,#+10
   \   0000066C   0xDBDD             BLT.N    ??BcMFreqStateCheck_92
   1010          		for ( j=0; j<i; j++ )
   \                     ??BcMFreqStateCheck_95:
   \   0000066E   0x2600             MOVS     R6,#+0
   \   00000670   0x460B             MOV      R3,R1
   \   00000672   0xF1A5 0x0E01      SUB      LR,R5,#+1
   \   00000676   0xE019             B.N      ??BcMFreqStateCheck_96
   1011          		{
   1012          			if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   \                     ??BcMFreqStateCheck_97:
   \   00000678   0x781F             LDRB     R7,[R3, #+0]
   \   0000067A   0x3F30             SUBS     R7,R7,#+48
   \   0000067C   0x2F0A             CMP      R7,#+10
   \   0000067E   0xF080 0x82BC      BCS.W    ??BcMFreqStateCheck_7
   1013          			for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   \   00000682   0x2701             MOVS     R7,#+1
   \   00000684   0x46B4             MOV      R12,R6
   \   00000686   0x4576             CMP      R6,LR
   \   00000688   0xDA09             BGE.N    ??BcMFreqStateCheck_98
   \                     ??BcMFreqStateCheck_99:
   \   0000068A   0xEB07 0x0887      ADD      R8,R7,R7, LSL #+2
   \   0000068E   0xEA4F 0x0748      LSL      R7,R8,#+1
   \   00000692   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   00000696   0xFA5F 0xFC8C      UXTB     R12,R12
   \   0000069A   0x45F4             CMP      R12,LR
   \   0000069C   0xDBF5             BLT.N    ??BcMFreqStateCheck_99
   1014          			TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   \                     ??BcMFreqStateCheck_98:
   \   0000069E   0xF813 0xCB01      LDRB     R12,[R3], #+1
   \   000006A2   0xF1AC 0x0C30      SUB      R12,R12,#+48
   \   000006A6   0xFB07 0x440C      MLA      R4,R7,R12,R4
   1015          		}
   \   000006AA   0x1C76             ADDS     R6,R6,#+1
   \                     ??BcMFreqStateCheck_96:
   \   000006AC   0xB2F6             UXTB     R6,R6
   \   000006AE   0x42AE             CMP      R6,R5
   \   000006B0   0xDBE2             BLT.N    ??BcMFreqStateCheck_97
   1016          		Actch = TempCopy;
   1017          		BcMRfStatus->ActChannel = TempCopy;
   \   000006B2   0x6C43             LDR      R3,[R0, #+68]
   \   000006B4   0x801C             STRH     R4,[R3, #+0]
   1018          
   1019          		//SWaveStatus->OneFAStatus = 0x03;		// Current FA
   1020          		//========================================================================//
   1021          
   1022          		//=====================//
   1023          		// Number Of Channel //
   1024          		//========================================================================//
   1025          		DataCnt2 = DataCnt;
   \   000006B6   0xB2D2             UXTB     R2,R2
   \   000006B8   0x4610             MOV      R0,R2
   1026          		TempCopy = 0;
   \   000006BA   0x2400             MOVS     R4,#+0
   1027          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   \   000006BC   0x2500             MOVS     R5,#+0
   \                     ??BcMFreqStateCheck_100:
   \   000006BE   0x1C56             ADDS     R6,R2,#+1
   \   000006C0   0xB2D2             UXTB     R2,R2
   \   000006C2   0x5C52             LDRB     R2,[R2, R1]
   \   000006C4   0x2A2C             CMP      R2,#+44
   \   000006C6   0x4632             MOV      R2,R6
   \   000006C8   0xD002             BEQ.N    ??BcMFreqStateCheck_101
   \   000006CA   0x1C6D             ADDS     R5,R5,#+1
   \   000006CC   0x2D0A             CMP      R5,#+10
   \   000006CE   0xDBF6             BLT.N    ??BcMFreqStateCheck_100
   1028          		for ( j=0; j<i; j++ )
   \                     ??BcMFreqStateCheck_101:
   \   000006D0   0x2600             MOVS     R6,#+0
   \   000006D2   0x2D01             CMP      R5,#+1
   \   000006D4   0xDB20             BLT.N    ??BcMFreqStateCheck_102
   \   000006D6   0xF1A5 0x0E01      SUB      LR,R5,#+1
   1029          		{
   1030          			if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   \                     ??BcMFreqStateCheck_103:
   \   000006DA   0x5C47             LDRB     R7,[R0, R1]
   \   000006DC   0x3F30             SUBS     R7,R7,#+48
   \   000006DE   0x2F0A             CMP      R7,#+10
   \   000006E0   0xF080 0x828B      BCS.W    ??BcMFreqStateCheck_7
   1031          			for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   \   000006E4   0x2701             MOVS     R7,#+1
   \   000006E6   0x46B4             MOV      R12,R6
   \   000006E8   0x4576             CMP      R6,LR
   \   000006EA   0xDA09             BGE.N    ??BcMFreqStateCheck_104
   \                     ??BcMFreqStateCheck_105:
   \   000006EC   0xEB07 0x0887      ADD      R8,R7,R7, LSL #+2
   \   000006F0   0xEA4F 0x0748      LSL      R7,R8,#+1
   \   000006F4   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   000006F8   0xFA5F 0xFC8C      UXTB     R12,R12
   \   000006FC   0x45F4             CMP      R12,LR
   \   000006FE   0xDBF5             BLT.N    ??BcMFreqStateCheck_105
   1032          			TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   \                     ??BcMFreqStateCheck_104:
   \   00000700   0xF810 0xC001      LDRB     R12,[R0, R1]
   \   00000704   0xF1AC 0x0C30      SUB      R12,R12,#+48
   \   00000708   0xFB07 0x440C      MLA      R4,R7,R12,R4
   \   0000070C   0x1C40             ADDS     R0,R0,#+1
   \   0000070E   0xB2C0             UXTB     R0,R0
   1033          		}
   \   00000710   0x1C76             ADDS     R6,R6,#+1
   \   00000712   0xB2F6             UXTB     R6,R6
   \   00000714   0x42AE             CMP      R6,R5
   \   00000716   0xDBE0             BLT.N    ??BcMFreqStateCheck_103
   1034          
   1035          		BcMRfStatus->NumberOfChannel = TempCopy;
   \                     ??BcMFreqStateCheck_102:
   \   00000718   0x805C             STRH     R4,[R3, #+2]
   1036          
   1037          		if ( TempCopy == 0 ) return(FALSE);
   \   0000071A   0xB220             SXTH     R0,R4
   \   0000071C   0x2800             CMP      R0,#+0
   \   0000071E   0xF000 0x826C      BEQ.W    ??BcMFreqStateCheck_7
   1038          
   1039          		//SWaveStatus->ChannelList = ( ((TempCopy/10)<<4) + (TempCopy%10) );
   1040          		chlist = TempCopy;
   \   00000722   0xFA0F 0xFE84      SXTH     LR,R4
   1041          
   1042          		//==============//
   1043          		// Channel List //
   1044          		//========================================================================//
   1045          		for ( k=0; k<chlist; k++ )
   \   00000726   0xF04F 0x0800      MOV      R8,#+0
   \   0000072A   0xE030             B.N      ??BcMFreqStateCheck_106
   1046          		{
   1047          			DataCnt2 = DataCnt;
   1048          			TempCopy = 0;
   1049          			for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   \                     ??BcMFreqStateCheck_107:
   \   0000072C   0x1C6D             ADDS     R5,R5,#+1
   \   0000072E   0x2D0A             CMP      R5,#+10
   \   00000730   0xDB33             BLT.N    ??BcMFreqStateCheck_108
   1050          			if ( i > 4 ) return(FALSE);
   \                     ??BcMFreqStateCheck_109:
   \   00000732   0x2D05             CMP      R5,#+5
   \   00000734   0xF280 0x8261      BGE.W    ??BcMFreqStateCheck_7
   1051          			for ( j=0; j<i; j++ )
   \   00000738   0x2600             MOVS     R6,#+0
   \   0000073A   0x2D01             CMP      R5,#+1
   \   0000073C   0xDB20             BLT.N    ??BcMFreqStateCheck_110
   \   0000073E   0xF1A5 0x0901      SUB      R9,R5,#+1
   1052          			{
   1053          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   \                     ??BcMFreqStateCheck_111:
   \   00000742   0x5C47             LDRB     R7,[R0, R1]
   \   00000744   0x3F30             SUBS     R7,R7,#+48
   \   00000746   0x2F0A             CMP      R7,#+10
   \   00000748   0xF080 0x8257      BCS.W    ??BcMFreqStateCheck_7
   1054          				for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   \   0000074C   0x2701             MOVS     R7,#+1
   \   0000074E   0x46B4             MOV      R12,R6
   \   00000750   0x454E             CMP      R6,R9
   \   00000752   0xDA09             BGE.N    ??BcMFreqStateCheck_112
   \                     ??BcMFreqStateCheck_113:
   \   00000754   0xEB07 0x0A87      ADD      R10,R7,R7, LSL #+2
   \   00000758   0xEA4F 0x074A      LSL      R7,R10,#+1
   \   0000075C   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   00000760   0xFA5F 0xFC8C      UXTB     R12,R12
   \   00000764   0x45CC             CMP      R12,R9
   \   00000766   0xDBF5             BLT.N    ??BcMFreqStateCheck_113
   1055          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   \                     ??BcMFreqStateCheck_112:
   \   00000768   0xF810 0xC001      LDRB     R12,[R0, R1]
   \   0000076C   0xF1AC 0x0C30      SUB      R12,R12,#+48
   \   00000770   0xFB07 0x440C      MLA      R4,R7,R12,R4
   \   00000774   0x1C40             ADDS     R0,R0,#+1
   \   00000776   0xB2C0             UXTB     R0,R0
   1056          			}
   \   00000778   0x1C76             ADDS     R6,R6,#+1
   \   0000077A   0xB2F6             UXTB     R6,R6
   \   0000077C   0x42AE             CMP      R6,R5
   \   0000077E   0xDBE0             BLT.N    ??BcMFreqStateCheck_111
   1057          			
   1058          			BcMRfStatus->PN_Vaule[k] = TempCopy;
   \                     ??BcMFreqStateCheck_110:
   \   00000780   0xEB03 0x0048      ADD      R0,R3,R8, LSL #+1
   \   00000784   0x8244             STRH     R4,[R0, #+18]
   1059          			if ( Actch == TempCopy ){}
   \   00000786   0xF108 0x0001      ADD      R0,R8,#+1
   \   0000078A   0xFA5F 0xF880      UXTB     R8,R0
   \                     ??BcMFreqStateCheck_106:
   \   0000078E   0xB2D2             UXTB     R2,R2
   \   00000790   0x4610             MOV      R0,R2
   \   00000792   0x45F0             CMP      R8,LR
   \   00000794   0xDA08             BGE.N    ??BcMFreqStateCheck_114
   \   00000796   0x2400             MOVS     R4,#+0
   \   00000798   0x2500             MOVS     R5,#+0
   \                     ??BcMFreqStateCheck_108:
   \   0000079A   0x1C56             ADDS     R6,R2,#+1
   \   0000079C   0xB2D2             UXTB     R2,R2
   \   0000079E   0x5C52             LDRB     R2,[R2, R1]
   \   000007A0   0x2A2C             CMP      R2,#+44
   \   000007A2   0x4632             MOV      R2,R6
   \   000007A4   0xD1C2             BNE.N    ??BcMFreqStateCheck_107
   \   000007A6   0xE7C4             B.N      ??BcMFreqStateCheck_109
   1060          				
   1061          		}
   1062          		//========================================================================//
   1063          
   1064          		//=======================//
   1065          		// Number Of Active PN	//
   1066          		//========================================================================//
   1067          		DataCnt2 = DataCnt;
   1068          		TempCopy = 0;
   \                     ??BcMFreqStateCheck_114:
   \   000007A8   0x2400             MOVS     R4,#+0
   1069          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   \   000007AA   0x2500             MOVS     R5,#+0
   \                     ??BcMFreqStateCheck_115:
   \   000007AC   0x1C56             ADDS     R6,R2,#+1
   \   000007AE   0xB2D2             UXTB     R2,R2
   \   000007B0   0x5C52             LDRB     R2,[R2, R1]
   \   000007B2   0x2A2C             CMP      R2,#+44
   \   000007B4   0x4632             MOV      R2,R6
   \   000007B6   0xD002             BEQ.N    ??BcMFreqStateCheck_116
   \   000007B8   0x1C6D             ADDS     R5,R5,#+1
   \   000007BA   0x2D0A             CMP      R5,#+10
   \   000007BC   0xDBF6             BLT.N    ??BcMFreqStateCheck_115
   1070          		if ( i > 1 ) return(FALSE);
   \                     ??BcMFreqStateCheck_116:
   \   000007BE   0x2D02             CMP      R5,#+2
   \   000007C0   0xF280 0x821B      BGE.W    ??BcMFreqStateCheck_7
   1071          
   1072          		if(DataBuff[DataCnt2]  == '0')goto FER_VAULE;
   \   000007C4   0x5C46             LDRB     R6,[R0, R1]
   \   000007C6   0x2E30             CMP      R6,#+48
   \   000007C8   0xF000 0x80E4      BEQ.W    ??BcMFreqStateCheck_117
   1073          
   1074          		for ( j=0; j<i; j++ )
   \   000007CC   0x2600             MOVS     R6,#+0
   \   000007CE   0x2D01             CMP      R5,#+1
   \   000007D0   0xDB20             BLT.N    ??BcMFreqStateCheck_118
   \   000007D2   0xF1A5 0x0E01      SUB      LR,R5,#+1
   1075          		{
   1076          			if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   \                     ??BcMFreqStateCheck_119:
   \   000007D6   0x5C47             LDRB     R7,[R0, R1]
   \   000007D8   0x3F30             SUBS     R7,R7,#+48
   \   000007DA   0x2F0A             CMP      R7,#+10
   \   000007DC   0xF080 0x820D      BCS.W    ??BcMFreqStateCheck_7
   1077          			for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   \   000007E0   0x2701             MOVS     R7,#+1
   \   000007E2   0x46B4             MOV      R12,R6
   \   000007E4   0x4576             CMP      R6,LR
   \   000007E6   0xDA09             BGE.N    ??BcMFreqStateCheck_120
   \                     ??BcMFreqStateCheck_121:
   \   000007E8   0xEB07 0x0887      ADD      R8,R7,R7, LSL #+2
   \   000007EC   0xEA4F 0x0748      LSL      R7,R8,#+1
   \   000007F0   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   000007F4   0xFA5F 0xFC8C      UXTB     R12,R12
   \   000007F8   0x45F4             CMP      R12,LR
   \   000007FA   0xDBF5             BLT.N    ??BcMFreqStateCheck_121
   1078          			TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   \                     ??BcMFreqStateCheck_120:
   \   000007FC   0xF810 0xC001      LDRB     R12,[R0, R1]
   \   00000800   0xF1AC 0x0C30      SUB      R12,R12,#+48
   \   00000804   0xFB07 0x440C      MLA      R4,R7,R12,R4
   \   00000808   0x1C40             ADDS     R0,R0,#+1
   \   0000080A   0xB2C0             UXTB     R0,R0
   1079          		}
   \   0000080C   0x1C76             ADDS     R6,R6,#+1
   \   0000080E   0xB2F6             UXTB     R6,R6
   \   00000810   0x42AE             CMP      R6,R5
   \   00000812   0xDBE0             BLT.N    ??BcMFreqStateCheck_119
   1080          		BcMRfStatus->ActPN = TempCopy;
   \                     ??BcMFreqStateCheck_118:
   \   00000814   0x821C             STRH     R4,[R3, #+16]
   1081          		//	Ser0Printf("ActPN : %d	\n", Rf_sts.ActPN);
   1082          
   1083          		if ( (TempCopy > 6)||(TempCopy < 1 ) ) return(FALSE);
   \   00000816   0x1E60             SUBS     R0,R4,#+1
   \   00000818   0x2806             CMP      R0,#+6
   \   0000081A   0xF080 0x81EE      BCS.W    ??BcMFreqStateCheck_7
   1084          		chlist = TempCopy;
   \   0000081E   0xFA0F 0xFE84      SXTH     LR,R4
   1085          		//========================================================================//
   1086          
   1087          
   1088          		//============================//
   1089          		// Active Channel Ec/Io Value //
   1090          		//========================================================================//
   1091          		for ( k=0; k<chlist; k++ )
   \   00000822   0xF04F 0x0800      MOV      R8,#+0
   \   00000826   0xE029             B.N      ??BcMFreqStateCheck_122
   1092          		{
   1093          			DataCnt2 = DataCnt;
   1094          			TempCopy = 0;
   1095          
   1096          			for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == '(' ) break;
   1097          			if ( i > 4 ) return(FALSE);
   1098          			for ( j=0; j<i; j++ )
   1099          			{
   1100          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   1101          				for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   1102          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   1103          			}
   1104          			
   1105          			BcMRfStatus->PN_Vaule[k] = TempCopy;
   1106          			
   1107          			DataCnt2 = DataCnt;
   1108          			TempCopy = 0;
   1109          			for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ')' ) break;
   1110          			DataCnt++;		// Remove ','
   1111          			if ( DataBuff[DataCnt2] == '-' )
   1112          			{
   1113          				DataCnt2++;
   1114          				for ( j=0; j<i-1; j++ )
   1115          				{
   1116          					if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   1117          					for ( Power=1,pw=j; pw<i-2; pw++ ) Power *= 10;
   1118          					TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   1119          				}
   1120          				TempCopy = -TempCopy;
   1121          				BcMRfStatus->EcIo[k] = TempCopy;
   1122          			}
   1123          			else
   1124          			{
   1125          				for ( j=0; j<i; j++ )
   \                     ??BcMFreqStateCheck_123:
   \   00000828   0x2600             MOVS     R6,#+0
   \   0000082A   0x2D01             CMP      R5,#+1
   \   0000082C   0xDB20             BLT.N    ??BcMFreqStateCheck_124
   \   0000082E   0xF1A5 0x0A01      SUB      R10,R5,#+1
   1126          				{
   1127          					if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   \                     ??BcMFreqStateCheck_125:
   \   00000832   0x5C47             LDRB     R7,[R0, R1]
   \   00000834   0x3F30             SUBS     R7,R7,#+48
   \   00000836   0x2F0A             CMP      R7,#+10
   \   00000838   0xF080 0x81DF      BCS.W    ??BcMFreqStateCheck_7
   1128          					for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   \   0000083C   0x2701             MOVS     R7,#+1
   \   0000083E   0x46B4             MOV      R12,R6
   \   00000840   0x4556             CMP      R6,R10
   \   00000842   0xDA09             BGE.N    ??BcMFreqStateCheck_126
   \                     ??BcMFreqStateCheck_127:
   \   00000844   0xEB07 0x0B87      ADD      R11,R7,R7, LSL #+2
   \   00000848   0xEA4F 0x074B      LSL      R7,R11,#+1
   \   0000084C   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   00000850   0xFA5F 0xFC8C      UXTB     R12,R12
   \   00000854   0x45D4             CMP      R12,R10
   \   00000856   0xDBF5             BLT.N    ??BcMFreqStateCheck_127
   1129          					TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   \                     ??BcMFreqStateCheck_126:
   \   00000858   0xF810 0xC001      LDRB     R12,[R0, R1]
   \   0000085C   0xF1AC 0x0C30      SUB      R12,R12,#+48
   \   00000860   0xFB07 0x440C      MLA      R4,R7,R12,R4
   \   00000864   0x1C40             ADDS     R0,R0,#+1
   \   00000866   0xB2C0             UXTB     R0,R0
   1130          				}
   \   00000868   0x1C76             ADDS     R6,R6,#+1
   \   0000086A   0xB2F6             UXTB     R6,R6
   \   0000086C   0x42AE             CMP      R6,R5
   \   0000086E   0xDBE0             BLT.N    ??BcMFreqStateCheck_125
   1131          				BcMRfStatus->EcIo[k] = TempCopy;
   \                     ??BcMFreqStateCheck_124:
   \   00000870   0xF8A9 0x401E      STRH     R4,[R9, #+30]
   1132          			}
   \                     ??BcMFreqStateCheck_128:
   \   00000874   0xF108 0x0001      ADD      R0,R8,#+1
   \   00000878   0xFA5F 0xF880      UXTB     R8,R0
   \                     ??BcMFreqStateCheck_122:
   \   0000087C   0x45F0             CMP      R8,LR
   \   0000087E   0xDA74             BGE.N    ??BcMFreqStateCheck_129
   \   00000880   0xB2D2             UXTB     R2,R2
   \   00000882   0x4610             MOV      R0,R2
   \   00000884   0x2400             MOVS     R4,#+0
   \   00000886   0x2500             MOVS     R5,#+0
   \                     ??BcMFreqStateCheck_130:
   \   00000888   0x1C56             ADDS     R6,R2,#+1
   \   0000088A   0xB2D2             UXTB     R2,R2
   \   0000088C   0x5C52             LDRB     R2,[R2, R1]
   \   0000088E   0x2A28             CMP      R2,#+40
   \   00000890   0x4632             MOV      R2,R6
   \   00000892   0xD002             BEQ.N    ??BcMFreqStateCheck_131
   \   00000894   0x1C6D             ADDS     R5,R5,#+1
   \   00000896   0x2D0A             CMP      R5,#+10
   \   00000898   0xDBF6             BLT.N    ??BcMFreqStateCheck_130
   \                     ??BcMFreqStateCheck_131:
   \   0000089A   0x2D05             CMP      R5,#+5
   \   0000089C   0xF280 0x81AD      BGE.W    ??BcMFreqStateCheck_7
   \   000008A0   0x2600             MOVS     R6,#+0
   \   000008A2   0x2D01             CMP      R5,#+1
   \   000008A4   0xDB20             BLT.N    ??BcMFreqStateCheck_132
   \   000008A6   0xF1A5 0x0901      SUB      R9,R5,#+1
   \                     ??BcMFreqStateCheck_133:
   \   000008AA   0x5C47             LDRB     R7,[R0, R1]
   \   000008AC   0x3F30             SUBS     R7,R7,#+48
   \   000008AE   0x2F0A             CMP      R7,#+10
   \   000008B0   0xF080 0x81A3      BCS.W    ??BcMFreqStateCheck_7
   \   000008B4   0x2701             MOVS     R7,#+1
   \   000008B6   0x46B4             MOV      R12,R6
   \   000008B8   0x454E             CMP      R6,R9
   \   000008BA   0xDA09             BGE.N    ??BcMFreqStateCheck_134
   \                     ??BcMFreqStateCheck_135:
   \   000008BC   0xEB07 0x0A87      ADD      R10,R7,R7, LSL #+2
   \   000008C0   0xEA4F 0x074A      LSL      R7,R10,#+1
   \   000008C4   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   000008C8   0xFA5F 0xFC8C      UXTB     R12,R12
   \   000008CC   0x45CC             CMP      R12,R9
   \   000008CE   0xDBF5             BLT.N    ??BcMFreqStateCheck_135
   \                     ??BcMFreqStateCheck_134:
   \   000008D0   0xF810 0xC001      LDRB     R12,[R0, R1]
   \   000008D4   0xF1AC 0x0C30      SUB      R12,R12,#+48
   \   000008D8   0xFB07 0x440C      MLA      R4,R7,R12,R4
   \   000008DC   0x1C40             ADDS     R0,R0,#+1
   \   000008DE   0xB2C0             UXTB     R0,R0
   \   000008E0   0x1C76             ADDS     R6,R6,#+1
   \   000008E2   0xB2F6             UXTB     R6,R6
   \   000008E4   0x42AE             CMP      R6,R5
   \   000008E6   0xDBE0             BLT.N    ??BcMFreqStateCheck_133
   \                     ??BcMFreqStateCheck_132:
   \   000008E8   0xEB03 0x0948      ADD      R9,R3,R8, LSL #+1
   \   000008EC   0xF8A9 0x4012      STRH     R4,[R9, #+18]
   \   000008F0   0xB2D2             UXTB     R2,R2
   \   000008F2   0x4610             MOV      R0,R2
   \   000008F4   0x2400             MOVS     R4,#+0
   \   000008F6   0x2500             MOVS     R5,#+0
   \                     ??BcMFreqStateCheck_136:
   \   000008F8   0x1C56             ADDS     R6,R2,#+1
   \   000008FA   0xB2D2             UXTB     R2,R2
   \   000008FC   0x5C52             LDRB     R2,[R2, R1]
   \   000008FE   0x2A29             CMP      R2,#+41
   \   00000900   0x4632             MOV      R2,R6
   \   00000902   0xD002             BEQ.N    ??BcMFreqStateCheck_137
   \   00000904   0x1C6D             ADDS     R5,R5,#+1
   \   00000906   0x2D0A             CMP      R5,#+10
   \   00000908   0xDBF6             BLT.N    ??BcMFreqStateCheck_136
   \                     ??BcMFreqStateCheck_137:
   \   0000090A   0x1C52             ADDS     R2,R2,#+1
   \   0000090C   0x5C46             LDRB     R6,[R0, R1]
   \   0000090E   0x2E2D             CMP      R6,#+45
   \   00000910   0xD18A             BNE.N    ??BcMFreqStateCheck_123
   \   00000912   0x1C40             ADDS     R0,R0,#+1
   \   00000914   0xB2C0             UXTB     R0,R0
   \   00000916   0x2600             MOVS     R6,#+0
   \   00000918   0xF1A5 0x0A01      SUB      R10,R5,#+1
   \   0000091C   0xF1BA 0x0F01      CMP      R10,#+1
   \   00000920   0xDB1F             BLT.N    ??BcMFreqStateCheck_138
   \   00000922   0x1EAD             SUBS     R5,R5,#+2
   \                     ??BcMFreqStateCheck_139:
   \   00000924   0x5C47             LDRB     R7,[R0, R1]
   \   00000926   0x3F30             SUBS     R7,R7,#+48
   \   00000928   0x2F0A             CMP      R7,#+10
   \   0000092A   0xF080 0x8166      BCS.W    ??BcMFreqStateCheck_7
   \   0000092E   0x2701             MOVS     R7,#+1
   \   00000930   0x46B4             MOV      R12,R6
   \   00000932   0x42AE             CMP      R6,R5
   \   00000934   0xDA09             BGE.N    ??BcMFreqStateCheck_140
   \                     ??BcMFreqStateCheck_141:
   \   00000936   0xEB07 0x0B87      ADD      R11,R7,R7, LSL #+2
   \   0000093A   0xEA4F 0x074B      LSL      R7,R11,#+1
   \   0000093E   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   00000942   0xFA5F 0xFC8C      UXTB     R12,R12
   \   00000946   0x45AC             CMP      R12,R5
   \   00000948   0xDBF5             BLT.N    ??BcMFreqStateCheck_141
   \                     ??BcMFreqStateCheck_140:
   \   0000094A   0xF810 0xC001      LDRB     R12,[R0, R1]
   \   0000094E   0xF1AC 0x0C30      SUB      R12,R12,#+48
   \   00000952   0xFB07 0x440C      MLA      R4,R7,R12,R4
   \   00000956   0x1C40             ADDS     R0,R0,#+1
   \   00000958   0xB2C0             UXTB     R0,R0
   \   0000095A   0x1C76             ADDS     R6,R6,#+1
   \   0000095C   0xB2F6             UXTB     R6,R6
   \   0000095E   0x4556             CMP      R6,R10
   \   00000960   0xDBE0             BLT.N    ??BcMFreqStateCheck_139
   \                     ??BcMFreqStateCheck_138:
   \   00000962   0x4260             RSBS     R0,R4,#+0
   \   00000964   0xF8A9 0x001E      STRH     R0,[R9, #+30]
   \   00000968   0xE784             B.N      ??BcMFreqStateCheck_128
   1133          		}
   1134          		///////
   1135          
   1136          		for ( k=chlist; k<6; k++ )
   \                     ??BcMFreqStateCheck_129:
   \   0000096A   0xFA5F 0xF88E      UXTB     R8,LR
   \   0000096E   0xFA5F 0xFE8E      UXTB     LR,LR
   \   00000972   0xF1BE 0x0F06      CMP      LR,#+6
   \   00000976   0xD20D             BCS.N    ??BcMFreqStateCheck_117
   \   00000978   0xEB03 0x0048      ADD      R0,R3,R8, LSL #+1
   \   0000097C   0xF1B8 0x0F06      CMP      R8,#+6
   \   00000980   0xDA08             BGE.N    ??BcMFreqStateCheck_117
   1137          		{
   1138          			BcMRfStatus->PN_Vaule[k] = 0;
   \                     ??BcMFreqStateCheck_142:
   \   00000982   0x2400             MOVS     R4,#+0
   \   00000984   0x8244             STRH     R4,[R0, #+18]
   1139          			BcMRfStatus->EcIo[k]	 = 0;
   \   00000986   0x83C4             STRH     R4,[R0, #+30]
   1140          		}
   \   00000988   0xF108 0x0801      ADD      R8,R8,#+1
   \   0000098C   0x1C80             ADDS     R0,R0,#+2
   \   0000098E   0xF1B8 0x0F06      CMP      R8,#+6
   \   00000992   0xDBF6             BLT.N    ??BcMFreqStateCheck_142
   1141          		//========================================================================//
   1142          
   1143          		FER_VAULE:
   1144          		//===========//
   1145          		// FER Value //
   1146          		//========================================================================//
   1147          		DataCnt2 = DataCnt;
   \                     ??BcMFreqStateCheck_117:
   \   00000994   0xB2D2             UXTB     R2,R2
   \   00000996   0x4610             MOV      R0,R2
   1148          		TempCopy = 0;
   \   00000998   0x2400             MOVS     R4,#+0
   1149          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   \   0000099A   0x2500             MOVS     R5,#+0
   \                     ??BcMFreqStateCheck_143:
   \   0000099C   0x1C56             ADDS     R6,R2,#+1
   \   0000099E   0xB2D2             UXTB     R2,R2
   \   000009A0   0x5C52             LDRB     R2,[R2, R1]
   \   000009A2   0x2A2C             CMP      R2,#+44
   \   000009A4   0x4632             MOV      R2,R6
   \   000009A6   0xD002             BEQ.N    ??BcMFreqStateCheck_144
   \   000009A8   0x1C6D             ADDS     R5,R5,#+1
   \   000009AA   0x2D0A             CMP      R5,#+10
   \   000009AC   0xDBF6             BLT.N    ??BcMFreqStateCheck_143
   1150          		for ( j=0; j<i; j++ )
   \                     ??BcMFreqStateCheck_144:
   \   000009AE   0x2600             MOVS     R6,#+0
   \   000009B0   0x2D01             CMP      R5,#+1
   \   000009B2   0xDB20             BLT.N    ??BcMFreqStateCheck_145
   \   000009B4   0xF1A5 0x0E01      SUB      LR,R5,#+1
   1151          		{
   1152          			if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   \                     ??BcMFreqStateCheck_146:
   \   000009B8   0x5C47             LDRB     R7,[R0, R1]
   \   000009BA   0x3F30             SUBS     R7,R7,#+48
   \   000009BC   0x2F0A             CMP      R7,#+10
   \   000009BE   0xF080 0x811C      BCS.W    ??BcMFreqStateCheck_7
   1153          			for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   \   000009C2   0x2701             MOVS     R7,#+1
   \   000009C4   0x46B4             MOV      R12,R6
   \   000009C6   0x4576             CMP      R6,LR
   \   000009C8   0xDA09             BGE.N    ??BcMFreqStateCheck_147
   \                     ??BcMFreqStateCheck_148:
   \   000009CA   0xEB07 0x0887      ADD      R8,R7,R7, LSL #+2
   \   000009CE   0xEA4F 0x0748      LSL      R7,R8,#+1
   \   000009D2   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   000009D6   0xFA5F 0xFC8C      UXTB     R12,R12
   \   000009DA   0x45F4             CMP      R12,LR
   \   000009DC   0xDBF5             BLT.N    ??BcMFreqStateCheck_148
   1154          			TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   \                     ??BcMFreqStateCheck_147:
   \   000009DE   0xF810 0xC001      LDRB     R12,[R0, R1]
   \   000009E2   0xF1AC 0x0C30      SUB      R12,R12,#+48
   \   000009E6   0xFB07 0x440C      MLA      R4,R7,R12,R4
   \   000009EA   0x1C40             ADDS     R0,R0,#+1
   \   000009EC   0xB2C0             UXTB     R0,R0
   1155          		}
   \   000009EE   0x1C76             ADDS     R6,R6,#+1
   \   000009F0   0xB2F6             UXTB     R6,R6
   \   000009F2   0x42AE             CMP      R6,R5
   \   000009F4   0xDBE0             BLT.N    ??BcMFreqStateCheck_146
   1156          
   1157          		BcMRfStatus->FerValue = TempCopy;
   \                     ??BcMFreqStateCheck_145:
   \   000009F6   0x855C             STRH     R4,[R3, #+42]
   1158          		//========================================================================//
   1159          
   1160          		//==========//
   1161          		// RX Value //
   1162          		//========================================================================//
   1163          		DataCnt2 = DataCnt;
   \   000009F8   0xB2D2             UXTB     R2,R2
   \   000009FA   0x4610             MOV      R0,R2
   1164          		TempCopy = 0;
   \   000009FC   0x2400             MOVS     R4,#+0
   1165          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   \   000009FE   0x2500             MOVS     R5,#+0
   \                     ??BcMFreqStateCheck_149:
   \   00000A00   0x1C56             ADDS     R6,R2,#+1
   \   00000A02   0xB2D2             UXTB     R2,R2
   \   00000A04   0x5C52             LDRB     R2,[R2, R1]
   \   00000A06   0x2A2C             CMP      R2,#+44
   \   00000A08   0x4632             MOV      R2,R6
   \   00000A0A   0xD002             BEQ.N    ??BcMFreqStateCheck_150
   \   00000A0C   0x1C6D             ADDS     R5,R5,#+1
   \   00000A0E   0x2D0A             CMP      R5,#+10
   \   00000A10   0xDBF6             BLT.N    ??BcMFreqStateCheck_149
   1166          		if ( DataBuff[DataCnt2] == '-' )
   \                     ??BcMFreqStateCheck_150:
   \   00000A12   0x5C46             LDRB     R6,[R0, R1]
   \   00000A14   0x2E2D             CMP      R6,#+45
   \   00000A16   0xD129             BNE.N    ??BcMFreqStateCheck_151
   1167          		{
   1168          			DataCnt2++;
   \   00000A18   0x1C40             ADDS     R0,R0,#+1
   \   00000A1A   0xB2C0             UXTB     R0,R0
   1169          			for ( j=0; j<i-1; j++ )
   \   00000A1C   0x2600             MOVS     R6,#+0
   \   00000A1E   0xF1A5 0x0E01      SUB      LR,R5,#+1
   \   00000A22   0xF1BE 0x0F01      CMP      LR,#+1
   \   00000A26   0xDB1F             BLT.N    ??BcMFreqStateCheck_152
   \   00000A28   0x1EAD             SUBS     R5,R5,#+2
   1170          			{
   1171          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   \                     ??BcMFreqStateCheck_153:
   \   00000A2A   0x5C47             LDRB     R7,[R0, R1]
   \   00000A2C   0x3F30             SUBS     R7,R7,#+48
   \   00000A2E   0x2F0A             CMP      R7,#+10
   \   00000A30   0xF080 0x80E3      BCS.W    ??BcMFreqStateCheck_7
   1172          				for ( Power=1,pw=j; pw<i-2; pw++ ) Power *= 10;
   \   00000A34   0x2701             MOVS     R7,#+1
   \   00000A36   0x46B4             MOV      R12,R6
   \   00000A38   0x42AE             CMP      R6,R5
   \   00000A3A   0xDA09             BGE.N    ??BcMFreqStateCheck_154
   \                     ??BcMFreqStateCheck_155:
   \   00000A3C   0xEB07 0x0887      ADD      R8,R7,R7, LSL #+2
   \   00000A40   0xEA4F 0x0748      LSL      R7,R8,#+1
   \   00000A44   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   00000A48   0xFA5F 0xFC8C      UXTB     R12,R12
   \   00000A4C   0x45AC             CMP      R12,R5
   \   00000A4E   0xDBF5             BLT.N    ??BcMFreqStateCheck_155
   1173          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   \                     ??BcMFreqStateCheck_154:
   \   00000A50   0xF810 0xC001      LDRB     R12,[R0, R1]
   \   00000A54   0xF1AC 0x0C30      SUB      R12,R12,#+48
   \   00000A58   0xFB07 0x440C      MLA      R4,R7,R12,R4
   \   00000A5C   0x1C40             ADDS     R0,R0,#+1
   \   00000A5E   0xB2C0             UXTB     R0,R0
   1174          			}
   \   00000A60   0x1C76             ADDS     R6,R6,#+1
   \   00000A62   0xB2F6             UXTB     R6,R6
   \   00000A64   0x4576             CMP      R6,LR
   \   00000A66   0xDBE0             BLT.N    ??BcMFreqStateCheck_153
   1175          			TempCopy = -TempCopy;
   \                     ??BcMFreqStateCheck_152:
   \   00000A68   0x4264             RSBS     R4,R4,#+0
   1176          			BcMRfStatus->RxValue = TempCopy;
   \   00000A6A   0xE023             B.N      ??BcMFreqStateCheck_156
   1177          		}
   1178          		else
   1179          		{
   1180          			for ( j=0; j<i; j++ )
   \                     ??BcMFreqStateCheck_151:
   \   00000A6C   0x2600             MOVS     R6,#+0
   \   00000A6E   0x2D01             CMP      R5,#+1
   \   00000A70   0xDB20             BLT.N    ??BcMFreqStateCheck_156
   \   00000A72   0xF1A5 0x0E01      SUB      LR,R5,#+1
   1181          			{
   1182          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   \                     ??BcMFreqStateCheck_157:
   \   00000A76   0x5C47             LDRB     R7,[R0, R1]
   \   00000A78   0x3F30             SUBS     R7,R7,#+48
   \   00000A7A   0x2F0A             CMP      R7,#+10
   \   00000A7C   0xF080 0x80BD      BCS.W    ??BcMFreqStateCheck_7
   1183          				for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   \   00000A80   0x2701             MOVS     R7,#+1
   \   00000A82   0x46B4             MOV      R12,R6
   \   00000A84   0x4576             CMP      R6,LR
   \   00000A86   0xDA09             BGE.N    ??BcMFreqStateCheck_158
   \                     ??BcMFreqStateCheck_159:
   \   00000A88   0xEB07 0x0887      ADD      R8,R7,R7, LSL #+2
   \   00000A8C   0xEA4F 0x0748      LSL      R7,R8,#+1
   \   00000A90   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   00000A94   0xFA5F 0xFC8C      UXTB     R12,R12
   \   00000A98   0x45F4             CMP      R12,LR
   \   00000A9A   0xDBF5             BLT.N    ??BcMFreqStateCheck_159
   1184          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   \                     ??BcMFreqStateCheck_158:
   \   00000A9C   0xF810 0xC001      LDRB     R12,[R0, R1]
   \   00000AA0   0xF1AC 0x0C30      SUB      R12,R12,#+48
   \   00000AA4   0xFB07 0x440C      MLA      R4,R7,R12,R4
   \   00000AA8   0x1C40             ADDS     R0,R0,#+1
   \   00000AAA   0xB2C0             UXTB     R0,R0
   1185          			}
   \   00000AAC   0x1C76             ADDS     R6,R6,#+1
   \   00000AAE   0xB2F6             UXTB     R6,R6
   \   00000AB0   0x42AE             CMP      R6,R5
   \   00000AB2   0xDBE0             BLT.N    ??BcMFreqStateCheck_157
   1186          			BcMRfStatus->RxValue = TempCopy;
   \                     ??BcMFreqStateCheck_156:
   \   00000AB4   0x859C             STRH     R4,[R3, #+44]
   1187          		}
   1188          
   1189          		//========================================================================//
   1190          		if ( TempCopy > 0 ) return(FALSE);
   \   00000AB6   0xB224             SXTH     R4,R4
   \   00000AB8   0x2C01             CMP      R4,#+1
   \   00000ABA   0xF280 0x809E      BGE.W    ??BcMFreqStateCheck_7
   1191          
   1192          		//==========//
   1193          		// TX Value //
   1194          		//========================================================================//
   1195          		DataCnt2 = DataCnt;
   \   00000ABE   0xB2D2             UXTB     R2,R2
   \   00000AC0   0x4610             MOV      R0,R2
   1196          		TempCopy = 0;
   \   00000AC2   0x2400             MOVS     R4,#+0
   1197          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   \   00000AC4   0x2500             MOVS     R5,#+0
   \                     ??BcMFreqStateCheck_160:
   \   00000AC6   0x1C56             ADDS     R6,R2,#+1
   \   00000AC8   0xB2D2             UXTB     R2,R2
   \   00000ACA   0x5C52             LDRB     R2,[R2, R1]
   \   00000ACC   0x2A2C             CMP      R2,#+44
   \   00000ACE   0x4632             MOV      R2,R6
   \   00000AD0   0xD002             BEQ.N    ??BcMFreqStateCheck_161
   \   00000AD2   0x1C6D             ADDS     R5,R5,#+1
   \   00000AD4   0x2D0A             CMP      R5,#+10
   \   00000AD6   0xDBF6             BLT.N    ??BcMFreqStateCheck_160
   1198          		if ( DataBuff[DataCnt2] == '-' )
   \                     ??BcMFreqStateCheck_161:
   \   00000AD8   0x5C46             LDRB     R6,[R0, R1]
   \   00000ADA   0x2E2D             CMP      R6,#+45
   \   00000ADC   0xD12A             BNE.N    ??BcMFreqStateCheck_162
   1199          		{
   1200          			DataCnt2++;
   \   00000ADE   0x1C40             ADDS     R0,R0,#+1
   \   00000AE0   0xB2C0             UXTB     R0,R0
   1201          			for ( j=0; j<i-1; j++ )
   \   00000AE2   0x2600             MOVS     R6,#+0
   \   00000AE4   0xF1A5 0x0E01      SUB      LR,R5,#+1
   \   00000AE8   0xF1BE 0x0F01      CMP      LR,#+1
   \   00000AEC   0xDB1F             BLT.N    ??BcMFreqStateCheck_163
   \   00000AEE   0x1EAD             SUBS     R5,R5,#+2
   1202          			{
   1203          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   \                     ??BcMFreqStateCheck_164:
   \   00000AF0   0x5C47             LDRB     R7,[R0, R1]
   \   00000AF2   0x3F30             SUBS     R7,R7,#+48
   \   00000AF4   0x2F0A             CMP      R7,#+10
   \   00000AF6   0xF080 0x8080      BCS.W    ??BcMFreqStateCheck_7
   1204          				for ( Power=1,pw=j; pw<i-2; pw++ ) Power *= 10;
   \   00000AFA   0x2701             MOVS     R7,#+1
   \   00000AFC   0x46B4             MOV      R12,R6
   \   00000AFE   0x42AE             CMP      R6,R5
   \   00000B00   0xDA09             BGE.N    ??BcMFreqStateCheck_165
   \                     ??BcMFreqStateCheck_166:
   \   00000B02   0xEB07 0x0887      ADD      R8,R7,R7, LSL #+2
   \   00000B06   0xEA4F 0x0748      LSL      R7,R8,#+1
   \   00000B0A   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   00000B0E   0xFA5F 0xFC8C      UXTB     R12,R12
   \   00000B12   0x45AC             CMP      R12,R5
   \   00000B14   0xDBF5             BLT.N    ??BcMFreqStateCheck_166
   1205          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   \                     ??BcMFreqStateCheck_165:
   \   00000B16   0xF810 0xC001      LDRB     R12,[R0, R1]
   \   00000B1A   0xF1AC 0x0C30      SUB      R12,R12,#+48
   \   00000B1E   0xFB07 0x440C      MLA      R4,R7,R12,R4
   \   00000B22   0x1C40             ADDS     R0,R0,#+1
   \   00000B24   0xB2C0             UXTB     R0,R0
   1206          			}
   \   00000B26   0x1C76             ADDS     R6,R6,#+1
   \   00000B28   0xB2F6             UXTB     R6,R6
   \   00000B2A   0x4576             CMP      R6,LR
   \   00000B2C   0xDBE0             BLT.N    ??BcMFreqStateCheck_164
   1207          			TempCopy = -TempCopy;
   1208          			BcMRfStatus->TxValue = TempCopy;
   \                     ??BcMFreqStateCheck_163:
   \   00000B2E   0x4260             RSBS     R0,R4,#+0
   \   00000B30   0x85D8             STRH     R0,[R3, #+46]
   \   00000B32   0xE023             B.N      ??BcMFreqStateCheck_167
   1209          		}
   1210          		else
   1211          		{
   1212          			for ( j=0; j<i; j++ )
   \                     ??BcMFreqStateCheck_162:
   \   00000B34   0x2600             MOVS     R6,#+0
   \   00000B36   0x2D01             CMP      R5,#+1
   \   00000B38   0xDB1F             BLT.N    ??BcMFreqStateCheck_168
   \   00000B3A   0xF1A5 0x0E01      SUB      LR,R5,#+1
   1213          			{
   1214          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   \                     ??BcMFreqStateCheck_169:
   \   00000B3E   0x5C47             LDRB     R7,[R0, R1]
   \   00000B40   0x3F30             SUBS     R7,R7,#+48
   \   00000B42   0x2F0A             CMP      R7,#+10
   \   00000B44   0xD259             BCS.N    ??BcMFreqStateCheck_7
   1215          				for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   \   00000B46   0x2701             MOVS     R7,#+1
   \   00000B48   0x46B4             MOV      R12,R6
   \   00000B4A   0x4576             CMP      R6,LR
   \   00000B4C   0xDA09             BGE.N    ??BcMFreqStateCheck_170
   \                     ??BcMFreqStateCheck_171:
   \   00000B4E   0xEB07 0x0887      ADD      R8,R7,R7, LSL #+2
   \   00000B52   0xEA4F 0x0748      LSL      R7,R8,#+1
   \   00000B56   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   00000B5A   0xFA5F 0xFC8C      UXTB     R12,R12
   \   00000B5E   0x45F4             CMP      R12,LR
   \   00000B60   0xDBF5             BLT.N    ??BcMFreqStateCheck_171
   1216          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   \                     ??BcMFreqStateCheck_170:
   \   00000B62   0xF810 0xC001      LDRB     R12,[R0, R1]
   \   00000B66   0xF1AC 0x0C30      SUB      R12,R12,#+48
   \   00000B6A   0xFB07 0x440C      MLA      R4,R7,R12,R4
   \   00000B6E   0x1C40             ADDS     R0,R0,#+1
   \   00000B70   0xB2C0             UXTB     R0,R0
   1217          			}
   \   00000B72   0x1C76             ADDS     R6,R6,#+1
   \   00000B74   0xB2F6             UXTB     R6,R6
   \   00000B76   0x42AE             CMP      R6,R5
   \   00000B78   0xDBE1             BLT.N    ??BcMFreqStateCheck_169
   1218          			BcMRfStatus->TxValue = TempCopy;
   \                     ??BcMFreqStateCheck_168:
   \   00000B7A   0x85DC             STRH     R4,[R3, #+46]
   1219          		}
   1220          
   1221          		//===========//
   1222          		// ADJ Value //
   1223          		//========================================================================//
   1224          		DataCnt2 = DataCnt;
   \                     ??BcMFreqStateCheck_167:
   \   00000B7C   0xB2D2             UXTB     R2,R2
   \   00000B7E   0x4610             MOV      R0,R2
   1225          		TempCopy = 0;
   \   00000B80   0x2400             MOVS     R4,#+0
   1226          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == 0x0d ) break;
   \   00000B82   0x2500             MOVS     R5,#+0
   \                     ??BcMFreqStateCheck_172:
   \   00000B84   0xB2D2             UXTB     R2,R2
   \   00000B86   0x5C56             LDRB     R6,[R2, R1]
   \   00000B88   0x2E0D             CMP      R6,#+13
   \   00000B8A   0xD003             BEQ.N    ??BcMFreqStateCheck_173
   \   00000B8C   0x1C52             ADDS     R2,R2,#+1
   \   00000B8E   0x1C6D             ADDS     R5,R5,#+1
   \   00000B90   0x2D0A             CMP      R5,#+10
   \   00000B92   0xDBF7             BLT.N    ??BcMFreqStateCheck_172
   1227          		if ( DataBuff[DataCnt2] == '-' )
   \                     ??BcMFreqStateCheck_173:
   \   00000B94   0x5C42             LDRB     R2,[R0, R1]
   \   00000B96   0x2A2D             CMP      R2,#+45
   \   00000B98   0xD127             BNE.N    ??BcMFreqStateCheck_174
   1228          		{
   1229          			DataCnt2++;
   \   00000B9A   0x1C40             ADDS     R0,R0,#+1
   \   00000B9C   0xB2C0             UXTB     R0,R0
   1230          			for ( j=0; j<i-1; j++ )
   \   00000B9E   0x2600             MOVS     R6,#+0
   \   00000BA0   0x1E6A             SUBS     R2,R5,#+1
   \   00000BA2   0x2A01             CMP      R2,#+1
   \   00000BA4   0xDB1E             BLT.N    ??BcMFreqStateCheck_175
   \   00000BA6   0x1EAD             SUBS     R5,R5,#+2
   1231          			{
   1232          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   \                     ??BcMFreqStateCheck_176:
   \   00000BA8   0x5C47             LDRB     R7,[R0, R1]
   \   00000BAA   0x3F30             SUBS     R7,R7,#+48
   \   00000BAC   0x2F0A             CMP      R7,#+10
   \   00000BAE   0xD224             BCS.N    ??BcMFreqStateCheck_7
   1233          				for ( Power=1,pw=j; pw<i-2; pw++ ) Power *= 10;
   \   00000BB0   0x2701             MOVS     R7,#+1
   \   00000BB2   0x46B4             MOV      R12,R6
   \   00000BB4   0x42AE             CMP      R6,R5
   \   00000BB6   0xDA09             BGE.N    ??BcMFreqStateCheck_177
   \                     ??BcMFreqStateCheck_178:
   \   00000BB8   0xEB07 0x0E87      ADD      LR,R7,R7, LSL #+2
   \   00000BBC   0xEA4F 0x074E      LSL      R7,LR,#+1
   \   00000BC0   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   00000BC4   0xFA5F 0xFC8C      UXTB     R12,R12
   \   00000BC8   0x45AC             CMP      R12,R5
   \   00000BCA   0xDBF5             BLT.N    ??BcMFreqStateCheck_178
   1234          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   \                     ??BcMFreqStateCheck_177:
   \   00000BCC   0xF810 0xC001      LDRB     R12,[R0, R1]
   \   00000BD0   0xF1AC 0x0C30      SUB      R12,R12,#+48
   \   00000BD4   0xFB07 0x440C      MLA      R4,R7,R12,R4
   \   00000BD8   0x1C40             ADDS     R0,R0,#+1
   \   00000BDA   0xB2C0             UXTB     R0,R0
   1235          			}
   \   00000BDC   0x1C76             ADDS     R6,R6,#+1
   \   00000BDE   0xB2F6             UXTB     R6,R6
   \   00000BE0   0x4296             CMP      R6,R2
   \   00000BE2   0xDBE1             BLT.N    ??BcMFreqStateCheck_176
   1236          			TempCopy = -TempCopy;
   1237          			BcMRfStatus->AdjValue = TempCopy;
   \                     ??BcMFreqStateCheck_175:
   \   00000BE4   0x4260             RSBS     R0,R4,#+0
   \   00000BE6   0x8618             STRH     R0,[R3, #+48]
   \   00000BE8   0xE024             B.N      ??BcMFreqStateCheck_87
   1238          			
   1239          		}
   1240          		else
   1241          		{
   1242          			for ( j=0; j<i; j++ )
   \                     ??BcMFreqStateCheck_174:
   \   00000BEA   0x2600             MOVS     R6,#+0
   \   00000BEC   0x2D01             CMP      R5,#+1
   \   00000BEE   0xDB20             BLT.N    ??BcMFreqStateCheck_179
   \   00000BF0   0x1E6A             SUBS     R2,R5,#+1
   1243          			{
   1244          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   \                     ??BcMFreqStateCheck_180:
   \   00000BF2   0x5C47             LDRB     R7,[R0, R1]
   \   00000BF4   0x3F30             SUBS     R7,R7,#+48
   \   00000BF6   0x2F0A             CMP      R7,#+10
   \   00000BF8   0xD301             BCC.N    ??BcMFreqStateCheck_181
   \                     ??BcMFreqStateCheck_7:
   \   00000BFA   0x2000             MOVS     R0,#+0
   \   00000BFC   0xE01B             B.N      ??BcMFreqStateCheck_182
   1245          				for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   \                     ??BcMFreqStateCheck_181:
   \   00000BFE   0x2701             MOVS     R7,#+1
   \   00000C00   0x46B4             MOV      R12,R6
   \   00000C02   0x4296             CMP      R6,R2
   \   00000C04   0xDA09             BGE.N    ??BcMFreqStateCheck_183
   \                     ??BcMFreqStateCheck_184:
   \   00000C06   0xEB07 0x0E87      ADD      LR,R7,R7, LSL #+2
   \   00000C0A   0xEA4F 0x074E      LSL      R7,LR,#+1
   \   00000C0E   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   00000C12   0xFA5F 0xFC8C      UXTB     R12,R12
   \   00000C16   0x4594             CMP      R12,R2
   \   00000C18   0xDBF5             BLT.N    ??BcMFreqStateCheck_184
   1246          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   \                     ??BcMFreqStateCheck_183:
   \   00000C1A   0xF810 0xC001      LDRB     R12,[R0, R1]
   \   00000C1E   0xF1AC 0x0C30      SUB      R12,R12,#+48
   \   00000C22   0xFB07 0x440C      MLA      R4,R7,R12,R4
   \   00000C26   0x1C40             ADDS     R0,R0,#+1
   \   00000C28   0xB2C0             UXTB     R0,R0
   1247          			}
   \   00000C2A   0x1C76             ADDS     R6,R6,#+1
   \   00000C2C   0xB2F6             UXTB     R6,R6
   \   00000C2E   0x42AE             CMP      R6,R5
   \   00000C30   0xDBDF             BLT.N    ??BcMFreqStateCheck_180
   1248          			BcMRfStatus->AdjValue = TempCopy;
   \                     ??BcMFreqStateCheck_179:
   \   00000C32   0x861C             STRH     R4,[R3, #+48]
   1249          		}
   1250          		//========================================================================//
   1251          	}
   1252          	return(TRUE);
   \                     ??BcMFreqStateCheck_87:
   \   00000C34   0x2001             MOVS     R0,#+1
   \                     ??BcMFreqStateCheck_182:
   \   00000C36   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1253          }
   1254          

   \                                 In section .text, align 2, keep-with-next
   1255          INT8S BcMPilotStateCheck ( INT8U *DataBuff )
   1256          {
   \                     BcMPilotStateCheck:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   1257          	INT8U 	i, j, DataCnt=0, DataCnt2=0, pw;
   \   00000004   0x2100             MOVS     R1,#+0
   1258          	INT8U   k;
   1259          	INT16S	TempCopy, Power;
   1260          	INT8U	uTemp;
   1261           
   1262          	//============================//
   1263          	// Active Channel Ec/Io Value //
   1264          	//========================================================================//
   1265          
   1266          	DataCnt = 0;
   1267          	TempCopy = 0;
   \   00000006   0x2500             MOVS     R5,#+0
   1268          
   1269          
   1270          	for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   \   00000008   0x460A             MOV      R2,R1
   \   0000000A   0x4603             MOV      R3,R0
   \                     ??BcMPilotStateCheck_0:
   \   0000000C   0xF813 0x4B01      LDRB     R4,[R3], #+1
   \   00000010   0x2C2C             CMP      R4,#+44
   \   00000012   0xD101             BNE.N    ??BcMPilotStateCheck_1
   \                     ??BcMPilotStateCheck_2:
   \   00000014   0x1C49             ADDS     R1,R1,#+1
   \   00000016   0xE01B             B.N      ??BcMPilotStateCheck_3
   \                     ??BcMPilotStateCheck_1:
   \   00000018   0x1C49             ADDS     R1,R1,#+1
   \   0000001A   0x1C52             ADDS     R2,R2,#+1
   \   0000001C   0xF813 0x4B01      LDRB     R4,[R3], #+1
   \   00000020   0x2C2C             CMP      R4,#+44
   \   00000022   0xBF1F             ITTTT    NE 
   \   00000024   0x1C49             ADDNE    R1,R1,#+1
   \   00000026   0x1C52             ADDNE    R2,R2,#+1
   \   00000028   0xF813 0x4B01      LDRBNE   R4,[R3], #+1
   \   0000002C   0x2C2C             CMPNE    R4,#+44
   \   0000002E   0xBF1F             ITTTT    NE 
   \   00000030   0x1C49             ADDNE    R1,R1,#+1
   \   00000032   0x1C52             ADDNE    R2,R2,#+1
   \   00000034   0xF813 0x4B01      LDRBNE   R4,[R3], #+1
   \   00000038   0x2C2C             CMPNE    R4,#+44
   \   0000003A   0xBF1F             ITTTT    NE 
   \   0000003C   0x1C49             ADDNE    R1,R1,#+1
   \   0000003E   0x1C52             ADDNE    R2,R2,#+1
   \   00000040   0xF813 0x4B01      LDRBNE   R4,[R3], #+1
   \   00000044   0x2C2C             CMPNE    R4,#+44
   \   00000046   0xD0E5             BEQ.N    ??BcMPilotStateCheck_2
   \   00000048   0x1C49             ADDS     R1,R1,#+1
   \   0000004A   0x1C52             ADDS     R2,R2,#+1
   \   0000004C   0x2A0A             CMP      R2,#+10
   \   0000004E   0xDBDD             BLT.N    ??BcMPilotStateCheck_0
   1271          	for ( j=0; j<(DataCnt-1); j++ )
   \                     ??BcMPilotStateCheck_3:
   \   00000050   0x2400             MOVS     R4,#+0
   \   00000052   0xB2C9             UXTB     R1,R1
   \   00000054   0x1E4F             SUBS     R7,R1,#+1
   \   00000056   0x2F01             CMP      R7,#+1
   \   00000058   0xDB17             BLT.N    ??BcMPilotStateCheck_4
   \   0000005A   0x4684             MOV      R12,R0
   \   0000005C   0x1E56             SUBS     R6,R2,#+1
   1272          	{
   1273          		for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   \                     ??BcMPilotStateCheck_5:
   \   0000005E   0x2201             MOVS     R2,#+1
   \   00000060   0x4623             MOV      R3,R4
   \   00000062   0xFA5F 0xF884      UXTB     R8,R4
   \   00000066   0x45B0             CMP      R8,R6
   \   00000068   0xDA07             BGE.N    ??BcMPilotStateCheck_6
   \                     ??BcMPilotStateCheck_7:
   \   0000006A   0xEB02 0x0882      ADD      R8,R2,R2, LSL #+2
   \   0000006E   0xEA4F 0x0248      LSL      R2,R8,#+1
   \   00000072   0x1C5B             ADDS     R3,R3,#+1
   \   00000074   0xB2DB             UXTB     R3,R3
   \   00000076   0x42B3             CMP      R3,R6
   \   00000078   0xDBF7             BLT.N    ??BcMPilotStateCheck_7
   1274          		TempCopy = TempCopy + (DataBuff[j]-'0')*Power;
   \                     ??BcMPilotStateCheck_6:
   \   0000007A   0xF81C 0x3B01      LDRB     R3,[R12], #+1
   \   0000007E   0x3B30             SUBS     R3,R3,#+48
   \   00000080   0xFB02 0x5503      MLA      R5,R2,R3,R5
   1275          	}
   \   00000084   0x1C64             ADDS     R4,R4,#+1
   \   00000086   0x42BC             CMP      R4,R7
   \   00000088   0xDBE9             BLT.N    ??BcMPilotStateCheck_5
   1276          	BcMPilotStatus->PN_Vaule[0] = TempCopy;
   \                     ??BcMPilotStateCheck_4:
   \   0000008A   0x.... 0x....      LDR.W    R2,??DataTable89
   \   0000008E   0x6814             LDR      R4,[R2, #+0]
   \   00000090   0x8025             STRH     R5,[R4, #+0]
   1277          
   1278          	if (DataBuff[DataCnt] == '-' )DataCnt++;
   \   00000092   0x5C0A             LDRB     R2,[R1, R0]
   \   00000094   0x2A2D             CMP      R2,#+45
   \   00000096   0xBF08             IT       EQ 
   \   00000098   0x1C49             ADDEQ    R1,R1,#+1
   1279          
   1280          	DataCnt2 = DataCnt;
   \   0000009A   0xB2C9             UXTB     R1,R1
   \   0000009C   0x460A             MOV      R2,R1
   1281          	TempCopy = 0;
   \   0000009E   0x2500             MOVS     R5,#+0
   1282          	k = DataCnt;		
   \   000000A0   0x460F             MOV      R7,R1
   1283          
   1284           	for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   \   000000A2   0x230A             MOVS     R3,#+10
   \                     ??BcMPilotStateCheck_8:
   \   000000A4   0x1C4E             ADDS     R6,R1,#+1
   \   000000A6   0xB2C9             UXTB     R1,R1
   \   000000A8   0x5C09             LDRB     R1,[R1, R0]
   \   000000AA   0x292C             CMP      R1,#+44
   \   000000AC   0x4631             MOV      R1,R6
   \   000000AE   0xD001             BEQ.N    ??BcMPilotStateCheck_9
   \   000000B0   0x1E5B             SUBS     R3,R3,#+1
   \   000000B2   0xD1F7             BNE.N    ??BcMPilotStateCheck_8
   1285          	for ( i=0; i<10; i++ ) if ( DataBuff[k++] == '.' ) break;
   \                     ??BcMPilotStateCheck_9:
   \   000000B4   0x2300             MOVS     R3,#+0
   \                     ??BcMPilotStateCheck_10:
   \   000000B6   0x1C7E             ADDS     R6,R7,#+1
   \   000000B8   0xB2FF             UXTB     R7,R7
   \   000000BA   0x5C3F             LDRB     R7,[R7, R0]
   \   000000BC   0x2F2E             CMP      R7,#+46
   \   000000BE   0x4637             MOV      R7,R6
   \   000000C0   0xD002             BEQ.N    ??BcMPilotStateCheck_11
   \   000000C2   0x1C5B             ADDS     R3,R3,#+1
   \   000000C4   0x2B0A             CMP      R3,#+10
   \   000000C6   0xDBF6             BLT.N    ??BcMPilotStateCheck_10
   1286          	if(i>(DataCnt-DataCnt2))	{k=DataCnt; i=DataCnt-DataCnt2-1;}			// 130304
   \                     ??BcMPilotStateCheck_11:
   \   000000C8   0xB2C9             UXTB     R1,R1
   \   000000CA   0x1A8E             SUBS     R6,R1,R2
   \   000000CC   0x429E             CMP      R6,R3
   \   000000CE   0xDA03             BGE.N    ??BcMPilotStateCheck_12
   \   000000D0   0x460F             MOV      R7,R1
   \   000000D2   0x1A8B             SUBS     R3,R1,R2
   \   000000D4   0x1E5B             SUBS     R3,R3,#+1
   \   000000D6   0xB2DB             UXTB     R3,R3
   1287          
   1288          	for ( j = DataCnt2; j < (k-1); j++ )
   \                     ??BcMPilotStateCheck_12:
   \   000000D8   0x4616             MOV      R6,R2
   \   000000DA   0xB2FF             UXTB     R7,R7
   \   000000DC   0x1E7F             SUBS     R7,R7,#+1
   \   000000DE   0x42BA             CMP      R2,R7
   \   000000E0   0xBFBF             ITTTT    LT 
   \   000000E2   0xEBA6 0x0C02      SUBLT    R12,R6,R2
   \   000000E6   0xEB06 0x0E00      ADDLT    LR,R6,R0
   \   000000EA   0xF1A3 0x0801      SUBLT    R8,R3,#+1
   \   000000EE   0x42BE             CMPLT    R6,R7
   \   000000F0   0xDA18             BGE.N    ??BcMPilotStateCheck_13
   1289          	{
   1290          		for ( Power=1,pw = (j - DataCnt2) ; pw < (i - 1); pw++ ) Power =  Power * 10;
   \                     ??BcMPilotStateCheck_14:
   \   000000F2   0x2201             MOVS     R2,#+1
   \   000000F4   0x45C4             CMP      R12,R8
   \   000000F6   0xBFBC             ITT      LT 
   \   000000F8   0xFA5F 0xF38C      UXTBLT   R3,R12
   \   000000FC   0x4543             CMPLT    R3,R8
   \   000000FE   0xDA07             BGE.N    ??BcMPilotStateCheck_15
   \                     ??BcMPilotStateCheck_16:
   \   00000100   0xEB02 0x0982      ADD      R9,R2,R2, LSL #+2
   \   00000104   0xEA4F 0x0249      LSL      R2,R9,#+1
   \   00000108   0x1C5B             ADDS     R3,R3,#+1
   \   0000010A   0xB2DB             UXTB     R3,R3
   \   0000010C   0x4543             CMP      R3,R8
   \   0000010E   0xDBF7             BLT.N    ??BcMPilotStateCheck_16
   1291          		TempCopy = TempCopy + (DataBuff[j]-'0')*Power;
   \                     ??BcMPilotStateCheck_15:
   \   00000110   0xF81E 0x3B01      LDRB     R3,[LR], #+1
   \   00000114   0x3B30             SUBS     R3,R3,#+48
   \   00000116   0xFB02 0x5503      MLA      R5,R2,R3,R5
   1292          	}
   \   0000011A   0x1C76             ADDS     R6,R6,#+1
   \   0000011C   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   00000120   0x42BE             CMP      R6,R7
   \   00000122   0xDBE6             BLT.N    ??BcMPilotStateCheck_14
   1293          	BcMPilotStatus->EcIo[0] = TempCopy;
   \                     ??BcMPilotStateCheck_13:
   \   00000124   0x8125             STRH     R5,[R4, #+8]
   1294           
   1295          	DataCnt2 = DataCnt;
   \   00000126   0x460A             MOV      R2,R1
   1296          	TempCopy = 0;
   \   00000128   0x2500             MOVS     R5,#+0
   1297          
   1298          	for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   \   0000012A   0x2300             MOVS     R3,#+0
   \                     ??BcMPilotStateCheck_17:
   \   0000012C   0x1C4E             ADDS     R6,R1,#+1
   \   0000012E   0xB2C9             UXTB     R1,R1
   \   00000130   0x5C09             LDRB     R1,[R1, R0]
   \   00000132   0x292C             CMP      R1,#+44
   \   00000134   0x4631             MOV      R1,R6
   \   00000136   0xD002             BEQ.N    ??BcMPilotStateCheck_18
   \   00000138   0x1C5B             ADDS     R3,R3,#+1
   \   0000013A   0x2B0A             CMP      R3,#+10
   \   0000013C   0xDBF6             BLT.N    ??BcMPilotStateCheck_17
   1299          	for ( j=DataCnt2; j<(DataCnt-1); j++ )
   \                     ??BcMPilotStateCheck_18:
   \   0000013E   0x4616             MOV      R6,R2
   \   00000140   0xB2C9             UXTB     R1,R1
   \   00000142   0x1E4F             SUBS     R7,R1,#+1
   \   00000144   0x42BA             CMP      R2,R7
   \   00000146   0xBFBF             ITTTT    LT 
   \   00000148   0xEBA6 0x0E02      SUBLT    LR,R6,R2
   \   0000014C   0xEB06 0x0800      ADDLT    R8,R6,R0
   \   00000150   0xF1A3 0x0901      SUBLT    R9,R3,#+1
   \   00000154   0x42BE             CMPLT    R6,R7
   \   00000156   0xDA18             BGE.N    ??BcMPilotStateCheck_19
   1300          	{
   1301          		for ( Power=1,pw = (j - DataCnt2) ; pw < (i - 1); pw++ ) Power =  Power * 10;
   \                     ??BcMPilotStateCheck_20:
   \   00000158   0x2201             MOVS     R2,#+1
   \   0000015A   0x45CE             CMP      LR,R9
   \   0000015C   0xBFBC             ITT      LT 
   \   0000015E   0xFA5F 0xF38E      UXTBLT   R3,LR
   \   00000162   0x454B             CMPLT    R3,R9
   \   00000164   0xDA07             BGE.N    ??BcMPilotStateCheck_21
   \                     ??BcMPilotStateCheck_22:
   \   00000166   0xEB02 0x0A82      ADD      R10,R2,R2, LSL #+2
   \   0000016A   0xEA4F 0x024A      LSL      R2,R10,#+1
   \   0000016E   0x1C5B             ADDS     R3,R3,#+1
   \   00000170   0xB2DB             UXTB     R3,R3
   \   00000172   0x454B             CMP      R3,R9
   \   00000174   0xDBF7             BLT.N    ??BcMPilotStateCheck_22
   1302          		TempCopy = TempCopy + (DataBuff[j]-'0')*Power;
   \                     ??BcMPilotStateCheck_21:
   \   00000176   0xF818 0x3B01      LDRB     R3,[R8], #+1
   \   0000017A   0x3B30             SUBS     R3,R3,#+48
   \   0000017C   0xFB02 0x5503      MLA      R5,R2,R3,R5
   1303          	}
   \   00000180   0x1C76             ADDS     R6,R6,#+1
   \   00000182   0xF10E 0x0E01      ADD      LR,LR,#+1
   \   00000186   0x42BE             CMP      R6,R7
   \   00000188   0xDBE6             BLT.N    ??BcMPilotStateCheck_20
   1304          	BcMPilotStatus->PN_Vaule[1] = TempCopy;;
   \                     ??BcMPilotStateCheck_19:
   \   0000018A   0x8065             STRH     R5,[R4, #+2]
   1305          
   1306          	{
   1307          		
   1308           		if (DataBuff[DataCnt] == '-' )DataCnt++;
   \   0000018C   0x5C0A             LDRB     R2,[R1, R0]
   \   0000018E   0x2A2D             CMP      R2,#+45
   \   00000190   0xBF08             IT       EQ 
   \   00000192   0x1C49             ADDEQ    R1,R1,#+1
   1309          
   1310          		DataCnt2 = DataCnt;
   \   00000194   0xB2C9             UXTB     R1,R1
   \   00000196   0x460A             MOV      R2,R1
   1311          		TempCopy = 0;
   \   00000198   0x2500             MOVS     R5,#+0
   1312          		k = DataCnt;
   \   0000019A   0x460F             MOV      R7,R1
   1313           
   1314          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   \   0000019C   0x230A             MOVS     R3,#+10
   \                     ??BcMPilotStateCheck_23:
   \   0000019E   0x1C4E             ADDS     R6,R1,#+1
   \   000001A0   0xB2C9             UXTB     R1,R1
   \   000001A2   0x5C09             LDRB     R1,[R1, R0]
   \   000001A4   0x292C             CMP      R1,#+44
   \   000001A6   0x4631             MOV      R1,R6
   \   000001A8   0xD001             BEQ.N    ??BcMPilotStateCheck_24
   \   000001AA   0x1E5B             SUBS     R3,R3,#+1
   \   000001AC   0xD1F7             BNE.N    ??BcMPilotStateCheck_23
   1315          		for ( i=0; i<10; i++ ) if ( DataBuff[k++] == '.' ) break;
   \                     ??BcMPilotStateCheck_24:
   \   000001AE   0x2300             MOVS     R3,#+0
   \                     ??BcMPilotStateCheck_25:
   \   000001B0   0x1C7E             ADDS     R6,R7,#+1
   \   000001B2   0xB2FF             UXTB     R7,R7
   \   000001B4   0x5C3F             LDRB     R7,[R7, R0]
   \   000001B6   0x2F2E             CMP      R7,#+46
   \   000001B8   0x4637             MOV      R7,R6
   \   000001BA   0xD002             BEQ.N    ??BcMPilotStateCheck_26
   \   000001BC   0x1C5B             ADDS     R3,R3,#+1
   \   000001BE   0x2B0A             CMP      R3,#+10
   \   000001C0   0xDBF6             BLT.N    ??BcMPilotStateCheck_25
   1316          		if(i>(DataCnt-DataCnt2)) {k=DataCnt; i=DataCnt-DataCnt2-1;}				// 130304
   \                     ??BcMPilotStateCheck_26:
   \   000001C2   0xB2C9             UXTB     R1,R1
   \   000001C4   0x1A8E             SUBS     R6,R1,R2
   \   000001C6   0x429E             CMP      R6,R3
   \   000001C8   0xDA03             BGE.N    ??BcMPilotStateCheck_27
   \   000001CA   0x460F             MOV      R7,R1
   \   000001CC   0x1A8B             SUBS     R3,R1,R2
   \   000001CE   0x1E5B             SUBS     R3,R3,#+1
   \   000001D0   0xB2DB             UXTB     R3,R3
   1317          
   1318          		
   1319          
   1320          		for ( j = DataCnt2; j < (k-1); j++ )
   \                     ??BcMPilotStateCheck_27:
   \   000001D2   0x4616             MOV      R6,R2
   \   000001D4   0xB2FF             UXTB     R7,R7
   \   000001D6   0x1E7F             SUBS     R7,R7,#+1
   \   000001D8   0x42BA             CMP      R2,R7
   \   000001DA   0xBFBF             ITTTT    LT 
   \   000001DC   0xEBA6 0x0C02      SUBLT    R12,R6,R2
   \   000001E0   0xEB06 0x0E00      ADDLT    LR,R6,R0
   \   000001E4   0xF1A3 0x0801      SUBLT    R8,R3,#+1
   \   000001E8   0x42BE             CMPLT    R6,R7
   \   000001EA   0xDA18             BGE.N    ??BcMPilotStateCheck_28
   1321          		{
   1322           			for ( Power=1,pw = (j - DataCnt2) ; pw < (i - 1); pw++ ) Power =  Power * 10;
   \                     ??BcMPilotStateCheck_29:
   \   000001EC   0x2201             MOVS     R2,#+1
   \   000001EE   0x45C4             CMP      R12,R8
   \   000001F0   0xBFBC             ITT      LT 
   \   000001F2   0xFA5F 0xF38C      UXTBLT   R3,R12
   \   000001F6   0x4543             CMPLT    R3,R8
   \   000001F8   0xDA07             BGE.N    ??BcMPilotStateCheck_30
   \                     ??BcMPilotStateCheck_31:
   \   000001FA   0xEB02 0x0982      ADD      R9,R2,R2, LSL #+2
   \   000001FE   0xEA4F 0x0249      LSL      R2,R9,#+1
   \   00000202   0x1C5B             ADDS     R3,R3,#+1
   \   00000204   0xB2DB             UXTB     R3,R3
   \   00000206   0x4543             CMP      R3,R8
   \   00000208   0xDBF7             BLT.N    ??BcMPilotStateCheck_31
   1323          			TempCopy = TempCopy + (DataBuff[j]-'0')*Power;
   \                     ??BcMPilotStateCheck_30:
   \   0000020A   0xF81E 0x3B01      LDRB     R3,[LR], #+1
   \   0000020E   0x3B30             SUBS     R3,R3,#+48
   \   00000210   0xFB02 0x5503      MLA      R5,R2,R3,R5
   1324            		}
   \   00000214   0x1C76             ADDS     R6,R6,#+1
   \   00000216   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   0000021A   0x42BE             CMP      R6,R7
   \   0000021C   0xDBE6             BLT.N    ??BcMPilotStateCheck_29
   1325          		BcMPilotStatus->EcIo[1] = TempCopy;;
   \                     ??BcMPilotStateCheck_28:
   \   0000021E   0x8165             STRH     R5,[R4, #+10]
   1326          
   1327           		DataCnt2 = DataCnt;
   \   00000220   0x460A             MOV      R2,R1
   1328          		TempCopy = 0;
   \   00000222   0x2500             MOVS     R5,#+0
   1329          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   \   00000224   0x2300             MOVS     R3,#+0
   \                     ??BcMPilotStateCheck_32:
   \   00000226   0x1C4E             ADDS     R6,R1,#+1
   \   00000228   0xB2C9             UXTB     R1,R1
   \   0000022A   0x5C09             LDRB     R1,[R1, R0]
   \   0000022C   0x292C             CMP      R1,#+44
   \   0000022E   0x4631             MOV      R1,R6
   \   00000230   0xD002             BEQ.N    ??BcMPilotStateCheck_33
   \   00000232   0x1C5B             ADDS     R3,R3,#+1
   \   00000234   0x2B0A             CMP      R3,#+10
   \   00000236   0xDBF6             BLT.N    ??BcMPilotStateCheck_32
   1330          
   1331          
   1332          		for ( j=DataCnt2; j<(DataCnt-1); j++ )
   \                     ??BcMPilotStateCheck_33:
   \   00000238   0x4616             MOV      R6,R2
   \   0000023A   0xB2C9             UXTB     R1,R1
   \   0000023C   0x1E4F             SUBS     R7,R1,#+1
   \   0000023E   0x42BA             CMP      R2,R7
   \   00000240   0xBFBF             ITTTT    LT 
   \   00000242   0xEBA6 0x0E02      SUBLT    LR,R6,R2
   \   00000246   0xEB06 0x0800      ADDLT    R8,R6,R0
   \   0000024A   0xF1A3 0x0901      SUBLT    R9,R3,#+1
   \   0000024E   0x42BE             CMPLT    R6,R7
   \   00000250   0xDA18             BGE.N    ??BcMPilotStateCheck_34
   1333          		{
   1334          			for ( Power=1,pw = (j - DataCnt2) ; pw < (i - 1); pw++ ) Power =  Power * 10;
   \                     ??BcMPilotStateCheck_35:
   \   00000252   0x2201             MOVS     R2,#+1
   \   00000254   0x45CE             CMP      LR,R9
   \   00000256   0xBFBC             ITT      LT 
   \   00000258   0xFA5F 0xF38E      UXTBLT   R3,LR
   \   0000025C   0x454B             CMPLT    R3,R9
   \   0000025E   0xDA07             BGE.N    ??BcMPilotStateCheck_36
   \                     ??BcMPilotStateCheck_37:
   \   00000260   0xEB02 0x0A82      ADD      R10,R2,R2, LSL #+2
   \   00000264   0xEA4F 0x024A      LSL      R2,R10,#+1
   \   00000268   0x1C5B             ADDS     R3,R3,#+1
   \   0000026A   0xB2DB             UXTB     R3,R3
   \   0000026C   0x454B             CMP      R3,R9
   \   0000026E   0xDBF7             BLT.N    ??BcMPilotStateCheck_37
   1335           			TempCopy = TempCopy + (DataBuff[j]-'0')*Power;
   \                     ??BcMPilotStateCheck_36:
   \   00000270   0xF818 0x3B01      LDRB     R3,[R8], #+1
   \   00000274   0x3B30             SUBS     R3,R3,#+48
   \   00000276   0xFB02 0x5503      MLA      R5,R2,R3,R5
   1336           		}
   \   0000027A   0x1C76             ADDS     R6,R6,#+1
   \   0000027C   0xF10E 0x0E01      ADD      LR,LR,#+1
   \   00000280   0x42BE             CMP      R6,R7
   \   00000282   0xDBE6             BLT.N    ??BcMPilotStateCheck_35
   1337          		BcMPilotStatus->PN_Vaule[2] = (INT8U )TempCopy;;
   \                     ??BcMPilotStateCheck_34:
   \   00000284   0xB2ED             UXTB     R5,R5
   \   00000286   0x80A5             STRH     R5,[R4, #+4]
   1338           	}
   1339          
   1340          	
   1341           	if (DataBuff[DataCnt] == '-' )DataCnt++;
   \   00000288   0x5C0A             LDRB     R2,[R1, R0]
   \   0000028A   0x2A2D             CMP      R2,#+45
   \   0000028C   0xBF08             IT       EQ 
   \   0000028E   0x1C49             ADDEQ    R1,R1,#+1
   1342          
   1343          	DataCnt2 = DataCnt;
   \   00000290   0xB2C9             UXTB     R1,R1
   \   00000292   0x460A             MOV      R2,R1
   1344          	TempCopy = 0;
   \   00000294   0x2500             MOVS     R5,#+0
   1345          	k = DataCnt;		
   \   00000296   0x460F             MOV      R7,R1
   1346          
   1347          	for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   \   00000298   0x230A             MOVS     R3,#+10
   \                     ??BcMPilotStateCheck_38:
   \   0000029A   0x1C4E             ADDS     R6,R1,#+1
   \   0000029C   0xB2C9             UXTB     R1,R1
   \   0000029E   0x5C09             LDRB     R1,[R1, R0]
   \   000002A0   0x292C             CMP      R1,#+44
   \   000002A2   0x4631             MOV      R1,R6
   \   000002A4   0xD001             BEQ.N    ??BcMPilotStateCheck_39
   \   000002A6   0x1E5B             SUBS     R3,R3,#+1
   \   000002A8   0xD1F7             BNE.N    ??BcMPilotStateCheck_38
   1348          	for ( i=0; i<10; i++ ) if ( DataBuff[k++] == '.' ) break;
   \                     ??BcMPilotStateCheck_39:
   \   000002AA   0x2300             MOVS     R3,#+0
   \                     ??BcMPilotStateCheck_40:
   \   000002AC   0x1C7E             ADDS     R6,R7,#+1
   \   000002AE   0xB2FF             UXTB     R7,R7
   \   000002B0   0x5C3F             LDRB     R7,[R7, R0]
   \   000002B2   0x2F2E             CMP      R7,#+46
   \   000002B4   0x4637             MOV      R7,R6
   \   000002B6   0xD002             BEQ.N    ??BcMPilotStateCheck_41
   \   000002B8   0x1C5B             ADDS     R3,R3,#+1
   \   000002BA   0x2B0A             CMP      R3,#+10
   \   000002BC   0xDBF6             BLT.N    ??BcMPilotStateCheck_40
   1349          	if(i>(DataCnt-DataCnt2)) {k=DataCnt; i=DataCnt-DataCnt2-1;} 			// 130304
   \                     ??BcMPilotStateCheck_41:
   \   000002BE   0xB2C9             UXTB     R1,R1
   \   000002C0   0x1A8E             SUBS     R6,R1,R2
   \   000002C2   0x429E             CMP      R6,R3
   \   000002C4   0xDA03             BGE.N    ??BcMPilotStateCheck_42
   \   000002C6   0x460F             MOV      R7,R1
   \   000002C8   0x1A8B             SUBS     R3,R1,R2
   \   000002CA   0x1E5B             SUBS     R3,R3,#+1
   \   000002CC   0xB2DB             UXTB     R3,R3
   1350           
   1351          	for ( j = DataCnt2; j < (k-1); j++ )
   \                     ??BcMPilotStateCheck_42:
   \   000002CE   0x4616             MOV      R6,R2
   \   000002D0   0xB2FF             UXTB     R7,R7
   \   000002D2   0x1E7F             SUBS     R7,R7,#+1
   \   000002D4   0x42BA             CMP      R2,R7
   \   000002D6   0xBFBF             ITTTT    LT 
   \   000002D8   0xEBA6 0x0C02      SUBLT    R12,R6,R2
   \   000002DC   0xEB06 0x0E00      ADDLT    LR,R6,R0
   \   000002E0   0xF1A3 0x0801      SUBLT    R8,R3,#+1
   \   000002E4   0x42BE             CMPLT    R6,R7
   \   000002E6   0xDA18             BGE.N    ??BcMPilotStateCheck_43
   1352          	{
   1353          		for ( Power=1,pw = (j - DataCnt2) ; pw < (i - 1); pw++ ) Power =  Power * 10;
   \                     ??BcMPilotStateCheck_44:
   \   000002E8   0x2201             MOVS     R2,#+1
   \   000002EA   0x45C4             CMP      R12,R8
   \   000002EC   0xBFBC             ITT      LT 
   \   000002EE   0xFA5F 0xF38C      UXTBLT   R3,R12
   \   000002F2   0x4543             CMPLT    R3,R8
   \   000002F4   0xDA07             BGE.N    ??BcMPilotStateCheck_45
   \                     ??BcMPilotStateCheck_46:
   \   000002F6   0xEB02 0x0982      ADD      R9,R2,R2, LSL #+2
   \   000002FA   0xEA4F 0x0249      LSL      R2,R9,#+1
   \   000002FE   0x1C5B             ADDS     R3,R3,#+1
   \   00000300   0xB2DB             UXTB     R3,R3
   \   00000302   0x4543             CMP      R3,R8
   \   00000304   0xDBF7             BLT.N    ??BcMPilotStateCheck_46
   1354          		TempCopy = TempCopy + (DataBuff[j]-'0')*Power;
   \                     ??BcMPilotStateCheck_45:
   \   00000306   0xF81E 0x3B01      LDRB     R3,[LR], #+1
   \   0000030A   0x3B30             SUBS     R3,R3,#+48
   \   0000030C   0xFB02 0x5503      MLA      R5,R2,R3,R5
   1355          	}
   \   00000310   0x1C76             ADDS     R6,R6,#+1
   \   00000312   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   00000316   0x42BE             CMP      R6,R7
   \   00000318   0xDBE6             BLT.N    ??BcMPilotStateCheck_44
   1356          	BcMPilotStatus->EcIo[2] = TempCopy;
   \                     ??BcMPilotStateCheck_43:
   \   0000031A   0x81A5             STRH     R5,[R4, #+12]
   1357          
   1358          	DataCnt2 = DataCnt;
   \   0000031C   0x460A             MOV      R2,R1
   1359          	TempCopy = 0;
   \   0000031E   0x2500             MOVS     R5,#+0
   1360          
   1361          	for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   \   00000320   0x2300             MOVS     R3,#+0
   \                     ??BcMPilotStateCheck_47:
   \   00000322   0x1C4E             ADDS     R6,R1,#+1
   \   00000324   0xB2C9             UXTB     R1,R1
   \   00000326   0x5C09             LDRB     R1,[R1, R0]
   \   00000328   0x292C             CMP      R1,#+44
   \   0000032A   0x4631             MOV      R1,R6
   \   0000032C   0xD002             BEQ.N    ??BcMPilotStateCheck_48
   \   0000032E   0x1C5B             ADDS     R3,R3,#+1
   \   00000330   0x2B0A             CMP      R3,#+10
   \   00000332   0xDBF6             BLT.N    ??BcMPilotStateCheck_47
   1362          
   1363          	for ( j=DataCnt2; j<(DataCnt-1); j++ )
   \                     ??BcMPilotStateCheck_48:
   \   00000334   0x4616             MOV      R6,R2
   \   00000336   0xB2C9             UXTB     R1,R1
   \   00000338   0x1E4F             SUBS     R7,R1,#+1
   \   0000033A   0x4696             MOV      LR,R2
   \   0000033C   0x45BE             CMP      LR,R7
   \   0000033E   0xBFBF             ITTTT    LT 
   \   00000340   0xEBA6 0x0E02      SUBLT    LR,R6,R2
   \   00000344   0xEB06 0x0800      ADDLT    R8,R6,R0
   \   00000348   0xF1A3 0x0901      SUBLT    R9,R3,#+1
   \   0000034C   0x42BE             CMPLT    R6,R7
   \   0000034E   0xDA18             BGE.N    ??BcMPilotStateCheck_49
   1364          	{
   1365          		for ( Power=1,pw = (j - DataCnt2) ; pw < (i - 1); pw++ ) Power =  Power * 10;
   \                     ??BcMPilotStateCheck_50:
   \   00000350   0x2201             MOVS     R2,#+1
   \   00000352   0x45CE             CMP      LR,R9
   \   00000354   0xBFBC             ITT      LT 
   \   00000356   0xFA5F 0xF38E      UXTBLT   R3,LR
   \   0000035A   0x454B             CMPLT    R3,R9
   \   0000035C   0xDA07             BGE.N    ??BcMPilotStateCheck_51
   \                     ??BcMPilotStateCheck_52:
   \   0000035E   0xEB02 0x0A82      ADD      R10,R2,R2, LSL #+2
   \   00000362   0xEA4F 0x024A      LSL      R2,R10,#+1
   \   00000366   0x1C5B             ADDS     R3,R3,#+1
   \   00000368   0xB2DB             UXTB     R3,R3
   \   0000036A   0x454B             CMP      R3,R9
   \   0000036C   0xDBF7             BLT.N    ??BcMPilotStateCheck_52
   1366          		TempCopy = TempCopy + (DataBuff[j]-'0')*Power;
   \                     ??BcMPilotStateCheck_51:
   \   0000036E   0xF818 0x3B01      LDRB     R3,[R8], #+1
   \   00000372   0x3B30             SUBS     R3,R3,#+48
   \   00000374   0xFB02 0x5503      MLA      R5,R2,R3,R5
   1367          	}
   \   00000378   0x1C76             ADDS     R6,R6,#+1
   \   0000037A   0xF10E 0x0E01      ADD      LR,LR,#+1
   \   0000037E   0x42BE             CMP      R6,R7
   \   00000380   0xDBE6             BLT.N    ??BcMPilotStateCheck_50
   1368          
   1369          	BcMPilotStatus->PN_Vaule[3] = TempCopy;
   \                     ??BcMPilotStateCheck_49:
   \   00000382   0x80E5             STRH     R5,[R4, #+6]
   1370          
   1371           // EcIO 3	
   1372          	if (DataBuff[DataCnt] == '-' )DataCnt++;
   \   00000384   0x5C0A             LDRB     R2,[R1, R0]
   \   00000386   0x2A2D             CMP      R2,#+45
   \   00000388   0xBF08             IT       EQ 
   \   0000038A   0x1C49             ADDEQ    R1,R1,#+1
   1373          
   1374          	DataCnt2 = DataCnt;
   \   0000038C   0xB2C9             UXTB     R1,R1
   \   0000038E   0x460A             MOV      R2,R1
   1375          	TempCopy = 0;
   \   00000390   0x2500             MOVS     R5,#+0
   1376          	k = DataCnt;		
   \   00000392   0x460E             MOV      R6,R1
   1377          
   1378          	for ( i=0; i<10; i++ )
   \   00000394   0x230A             MOVS     R3,#+10
   1379          	{
   1380          		uTemp = DataBuff[DataCnt++];
   \                     ??BcMPilotStateCheck_53:
   \   00000396   0xB2C9             UXTB     R1,R1
   \   00000398   0x5C0F             LDRB     R7,[R1, R0]
   \   0000039A   0x1C49             ADDS     R1,R1,#+1
   1381          		if ((uTemp == ',') || (uTemp == NULL)|| (uTemp == 0x0d))	break;		// 130304
   \   0000039C   0x2F2C             CMP      R7,#+44
   \   0000039E   0xBF18             IT       NE 
   \   000003A0   0x2F00             CMPNE    R7,#+0
   \   000003A2   0xBF18             IT       NE 
   \   000003A4   0x2F0D             CMPNE    R7,#+13
   \   000003A6   0xD001             BEQ.N    ??BcMPilotStateCheck_54
   1382          	}
   \   000003A8   0x1E5B             SUBS     R3,R3,#+1
   \   000003AA   0xD1F4             BNE.N    ??BcMPilotStateCheck_53
   1383          	for ( i=0; i<10; i++ ) if ( DataBuff[k++] == '.' ) break;
   \                     ??BcMPilotStateCheck_54:
   \   000003AC   0x2300             MOVS     R3,#+0
   \                     ??BcMPilotStateCheck_55:
   \   000003AE   0x1C77             ADDS     R7,R6,#+1
   \   000003B0   0xB2F6             UXTB     R6,R6
   \   000003B2   0x5C36             LDRB     R6,[R6, R0]
   \   000003B4   0x2E2E             CMP      R6,#+46
   \   000003B6   0x463E             MOV      R6,R7
   \   000003B8   0xD002             BEQ.N    ??BcMPilotStateCheck_56
   \   000003BA   0x1C5B             ADDS     R3,R3,#+1
   \   000003BC   0x2B0A             CMP      R3,#+10
   \   000003BE   0xDBF6             BLT.N    ??BcMPilotStateCheck_55
   1384          	if(i>(DataCnt-DataCnt2))	{k=DataCnt; i=DataCnt-DataCnt2-1;}				// 130304
   \                     ??BcMPilotStateCheck_56:
   \   000003C0   0xB2C9             UXTB     R1,R1
   \   000003C2   0x1A8F             SUBS     R7,R1,R2
   \   000003C4   0x429F             CMP      R7,R3
   \   000003C6   0xDA03             BGE.N    ??BcMPilotStateCheck_57
   \   000003C8   0x460E             MOV      R6,R1
   \   000003CA   0x1A89             SUBS     R1,R1,R2
   \   000003CC   0x1E4B             SUBS     R3,R1,#+1
   \   000003CE   0xB2DB             UXTB     R3,R3
   1385          
   1386          
   1387          	for ( j = DataCnt2; j < (k-1); j++ )
   \                     ??BcMPilotStateCheck_57:
   \   000003D0   0x4611             MOV      R1,R2
   \   000003D2   0xB2F6             UXTB     R6,R6
   \   000003D4   0x1E76             SUBS     R6,R6,#+1
   \   000003D6   0x42B2             CMP      R2,R6
   \   000003D8   0xBFBF             ITTTT    LT 
   \   000003DA   0x2700             MOVLT    R7,#+0
   \   000003DC   0x1808             ADDLT    R0,R1,R0
   \   000003DE   0xF1A3 0x0C01      SUBLT    R12,R3,#+1
   \   000003E2   0x42B1             CMPLT    R1,R6
   \   000003E4   0xDA16             BGE.N    ??BcMPilotStateCheck_58
   1388          	{
   1389          		for ( Power=1,pw = (j - DataCnt2) ; pw < (i - 1); pw++ ) Power =  Power * 10;
   \                     ??BcMPilotStateCheck_59:
   \   000003E6   0x2201             MOVS     R2,#+1
   \   000003E8   0x4567             CMP      R7,R12
   \   000003EA   0xBFBC             ITT      LT 
   \   000003EC   0xB2FB             UXTBLT   R3,R7
   \   000003EE   0x4563             CMPLT    R3,R12
   \   000003F0   0xDA07             BGE.N    ??BcMPilotStateCheck_60
   \                     ??BcMPilotStateCheck_61:
   \   000003F2   0xEB02 0x0E82      ADD      LR,R2,R2, LSL #+2
   \   000003F6   0xEA4F 0x024E      LSL      R2,LR,#+1
   \   000003FA   0x1C5B             ADDS     R3,R3,#+1
   \   000003FC   0xB2DB             UXTB     R3,R3
   \   000003FE   0x4563             CMP      R3,R12
   \   00000400   0xDBF7             BLT.N    ??BcMPilotStateCheck_61
   1390          		TempCopy = TempCopy + (DataBuff[j]-'0')*Power;
   \                     ??BcMPilotStateCheck_60:
   \   00000402   0xF810 0x3B01      LDRB     R3,[R0], #+1
   \   00000406   0x3B30             SUBS     R3,R3,#+48
   \   00000408   0xFB02 0x5503      MLA      R5,R2,R3,R5
   1391          	}
   \   0000040C   0x1C49             ADDS     R1,R1,#+1
   \   0000040E   0x1C7F             ADDS     R7,R7,#+1
   \   00000410   0x42B1             CMP      R1,R6
   \   00000412   0xDBE8             BLT.N    ??BcMPilotStateCheck_59
   1392          	BcMPilotStatus->EcIo[3] = TempCopy;;
   \                     ??BcMPilotStateCheck_58:
   \   00000414   0x81E5             STRH     R5,[R4, #+14]
   1393            	return(TRUE);
   \   00000416   0x2001             MOVS     R0,#+1
   \   00000418   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   1394          }
   1395          
   1396          

   \                                 In section .text, align 2, keep-with-next
   1397          INT32S BcMdemTcpConnect(INT8U *ConnectIP, INT8U IPLen, INT32U PortNum)
   1398          {
   \                     BcMdemTcpConnect:
   \   00000000   0xE92D 0x4FF7      PUSH     {R0-R2,R4-R11,LR}
   \   00000004   0x4683             MOV      R11,R0
   1399              INT8U CmdStep = 0,result = 0;
   1400          	INT8U CmdStepCnt = 0;
   \   00000006   0x2500             MOVS     R5,#+0
   1401          
   1402          	INT8U Tmp = FALSE;
   \   00000008   0x2600             MOVS     R6,#+0
   1403          
   1404          	CmdStep = ModemTcpModeCmd;
   \   0000000A   0x270B             MOVS     R7,#+11
   \   0000000C   0x.... 0x....      ADR.W    R8,`?<Constant "%s%s,%d">`
   \   00000010   0x.... 0x....      ADR.W    R9,`?<Constant "AT$TCPOPEN=">`
   \   00000014   0x.... 0x....      LDR.W    R10,??DataTable89_1
   \   00000018   0x.... 0x....      ADR.W    R0,`?<Constant "AT+CRM=251">`
   \   0000001C   0xE004             B.N      ??BcMdemTcpConnect_0
   1405          	
   1406          TCP_INIT_SEQUENCE : 
   1407          
   1408          	if( CmdStepCnt > 4) return FALSE;
   1409          
   1410          	switch(CmdStep)
   1411          	{
   1412          		case ModemTcpModeCmd: 	BcMdemXmit(CdmaModemTcpModeCmd); 	result = 0; break;
   1413          		case ModemTcpIdCmd: 	BcMdemXmit(CdmaModemTcpIdCmd); 		result = 0; break;
   \                     ??BcMdemTcpConnect_1:
   \   0000001E   0x.... 0x....      ADR.W    R0,`?<Constant "AT$TCPUID=SKTELECOM">`
   \   00000022   0xE001             B.N      ??BcMdemTcpConnect_0
   1414          		case ModemTcpPwCmd: 	BcMdemXmit(CdmaModemTcpPwCmd); 		result = 0; break;
   \                     ??BcMdemTcpConnect_2:
   \   00000024   0x.... 0x....      ADR.W    R0,`?<Constant "AT$TCPPASSWDNULL">`
   \                     ??BcMdemTcpConnect_0:
   \   00000028   0x.... 0x....      BL       BcMdemXmit
   \   0000002C   0x2400             MOVS     R4,#+0
   \   0000002E   0xE018             B.N      ??BcMdemTcpConnect_3
   1415          		case ModemTcpConnect: 	BcMdemXmit(CdmaModemTcpConnect); 	result = 1; break;
   \                     ??BcMdemTcpConnect_4:
   \   00000030   0x.... 0x....      ADR.W    R0,`?<Constant "ATD1501">`
   \   00000034   0x.... 0x....      BL       BcMdemXmit
   \   00000038   0x2401             MOVS     R4,#+1
   \   0000003A   0xE012             B.N      ??BcMdemTcpConnect_3
   1416          		case ModemTcpOpenCmd: 	
   1417          
   1418          			ConnectIP[IPLen] = 0; //Insert Null
   \                     ??BcMdemTcpConnect_5:
   \   0000003C   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0xF800 0x100B      STRB     R1,[R0, R11]
   1419          			sprintf((char *)TxCdmaData, "%s%s,%d", CdmaModemTcpOpenCmd,ConnectIP, PortNum);
   \   00000046   0xF20A 0x4404      ADDW     R4,R10,#+1028
   \   0000004A   0x9802             LDR      R0,[SP, #+8]
   \   0000004C   0x9000             STR      R0,[SP, #+0]
   \   0000004E   0x465B             MOV      R3,R11
   \   00000050   0x464A             MOV      R2,R9
   \   00000052   0x4641             MOV      R1,R8
   \   00000054   0x4620             MOV      R0,R4
   \   00000056   0x.... 0x....      BL       sprintf
   1420          			BcMdemXmit((INT8U *)TxCdmaData);
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x.... 0x....      BL       BcMdemXmit
   1421          	
   1422          			result = 2; 
   \   00000060   0x2402             MOVS     R4,#+2
   1423          		break;
   1424          	}
   1425          	OSTimeDly(500L);
   \                     ??BcMdemTcpConnect_3:
   \   00000062   0xF44F 0x70FA      MOV      R0,#+500
   \   00000066   0x.... 0x....      BL       OSTimeDly
   1426          	CmdStepCnt++;
   \   0000006A   0x1C6D             ADDS     R5,R5,#+1
   1427          	switch(result)
   \   0000006C   0xB11C             CBZ.N    R4,??BcMdemTcpConnect_6
   \   0000006E   0x2C02             CMP      R4,#+2
   \   00000070   0xD025             BEQ.N    ??BcMdemTcpConnect_7
   \   00000072   0xD30C             BCC.N    ??BcMdemTcpConnect_8
   \   00000074   0xE037             B.N      ??BcMdemTcpConnect_9
   1428          	{
   1429          		case 0:
   1430          			if(BcMdemSyncProtocolCheck())
   \                     ??BcMdemTcpConnect_6:
   \   00000076   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   0000007A   0xB120             CBZ.N    R0,??BcMdemTcpConnect_10
   1431          			{
   1432          				if(BcMdemSyncCheck((char *)RxCdmaData) != 14)return FALSE;
   \   0000007C   0x4650             MOV      R0,R10
   \   0000007E   0x.... 0x....      BL       BcMdemSyncCheck
   \   00000082   0x280E             CMP      R0,#+14
   \   00000084   0xD02D             BEQ.N    ??BcMdemTcpConnect_11
   1433          			}
   1434          			else return FALSE;
   1435          			CmdStepCnt = 0;		
   1436          			Tmp = TRUE;
   1437          		break;
   1438          
   1439          		case 1:
   1440          			if(BcMdemSyncProtocolCheck())
   1441          			{	
   1442          				if(BcMdemSyncCheck((char *)RxCdmaData) == 11)
   1443          				{
   1444          					Tmp = TRUE;
   1445          					break;  		//"CONNECT"	
   1446          				}
   1447          				if(BcMdemSyncCheck((char *)RxCdmaData) != 14)return FALSE; 	//"OK"
   1448          			}
   1449          			else return FALSE;
   1450          			
   1451          			if(BcMdemSyncProtocolCheck())
   1452          			{
   1453          				if(BcMdemSyncCheck((char *)RxCdmaData) != 11)return FALSE;
   1454          			}
   1455          			else return FALSE;
   1456          			CmdStepCnt = 0;		
   1457          			Tmp = TRUE;
   1458          		break;
   1459          
   1460          		case 2:
   1461          			if(BcMdemSyncProtocolCheck())
   1462          			{
   1463          				if(BcMdemSyncCheck((char *)RxCdmaData) != 14)return FALSE;
   1464          			}
   1465          			else return FALSE;
   1466          			
   1467          			if(BcMdemSyncProtocolCheck())
   1468          			{	
   1469          				if(BcMdemSyncCheck((char *)RxCdmaData) != 18)return FALSE;
   1470          				
   1471          			}
   1472          			else return FALSE;
   \                     ??BcMdemTcpConnect_10:
   \   00000086   0x2000             MOVS     R0,#+0
   \                     ??BcMdemTcpConnect_12:
   \   00000088   0xB003             ADD      SP,SP,#+12
   \   0000008A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??BcMdemTcpConnect_8:
   \   0000008E   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD0F7             BEQ.N    ??BcMdemTcpConnect_10
   \   00000096   0x4650             MOV      R0,R10
   \   00000098   0x.... 0x....      BL       BcMdemSyncCheck
   \   0000009C   0x280B             CMP      R0,#+11
   \   0000009E   0xD021             BEQ.N    ??BcMdemTcpConnect_13
   \   000000A0   0x4650             MOV      R0,R10
   \   000000A2   0x.... 0x....      BL       BcMdemSyncCheck
   \   000000A6   0x280E             CMP      R0,#+14
   \   000000A8   0xD1ED             BNE.N    ??BcMdemTcpConnect_10
   \   000000AA   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD0E9             BEQ.N    ??BcMdemTcpConnect_10
   \   000000B2   0x4650             MOV      R0,R10
   \   000000B4   0x.... 0x....      BL       BcMdemSyncCheck
   \   000000B8   0x280B             CMP      R0,#+11
   \   000000BA   0xD012             BEQ.N    ??BcMdemTcpConnect_11
   \   000000BC   0xE7E3             B.N      ??BcMdemTcpConnect_10
   \                     ??BcMdemTcpConnect_7:
   \   000000BE   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   000000C2   0x2800             CMP      R0,#+0
   \   000000C4   0xD0DF             BEQ.N    ??BcMdemTcpConnect_10
   \   000000C6   0x4650             MOV      R0,R10
   \   000000C8   0x.... 0x....      BL       BcMdemSyncCheck
   \   000000CC   0x280E             CMP      R0,#+14
   \   000000CE   0xD1DA             BNE.N    ??BcMdemTcpConnect_10
   \   000000D0   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD0D6             BEQ.N    ??BcMdemTcpConnect_10
   \   000000D8   0x4650             MOV      R0,R10
   \   000000DA   0x.... 0x....      BL       BcMdemSyncCheck
   \   000000DE   0x2812             CMP      R0,#+18
   \   000000E0   0xD1D1             BNE.N    ??BcMdemTcpConnect_10
   1473          			CmdStepCnt = 0;		
   \                     ??BcMdemTcpConnect_11:
   \   000000E2   0x2500             MOVS     R5,#+0
   1474          			Tmp = TRUE;
   \                     ??BcMdemTcpConnect_13:
   \   000000E4   0x2601             MOVS     R6,#+1
   1475          		break;
   1476          		
   1477          	}
   1478          
   1479          	if(CmdStep == ModemTcpOpenCmd)return TRUE;
   \                     ??BcMdemTcpConnect_9:
   \   000000E6   0x2F0F             CMP      R7,#+15
   \   000000E8   0xBF08             IT       EQ 
   \   000000EA   0x2001             MOVEQ    R0,#+1
   \   000000EC   0xD0CC             BEQ.N    ??BcMdemTcpConnect_12
   1480          //	CmdStep++;
   1481          	if(	Tmp == TRUE )	CmdStep++;
   \   000000EE   0x2E01             CMP      R6,#+1
   \   000000F0   0xBF08             IT       EQ 
   \   000000F2   0x1C7F             ADDEQ    R7,R7,#+1
   \   000000F4   0xB2ED             UXTB     R5,R5
   \   000000F6   0x2D05             CMP      R5,#+5
   \   000000F8   0xD2C5             BCS.N    ??BcMdemTcpConnect_10
   \   000000FA   0xB2FF             UXTB     R7,R7
   \   000000FC   0x2F0B             CMP      R7,#+11
   \   000000FE   0xD007             BEQ.N    ??BcMdemTcpConnect_14
   \   00000100   0xD3AF             BCC.N    ??BcMdemTcpConnect_3
   \   00000102   0x2F0D             CMP      R7,#+13
   \   00000104   0xD08E             BEQ.N    ??BcMdemTcpConnect_2
   \   00000106   0xD38A             BCC.N    ??BcMdemTcpConnect_1
   \   00000108   0x2F0F             CMP      R7,#+15
   \   0000010A   0xD097             BEQ.N    ??BcMdemTcpConnect_5
   \   0000010C   0xD390             BCC.N    ??BcMdemTcpConnect_4
   \   0000010E   0xE7A8             B.N      ??BcMdemTcpConnect_3
   \                     ??BcMdemTcpConnect_14:
   \   00000110   0x.... 0x....      ADR.W    R0,`?<Constant "AT+CRM=251">`
   \   00000114   0xE788             B.N      ??BcMdemTcpConnect_0
   1482          	goto TCP_INIT_SEQUENCE;
   1483          }
   1484          

   \                                 In section .text, align 2, keep-with-next
   1485          INT32S BcMdemTcpExit(void)
   1486          { 
   \                     BcMdemTcpExit:
   \   00000000   0xB510             PUSH     {R4,LR}
   1487          	INT8U nRet = TRUE;
   1488          	
   1489          	BcMdemXmit(CdmaModemTcpCloseCmd);
   \   00000002   0x.... 0x....      ADR.W    R0,`?<Constant "AT$TCPCLOSE">`
   \   00000006   0x.... 0x....      BL       BcMdemXmit
   1490          
   1491          	if(BcMdemSyncProtocolCheck())
   \   0000000A   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   0000000E   0xB398             CBZ.N    R0,??BcMdemTcpExit_0
   1492          	{
   1493          		if(BcMdemSyncCheck((char *)RxCdmaData) != 14)return 1;
   \   00000010   0x.... 0x....      LDR.W    R4,??DataTable89_1
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       BcMdemSyncCheck
   \   0000001A   0x280E             CMP      R0,#+14
   \   0000001C   0xD12A             BNE.N    ??BcMdemTcpExit_1
   1494          
   1495          	}
   1496          	else return FALSE;
   1497          	
   1498          	OSTimeDly(Time10mSec);
   \   0000001E   0x200A             MOVS     R0,#+10
   \   00000020   0x.... 0x....      BL       OSTimeDly
   1499          
   1500          	if(BcMdemSyncProtocolCheck())
   \   00000024   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   00000028   0xB330             CBZ.N    R0,??BcMdemTcpExit_0
   1501          	{
   1502          		if(BcMdemSyncCheck((char *)RxCdmaData) != 26)return 2;
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       BcMdemSyncCheck
   \   00000030   0x281A             CMP      R0,#+26
   \   00000032   0xD001             BEQ.N    ??BcMdemTcpExit_2
   \   00000034   0x2002             MOVS     R0,#+2
   \   00000036   0xBD10             POP      {R4,PC}
   1503          	}
   1504          	else return FALSE;
   1505          
   1506          	OSTimeDly(Time10mSec);
   \                     ??BcMdemTcpExit_2:
   \   00000038   0x200A             MOVS     R0,#+10
   \   0000003A   0x.... 0x....      BL       OSTimeDly
   1507          	
   1508          	BcMdemXmit(CdmaModemTcpExitCmd);
   \   0000003E   0x.... 0x....      ADR.W    R0,`?<Constant "AT$TCPEXIT">`
   \   00000042   0x.... 0x....      BL       BcMdemXmit
   1509          
   1510          	if(BcMdemSyncProtocolCheck())
   \   00000046   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   0000004A   0xB1A8             CBZ.N    R0,??BcMdemTcpExit_0
   1511          	{
   1512          		if(BcMdemSyncCheck((char *)RxCdmaData) != 14)return 3;
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x.... 0x....      BL       BcMdemSyncCheck
   \   00000052   0x280E             CMP      R0,#+14
   \   00000054   0xD001             BEQ.N    ??BcMdemTcpExit_3
   \   00000056   0x2003             MOVS     R0,#+3
   \   00000058   0xBD10             POP      {R4,PC}
   1513          	}
   1514          	else return FALSE;
   1515          
   1516          	OSTimeDly(Time10mSec);
   \                     ??BcMdemTcpExit_3:
   \   0000005A   0x200A             MOVS     R0,#+10
   \   0000005C   0x.... 0x....      BL       OSTimeDly
   1517          
   1518          	if(BcMdemSyncProtocolCheck())
   \   00000060   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   00000064   0xB140             CBZ.N    R0,??BcMdemTcpExit_0
   1519          	{
   1520          		if(BcMdemSyncCheck((char *)RxCdmaData) != 12)return 4;
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       BcMdemSyncCheck
   \   0000006C   0x280C             CMP      R0,#+12
   \   0000006E   0xD001             BEQ.N    ??BcMdemTcpExit_1
   \   00000070   0x2004             MOVS     R0,#+4
   \   00000072   0xBD10             POP      {R4,PC}
   1521          	}
   1522          	else return FALSE;
   1523          
   1524          	return nRet;
   \                     ??BcMdemTcpExit_1:
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xBD10             POP      {R4,PC}
   \                     ??BcMdemTcpExit_0:
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xBD10             POP      {R4,PC}          ;; return
   1525          }	
   1526          

   \                                 In section .text, align 2, keep-with-next
   1527          INT32S BcMdemSwReset(void)
   1528          { 
   \                     BcMdemSwReset:
   \   00000000   0xB510             PUSH     {R4,LR}
   1529          	INT8U nRet = TRUE;
   1530          	
   1531          	BcMdemXmit(CdmaModemSwRstCmd);
   \   00000002   0x.... 0x....      ADR.W    R0,`?<Constant "AT*SKT*RESET">`
   \   00000006   0x.... 0x....      BL       BcMdemXmit
   1532          
   1533          	if(BcMdemSyncProtocolCheck())
   \   0000000A   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   0000000E   0xB170             CBZ.N    R0,??BcMdemSwReset_0
   1534          	{
   1535          		if(BcMdemSyncCheck((char *)RxCdmaData) != 27)return FALSE;
   \   00000010   0x.... 0x....      LDR.W    R4,??DataTable89_1
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       BcMdemSyncCheck
   \   0000001A   0x281B             CMP      R0,#+27
   \   0000001C   0xD001             BEQ.N    ??BcMdemSwReset_1
   \                     ??BcMdemSwReset_2:
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBD10             POP      {R4,PC}
   1536          	}
   1537          	else return FALSE;
   1538          
   1539          	OSTimeDly(Time10mSec);
   \                     ??BcMdemSwReset_1:
   \   00000022   0x200A             MOVS     R0,#+10
   \   00000024   0x.... 0x....      BL       OSTimeDly
   1540          
   1541          	if(BcMdemSyncProtocolCheck())
   \   00000028   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   0000002C   0xB900             CBNZ.N   R0,??BcMdemSwReset_3
   \                     ??BcMdemSwReset_0:
   \   0000002E   0xBD10             POP      {R4,PC}          ;; return
   1542          	{
   1543          		if(BcMdemSyncCheck((char *)RxCdmaData) != 14)return FALSE;
   \                     ??BcMdemSwReset_3:
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       BcMdemSyncCheck
   \   00000036   0x280E             CMP      R0,#+14
   \   00000038   0xD1F1             BNE.N    ??BcMdemSwReset_2
   1544          	}
   1545          	else return FALSE;
   1546          
   1547          	return nRet;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0xBD10             POP      {R4,PC}
   1548          }	
   1549          
   1550          // RETRUN DEFINE
   1551          // -1 : *SKT*ORI Error
   1552          // -2 : OK Error
   1553          // -3 : *SKT*VCALL Error
   1554          // -4 : *SKT*VOICECONNECT Error
   1555          

   \                                 In section .text, align 2, keep-with-next
   1556          INT32S BcMdemCalling(char *DstTel)
   1557          { 
   \                     BcMdemCalling:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB099             SUB      SP,SP,#+100
   \   00000004   0x4604             MOV      R4,R0
   1558          	INT16U i = 0, j = 0;
   \   00000006   0x2500             MOVS     R5,#+0
   1559          	INT8U Ptr[100];
   1560          	INT32S nRet = TRUE;
   1561          	
   1562          	sprintf((char *)TxCdmaData, "%s%s", CdmaCallingCmd, DstTel);
   \   00000008   0x.... 0x....      LDR.W    R6,??DataTable89_1
   \   0000000C   0xF206 0x4704      ADDW     R7,R6,#+1028
   \   00000010   0x4623             MOV      R3,R4
   \   00000012   0x.... 0x....      ADR.W    R2,`?<Constant "AT*SKT*ORI=">`
   \   00000016   0x.... 0x....      ADR.W    R1,`?<Constant "%s%s">`
   \   0000001A   0x4638             MOV      R0,R7
   \   0000001C   0x.... 0x....      BL       sprintf
   1563          
   1564          	BcMdemXmit((INT8U *)TxCdmaData);
   \   00000020   0x4638             MOV      R0,R7
   \   00000022   0x.... 0x....      BL       BcMdemXmit
   1565          
   1566          	if(BcMdemSyncProtocolCheck()) // *SKT*ORI=
   \   00000026   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   0000002A   0xB150             CBZ.N    R0,??BcMdemCalling_0
   1567          	{
   1568          		if(BcMdemSyncCheck((char *)RxCdmaData) != 33)return -1; 
   \   0000002C   0x4630             MOV      R0,R6
   \   0000002E   0x.... 0x....      BL       BcMdemSyncCheck
   \   00000032   0x2821             CMP      R0,#+33
   \   00000034   0xD105             BNE.N    ??BcMdemCalling_0
   1569          	}
   1570          	else return -1;
   1571          
   1572          	if(BcMdemSyncProtocolCheck()) // OK
   \   00000036   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   0000003A   0xB928             CBNZ.N   R0,??BcMdemCalling_1
   1573          	{
   1574          		if(BcMdemSyncCheck((char *)RxCdmaData) != 14)return -2; 
   1575          	}
   1576          	else return -2;
   \                     ??BcMdemCalling_2:
   \   0000003C   0xF06F 0x0001      MVN      R0,#+1
   \   00000040   0xE033             B.N      ??BcMdemCalling_3
   \                     ??BcMdemCalling_0:
   \   00000042   0xF04F 0x30FF      MOV      R0,#-1
   \   00000046   0xE030             B.N      ??BcMdemCalling_3
   \                     ??BcMdemCalling_1:
   \   00000048   0x4630             MOV      R0,R6
   \   0000004A   0x.... 0x....      BL       BcMdemSyncCheck
   \   0000004E   0x280E             CMP      R0,#+14
   \   00000050   0xD1F4             BNE.N    ??BcMdemCalling_2
   1577          	
   1578          	if(BcMdemSyncProtocolCheck()) // *SKT*VCALL:
   \   00000052   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   00000056   0xB160             CBZ.N    R0,??BcMdemCalling_4
   1579          	{
   1580          		for(i = 0; i < strlen(RspmsgCallAck);i++)Ptr[i] = RxCdmaData[i];
   \   00000058   0x220B             MOVS     R2,#+11
   \   0000005A   0x4631             MOV      R1,R6
   \   0000005C   0xA800             ADD      R0,SP,#+0
   \   0000005E   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000062   0x270B             MOVS     R7,#+11
   1581          		Ptr[i] = 0;
   \   00000064   0xF88D 0x500B      STRB     R5,[SP, #+11]
   1582          		if(BcMdemSyncCheck((char *)Ptr) != 28)return -3;
   \   00000068   0xA800             ADD      R0,SP,#+0
   \   0000006A   0x.... 0x....      BL       BcMdemSyncCheck
   \   0000006E   0x281C             CMP      R0,#+28
   \   00000070   0xD009             BEQ.N    ??BcMdemCalling_5
   1583          		
   1584          		for(j = 0; j < strlen(DstTel); j++, i++)
   1585          		{
   1586          			if(DstTel[j] != RxCdmaData[i])return -3;
   1587          		}
   1588          	}
   1589          	else return -3;
   \                     ??BcMdemCalling_4:
   \   00000072   0xF06F 0x0002      MVN      R0,#+2
   \   00000076   0xE018             B.N      ??BcMdemCalling_3
   \                     ??BcMdemCalling_6:
   \   00000078   0x5D28             LDRB     R0,[R5, R4]
   \   0000007A   0xB2BF             UXTH     R7,R7
   \   0000007C   0x5DB9             LDRB     R1,[R7, R6]
   \   0000007E   0x4288             CMP      R0,R1
   \   00000080   0xD1F7             BNE.N    ??BcMdemCalling_4
   \   00000082   0x1C6D             ADDS     R5,R5,#+1
   \   00000084   0x1C7F             ADDS     R7,R7,#+1
   \                     ??BcMdemCalling_5:
   \   00000086   0x4620             MOV      R0,R4
   \   00000088   0x.... 0x....      BL       strlen
   \   0000008C   0xB2AD             UXTH     R5,R5
   \   0000008E   0x4285             CMP      R5,R0
   \   00000090   0xD3F2             BCC.N    ??BcMdemCalling_6
   1590          
   1591          	if(BcMdemSyncProtocolCheck()) // *SKT*VOICECONNECT
   \   00000092   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   00000096   0xB130             CBZ.N    R0,??BcMdemCalling_7
   1592          	{
   1593          		if(BcMdemSyncCheck((char *)RxCdmaData) != 29)return -4; 
   \   00000098   0x4630             MOV      R0,R6
   \   0000009A   0x.... 0x....      BL       BcMdemSyncCheck
   \   0000009E   0x281D             CMP      R0,#+29
   \   000000A0   0xBF08             IT       EQ 
   \   000000A2   0x2001             MOVEQ    R0,#+1
   1594          	}
   1595          	else return -4;
   1596          	
   1597          	return nRet;
   \   000000A4   0xD001             BEQ.N    ??BcMdemCalling_3
   \                     ??BcMdemCalling_7:
   \   000000A6   0xF06F 0x0003      MVN      R0,#+3
   \                     ??BcMdemCalling_3:
   \   000000AA   0xB019             ADD      SP,SP,#+100
   \   000000AC   0xBDF0             POP      {R4-R7,PC}       ;; return
   1598          }
   1599          
   1600          

   \                                 In section .text, align 2, keep-with-next
   1601          INT32S CdmaModemTrafficCheck(void)
   1602          { 
   \                     CdmaModemTrafficCheck:
   \   00000000   0xB580             PUSH     {R7,LR}
   1603          	INT8U nRet = TRUE;
   1604          	
   1605          	nRet = BcMdemCommad(ModemTrafficCmd);
   1606          
   1607          	return nRet;
   \   00000002   0x2007             MOVS     R0,#+7
   \   00000004   0x....             B.N      ?Subroutine2
   1608          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   0x.... 0x....      BL       BcMdemCommad
   \   00000004   0xB2C0             UXTB     R0,R0
   \   00000006   0xBD02             POP      {R1,PC}          ;; return
   1609          

   \                                 In section .text, align 2, keep-with-next
   1610          INT32S CdmaModemHangUp(void)
   1611          { 
   \                     CdmaModemHangUp:
   \   00000000   0xB580             PUSH     {R7,LR}
   1612          	INT8U nRet = TRUE;
   1613          	
   1614          	nRet = BcMdemCommad(ModemHangUpCmd);
   1615          
   1616          	return nRet;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004                      REQUIRE ?Subroutine2
   \   00000004                      ;; // Fall through to label ?Subroutine2
   1617          }
   1618          
   1619          
   1620          

   \                                 In section .text, align 2, keep-with-next
   1621          INT32S ModemHangUp(void)
   1622          { 
   \                     ModemHangUp:
   \   00000000   0xB580             PUSH     {R7,LR}
   1623          	INT8U nRet = TRUE;
   1624          	
   1625          	nRet = BcMdemCommad(ModemHangUpCommand);
   1626          
   1627          	return nRet;
   \   00000002   0x2017             MOVS     R0,#+23
   \   00000004   0x....             B.N      ?Subroutine2
   1628          }
   1629          
   1630          
   1631          
   1632          

   \                                 In section .text, align 2, keep-with-next
   1633          INT32S ModemLockOrder(void)
   1634          { 
   \                     ModemLockOrder:
   \   00000000   0xB580             PUSH     {R7,LR}
   1635          	INT8U nRet = TRUE;
   1636          	
   1637          	nRet = BcMdemCommad(ModemLockOrderCmd);
   1638          
   1639          	return nRet;
   \   00000002   0x2013             MOVS     R0,#+19
   \   00000004   0x....             B.N      ?Subroutine2
   1640          }
   1641          
   1642          

   \                                 In section .text, align 2, keep-with-next
   1643          INT32S ModemGMMLockOrder(void)
   1644          { 
   \                     ModemGMMLockOrder:
   \   00000000   0xB580             PUSH     {R7,LR}
   1645          	INT8U nRet = TRUE;
   1646          	
   1647          	nRet = BcMdemCommad(ModemGMMLockOrderCmd);
   1648          
   1649          	return nRet;
   \   00000002   0x2014             MOVS     R0,#+20
   \   00000004   0x....             B.N      ?Subroutine2
   1650          }
   1651          

   \                                 In section .text, align 2, keep-with-next
   1652          INT32S ModemPwrOFF(void)
   1653          { 
   \                     ModemPwrOFF:
   \   00000000   0xB580             PUSH     {R7,LR}
   1654          	INT8U nRet = TRUE;
   1655          	
   1656          	nRet = BcMdemCommad(ModemPWROFFCmd);
   1657          
   1658          	return nRet;
   \   00000002   0x2016             MOVS     R0,#+22
   \   00000004   0x....             B.N      ?Subroutine2
   1659          }
   1660          
   1661          
   1662          

   \                                 In section .text, align 4, keep-with-next
   1663          INT32S BcMdemCommad(INT8U Commad)
   1664          {
   \                     BcMdemCommad:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB09A             SUB      SP,SP,#+104
   \   00000004   0x4605             MOV      R5,R0
   1665          	INT16U i = 0;
   1666          	INT32S nlen = 0;
   1667          	INT32S nRet = 0;
   \   00000006   0x2400             MOVS     R4,#+0
   1668          	INT8U Ptr[100];
   1669            
   1670          	switch(Commad)
   \   00000008   0x1E40             SUBS     R0,R0,#+1
   \   0000000A   0x2816             CMP      R0,#+22
   \   0000000C   0xF200 0x80AF      BHI.W    ??BcMdemCommad_1
   \   00000010   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??BcMdemCommad_0:
   \   00000014   0x40 0xAD          DC8      0x40,0xAD,0xAD,0xAD
   \              0xAD 0xAD    
   \   00000018   0x43 0x3D          DC8      0x43,0x3D,0x43,0x1C
   \              0x43 0x1C    
   \   0000001C   0x0C 0xAD          DC8      0xC,0xAD,0xAD,0xAD
   \              0xAD 0xAD    
   \   00000020   0xAD 0xAD          DC8      0xAD,0xAD,0xAD,0xAD
   \              0xAD 0xAD    
   \   00000024   0xAD 0x5B          DC8      0xAD,0x5B,0x5E,0x79
   \              0x5E 0x79    
   \   00000028   0xAD 0x93          DC8      0xAD,0x93,0x96,0x0
   \              0x96 0x00    
   1671          	{
   1672          		case MsgReciveCmd: 			BcMdemXmit(CdmaMsgReciveCmd); 	break;
   \                     ??BcMdemCommad_2:
   \   0000002C   0x.... 0x....      ADR.W    R0,`?<Constant "AT*SKTR*SMSMT">`
   \   00000030   0x.... 0x....      BL       BcMdemXmit
   1673          		case MsgCheckCmd: 			BcMdemXmit(CdmaMsgCheckCmd); 	break;
   1674          		case ModemTimeCmd: 			BcMdemXmit(CdmaModemTimeCmd); 	break;
   1675          		case ModemRfStsCmd: 		BcMdemXmit(CdmaModemRfStsCmd); 	break;
   1676          		case ModemHangUpCmd: 		BcMdemXmit(CdmaModemHangUpCmd); break;
   1677          		case ModemTrafficCmd:		BcMdemXmit(CdmaModemTrafficCmd);break;
   1678          		case ModemPilotCmd: 		BcMdemXmit(CdmaModemPilotCmd); 	break; 
   1679          		case ModemLockOrderCmd: 	BcMdemXmit(LockOrderCmd); 		break; 
   1680          		case ModemGMMLockOrderCmd: 	BcMdemXmit(GMMLockOrderCmd); 	break; 
   1681          		case ModemPWROFFCmd: 		BcMdemXmit(ModemPWROFF); 		break; 
   1682          
   1683          
   1684          		case ModemHangUpCommand: 	BcMdemXmit(PhoneHangUpCmd); break;
   1685          
   1686          
   1687          		default : return FALSE;
   1688          	}
   1689          
   1690          	switch(Commad)
   1691          	{
   1692          		case MsgReciveCmd:
   1693          		
   1694          			if((nlen = BcMdemSyncProtocolCheck()) != FALSE)
   \                     ??BcMdemCommad_3:
   \   00000034   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   00000038   0x0006             MOVS     R6,R0
   \   0000003A   0xF000 0x8098      BEQ.W    ??BcMdemCommad_1
   1695          			{
   1696          				nRet = BcMdemDataProtocolCheck(Commad);
   \   0000003E   0x2009             MOVS     R0,#+9
   \   00000040   0x.... 0x....      BL       BcMdemDataProtocolCheck
   \   00000044   0x0004             MOVS     R4,R0
   1697          				if(!nRet)return FALSE;
   \   00000046   0xF000 0x8092      BEQ.W    ??BcMdemCommad_1
   1698          				if(nRet > 0) nRet = nlen;	// normal case .. len return.
   \   0000004A   0xE01C             B.N      ??BcMdemCommad_4
   1699          			}
   \                     ??BcMdemCommad_5:
   \   0000004C   0x.... 0x....      ADR.W    R0,`?<Constant "AT*SKTR*SMSCNT?">`
   \                     ??BcMdemCommad_6:
   \   00000050   0x.... 0x....      BL       BcMdemXmit
   1700          			else return FALSE;
   1701          		break;	
   1702          
   1703          		case ModemPilotCmd:
   1704          		case MsgCheckCmd: 	
   1705          		case ModemTimeCmd:
   1706          		case ModemRfStsCmd:
   1707          		case ModemTrafficCmd:
   1708          		case ModemPWROFFCmd:	
   1709          			if((nlen = BcMdemSyncProtocolCheck()) != FALSE)
   \                     ??BcMdemCommad_7:
   \   00000054   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   00000058   0x0006             MOVS     R6,R0
   \   0000005A   0xF000 0x8088      BEQ.W    ??BcMdemCommad_1
   1710          			{
   1711          				nRet = BcMdemDataProtocolCheck(Commad);
   \   0000005E   0xB268             SXTB     R0,R5
   \   00000060   0x.... 0x....      BL       BcMdemDataProtocolCheck
   \   00000064   0x0004             MOVS     R4,R0
   1712          
   1713          				if(!nRet)return FALSE;
   \   00000066   0xF000 0x8082      BEQ.W    ??BcMdemCommad_1
   1714          				if(!BcMdemSyncProtocolCheck())return FALSE;
   \   0000006A   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD07D             BEQ.N    ??BcMdemCommad_1
   1715          				
   1716          				if((BcMdemSyncCheck((char *)RxCdmaData) != 14))	return FALSE;
   \   00000072   0x.... 0x....      LDR.W    R0,??DataTable89_1
   \   00000076   0x.... 0x....      BL       BcMdemSyncCheck
   \   0000007A   0x280E             CMP      R0,#+14
   \   0000007C   0xD177             BNE.N    ??BcMdemCommad_1
   1717          
   1718          				if(Commad == MsgCheckCmd)
   \   0000007E   0x2D08             CMP      R5,#+8
   \   00000080   0xBF18             IT       NE 
   \   00000082   0x2D07             CMPNE    R5,#+7
   1719          				{
   1720          //					nRet = nlen;
   1721          				}
   1722           				else if(Commad != ModemTrafficCmd)
   \   00000084   0xD01E             BEQ.N    ??BcMdemCommad_8
   1723          				{
   1724          					if(nRet > 0) nRet = nlen;	// normal case .. len return.
   \                     ??BcMdemCommad_4:
   \   00000086   0x2C01             CMP      R4,#+1
   \   00000088   0xDB1C             BLT.N    ??BcMdemCommad_8
   \   0000008A   0x4634             MOV      R4,R6
   \   0000008C   0xE01A             B.N      ??BcMdemCommad_8
   1725          				}	
   1726          			}
   \                     ??BcMdemCommad_9:
   \   0000008E   0x.... 0x....      ADR.W    R0,`?<Constant "AT*SKTR*RFSTS">`
   \   00000092   0xE7DD             B.N      ??BcMdemCommad_6
   \                     ??BcMdemCommad_10:
   \   00000094   0x.... 0x....      ADR.W    R0,`?<Constant "AT*SKT*REL">`
   \   00000098   0xE054             B.N      ??BcMdemCommad_11
   \                     ??BcMdemCommad_12:
   \   0000009A   0x.... 0x....      ADR.W    R0,`?<Constant "AT*SKT*PING">`
   \   0000009E   0x.... 0x....      BL       BcMdemXmit
   \   000000A2   0x1E6E             SUBS     R6,R5,#+1
   \   000000A4   0xD050             BEQ.N    ??BcMdemCommad_13
   \   000000A6   0x1F36             SUBS     R6,R6,#+4
   \   000000A8   0x2E03             CMP      R6,#+3
   \   000000AA   0xD9D3             BLS.N    ??BcMdemCommad_7
   \   000000AC   0x1F36             SUBS     R6,R6,#+4
   \   000000AE   0xD0C1             BEQ.N    ??BcMdemCommad_3
   \   000000B0   0x3E09             SUBS     R6,R6,#+9
   \   000000B2   0xD0CF             BEQ.N    ??BcMdemCommad_7
   \   000000B4   0x1E76             SUBS     R6,R6,#+1
   \   000000B6   0xD00F             BEQ.N    ??BcMdemCommad_14
   \   000000B8   0x1E76             SUBS     R6,R6,#+1
   \   000000BA   0xD028             BEQ.N    ??BcMdemCommad_15
   \   000000BC   0x1EB6             SUBS     R6,R6,#+2
   \   000000BE   0xD0C9             BEQ.N    ??BcMdemCommad_7
   \   000000C0   0x1E76             SUBS     R6,R6,#+1
   \   000000C2   0xD041             BEQ.N    ??BcMdemCommad_13
   1727          			else return FALSE;
   1728          		break;	
   1729           		case ModemHangUpCmd:
   1730          		case ModemHangUpCommand:
   1731          			
   1732          			if(BcMdemSyncProtocolCheck())
   1733          			{
   1734          				for(i = 0; i < strlen(RspmsgHangup);i++)Ptr[i] = RxCdmaData[i];
   1735          				Ptr[i] = 0;
   1736          				if(BcMdemSyncCheck((char *)Ptr) != 30)return FALSE;
   1737          				
   1738          				if(RxCdmaData[i] != '1')return FALSE;
   1739          			}
   1740          			else return FALSE;
   1741          			
   1742          		break; 
   1743          		case ModemLockOrderCmd:
   1744          			
   1745          			if(BcMdemSyncProtocolCheck())
   1746          			{
   1747          				for(i = 0; i < strlen(RspLockOrder);i++)Ptr[i] = RxCdmaData[i];
   1748          				Ptr[i] = 0;
   1749          				if(BcMdemSyncCheck((char *)Ptr) != 35)	return FALSE;
   1750          
   1751          				{
   1752          					INT8U *tPtr = RxCdmaData;
   1753          
   1754          					for(; i < 20; i++)
   1755          					{
   1756          						if(*tPtr == ',')
   1757          						{	
   1758          							*tPtr++;
   1759          							break;
   1760          						}
   1761          						else
   1762          						{
   1763          							tPtr++;
   1764          
   1765          						}
   1766          						
   1767          //						Ser3Ptr->printf("[%c]",*tPtr);
   1768          					}
   1769          //					Ser3Ptr->printf("\n");
   1770          					
   1771          					LockOrder = atoh(*tPtr);
   1772          	//				Ser3Ptr->printf("RxCdmaData [%d][%d]>[%d]\n",i, *tPtr,LockOrder);
   1773          				}
   1774          			}
   1775          			else return FALSE;
   1776          
   1777          			
   1778          		break; 
   1779          		case ModemGMMLockOrderCmd:
   1780          			if(BcMdemSyncProtocolCheck())
   1781          			{
   1782          				for(i = 0; i < strlen(RspGMMLockOrder);i++)Ptr[i] = RxCdmaData[i];
   1783          				Ptr[i] = 0;
   1784          				if(BcMdemSyncCheck((char *)Ptr) != 36)return FALSE;
   1785          
   1786          				GMMLockOrder = atoh(RxCdmaData[i]);
   1787          			}
   1788          			else return FALSE;
   1789          
   1790          			
   1791          		break; 
   1792          
   1793           	}
   1794          	return nRet;
   \                     ??BcMdemCommad_8:
   \   000000C4   0x4620             MOV      R0,R4
   \                     ??BcMdemCommad_16:
   \   000000C6   0xB01A             ADD      SP,SP,#+104
   \   000000C8   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??BcMdemCommad_17:
   \   000000CA   0x.... 0x....      ADR.W    R0,`?<Constant "AT*SKTR*PILOT?">`
   \   000000CE   0xE7BF             B.N      ??BcMdemCommad_6
   \                     ??BcMdemCommad_18:
   \   000000D0   0x.... 0x....      ADR.W    R0,`?<Constant "AT+CGREG?">`
   \   000000D4   0x.... 0x....      BL       BcMdemXmit
   \                     ??BcMdemCommad_14:
   \   000000D8   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   000000DC   0x2800             CMP      R0,#+0
   \   000000DE   0xD046             BEQ.N    ??BcMdemCommad_1
   \   000000E0   0x....             LDR.N    R5,??DataTable89_1
   \   000000E2   0x2207             MOVS     R2,#+7
   \   000000E4   0x4629             MOV      R1,R5
   \   000000E6   0xA800             ADD      R0,SP,#+0
   \   000000E8   0x.... 0x....      BL       __aeabi_memcpy4
   \   000000EC   0xF88D 0x4007      STRB     R4,[SP, #+7]
   \   000000F0   0xA800             ADD      R0,SP,#+0
   \   000000F2   0x.... 0x....      BL       BcMdemSyncCheck
   \   000000F6   0x2823             CMP      R0,#+35
   \   000000F8   0xD139             BNE.N    ??BcMdemCommad_1
   \   000000FA   0x200D             MOVS     R0,#+13
   \                     ??BcMdemCommad_19:
   \   000000FC   0x7829             LDRB     R1,[R5, #+0]
   \   000000FE   0x292C             CMP      R1,#+44
   \   00000100   0xD137             BNE.N    ??BcMdemCommad_20
   \   00000102   0x1C6D             ADDS     R5,R5,#+1
   \   00000104   0xE038             B.N      ??BcMdemCommad_21
   \                     ??BcMdemCommad_22:
   \   00000106   0x.... 0x....      ADR.W    R0,`?<Constant "AT$$GMM_REJ?">`
   \   0000010A   0x.... 0x....      BL       BcMdemXmit
   \                     ??BcMdemCommad_15:
   \   0000010E   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   00000112   0xB360             CBZ.N    R0,??BcMdemCommad_1
   \   00000114   0x....             LDR.N    R5,??DataTable89_1
   \   00000116   0x220A             MOVS     R2,#+10
   \   00000118   0x4629             MOV      R1,R5
   \   0000011A   0xA800             ADD      R0,SP,#+0
   \   0000011C   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000120   0xF88D 0x400A      STRB     R4,[SP, #+10]
   \   00000124   0xA800             ADD      R0,SP,#+0
   \   00000126   0x.... 0x....      BL       BcMdemSyncCheck
   \   0000012A   0x2824             CMP      R0,#+36
   \   0000012C   0xD11F             BNE.N    ??BcMdemCommad_1
   \   0000012E   0x7AA8             LDRB     R0,[R5, #+10]
   \   00000130   0x.... 0x....      BL       atoh
   \   00000134   0x....             LDR.N    R1,??DataTable89_2
   \   00000136   0x7048             STRB     R0,[R1, #+1]
   \   00000138   0xE7C4             B.N      ??BcMdemCommad_8
   \                     ??BcMdemCommad_23:
   \   0000013A   0x.... 0x....      ADR.W    R0,`?<Constant "AT+ZPWROFF">`
   \   0000013E   0xE787             B.N      ??BcMdemCommad_6
   \                     ??BcMdemCommad_24:
   \   00000140   0x.... 0x....      ADR.W    R0,`?<Constant "AT+CHV">`
   \                     ??BcMdemCommad_11:
   \   00000144   0x.... 0x....      BL       BcMdemXmit
   \                     ??BcMdemCommad_13:
   \   00000148   0x.... 0x....      BL       BcMdemSyncProtocolCheck
   \   0000014C   0xB178             CBZ.N    R0,??BcMdemCommad_1
   \   0000014E   0x....             LDR.N    R5,??DataTable89_1
   \   00000150   0x2209             MOVS     R2,#+9
   \   00000152   0x4629             MOV      R1,R5
   \   00000154   0xA800             ADD      R0,SP,#+0
   \   00000156   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000015A   0xF88D 0x4009      STRB     R4,[SP, #+9]
   \   0000015E   0xA800             ADD      R0,SP,#+0
   \   00000160   0x.... 0x....      BL       BcMdemSyncCheck
   \   00000164   0x281E             CMP      R0,#+30
   \   00000166   0xBF04             ITT      EQ 
   \   00000168   0x7A68             LDRBEQ   R0,[R5, #+9]
   \   0000016A   0x2831             CMPEQ    R0,#+49
   \   0000016C   0xD0AA             BEQ.N    ??BcMdemCommad_8
   \                     ??BcMdemCommad_1:
   \   0000016E   0x2000             MOVS     R0,#+0
   \   00000170   0xE7A9             B.N      ??BcMdemCommad_16
   \                     ??BcMdemCommad_20:
   \   00000172   0x1C6D             ADDS     R5,R5,#+1
   \   00000174   0x1E40             SUBS     R0,R0,#+1
   \   00000176   0xD1C1             BNE.N    ??BcMdemCommad_19
   \                     ??BcMdemCommad_21:
   \   00000178   0x7828             LDRB     R0,[R5, #+0]
   \   0000017A   0x.... 0x....      BL       atoh
   \   0000017E   0x....             LDR.N    R1,??DataTable89_2
   \   00000180   0x7008             STRB     R0,[R1, #+0]
   \   00000182   0xE79F             B.N      ??BcMdemCommad_8
   1795          }
   1796          

   \                                 In section .text, align 2, keep-with-next
   1797          INT32S BcdemTimeGet(BcMTimeStr *nPtr)
   1798          {
   \                     BcdemTimeGet:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   1799          	INT8U i = 0;
   1800          	INT8U *tPtr = (INT8U *)nPtr;
   1801          	INT32S nRet = TRUE;
   \   00000004   0xF240 0x57DC      MOVW     R7,#+1500
   \   00000008   0x....             LDR.N    R5,??DataTable89_3
   \   0000000A   0xE005             B.N      ??BcdemTimeGet_0
   1802          		
   1803          S_START:
   1804          
   1805          	if(BcMRtryNo >= MaxTryNo) return FALSE;	// Max Try Error
   1806          
   1807          	nRet = BcMdemCommad(ModemTimeCmd);
   1808          
   1809          //	USART1Printf("1: BcdemTimeGet : [%d][%d]\n",BcMRtryNo,nRet);
   1810          
   1811          	if(nRet == FALSE)
   1812          	{
   1813          		BcMRtryNo++;
   \                     ??BcdemTimeGet_1:
   \   0000000C   0x79A8             LDRB     R0,[R5, #+6]
   \   0000000E   0x1C40             ADDS     R0,R0,#+1
   \   00000010   0x71A8             STRB     R0,[R5, #+6]
   1814          		OSTimeDly(1500);
   \   00000012   0x4638             MOV      R0,R7
   \   00000014   0x.... 0x....      BL       OSTimeDly
   1815          		goto S_START;
   1816          	}
   \                     ??BcdemTimeGet_0:
   \   00000018   0x79A8             LDRB     R0,[R5, #+6]
   \   0000001A   0x2805             CMP      R0,#+5
   \   0000001C   0xD301             BCC.N    ??BcdemTimeGet_2
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBDF2             POP      {R1,R4-R7,PC}
   \                     ??BcdemTimeGet_2:
   \   00000022   0x2005             MOVS     R0,#+5
   \   00000024   0x.... 0x....      BL       BcMdemCommad
   \   00000028   0x0006             MOVS     R6,R0
   \   0000002A   0xD0EF             BEQ.N    ??BcdemTimeGet_1
   1817          
   1818          	
   1819          	// mem init
   1820          	for(i = 0; i < sizeof(BcMTimeStr); i++)  *tPtr++ = 0;
   \   0000002C   0x2112             MOVS     R1,#+18
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       __aeabi_memclr
   1821          	
   1822          	for(i = 0; i < 4; i++) nPtr->Year[i] = BcMpresentTime->Year[i];
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x4621             MOV      R1,R4
   \                     ??BcdemTimeGet_3:
   \   00000038   0x6C2A             LDR      R2,[R5, #+64]
   \   0000003A   0x5C82             LDRB     R2,[R0, R2]
   \   0000003C   0xF801 0x2B01      STRB     R2,[R1], #+1
   \   00000040   0x1C40             ADDS     R0,R0,#+1
   \   00000042   0x2804             CMP      R0,#+4
   \   00000044   0xDBF8             BLT.N    ??BcdemTimeGet_3
   1823          	for(i = 0; i < 2; i++)
   \   00000046   0x2000             MOVS     R0,#+0
   1824          	{
   1825          		nPtr->Month[i]	= BcMpresentTime->Month[i];
   \                     ??BcdemTimeGet_4:
   \   00000048   0x6C29             LDR      R1,[R5, #+64]
   \   0000004A   0x1841             ADDS     R1,R0,R1
   \   0000004C   0x7909             LDRB     R1,[R1, #+4]
   \   0000004E   0x7121             STRB     R1,[R4, #+4]
   1826          		nPtr->Day[i]	= BcMpresentTime->Day[i];
   \   00000050   0x6C29             LDR      R1,[R5, #+64]
   \   00000052   0x1841             ADDS     R1,R0,R1
   \   00000054   0x7989             LDRB     R1,[R1, #+6]
   \   00000056   0x71A1             STRB     R1,[R4, #+6]
   1827          		nPtr->Hour[i]	= BcMpresentTime->Hour[i];
   \   00000058   0x6C29             LDR      R1,[R5, #+64]
   \   0000005A   0x1841             ADDS     R1,R0,R1
   \   0000005C   0x7A09             LDRB     R1,[R1, #+8]
   \   0000005E   0x7221             STRB     R1,[R4, #+8]
   1828          		nPtr->Min[i]	= BcMpresentTime->Min[i];
   \   00000060   0x6C29             LDR      R1,[R5, #+64]
   \   00000062   0x1841             ADDS     R1,R0,R1
   \   00000064   0x7A89             LDRB     R1,[R1, #+10]
   \   00000066   0x72A1             STRB     R1,[R4, #+10]
   1829          		nPtr->Sec[i]	= BcMpresentTime->Sec[i];
   \   00000068   0x6C29             LDR      R1,[R5, #+64]
   \   0000006A   0x1841             ADDS     R1,R0,R1
   \   0000006C   0x7B09             LDRB     R1,[R1, #+12]
   \   0000006E   0x7321             STRB     R1,[R4, #+12]
   1830          	}	
   \   00000070   0x1C40             ADDS     R0,R0,#+1
   \   00000072   0x1C64             ADDS     R4,R4,#+1
   \   00000074   0x2802             CMP      R0,#+2
   \   00000076   0xDBE7             BLT.N    ??BcdemTimeGet_4
   1831          
   1832          	OSTimeDly(1500);
   \   00000078   0x4638             MOV      R0,R7
   \   0000007A   0x.... 0x....      BL       OSTimeDly
   1833          	return nRet;
   \   0000007E   0x4630             MOV      R0,R6
   \   00000080   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1834          }
   1835          

   \                                 In section .text, align 2, keep-with-next
   1836          INT32S BcdemRfStsGet(BcMRfStsStr *nPtr)
   1837          {
   \                     BcdemRfStsGet:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1838          	INT8U i = 0;
   1839          //	INT16S *tPtr = (INT16S *)nPtr;
   1840          	INT8U *tPtr = (INT8U *)nPtr;
                 	       ^
Warning[Pe177]: variable "tPtr" was declared but never referenced
   1841          
   1842          	INT32S nRet = TRUE;
   \   00000004   0x....             LDR.N    R5,??DataTable89_3
   \   00000006   0xE006             B.N      ??BcdemRfStsGet_0
   1843          //	USART1Printf("01 :BcdemRfStsGet : [%d][%x] \n", tPtr,&tPtr);
   1844          
   1845          	
   1846          RF_START:
   1847          	if(BcMRtryNo >= MaxTryNo) return FALSE;	// Max Try Error
   1848          
   1849          	nRet = BcMdemCommad(ModemRfStsCmd);
   1850          
   1851          	if(nRet == FALSE)
   1852          	{
   1853          		BcMRtryNo++;
   \                     ??BcdemRfStsGet_1:
   \   00000008   0x79A8             LDRB     R0,[R5, #+6]
   \   0000000A   0x1C40             ADDS     R0,R0,#+1
   \   0000000C   0x71A8             STRB     R0,[R5, #+6]
   1854          		OSTimeDly(1000);
   \   0000000E   0xF44F 0x707A      MOV      R0,#+1000
   \   00000012   0x.... 0x....      BL       OSTimeDly
   1855          		goto RF_START;
   1856          	}
   \                     ??BcdemRfStsGet_0:
   \   00000016   0x79A8             LDRB     R0,[R5, #+6]
   \   00000018   0x2805             CMP      R0,#+5
   \   0000001A   0xD301             BCC.N    ??BcdemRfStsGet_2
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0xBD70             POP      {R4-R6,PC}
   \                     ??BcdemRfStsGet_2:
   \   00000020   0x2006             MOVS     R0,#+6
   \   00000022   0x.... 0x....      BL       BcMdemCommad
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD0EE             BEQ.N    ??BcdemRfStsGet_1
   1857          	// mem init
   1858          //	for(i = 0; i < sizeof(BcMRfStsStr); i++)  *tPtr++ = 0;
   1859          
   1860          	nPtr->ActChannel =	BcMRfStatus->ActChannel;
   \   0000002A   0x6C69             LDR      R1,[R5, #+68]
   \   0000002C   0x880A             LDRH     R2,[R1, #+0]
   \   0000002E   0x8022             STRH     R2,[R4, #+0]
   1861          //	USART1Printf("01 :ActChannel : [%d][%d] \n", BcMRfStatus->ActChannel,nPtr->ActChannel);
   1862          	
   1863          	for(i = 0; i < 6; i++)
   \   00000030   0x4622             MOV      R2,R4
   \   00000032   0x460B             MOV      R3,R1
   \   00000034   0x2506             MOVS     R5,#+6
   1864          	{
   1865          		nPtr->PN_Vaule[i] 	= BcMRfStatus->PN_Vaule[i];
   \                     ??BcdemRfStsGet_3:
   \   00000036   0x8A5E             LDRH     R6,[R3, #+18]
   \   00000038   0x8256             STRH     R6,[R2, #+18]
   1866          		nPtr->EcIo[i] 	  	= BcMRfStatus->EcIo[i];
   \   0000003A   0x8BDE             LDRH     R6,[R3, #+30]
   \   0000003C   0x83D6             STRH     R6,[R2, #+30]
   1867          		nPtr->PSC_Vaule[i]	= BcMRfStatus->PSC_Vaule[i];
   \   0000003E   0x8E9E             LDRH     R6,[R3, #+52]
   \   00000040   0x8696             STRH     R6,[R2, #+52]
   1868          	}
   \   00000042   0x1C9B             ADDS     R3,R3,#+2
   \   00000044   0x1C92             ADDS     R2,R2,#+2
   \   00000046   0x1E6D             SUBS     R5,R5,#+1
   \   00000048   0xD1F5             BNE.N    ??BcdemRfStsGet_3
   1869          
   1870          	nPtr->FerValue 	=	BcMRfStatus->FerValue;
   \   0000004A   0x8D4A             LDRH     R2,[R1, #+42]
   \   0000004C   0x8562             STRH     R2,[R4, #+42]
   1871          	nPtr->RxValue 	=	BcMRfStatus->RxValue;
   \   0000004E   0x8D8A             LDRH     R2,[R1, #+44]
   \   00000050   0x85A2             STRH     R2,[R4, #+44]
   1872          	nPtr->TxValue 	=	BcMRfStatus->TxValue;
   \   00000052   0x8DCA             LDRH     R2,[R1, #+46]
   \   00000054   0x85E2             STRH     R2,[R4, #+46]
   1873          	nPtr->AdjValue 	=	BcMRfStatus->AdjValue;
   \   00000056   0x8E0A             LDRH     R2,[R1, #+48]
   \   00000058   0x8622             STRH     R2,[R4, #+48]
   1874          
   1875          	nPtr->NumberOfChannel = BcMRfStatus->NumberOfChannel;
   \   0000005A   0x884A             LDRH     R2,[R1, #+2]
   \   0000005C   0x8062             STRH     R2,[R4, #+2]
   1876          	nPtr->ActPN = BcMRfStatus->ActPN;	
   \   0000005E   0x8A0A             LDRH     R2,[R1, #+16]
   \   00000060   0x8222             STRH     R2,[R4, #+16]
   1877          
   1878          	nPtr->PSClist 	= BcMRfStatus->PSClist;	
   \   00000062   0x8E4A             LDRH     R2,[R1, #+50]
   \   00000064   0x8662             STRH     R2,[R4, #+50]
   1879          	nPtr->BER 		= BcMRfStatus->BER;	
   \   00000066   0xF8B1 0x1040      LDRH     R1,[R1, #+64]
   \   0000006A   0xF8A4 0x1040      STRH     R1,[R4, #+64]
   1880          
   1881          	return nRet;
   \   0000006E   0xBD70             POP      {R4-R6,PC}       ;; return
   1882          }
   1883          

   \                                 In section .text, align 2, keep-with-next
   1884          INT32S BcMdemFuncselect(void)
   1885          {
   1886          	// Modem Status Check.
   1887          ////////////////////////////////////////////////////////////////////////////////////////	
   1888          	// error Case
   1889          	if(BcMRtryNo >= MaxTryNo)
   \                     BcMdemFuncselect:
   \   00000000   0x....             LDR.N    R0,??DataTable89_3
   \   00000002   0x7981             LDRB     R1,[R0, #+6]
   \   00000004   0x2905             CMP      R1,#+5
   \   00000006   0xD305             BCC.N    ??BcMdemFuncselect_0
   1890          	{
   1891          		TimeReqCnt = 0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x7141             STRB     R1,[R0, #+5]
   1892          		BcMRtryNo = 0;
   \   0000000C   0x7181             STRB     R1,[R0, #+6]
   1893          		return  MAX_TRY;
   \   0000000E   0xF06F 0x0001      MVN      R0,#+1
   \   00000012   0x4770             BX       LR
   1894          	}
   1895          
   1896          	if(++TimeReqCnt > 5)
   \                     ??BcMdemFuncselect_0:
   \   00000014   0x7941             LDRB     R1,[R0, #+5]
   \   00000016   0x1C49             ADDS     R1,R1,#+1
   \   00000018   0x7141             STRB     R1,[R0, #+5]
   \   0000001A   0xB2C9             UXTB     R1,R1
   \   0000001C   0x2906             CMP      R1,#+6
   \   0000001E   0xD303             BCC.N    ??BcMdemFuncselect_1
   1897          	{
   1898          		TimeReqCnt = 0;
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x7141             STRB     R1,[R0, #+5]
   1899          		return SELF_TIME;
   \   00000024   0x2004             MOVS     R0,#+4
   \   00000026   0x4770             BX       LR
   1900          	}
   1901          	else if(TimeReqCnt%2)	return SELF_RECV;
   \                     ??BcMdemFuncselect_1:
   \   00000028   0x07C8             LSLS     R0,R1,#+31
   \   0000002A   0xD501             BPL.N    ??BcMdemFuncselect_2
   \   0000002C   0x2003             MOVS     R0,#+3
   \   0000002E   0x4770             BX       LR
   1902          	else					return SELF_SEND;
   \                     ??BcMdemFuncselect_2:
   \   00000030   0x2002             MOVS     R0,#+2
   \   00000032   0x4770             BX       LR               ;; return
   1903          }
   1904          

   \                                 In section .text, align 2, keep-with-next
   1905          INT32S BcMdemRecv(INT8U *rbuf, INT8U *sTel, BcMTimeStr *rtime)
   1906          {
   \                     BcMdemRecv:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x4617             MOV      R7,R2
   1907          	INT32S len = 0;
   \   0000000A   0xF04F 0x0A00      MOV      R10,#+0
   1908          	INT32S nRet = 0;
   \   0000000E   0xF240 0x54DC      MOVW     R4,#+1500
   \   00000012   0x....             LDR.N    R6,??DataTable89_3
   \   00000014   0xE005             B.N      ??BcMdemRecv_0
   1909          	// 0: Fail
   1910          	// -1: Not Data
   1911          	
   1912          S_START:
   1913          
   1914          	if(BcMRtryNo >= MaxTryNo) return  FALSE;
   1915          	
   1916          	nRet = BcMdemCommad(MsgCheckCmd);
   1917          
   1918          	if(nRet == FALSE)
   1919          	{
   1920          		BcMRtryNo++;
   1921          		OSTimeDly(1500);
   1922          		goto S_START;
   1923          	}
   1924          	else if(nRet == NOT_DATA)
   1925          	{
   1926          		nRet = NOT_DATA;
   1927          	}
   1928          	else if(nRet > 0)//(nRet == TRUE)										// protocol ok --> data read
   1929          	{
   1930          		nRet = BcMdemCommad(MsgReciveCmd);
   1931          		if(nRet == FALSE)
   1932          		{
   1933          			BcMRtryNo++;
   \                     ??BcMdemRecv_1:
   \   00000016   0x79B0             LDRB     R0,[R6, #+6]
   \   00000018   0x1C40             ADDS     R0,R0,#+1
   \   0000001A   0x71B0             STRB     R0,[R6, #+6]
   1934          			OSTimeDly(1500);
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       OSTimeDly
   1935          			goto S_START;
   1936          		}
   \                     ??BcMdemRecv_0:
   \   00000022   0x79B0             LDRB     R0,[R6, #+6]
   \   00000024   0x2805             CMP      R0,#+5
   \   00000026   0xBF28             IT       CS 
   \   00000028   0x2000             MOVCS    R0,#+0
   \   0000002A   0xF080 0x8084      BCS.W    ??BcMdemRecv_2
   \   0000002E   0x2008             MOVS     R0,#+8
   \   00000030   0x.... 0x....      BL       BcMdemCommad
   \   00000034   0x4605             MOV      R5,R0
   \   00000036   0x2D00             CMP      R5,#+0
   \   00000038   0xD0ED             BEQ.N    ??BcMdemRecv_1
   \   0000003A   0xF115 0x0F01      CMN      R5,#+1
   \   0000003E   0xD075             BEQ.N    ??BcMdemRecv_3
   \   00000040   0x2D01             CMP      R5,#+1
   \   00000042   0xDB73             BLT.N    ??BcMdemRecv_3
   \   00000044   0x2009             MOVS     R0,#+9
   \   00000046   0x.... 0x....      BL       BcMdemCommad
   \   0000004A   0x4605             MOV      R5,R0
   \   0000004C   0x2D00             CMP      R5,#+0
   \   0000004E   0xD0E2             BEQ.N    ??BcMdemRecv_1
   1937          		//else if(nRet < 0)
   1938          		//{
   1939          		//	nRet = len;
   1940          		//}
   1941          		else if(nRet > 0)
   \   00000050   0x2D01             CMP      R5,#+1
   \   00000052   0xDB6B             BLT.N    ??BcMdemRecv_3
   1942          		{
   1943          			//len = len;
   1944          			// RxCdmaData
   1945          			{
   1946          				INT16U i = 0, cnt = 0, tcnt = 0;
   \   00000054   0x2600             MOVS     R6,#+0
   1947          				INT8U *tPtr = RxBcMData;
   \   00000056   0x....             LDR.N    R4,??DataTable89_4
   1948          
   1949          				////////////////////////////////////////////////////////////////
   1950          				for(i = 0; i < sizeof(BcMTimeStr); i++) *((INT8U *)rtime + i) = 0;
   \   00000058   0x2112             MOVS     R1,#+18
   \   0000005A   0x4638             MOV      R0,R7
   \   0000005C   0x.... 0x....      BL       __aeabi_memclr
   1951          				//////////////////////////////////////////////////////////////////////
   1952          				for(i = 0; i < 4; i++, cnt++) rtime->Year[i] = *tPtr++;
   \   00000060   0x7820             LDRB     R0,[R4, #+0]
   \   00000062   0x7038             STRB     R0,[R7, #+0]
   \   00000064   0x7860             LDRB     R0,[R4, #+1]
   \   00000066   0x7078             STRB     R0,[R7, #+1]
   \   00000068   0x78A0             LDRB     R0,[R4, #+2]
   \   0000006A   0x70B8             STRB     R0,[R7, #+2]
   \   0000006C   0x78E0             LDRB     R0,[R4, #+3]
   \   0000006E   0x70F8             STRB     R0,[R7, #+3]
   \   00000070   0x1D20             ADDS     R0,R4,#+4
   1953          				for(i = 0; i < 2; i++, cnt++) rtime->Month[i]= *tPtr++;
   \   00000072   0x46BC             MOV      R12,R7
   \   00000074   0xF04F 0x0E02      MOV      LR,#+2
   \                     ??BcMdemRecv_4:
   \   00000078   0xF810 0x1B01      LDRB     R1,[R0], #+1
   \   0000007C   0xF88C 0x1004      STRB     R1,[R12, #+4]
   \   00000080   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   00000084   0xF1BE 0x0E01      SUBS     LR,LR,#+1
   \   00000088   0xD1F6             BNE.N    ??BcMdemRecv_4
   1954          				for(i = 0; i < 2; i++, cnt++) rtime->Day[i]= *tPtr++;
   \   0000008A   0x4639             MOV      R1,R7
   \   0000008C   0x2202             MOVS     R2,#+2
   \                     ??BcMdemRecv_5:
   \   0000008E   0xF810 0x3B01      LDRB     R3,[R0], #+1
   \   00000092   0x718B             STRB     R3,[R1, #+6]
   \   00000094   0x1C49             ADDS     R1,R1,#+1
   \   00000096   0x1E52             SUBS     R2,R2,#+1
   \   00000098   0xD1F9             BNE.N    ??BcMdemRecv_5
   1955          				for(i = 0; i < 2; i++, cnt++) rtime->Hour[i]= *tPtr++;
   \   0000009A   0x4639             MOV      R1,R7
   \   0000009C   0x2202             MOVS     R2,#+2
   \                     ??BcMdemRecv_6:
   \   0000009E   0xF810 0x3B01      LDRB     R3,[R0], #+1
   \   000000A2   0x720B             STRB     R3,[R1, #+8]
   \   000000A4   0x1C49             ADDS     R1,R1,#+1
   \   000000A6   0x1E52             SUBS     R2,R2,#+1
   \   000000A8   0xD1F9             BNE.N    ??BcMdemRecv_6
   1956          				for(i = 0; i < 2; i++, cnt++) rtime->Min[i]= *tPtr++;
   \   000000AA   0x4639             MOV      R1,R7
   \   000000AC   0x2202             MOVS     R2,#+2
   \                     ??BcMdemRecv_7:
   \   000000AE   0xF810 0x3B01      LDRB     R3,[R0], #+1
   \   000000B2   0x728B             STRB     R3,[R1, #+10]
   \   000000B4   0x1C49             ADDS     R1,R1,#+1
   \   000000B6   0x1E52             SUBS     R2,R2,#+1
   \   000000B8   0xD1F9             BNE.N    ??BcMdemRecv_7
   1957          				for(i = 0; i < 2; i++, cnt++) rtime->Sec[i]= *tPtr++;
   \   000000BA   0x2102             MOVS     R1,#+2
   \                     ??BcMdemRecv_8:
   \   000000BC   0xF810 0x2B01      LDRB     R2,[R0], #+1
   \   000000C0   0x733A             STRB     R2,[R7, #+12]
   \   000000C2   0x1C7F             ADDS     R7,R7,#+1
   \   000000C4   0x1E49             SUBS     R1,R1,#+1
   \   000000C6   0xD1F9             BNE.N    ??BcMdemRecv_8
   1958          
   1959          				*tPtr++; cnt++;		// ','
   \   000000C8   0x1C44             ADDS     R4,R0,#+1
   \   000000CA   0x270F             MOVS     R7,#+15
   1960          				
   1961          				for(; cnt < nRet; cnt++)
   \   000000CC   0x2D10             CMP      R5,#+16
   \   000000CE   0xDB27             BLT.N    ??BcMdemRecv_9
   1962          				{
   1963          					if(*tPtr != ',')
   \                     ??BcMdemRecv_10:
   \   000000D0   0x7820             LDRB     R0,[R4, #+0]
   \   000000D2   0x282C             CMP      R0,#+44
   \   000000D4   0xD01D             BEQ.N    ??BcMdemRecv_11
   1964          					{	
   1965          						if(tcnt == 0)
   \   000000D6   0xB926             CBNZ.N   R6,??BcMdemRecv_12
   1966          						{
   1967          							*sTel++ = *tPtr++;
   \   000000D8   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   000000DC   0xF809 0x0B01      STRB     R0,[R9], #+1
   \   000000E0   0xE01A             B.N      ??BcMdemRecv_13
   1968          						}
   1969          						else if(tcnt == 1) tPtr++;
   \                     ??BcMdemRecv_12:
   \   000000E2   0x2E01             CMP      R6,#+1
   \   000000E4   0xBF1C             ITT      NE 
   \   000000E6   0x2E02             CMPNE    R6,#+2
   1970          						else if(tcnt == 2) tPtr++;
   \   000000E8   0x2E03             CMPNE    R6,#+3
   1971          						else if(tcnt == 3) tPtr++;
   \   000000EA   0xD101             BNE.N    ??BcMdemRecv_14
   \   000000EC   0x1C64             ADDS     R4,R4,#+1
   \   000000EE   0xE013             B.N      ??BcMdemRecv_13
   1972          						else
   1973          						{
   1974          							INT8U temp;
   1975          							temp = atoh(*tPtr++);
   \                     ??BcMdemRecv_14:
   \   000000F0   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   000000F4   0x.... 0x....      BL       atoh
   \   000000F8   0x4683             MOV      R11,R0
   1976          							temp = atoh(*tPtr++) + ( temp << 4 );
   1977          							rbuf[len++] = temp;
   \   000000FA   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   000000FE   0x.... 0x....      BL       atoh
   \   00000102   0xEB00 0x100B      ADD      R0,R0,R11, LSL #+4
   \   00000106   0xF80A 0x0008      STRB     R0,[R10, R8]
   \   0000010A   0xF10A 0x0A01      ADD      R10,R10,#+1
   1978          							cnt++;
   \   0000010E   0x1C7F             ADDS     R7,R7,#+1
   \   00000110   0xE002             B.N      ??BcMdemRecv_13
   1979          						}
   1980          					}
   1981          					else
   1982          					{
   1983          						tPtr++;
   \                     ??BcMdemRecv_11:
   \   00000112   0x1C64             ADDS     R4,R4,#+1
   1984          						tcnt++;
   \   00000114   0x1C70             ADDS     R0,R6,#+1
   \   00000116   0xB286             UXTH     R6,R0
   1985          					}
   1986          				}				
   \                     ??BcMdemRecv_13:
   \   00000118   0x1C78             ADDS     R0,R7,#+1
   \   0000011A   0xB287             UXTH     R7,R0
   \   0000011C   0x42AF             CMP      R7,R5
   \   0000011E   0xDBD7             BLT.N    ??BcMdemRecv_10
   1987          				nRet = len;
   \                     ??BcMdemRecv_9:
   \   00000120   0x4655             MOV      R5,R10
   1988          				rbuf[len++] = 0;	// null data insert
   \   00000122   0x2000             MOVS     R0,#+0
   \   00000124   0xF80A 0x0008      STRB     R0,[R10, R8]
   1989          				*sTel++ = 0;		// null data insert
   \   00000128   0xF889 0x0000      STRB     R0,[R9, #+0]
   1990          
   1991          			//Ser0Printf(" rDATA: %s", RxBcMData);
   1992          			//Ser0Printf(" DATA: %s", rbuf);
   1993          			//Ser0Printf(" len: %d \n", nRet);
   1994          			}
   1995          		}
   1996          	}
   1997          	OSTimeDly(1500);
   \                     ??BcMdemRecv_3:
   \   0000012C   0xF240 0x50DC      MOVW     R0,#+1500
   \   00000130   0x.... 0x....      BL       OSTimeDly
   1998          
   1999          	return nRet;
   \   00000134   0x4628             MOV      R0,R5
   \                     ??BcMdemRecv_2:
   \   00000136   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   2000          }
   2001          

   \                                 In section .text, align 2, keep-with-next
   2002          INT32S BcdemPilotGet(BcMPilotStsStr *nPtr)
   2003          {
   \                     BcdemPilotGet:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   2004          	INT8U i = 0;
   2005          //	INT16S *tPtr = (INT16S *)nPtr;
   2006          	INT8U *tPtr = (INT8U *)nPtr;
   2007          	INT32S nRet = TRUE;
   2008          
   2009          	nRet = BcMdemCommad(ModemPilotCmd);
   \   00000004   0x2012             MOVS     R0,#+18
   \   00000006   0x.... 0x....      BL       BcMdemCommad
   \   0000000A   0x4604             MOV      R4,R0
   2010          //	USART1Printf("01 :BcdemPilotGet : [%d][%x] \n", tPtr,&tPtr);
   2011          
   2012          	// mem init
   2013          	for(i = 0; i < sizeof(BcMPilotStsStr); i++)  *tPtr++ = 0;
   \   0000000C   0x2110             MOVS     R1,#+16
   \   0000000E   0x4628             MOV      R0,R5
   \   00000010   0x.... 0x....      BL       __aeabi_memclr
   2014          
   2015          	for(i = 0; i < 4; i++)
   \   00000014   0x....             LDR.N    R0,??DataTable89
   \   00000016   0x6800             LDR      R0,[R0, #+0]
   \   00000018   0x4629             MOV      R1,R5
   \   0000001A   0x4602             MOV      R2,R0
   \   0000001C   0x2304             MOVS     R3,#+4
   2016          	{
   2017          		nPtr->PN_Vaule[i] = BcMPilotStatus->PN_Vaule[i];
   \                     ??BcdemPilotGet_0:
   \   0000001E   0xF830 0x6B02      LDRH     R6,[R0], #+2
   \   00000022   0xF825 0x6B02      STRH     R6,[R5], #+2
   2018          		nPtr->EcIo[i] 	  = BcMPilotStatus->EcIo[i];
   \   00000026   0x8916             LDRH     R6,[R2, #+8]
   \   00000028   0x810E             STRH     R6,[R1, #+8]
   2019           	}
   \   0000002A   0x1C92             ADDS     R2,R2,#+2
   \   0000002C   0x1C89             ADDS     R1,R1,#+2
   \   0000002E   0x1E5B             SUBS     R3,R3,#+1
   \   00000030   0xD1F5             BNE.N    ??BcdemPilotGet_0
   2020          	return nRet;
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0xBD70             POP      {R4-R6,PC}       ;; return
   2021          }
   2022          

   \                                 In section .text, align 2, keep-with-next
   2023          int vSprintf(char * buf, const char *fmt, ...)
   2024          {
   \                     vSprintf:
   \   00000000   0xB40C             PUSH     {R2,R3}
   \   00000002   0xB580             PUSH     {R7,LR}
   2025          	va_list args;
   2026          	int i;
   2027          
   2028          	va_start(args, fmt);
   \   00000004   0xAA02             ADD      R2,SP,#+8
   2029          	i=vsprintf(buf,fmt,args);
   2030          	va_end(args);
   2031          	return i;
   \   00000006   0x.... 0x....      BL       vsprintf
   \   0000000A   0xBC02             POP      {R1}
   \   0000000C   0xF85D 0xFB0C      LDR      PC,[SP], #+12    ;; return
   2032          }

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "%s\\n">`:
   \   00000000   0x25 0x73          DC8 "%s\012"
   \              0x0A 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "%s">`:
   \   00000000   0x25 0x73          DC8 "%s"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "ATE0">`:
   \   00000000   0x41 0x54          DC8 "ATE0"
   \              0x45 0x30    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "AT+GMR">`:
   \   00000000   0x41 0x54          DC8 "AT+GMR"
   \              0x2B 0x47    
   \              0x4D 0x52    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "AT*SKT*DIAL">`:
   \   00000000   0x41 0x54          DC8 "AT*SKT*DIAL"
   \              0x2A 0x53    
   \              0x4B 0x54    
   \              0x2A 0x44    
   \              0x49 0x41    
   \              0x4C 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "AT*SKTR*ESN?">`:
   \   00000000   0x41 0x54          DC8 "AT*SKTR*ESN?"
   \              0x2A 0x53    
   \              0x4B 0x54    
   \              0x52 0x2A    
   \              0x45 0x53    
   \              0x4E 0x3F    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "AT*SKTR*ICCID?">`:
   \   00000000   0x41 0x54          DC8 "AT*SKTR*ICCID?"
   \              0x2A 0x53    
   \              0x4B 0x54    
   \              0x52 0x2A    
   \              0x49 0x43    
   \              0x43 0x49    
   \              0x44 0x3F    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "AT*SKTR*SMSMO=">`:
   \   00000000   0x41 0x54          DC8 "AT*SKTR*SMSMO="
   \              0x2A 0x53    
   \              0x4B 0x54    
   \              0x52 0x2A    
   \              0x53 0x4D    
   \              0x53 0x4D    
   \              0x4F 0x3D    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%s%s,%s,4098,0,0,0,">`:
   \   00000000   0x25 0x73          DC8 "%s%s,%s,4098,0,0,0,"
   \              0x25 0x73    
   \              0x2C 0x25    
   \              0x73 0x2C    
   \              0x34 0x30    
   \              0x39 0x38    
   \              0x2C 0x30    
   \              0x2C 0x30    
   \              0x2C 0x30    
   \              0x2C 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%s%s,%s,4098,,,,">`:
   \   00000000   0x25 0x73          DC8 "%s%s,%s,4098,,,,"
   \              0x25 0x73    
   \              0x2C 0x25    
   \              0x73 0x2C    
   \              0x34 0x30    
   \              0x39 0x38    
   \              0x2C 0x2C    
   \              0x2C 0x2C    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable74:
   \   00000000   0x25 0x73          DC8      "%s\n"
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "AT$TCPWRITE=">`:
   \   00000000   0x41 0x54          DC8 "AT$TCPWRITE="
   \              0x24 0x54    
   \              0x43 0x50    
   \              0x57 0x52    
   \              0x49 0x54    
   \              0x45 0x3D    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%02X">`:
   \   00000000   0x25 0x30          DC8 "%02X"
   \              0x32 0x58    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable75:
   \   00000000   0x25 0x73          DC8      0x25, 0x73, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable76:
   \   00000000   0x4F 0x4B          DC8      0x4F, 0x4B, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*SKTR*SMSMOACK:1">`:
   \   00000000   0x2A 0x53          DC8 "*SKTR*SMSMOACK:1"
   \              0x4B 0x54    
   \              0x52 0x2A    
   \              0x53 0x4D    
   \              0x53 0x4D    
   \              0x4F 0x41    
   \              0x43 0x4B    
   \              0x3A 0x31    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "CONNECT">`:
   \   00000000   0x43 0x4F          DC8 "CONNECT"
   \              0x4E 0x4E    
   \              0x45 0x43    
   \              0x54 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "NO CARRIER">`:
   \   00000000   0x4E 0x4F          DC8 "NO CARRIER"
   \              0x20 0x43    
   \              0x41 0x52    
   \              0x52 0x49    
   \              0x45 0x52    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "ERROR">`:
   \   00000000   0x45 0x52          DC8 "ERROR"
   \              0x52 0x4F    
   \              0x52 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "$008:0">`:
   \   00000000   0x24 0x30          DC8 "$008:0"
   \              0x30 0x38    
   \              0x3A 0x30    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "$008:1">`:
   \   00000000   0x24 0x30          DC8 "$008:1"
   \              0x30 0x38    
   \              0x3A 0x31    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "$006">`:
   \   00000000   0x24 0x30          DC8 "$006"
   \              0x30 0x36    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "$TCPOPEN">`:
   \   00000000   0x24 0x54          DC8 "$TCPOPEN"
   \              0x43 0x50    
   \              0x4F 0x50    
   \              0x45 0x4E    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*SKTR*SMSCNT:">`:
   \   00000000   0x2A 0x53          DC8 "*SKTR*SMSCNT:"
   \              0x4B 0x54    
   \              0x52 0x2A    
   \              0x53 0x4D    
   \              0x53 0x43    
   \              0x4E 0x54    
   \              0x3A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*SKTR*SMSMT:">`:
   \   00000000   0x2A 0x53          DC8 "*SKTR*SMSMT:"
   \              0x4B 0x54    
   \              0x52 0x2A    
   \              0x53 0x4D    
   \              0x53 0x4D    
   \              0x54 0x3A    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*SKTR*ESN:">`:
   \   00000000   0x2A 0x53          DC8 "*SKTR*ESN:"
   \              0x4B 0x54    
   \              0x52 0x2A    
   \              0x45 0x53    
   \              0x4E 0x3A    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*SKTR*RFSTS:">`:
   \   00000000   0x2A 0x53          DC8 "*SKTR*RFSTS:"
   \              0x4B 0x54    
   \              0x52 0x2A    
   \              0x52 0x46    
   \              0x53 0x54    
   \              0x53 0x3A    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*SKT*PONG:">`:
   \   00000000   0x2A 0x53          DC8 "*SKT*PONG:"
   \              0x4B 0x54    
   \              0x2A 0x50    
   \              0x4F 0x4E    
   \              0x47 0x3A    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "$TCPSENDDONE">`:
   \   00000000   0x24 0x54          DC8 "$TCPSENDDONE"
   \              0x43 0x50    
   \              0x53 0x45    
   \              0x4E 0x44    
   \              0x44 0x4F    
   \              0x4E 0x45    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "$TCPREADDATA=">`:
   \   00000000   0x24 0x54          DC8 "$TCPREADDATA="
   \              0x43 0x50    
   \              0x52 0x45    
   \              0x41 0x44    
   \              0x44 0x41    
   \              0x54 0x41    
   \              0x3D 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "$TCPCLOSED">`:
   \   00000000   0x24 0x54          DC8 "$TCPCLOSED"
   \              0x43 0x50    
   \              0x43 0x4C    
   \              0x4F 0x53    
   \              0x45 0x44    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*SKT*RESET:1">`:
   \   00000000   0x2A 0x53          DC8 "*SKT*RESET:1"
   \              0x4B 0x54    
   \              0x2A 0x52    
   \              0x45 0x53    
   \              0x45 0x54    
   \              0x3A 0x31    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*SKT*VCALL:">`:
   \   00000000   0x2A 0x53          DC8 "*SKT*VCALL:"
   \              0x4B 0x54    
   \              0x2A 0x56    
   \              0x43 0x41    
   \              0x4C 0x4C    
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*SKT*VOICECONNECT">`:
   \   00000000   0x2A 0x53          DC8 "*SKT*VOICECONNECT"
   \              0x4B 0x54    
   \              0x2A 0x56    
   \              0x4F 0x49    
   \              0x43 0x45    
   \              0x43 0x4F    
   \              0x4E 0x4E    
   \              0x45 0x43    
   \              0x54 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*SKT*REL:">`:
   \   00000000   0x2A 0x53          DC8 "*SKT*REL:"
   \              0x4B 0x54    
   \              0x2A 0x52    
   \              0x45 0x4C    
   \              0x3A 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*SKTR*PILOT:">`:
   \   00000000   0x2A 0x53          DC8 "*SKTR*PILOT:"
   \              0x4B 0x54    
   \              0x52 0x2A    
   \              0x50 0x49    
   \              0x4C 0x4F    
   \              0x54 0x3A    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*SKT*DIAL:">`:
   \   00000000   0x2A 0x53          DC8 "*SKT*DIAL:"
   \              0x4B 0x54    
   \              0x2A 0x44    
   \              0x49 0x41    
   \              0x4C 0x3A    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*SKT*ORI:">`:
   \   00000000   0x2A 0x53          DC8 "*SKT*ORI:"
   \              0x4B 0x54    
   \              0x2A 0x4F    
   \              0x52 0x49    
   \              0x3A 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*SKTR*ICCID:">`:
   \   00000000   0x2A 0x53          DC8 "*SKTR*ICCID:"
   \              0x4B 0x54    
   \              0x52 0x2A    
   \              0x49 0x43    
   \              0x43 0x49    
   \              0x44 0x3A    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "+CGREG:">`:
   \   00000000   0x2B 0x43          DC8 "+CGREG:"
   \              0x47 0x52    
   \              0x45 0x47    
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "$$GMM_REJ:">`:
   \   00000000   0x24 0x24          DC8 "$$GMM_REJ:"
   \              0x47 0x4D    
   \              0x4D 0x5F    
   \              0x52 0x45    
   \              0x4A 0x3A    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable77:
   \   00000000   0x4B 0x53          DC8      "KST"
   \              0x54 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable77_1:
   \   00000000   0x41 0x54          DC8      "ATS"
   \              0x53 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable77_2:
   \   00000000   0x78 0x30          DC8      "x05"
   \              0x35 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable77_3:
   \   00000000   0x78 0x30          DC8      "x06"
   \              0x36 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable77_4:
   \   00000000   0x........         DC32     BcMVerNum

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable77_5:
   \   00000000   0x........         DC32     pUSART1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable77_6:
   \   00000000   0x........         DC32     RxCdmaData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable77_7:
   \   00000000   0x........         DC32     `?<Constant "AT*SKT*REL">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable77_8:
   \   00000000   0x........         DC32     `?<Constant "AT*SKT*PING">`

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "OK">`:
   \   00000000   0x4F 0x4B          DC8 "OK"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "SAT">`:
   \   00000000   0x53 0x41          DC8 "SAT"
   \              0x54 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "KST">`:
   \   00000000   0x4B 0x53          DC8 "KST"
   \              0x54 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "ATS">`:
   \   00000000   0x41 0x54          DC8 "ATS"
   \              0x53 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "ZZB3">`:
   \   00000000   0x5A 0x5A          DC8 "ZZB3"
   \              0x42 0x33    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "ZZB4">`:
   \   00000000   0x5A 0x5A          DC8 "ZZB4"
   \              0x42 0x34    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "ZZB5">`:
   \   00000000   0x5A 0x5A          DC8 "ZZB5"
   \              0x42 0x35    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "0x0C">`:
   \   00000000   0x30 0x78          DC8 "0x0C"
   \              0x30 0x43    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "0x0D">`:
   \   00000000   0x30 0x78          DC8 "0x0D"
   \              0x30 0x44    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78:
   \   00000000   0x........         DC32     RxBcMData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable78_1:
   \   00000000   0x........         DC32     BcMVerNum

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable89:
   \   00000000   0x........         DC32     BcMPilotStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable89_1:
   \   00000000   0x........         DC32     RxCdmaData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable89_2:
   \   00000000   0x........         DC32     LockOrder

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable89_3:
   \   00000000   0x........         DC32     BcMVerNum

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable89_4:
   \   00000000   0x........         DC32     RxBcMData

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "AT*SKT*REL">`:
   \   00000000   0x41 0x54          DC8 "AT*SKT*REL"
   \              0x2A 0x53    
   \              0x4B 0x54    
   \              0x2A 0x52    
   \              0x45 0x4C    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "AT*SKT*PING">`:
   \   00000000   0x41 0x54          DC8 "AT*SKT*PING"
   \              0x2A 0x53    
   \              0x4B 0x54    
   \              0x2A 0x50    
   \              0x49 0x4E    
   \              0x47 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "AT+CRM=251">`:
   \   00000000   0x41 0x54          DC8 "AT+CRM=251"
   \              0x2B 0x43    
   \              0x52 0x4D    
   \              0x3D 0x32    
   \              0x35 0x31    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "AT$TCPUID=SKTELECOM">`:
   \   00000000   0x41 0x54          DC8 "AT$TCPUID=SKTELECOM"
   \              0x24 0x54    
   \              0x43 0x50    
   \              0x55 0x49    
   \              0x44 0x3D    
   \              0x53 0x4B    
   \              0x54 0x45    
   \              0x4C 0x45    
   \              0x43 0x4F    
   \              0x4D 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "AT$TCPPASSWDNULL">`:
   \   00000000   0x41 0x54          DC8 "AT$TCPPASSWDNULL"
   \              0x24 0x54    
   \              0x43 0x50    
   \              0x50 0x41    
   \              0x53 0x53    
   \              0x57 0x44    
   \              0x4E 0x55    
   \              0x4C 0x4C    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "ATD1501">`:
   \   00000000   0x41 0x54          DC8 "ATD1501"
   \              0x44 0x31    
   \              0x35 0x30    
   \              0x31 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%s%s,%d">`:
   \   00000000   0x25 0x73          DC8 "%s%s,%d"
   \              0x25 0x73    
   \              0x2C 0x25    
   \              0x64 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "AT$TCPOPEN=">`:
   \   00000000   0x41 0x54          DC8 "AT$TCPOPEN="
   \              0x24 0x54    
   \              0x43 0x50    
   \              0x4F 0x50    
   \              0x45 0x4E    
   \              0x3D 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "AT$TCPCLOSE">`:
   \   00000000   0x41 0x54          DC8 "AT$TCPCLOSE"
   \              0x24 0x54    
   \              0x43 0x50    
   \              0x43 0x4C    
   \              0x4F 0x53    
   \              0x45 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "AT$TCPEXIT">`:
   \   00000000   0x41 0x54          DC8 "AT$TCPEXIT"
   \              0x24 0x54    
   \              0x43 0x50    
   \              0x45 0x58    
   \              0x49 0x54    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "AT*SKT*RESET">`:
   \   00000000   0x41 0x54          DC8 "AT*SKT*RESET"
   \              0x2A 0x53    
   \              0x4B 0x54    
   \              0x2A 0x52    
   \              0x45 0x53    
   \              0x45 0x54    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%s%s">`:
   \   00000000   0x25 0x73          DC8 "%s%s"
   \              0x25 0x73    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "AT*SKT*ORI=">`:
   \   00000000   0x41 0x54          DC8 "AT*SKT*ORI="
   \              0x2A 0x53    
   \              0x4B 0x54    
   \              0x2A 0x4F    
   \              0x52 0x49    
   \              0x3D 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "AT*SKTR*SMSMT">`:
   \   00000000   0x41 0x54          DC8 "AT*SKTR*SMSMT"
   \              0x2A 0x53    
   \              0x4B 0x54    
   \              0x52 0x2A    
   \              0x53 0x4D    
   \              0x53 0x4D    
   \              0x54 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "AT*SKTR*SMSCNT?">`:
   \   00000000   0x41 0x54          DC8 "AT*SKTR*SMSCNT?"
   \              0x2A 0x53    
   \              0x4B 0x54    
   \              0x52 0x2A    
   \              0x53 0x4D    
   \              0x53 0x43    
   \              0x4E 0x54    
   \              0x3F 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "AT*SKTR*RFSTS">`:
   \   00000000   0x41 0x54          DC8 "AT*SKTR*RFSTS"
   \              0x2A 0x53    
   \              0x4B 0x54    
   \              0x52 0x2A    
   \              0x52 0x46    
   \              0x53 0x54    
   \              0x53 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "AT*SKTR*PILOT?">`:
   \   00000000   0x41 0x54          DC8 "AT*SKTR*PILOT?"
   \              0x2A 0x53    
   \              0x4B 0x54    
   \              0x52 0x2A    
   \              0x50 0x49    
   \              0x4C 0x4F    
   \              0x54 0x3F    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "AT+CGREG?">`:
   \   00000000   0x41 0x54          DC8 "AT+CGREG?"
   \              0x2B 0x43    
   \              0x47 0x52    
   \              0x45 0x47    
   \              0x3F 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "AT$$GMM_REJ?">`:
   \   00000000   0x41 0x54          DC8 "AT$$GMM_REJ?"
   \              0x24 0x24    
   \              0x47 0x4D    
   \              0x4D 0x5F    
   \              0x52 0x45    
   \              0x4A 0x3F    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "AT+ZPWROFF">`:
   \   00000000   0x41 0x54          DC8 "AT+ZPWROFF"
   \              0x2B 0x5A    
   \              0x50 0x57    
   \              0x52 0x4F    
   \              0x46 0x46    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "AT+CHV">`:
   \   00000000   0x41 0x54          DC8 "AT+CHV"
   \              0x2B 0x43    
   \              0x48 0x56    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "x05">`:
   \   00000000   0x78 0x30          DC8 "x05"
   \              0x35 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "x06">`:
   \   00000000   0x78 0x30          DC8 "x06"
   \              0x36 0x00    
   2033          #if 0
   2034          
   2035          int snprintf(char *str,size_t count,const char *fmt,...)
   2036          {
   2037          	size_t ret;
   2038          	va_list ap;
   2039              
   2040          	va_start(ap, fmt);
   2041          	ret = vsnprintf(str, count, fmt, ap);
   2042          	va_end(ap);
   2043          	return ret;
   2044          }
   2045          #endif
   2046          
   2047          
   2048          ////////////////////////////////////////////////////////////////////////////////
   2049          // End of Source File
   2050          /////////////////////
   2051          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       36  BcMFreqStateCheck
       32  BcMPilotStateCheck
      120  BcMdemCalling
             120 -> BcMdemSyncCheck
             120 -> BcMdemSyncProtocolCheck
             120 -> BcMdemXmit
             120 -> __aeabi_memcpy4
             120 -> sprintf
             120 -> strlen
      120  BcMdemCommad
             120 -> BcMdemDataProtocolCheck
             120 -> BcMdemSyncCheck
             120 -> BcMdemSyncProtocolCheck
             120 -> BcMdemXmit
             120 -> __aeabi_memcpy4
             120 -> atoh
       48  BcMdemDataProtocolCheck
              48 -> BcMFreqStateCheck
              48 -> BcMPilotStateCheck
              48 -> BcMdemSyncCheck
              48 -> __aeabi_memcpy4
              48 -> __iar_Strstr
        0  BcMdemDebug
        0  BcMdemFuncselect
      120  BcMdemInit
             120 -> BcMdemDataProtocolCheck
             120 -> BcMdemSyncCheck
             120 -> BcMdemSyncProtocolCheck
             120 -> BcMdemXmit
             120 -> __aeabi_memcpy4
      232  BcMdemMSGSentTx
             232 -> BcMdemSyncCheck
             232 -> BcMdemSyncProtocolCheck
             232 -> BcMdemXmit
             232 -> OSTimeDly
             232 -> sprintf
             232 -> strcat
      232  BcMdemMSGTx
             232 -> BcMdemSyncCheck
             232 -> BcMdemSyncProtocolCheck
             232 -> BcMdemXmit
             232 -> OSTimeDly
             232 -> sprintf
             232 -> strcat
       40  BcMdemRecv
              40 -> BcMdemCommad
              40 -> OSTimeDly
              40 -> __aeabi_memclr
              40 -> atoh
        8  BcMdemSwReset
               8 -> BcMdemSyncCheck
               8 -> BcMdemSyncProtocolCheck
               8 -> BcMdemXmit
               8 -> OSTimeDly
        8  BcMdemSyncCheck
               8 -> strlen
               8 -> strncmp
       24  BcMdemSyncProtocolCheck
              24 -- Indirect call
              24 -> OSTimeDly
              24 -> TimeOverCheck
              24 -> TimerRegist
       48  BcMdemTCPRxCheck
              48 -- Indirect call
              48 -> BcMdemSyncCheck
              48 -> BcMdemSyncProtocolCheck
              48 -> __aeabi_memcpy4
              48 -> atoh
      224  BcMdemTCPTx
             224 -> BcMdemSyncCheck
             224 -> BcMdemSyncProtocolCheck
             224 -> BcMdemXmit
             224 -> sprintf
             224 -> strcat
       48  BcMdemTcpConnect
              48 -> BcMdemSyncCheck
              48 -> BcMdemSyncProtocolCheck
              48 -> BcMdemXmit
              48 -> OSTimeDly
              48 -> sprintf
        8  BcMdemTcpExit
               8 -> BcMdemSyncCheck
               8 -> BcMdemSyncProtocolCheck
               8 -> BcMdemXmit
               8 -> OSTimeDly
       16  BcMdemXmit
               0 -- Indirect call
              16 -- Indirect call
       16  BcdemPilotGet
              16 -> BcMdemCommad
              16 -> __aeabi_memclr
       16  BcdemRfStsGet
              16 -> BcMdemCommad
              16 -> OSTimeDly
       24  BcdemTimeGet
              24 -> BcMdemCommad
              24 -> OSTimeDly
              24 -> __aeabi_memclr
        8  CdmaModemHangUp
               8 -> BcMdemCommad
        8  CdmaModemTrafficCheck
               8 -> BcMdemCommad
        8  ModemGMMLockOrder
               8 -> BcMdemCommad
        8  ModemHangUp
               8 -> BcMdemCommad
        8  ModemLockOrder
               8 -> BcMdemCommad
        8  ModemPwrOFF
               8 -> BcMdemCommad
       16  vSprintf
              16 -> vsprintf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      12  ?<Constant "$$GMM_REJ:">
       8  ?<Constant "$006">
       8  ?<Constant "$008:0">
       8  ?<Constant "$008:1">
      12  ?<Constant "$TCPCLOSED">
      12  ?<Constant "$TCPOPEN">
      16  ?<Constant "$TCPREADDATA=">
      16  ?<Constant "$TCPSENDDONE">
       8  ?<Constant "%02X">
       4  ?<Constant "%s">
       8  ?<Constant "%s%s">
       8  ?<Constant "%s%s,%d">
      20  ?<Constant "%s%s,%s,4098,,,,">
      20  ?<Constant "%s%s,%s,4098,0,0,0,">
       4  ?<Constant "%s\n">
      12  ?<Constant "*SKT*DIAL:">
      12  ?<Constant "*SKT*ORI:">
      12  ?<Constant "*SKT*PONG:">
      12  ?<Constant "*SKT*REL:">
      16  ?<Constant "*SKT*RESET:1">
      12  ?<Constant "*SKT*VCALL:">
      20  ?<Constant "*SKT*VOICECONNECT">
      12  ?<Constant "*SKTR*ESN:">
      16  ?<Constant "*SKTR*ICCID:">
      16  ?<Constant "*SKTR*PILOT:">
      16  ?<Constant "*SKTR*RFSTS:">
      16  ?<Constant "*SKTR*SMSCNT:">
      20  ?<Constant "*SKTR*SMSMOACK:1">
      16  ?<Constant "*SKTR*SMSMT:">
       8  ?<Constant "+CGREG:">
       8  ?<Constant "0x0C">
       8  ?<Constant "0x0D">
      16  ?<Constant "AT$$GMM_REJ?">
      12  ?<Constant "AT$TCPCLOSE">
      12  ?<Constant "AT$TCPEXIT">
      12  ?<Constant "AT$TCPOPEN=">
      20  ?<Constant "AT$TCPPASSWDNULL">
      20  ?<Constant "AT$TCPUID=SKTELECOM">
      16  ?<Constant "AT$TCPWRITE=">
      12  ?<Constant "AT*SKT*DIAL">
      12  ?<Constant "AT*SKT*ORI=">
      12  ?<Constant "AT*SKT*PING">
      12  ?<Constant "AT*SKT*REL">
      16  ?<Constant "AT*SKT*RESET">
      16  ?<Constant "AT*SKTR*ESN?">
      16  ?<Constant "AT*SKTR*ICCID?">
      16  ?<Constant "AT*SKTR*PILOT?">
      16  ?<Constant "AT*SKTR*RFSTS">
      16  ?<Constant "AT*SKTR*SMSCNT?">
      16  ?<Constant "AT*SKTR*SMSMO=">
      16  ?<Constant "AT*SKTR*SMSMT">
      12  ?<Constant "AT+CGREG?">
       8  ?<Constant "AT+CHV">
      12  ?<Constant "AT+CRM=251">
       8  ?<Constant "AT+GMR">
      12  ?<Constant "AT+ZPWROFF">
       8  ?<Constant "ATD1501">
       8  ?<Constant "ATE0">
       4  ?<Constant "ATS">
       8  ?<Constant "CONNECT">
       8  ?<Constant "ERROR">
       4  ?<Constant "KST">
      12  ?<Constant "NO CARRIER">
       4  ?<Constant "OK">
       4  ?<Constant "SAT">
       8  ?<Constant "ZZB3">
       8  ?<Constant "ZZB4">
       8  ?<Constant "ZZB5">
       4  ?<Constant "x05">
       4  ?<Constant "x06">
       4  ??DataTable74
       4  ??DataTable75
       4  ??DataTable76
       4  ??DataTable77
       4  ??DataTable77_1
       4  ??DataTable77_2
       4  ??DataTable77_3
       4  ??DataTable77_4
       4  ??DataTable77_5
       4  ??DataTable77_6
       4  ??DataTable77_7
       4  ??DataTable77_8
       4  ??DataTable78
       4  ??DataTable78_1
       4  ??DataTable89
       4  ??DataTable89_1
       4  ??DataTable89_2
       4  ??DataTable89_3
       4  ??DataTable89_4
       6  ?Subroutine0
       6  ?Subroutine1
       8  ?Subroutine2
    3130  BcMFreqStateCheck
    1052  BcMPilotStateCheck
       4  BcMPilotStatus
      16  BcMPilotStatusB
      68  BcMRfStatusB
      72  BcMVerNum
          BcMdebug
          TimeReqCnt
          BcMRtryNo
          BcMMaker
          BcMType
          ModemType
          BcMSrcTel
          BcMEsnNum
          ICCIDNum
          BcMTimerRx
          dUartPtr
          eUartPtr
          BcMpresentTime
          BcMRfStatus
     174  BcMdemCalling
     388  BcMdemCommad
     884  BcMdemDataProtocolCheck
      16  BcMdemDebug
      52  BcMdemFuncselect
     264  BcMdemInit
     210  BcMdemMSGSentTx
     210  BcMdemMSGTx
     314  BcMdemRecv
      62  BcMdemSwReset
     506  BcMdemSyncCheck
     120  BcMdemSyncProtocolCheck
     110  BcMdemTCPRxCheck
     112  BcMdemTCPTx
     278  BcMdemTcpConnect
     124  BcMdemTcpExit
      48  BcMdemXmit
      20  BcMpresentTimeB
      54  BcdemPilotGet
     112  BcdemRfStsGet
     130  BcdemTimeGet
       4  CdmaModemHangUp
       6  CdmaModemTrafficCheck
       4  EcIo0_Vaule
       4  EcIo1_Vaule
       4  EcIo2_Vaule
       4  EcIo3_Vaule
       2  LockOrder
          GMMLockOrder
       6  ModemGMMLockOrder
       6  ModemHangUp
       6  ModemLockOrder
       6  ModemPwrOFF
      52  ModemVersion
       1  MsgCheckCnt
       4  PN0_Vaule
       4  PN1_Vaule
       4  PN2_Vaule
       4  PN3_Vaule
    1028  RxBcMData
    2056  RxCdmaData
          TxCdmaData
     256  Send2Buf
      16  vSprintf

 
 3 531 bytes in section .bss
    76 bytes in section .data
    32 bytes in section .rodata
 9 288 bytes in section .text
 
 9 288 bytes of CODE  memory
    32 bytes of CONST memory
 3 607 bytes of DATA  memory

Errors: none
Warnings: 1

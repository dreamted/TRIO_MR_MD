###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     08/Feb/2018  09:39:52 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\code\exlib.c                                      #
#    Command line =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\code\exlib.c -lC D:\Project\TRIO\2.TRIO-MR\appl_s #
#                    tm207_20141204_RvsALC_20151223\out\ -o                   #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\out\ --endian=little --cpu=Cortex-M3 -e           #
#                    --fpu=None --dlib_config "D:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204 #
#                    _RvsALC_20151223\include\ -I                             #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\STM32F2xx_StdPeriph_Driver_v1212\ -I              #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\STM32F2xx_StdPeriph_Driver_v1212\inc\ -I          #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uC-CPU\ -I D:\Project\TRIO\2.TRIO-MR\appl_stm207_ #
#                    20141204_RvsALC_20151223\uC-LIB\ -I                      #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uCOS-II\Ports\ -I D:\Project\TRIO\2.TRIO-MR\appl_ #
#                    stm207_20141204_RvsALC_20151223\uCOS-II\Source\ -I       #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uC-Probe\ -Oh --use_c++_inline                    #
#    List file    =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\out\exlib.lst                                     #
#    Object file  =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\out\exlib.o                                       #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20151223\code\exlib.c
      1          
      2          /******************** (C) COPYRIGHT 2008 PILOG, NSINFO *************************
      3          * File Name          : exlib.c
      4          * Author             : Yoon Byong-Gyu(bgyoon@naver.com)
      5          * Date First Issued  : 02/01/2008
      6          * Description        : This file provides all the port/input/update firmware functions.
      7          * $Revision: 0.1 $
      8          * $Revision date: 2008.01.__
      9          ********************************************************************************/
     10          
     11          #define EXLIB_C
     12          
     13          #include "../include/main.h"

   \                                 In section .text, align 4, keep-with-next
   \   __absolute unsigned long const ExpioCS[(enum <unnamed>)20U]
   \                     ExpioCS:
   \   00000000   0x00008006         DC32 32774, 65546, 16393, 16396, 16397, 16398, 16399, 32782, 32783, 11
   \              0x0001000A   
   \              0x00004009   
   \              0x0000400C   
   \              0x0000400D   
   \              0x0000400E   
   \              0x0000400F   
   \              0x0000800E   
   \              0x0000800F   
   \              0x0000000B   
   \   00000028   0x0000000C         DC32 12, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   

   \                                 In section .bss, align 4
   \   __absolute unsigned short EXPIOrawData[(enum <unnamed>)20U]
   \                     EXPIOrawData:
   \   00000000                      DS8 40
     14          
     15          

   \                                 In section .text, align 2, keep-with-next
     16          void ExpioModeChanege(INT8U tmode)
     17          {
   \                     ExpioModeChanege:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
     18          	if(tmode == 0)
   \   00000002   0x....             LDR.N    R4,??DataTable4  ;; 0x40021000
   \   00000004   0x....             LDR.N    R5,??DataTable4_1  ;; 0x40020c00
   \   00000006   0xBB70             CBNZ.N   R0,??ExpioModeChanege_0
     19          	{
     20          		__PD14_PP_PP();
   \   00000008   0x230E             MOVS     R3,#+14
   \   0000000A   0x462A             MOV      R2,R5
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x2021             MOVS     R0,#+33
   \   00000010   0x.... 0x....      BL       GPIOPortInit
     21          		__PD15_PP_PP();
   \   00000014   0x230F             MOVS     R3,#+15
   \   00000016   0x462A             MOV      R2,R5
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x2021             MOVS     R0,#+33
   \   0000001C   0x.... 0x....      BL       GPIOPortInit
     22          		__PD0_PP_PP();
   \   00000020   0x2300             MOVS     R3,#+0
   \   00000022   0x462A             MOV      R2,R5
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x2021             MOVS     R0,#+33
   \   00000028   0x.... 0x....      BL       GPIOPortInit
     23          		__PD1_PP_PP();
   \   0000002C   0x2301             MOVS     R3,#+1
   \   0000002E   0x462A             MOV      R2,R5
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x2021             MOVS     R0,#+33
   \   00000034   0x.... 0x....      BL       GPIOPortInit
     24          		__PE7_PP_PP();
   \   00000038   0x2307             MOVS     R3,#+7
   \   0000003A   0x4622             MOV      R2,R4
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x2021             MOVS     R0,#+33
   \   00000040   0x.... 0x....      BL       GPIOPortInit
     25          		__PE8_PP_PP();
   \   00000044   0x2308             MOVS     R3,#+8
   \   00000046   0x4622             MOV      R2,R4
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0x2021             MOVS     R0,#+33
   \   0000004C   0x.... 0x....      BL       GPIOPortInit
     26          		__PE9_PP_PP();
   \   00000050   0x2309             MOVS     R3,#+9
   \   00000052   0x4622             MOV      R2,R4
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x2021             MOVS     R0,#+33
   \   00000058   0x.... 0x....      BL       GPIOPortInit
     27          		__PE10_PP_PP();
   \   0000005C   0x230A             MOVS     R3,#+10
   \   0000005E   0x4622             MOV      R2,R4
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x2021             MOVS     R0,#+33
   \   00000064   0x....             B.N      ?Subroutine0
     28          	}
     29          	else
     30          	{
     31          		__PD14_IN_FL();
   \                     ??ExpioModeChanege_0:
   \   00000066   0x230E             MOVS     R3,#+14
   \   00000068   0x462A             MOV      R2,R5
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0x.... 0x....      BL       GPIOPortInit
     32          		__PD15_IN_FL();
   \   00000072   0x230F             MOVS     R3,#+15
   \   00000074   0x462A             MOV      R2,R5
   \   00000076   0x2100             MOVS     R1,#+0
   \   00000078   0x4608             MOV      R0,R1
   \   0000007A   0x.... 0x....      BL       GPIOPortInit
     33          		__PD0_IN_FL();
   \   0000007E   0x2300             MOVS     R3,#+0
   \   00000080   0x462A             MOV      R2,R5
   \   00000082   0x4619             MOV      R1,R3
   \   00000084   0x4608             MOV      R0,R1
   \   00000086   0x.... 0x....      BL       GPIOPortInit
     34          		__PD1_IN_FL();
   \   0000008A   0x2301             MOVS     R3,#+1
   \   0000008C   0x462A             MOV      R2,R5
   \   0000008E   0x2100             MOVS     R1,#+0
   \   00000090   0x4608             MOV      R0,R1
   \   00000092   0x.... 0x....      BL       GPIOPortInit
     35          		__PE7_IN_FL();
   \   00000096   0x2307             MOVS     R3,#+7
   \   00000098   0x4622             MOV      R2,R4
   \   0000009A   0x2100             MOVS     R1,#+0
   \   0000009C   0x4608             MOV      R0,R1
   \   0000009E   0x.... 0x....      BL       GPIOPortInit
     36          		__PE8_IN_FL();
   \   000000A2   0x2308             MOVS     R3,#+8
   \   000000A4   0x4622             MOV      R2,R4
   \   000000A6   0x2100             MOVS     R1,#+0
   \   000000A8   0x4608             MOV      R0,R1
   \   000000AA   0x.... 0x....      BL       GPIOPortInit
     37          		__PE9_IN_FL();
   \   000000AE   0x2309             MOVS     R3,#+9
   \   000000B0   0x4622             MOV      R2,R4
   \   000000B2   0x2100             MOVS     R1,#+0
   \   000000B4   0x4608             MOV      R0,R1
   \   000000B6   0x.... 0x....      BL       GPIOPortInit
     38          		__PE10_IN_FL();
   \   000000BA   0x230A             MOVS     R3,#+10
   \   000000BC   0x4622             MOV      R2,R4
   \   000000BE   0x2100             MOVS     R1,#+0
   \   000000C0   0x4608             MOV      R0,R1
   \   000000C2                      REQUIRE ?Subroutine0
   \   000000C2                      ;; // Fall through to label ?Subroutine0
     39          	}
     40          /*
     41          #ifdef STM32FRxT6_USED
     42          	GPIOC->CNF.B6 = tmode;
     43          	GPIOC->CNF.B7 = tmode;
     44          	GPIOC->CNF.B8 = tmode;
     45          	GPIOC->CNF.B9 = tmode;
     46          	GPIOC->CNF.B10 = tmode;
     47          	GPIOC->CNF.B11 = tmode;
     48          	GPIOC->CNF.B12 = tmode;
     49          	GPIOD->CNF.B2 = tmode;
     50          #else
     51          	GPIOD->CNF.B14 = tmode;
     52          	GPIOD->CNF.B15 = tmode;
     53          	GPIOD->CNF.B0 = tmode;
     54          	GPIOD->CNF.B1 = tmode;
     55          	GPIOE->CNF.B7 = tmode;
     56          	GPIOE->CNF.B8 = tmode;
     57          	GPIOE->CNF.B9 = tmode;
     58          	GPIOE->CNF.B10 = tmode;
     59          #endif
     60          */
     61          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0xB001             ADD      SP,SP,#+4
   \   00000002   0xE8BD 0x4030      POP      {R4,R5,LR}
   \   00000006   0x.... 0x....      B.W      GPIOPortInit
     62          
     63          

   \                                 In section .text, align 2, keep-with-next
     64          void ExpioWriteData(INT8U SEL, INT16U Data)
     65          {
   \                     ExpioWriteData:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x460D             MOV      R5,R1
     66          	INT8U err;
     67          	
     68           	OSSemPend(ExpioSem, 0, &err);
   \   00000006   0x....             LDR.N    R4,??DataTable4_2
   \   00000008   0xAA00             ADD      R2,SP,#+0
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x.... 0x....      BL       OSSemPend
     69          	EXPIOrawData[SEL] = Data;
   \   00000012   0x....             LDR.N    R0,??DataTable4_3
   \   00000014   0xF820 0x5016      STRH     R5,[R0, R6, LSL #+1]
   \   00000018   0x.... 0x....      ADR.W    R0,ExpioCS
   \   0000001C   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   00000020   0x0906             LSRS     R6,R0,#+4
     70          
     71          	#ifdef __FSMC_SRAM_H
     72          		*(vu8 *)(EXPIOptr + SEL*EXPIOsize) = Data;
     73          	#else
     74          	{
     75          	
     76          		INT32U Addr = ExpioCS[SEL]/16;
     77          		INT32U BitAddr = ExpioCS[SEL]%16;
   \   00000022   0xF000 0x070F      AND      R7,R0,#0xF
     78          
     79          		ExpioModeChanege(0);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x.... 0x....      BL       ExpioModeChanege
     80          
     81          #ifdef STM32FRxT6_USED
     82          		GPIOC->ODR.B6  = (Data >> 0) & 0x01;
     83          		GPIOC->ODR.B7  = (Data >> 1) & 0x01;
     84          		GPIOC->ODR.B8  = (Data >> 2) & 0x01;
     85          		GPIOC->ODR.B9  = (Data >> 3) & 0x01;
     86          		GPIOC->ODR.B10 = (Data >> 4) & 0x01;
     87          		GPIOC->ODR.B11 = (Data >> 5) & 0x01;
     88          		GPIOC->ODR.B12 = (Data >> 6) & 0x01;
     89          		GPIOD->ODR.B2  = (Data >> 7) & 0x01;
     90          #else
     91          		GPIOD->__B.ODR.B14	= (Data >> 0) & 0x01;
   \   0000002C   0x....             LDR.N    R0,??DataTable4_4  ;; 0x40020c14
   \   0000002E   0x6801             LDR      R1,[R0, #+0]
   \   00000030   0xF365 0x318E      BFI      R1,R5,#+14,#+1
   \   00000034   0x6001             STR      R1,[R0, #+0]
     92          		GPIOD->__B.ODR.B15	= (Data >> 1) & 0x01;
   \   00000036   0x0629             LSLS     R1,R5,#+24
   \   00000038   0x0E49             LSRS     R1,R1,#+25
   \   0000003A   0x6802             LDR      R2,[R0, #+0]
   \   0000003C   0xF361 0x32CF      BFI      R2,R1,#+15,#+1
   \   00000040   0x6002             STR      R2,[R0, #+0]
     93          		GPIOD->__B.ODR.B0	= (Data >> 2) & 0x01;
   \   00000042   0x0629             LSLS     R1,R5,#+24
   \   00000044   0x0E89             LSRS     R1,R1,#+26
   \   00000046   0x6802             LDR      R2,[R0, #+0]
   \   00000048   0xF361 0x0200      BFI      R2,R1,#+0,#+1
   \   0000004C   0x6002             STR      R2,[R0, #+0]
     94          		GPIOD->__B.ODR.B1	= (Data >> 3) & 0x01;
   \   0000004E   0x0629             LSLS     R1,R5,#+24
   \   00000050   0x0EC9             LSRS     R1,R1,#+27
   \   00000052   0x6802             LDR      R2,[R0, #+0]
   \   00000054   0xF361 0x0241      BFI      R2,R1,#+1,#+1
   \   00000058   0x6002             STR      R2,[R0, #+0]
     95          		GPIOE->__B.ODR.B7	= (Data >> 4) & 0x01;
   \   0000005A   0x....             LDR.N    R0,??DataTable4_5  ;; 0x40021014
   \   0000005C   0x0629             LSLS     R1,R5,#+24
   \   0000005E   0x0F09             LSRS     R1,R1,#+28
   \   00000060   0x6802             LDR      R2,[R0, #+0]
   \   00000062   0xF361 0x12C7      BFI      R2,R1,#+7,#+1
   \   00000066   0x6002             STR      R2,[R0, #+0]
     96          		GPIOE->__B.ODR.B8	= (Data >> 5) & 0x01;
   \   00000068   0x0629             LSLS     R1,R5,#+24
   \   0000006A   0x0F49             LSRS     R1,R1,#+29
   \   0000006C   0x6802             LDR      R2,[R0, #+0]
   \   0000006E   0xF361 0x2208      BFI      R2,R1,#+8,#+1
   \   00000072   0x6002             STR      R2,[R0, #+0]
     97          		GPIOE->__B.ODR.B9	= (Data >> 6) & 0x01;
   \   00000074   0x0629             LSLS     R1,R5,#+24
   \   00000076   0x0F89             LSRS     R1,R1,#+30
   \   00000078   0x6802             LDR      R2,[R0, #+0]
   \   0000007A   0xF361 0x2249      BFI      R2,R1,#+9,#+1
   \   0000007E   0x6002             STR      R2,[R0, #+0]
     98          		GPIOE->__B.ODR.B10	= (Data >> 7) & 0x01;
   \   00000080   0x062D             LSLS     R5,R5,#+24
   \   00000082   0x0FE9             LSRS     R1,R5,#+31
   \   00000084   0x6802             LDR      R2,[R0, #+0]
   \   00000086   0xF361 0x228A      BFI      R2,R1,#+10,#+1
   \   0000008A   0x6002             STR      R2,[R0, #+0]
     99          #endif
    100          
    101          		// low
    102          		*(volatile INT32U *)(AHB1PERIPH_BASE + Addr + 0x0C) &=  ~(1 << BitAddr);
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0x40B8             LSLS     R0,R0,R7
   \   00000090   0x....             LDR.N    R1,??DataTable4_6  ;; 0x4002000c
   \   00000092   0x598A             LDR      R2,[R1, R6]
   \   00000094   0x4382             BICS     R2,R2,R0
   \   00000096   0x518A             STR      R2,[R1, R6]
    103          		// high
    104          		*(volatile INT32U *)(AHB1PERIPH_BASE + Addr + 0x0C) |=   (1 << BitAddr);
   \   00000098   0x598A             LDR      R2,[R1, R6]
   \   0000009A   0x4310             ORRS     R0,R0,R2
   \   0000009C   0x5188             STR      R0,[R1, R6]
    105          
    106          		ExpioModeChanege(1);
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0x.... 0x....      BL       ExpioModeChanege
    107          	}
    108          	#endif
    109          	
    110          	OSSemPost(ExpioSem);
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0x.... 0x....      BL       OSSemPost
    111          
    112          }
   \   000000AA   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    113          

   \                                 In section .text, align 2, keep-with-next
    114          INT16U ExpioReadData(INT8U SEL)
    115          {
   \                     ExpioReadData:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4680             MOV      R8,R0
    116          	INT16U ret = 0;
    117          	INT8U err;
    118          	
    119          	OSSemPend(ExpioSem, 0, &err);
   \   00000008   0x....             LDR.N    R4,??DataTable4_2
   \   0000000A   0xAA00             ADD      R2,SP,#+0
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x.... 0x....      BL       OSSemPend
    120          
    121          	#ifdef __FSMC_SRAM_H
    122          		ret = EXPIOrawData[SEL] = *(vu8 *)(EXPIOptr + SEL*EXPIOsize);
    123          	#else
    124          	{
    125          		INT32U Addr = ExpioCS[SEL]/16;
   \   00000014   0x.... 0x....      ADR.W    R0,ExpioCS
   \   00000018   0xF850 0x0028      LDR      R0,[R0, R8, LSL #+2]
   \   0000001C   0x0901             LSRS     R1,R0,#+4
    126          		INT32U BitAddr = ExpioCS[SEL]%16;
   \   0000001E   0xF000 0x000F      AND      R0,R0,#0xF
    127          
    128          		*(volatile INT32U *)(AHB1PERIPH_BASE + Addr + 0x0C) &=  ~(1 << BitAddr);
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0xFA02 0xF600      LSL      R6,R2,R0
   \   00000028   0x....             LDR.N    R0,??DataTable4_6  ;; 0x4002000c
   \   0000002A   0x1847             ADDS     R7,R0,R1
   \   0000002C   0x6838             LDR      R0,[R7, #+0]
   \   0000002E   0x43B0             BICS     R0,R0,R6
   \   00000030   0x6038             STR      R0,[R7, #+0]
    129          		ExpioModeChanege(1);
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x.... 0x....      BL       ExpioModeChanege
    130          
    131          		// low
    132          #ifdef STM32FRxT6_USED
    133          
    134          		ret = (ret << 1) | (GPIOD->IDR.B2);
    135          		ret = (ret << 1) | (GPIOC->IDR.B12);
    136          		ret = (ret << 1) | (GPIOC->IDR.B11);
    137          		ret = (ret << 1) | (GPIOC->IDR.B10);
    138          		ret = (ret << 1) | (GPIOC->IDR.B9);
    139          		ret = (ret << 1) | (GPIOC->IDR.B8);
    140          		ret = (ret << 1) | (GPIOC->IDR.B7);
    141          		ret = (ret << 1) | (GPIOC->IDR.B6);
    142          #else
    143          		ret = (ret << 1) | (GPIOE->__B.IDR.B10);
   \   00000038   0x....             LDR.N    R0,??DataTable4_7  ;; 0x40021010
   \   0000003A   0x6801             LDR      R1,[R0, #+0]
   \   0000003C   0xF3C1 0x2180      UBFX     R1,R1,#+10,#+1
    144          		ret = (ret << 1) | (GPIOE->__B.IDR.B9);
   \   00000040   0x6802             LDR      R2,[R0, #+0]
   \   00000042   0xF3C2 0x2240      UBFX     R2,R2,#+9,#+1
   \   00000046   0xEA42 0x0141      ORR      R1,R2,R1, LSL #+1
    145          		ret = (ret << 1) | (GPIOE->__B.IDR.B8);
   \   0000004A   0x6802             LDR      R2,[R0, #+0]
   \   0000004C   0xF3C2 0x2200      UBFX     R2,R2,#+8,#+1
   \   00000050   0xEA42 0x0141      ORR      R1,R2,R1, LSL #+1
    146          		ret = (ret << 1) | (GPIOE->__B.IDR.B7);
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0xF3C0 0x10C0      UBFX     R0,R0,#+7,#+1
   \   0000005A   0xEA40 0x0041      ORR      R0,R0,R1, LSL #+1
    147          		ret = (ret << 1) | (GPIOD->__B.IDR.B1);
   \   0000005E   0x....             LDR.N    R1,??DataTable4_8  ;; 0x40020c10
   \   00000060   0x680A             LDR      R2,[R1, #+0]
   \   00000062   0xF3C2 0x0240      UBFX     R2,R2,#+1,#+1
   \   00000066   0xEA42 0x0040      ORR      R0,R2,R0, LSL #+1
    148          		ret = (ret << 1) | (GPIOD->__B.IDR.B0);
   \   0000006A   0x680A             LDR      R2,[R1, #+0]
   \   0000006C   0x0852             LSRS     R2,R2,#+1
   \   0000006E   0x4140             ADCS     R0,R0,R0
   \   00000070   0xB280             UXTH     R0,R0
    149          		ret = (ret << 1) | (GPIOD->__B.IDR.B15);
   \   00000072   0x680A             LDR      R2,[R1, #+0]
   \   00000074   0xF3C2 0x32C0      UBFX     R2,R2,#+15,#+1
   \   00000078   0xEA42 0x0040      ORR      R0,R2,R0, LSL #+1
   \   0000007C   0xB280             UXTH     R0,R0
    150          		ret = (ret << 1) | (GPIOD->__B.IDR.B14);
   \   0000007E   0x6809             LDR      R1,[R1, #+0]
   \   00000080   0xF3C1 0x3180      UBFX     R1,R1,#+14,#+1
   \   00000084   0xEA41 0x0040      ORR      R0,R1,R0, LSL #+1
   \   00000088   0xB285             UXTH     R5,R0
    151          #endif
    152          		// SEL
    153          		// high
    154          		*(volatile INT32U *)(AHB1PERIPH_BASE + Addr + 0x0C) |=   (1 << BitAddr);
   \   0000008A   0x6838             LDR      R0,[R7, #+0]
   \   0000008C   0x4330             ORRS     R0,R6,R0
   \   0000008E   0x6038             STR      R0,[R7, #+0]
    155          
    156          		EXPIOrawData[SEL] = ret;
   \   00000090   0x....             LDR.N    R0,??DataTable4_3
   \   00000092   0xF820 0x5018      STRH     R5,[R0, R8, LSL #+1]
    157          	}
    158          	#endif
    159          	OSSemPost(ExpioSem);
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x.... 0x....      BL       OSSemPost
    160          
    161              return ret;
   \   0000009C   0x4628             MOV      R0,R5
   \   0000009E   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    162          }
    163          

   \                                 In section .text, align 2, keep-with-next
    164          unsigned short int ExpioBitRead (unsigned short int Bitaddr)
    165          {
   \                     ExpioBitRead:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    166          	INT16U	ExselNo;
    167          	INT16U	BitNumber;
    168          
    169          	ExselNo = (Bitaddr/16);
   \   00000004   0x0925             LSRS     R5,R4,#+4
    170          	BitNumber = (Bitaddr % 16);
    171          
    172          	ExpioReadData(ExselNo);
   \   00000006   0xB2E8             UXTB     R0,R5
   \   00000008   0x.... 0x....      BL       ExpioReadData
    173          	return BitRead(EXPIOrawData[ExselNo], BitNumber);	
   \   0000000C   0x....             LDR.N    R0,??DataTable4_3
   \   0000000E   0xF830 0x0015      LDRH     R0,[R0, R5, LSL #+1]
   \   00000012   0xF004 0x010F      AND      R1,R4,#0xF
   \   00000016   0x40C8             LSRS     R0,R0,R1
   \   00000018   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    174          }

   \                                 In section .text, align 2, keep-with-next
    175          void ExpioBitSet (unsigned short int Bitaddr)
    176          {
   \                     ExpioBitSet:
   \   00000000   0xB418             PUSH     {R3,R4}
    177          	INT16U	ExselNo;
    178          	INT16U	BitNumber;
    179          
    180          	ExselNo = (Bitaddr/16);
   \   00000002   0x0902             LSRS     R2,R0,#+4
    181          	BitNumber = (Bitaddr % 16);
    182           	EXPIOrawData[ExselNo] = ( EXPIOrawData[ExselNo] |(1 << BitNumber) );
   \   00000004   0x....             LDR.N    R3,??DataTable4_3
   \   00000006   0xF833 0x1012      LDRH     R1,[R3, R2, LSL #+1]
   \   0000000A   0x2401             MOVS     R4,#+1
   \   0000000C   0xF000 0x000F      AND      R0,R0,#0xF
   \   00000010   0xFA04 0xF000      LSL      R0,R4,R0
   \   00000014   0x4301             ORRS     R1,R0,R1
   \   00000016   0xF823 0x1012      STRH     R1,[R3, R2, LSL #+1]
    183          	ExpioWriteData(ExselNo, EXPIOrawData[ExselNo]);
   \   0000001A   0xB289             UXTH     R1,R1
   \   0000001C   0x....             B.N      ?Subroutine1
    184          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0xB2D0             UXTB     R0,R2
   \   00000002   0xBC14             POP      {R2,R4}
   \   00000004   0x....             B.N      ExpioWriteData
    185          

   \                                 In section .text, align 4, keep-with-next
    186          void ExpioBitRst(unsigned short int Bitaddr)
    187          {
   \                     ExpioBitRst:
   \   00000000   0xB418             PUSH     {R3,R4}
    188          	INT16U	ExselNo;
    189          	INT16U	BitNumber;
    190          
    191          	ExselNo = (Bitaddr/16);
   \   00000002   0x0902             LSRS     R2,R0,#+4
    192          	BitNumber = (Bitaddr % 16);
    193          	EXPIOrawData[ExselNo] = ( EXPIOrawData[ExselNo] & ~(1 << BitNumber) );
   \   00000004   0x4B00             LDR.N    R3,??ExpioBitRst_0
   \   00000006   0xE001             B.N      ??ExpioBitRst_1
   \                     ??ExpioBitRst_0:
   \   00000008   0x........         DC32     EXPIOrawData
   \                     ??ExpioBitRst_1:
   \   0000000C   0xF833 0x1012      LDRH     R1,[R3, R2, LSL #+1]
   \   00000010   0x2401             MOVS     R4,#+1
   \   00000012   0xF000 0x000F      AND      R0,R0,#0xF
   \   00000016   0xFA04 0xF000      LSL      R0,R4,R0
   \   0000001A   0x4381             BICS     R1,R1,R0
   \   0000001C   0xF823 0x1012      STRH     R1,[R3, R2, LSL #+1]
    194          	ExpioWriteData(ExselNo, EXPIOrawData[ExselNo]);
   \   00000020                      REQUIRE ?Subroutine1
   \   00000020                      ;; // Fall through to label ?Subroutine1
    195          	
    196          }
    197          #if 1

   \                                 In section .text, align 2, keep-with-next
    198          INT8U atoh (INT8U value )
    199          {
    200          	INT16U	num;
    201          
    202          	// isdigit() 는 입력값이 '0' ~ '9' 일경우 True
    203          	if( isdigit(value) ) num = value - '0';
   \                     atoh:
   \   00000000   0xF1A0 0x0130      SUB      R1,R0,#+48
   \   00000004   0x290A             CMP      R1,#+10
   \   00000006   0xBF38             IT       CC 
   \   00000008   0x3830             SUBCC    R0,R0,#+48
   \   0000000A   0xD30C             BCC.N    ??atoh_0
    204          
    205          	else if( (value >= 'a') && (value <= 'f') ) num = 10 + value - 'a';
   \   0000000C   0xF1A0 0x0161      SUB      R1,R0,#+97
   \   00000010   0x2906             CMP      R1,#+6
   \   00000012   0xBF38             IT       CC 
   \   00000014   0x3857             SUBCC    R0,R0,#+87
   \   00000016   0xD306             BCC.N    ??atoh_0
    206          	else if( (value >= 'A') && (value <= 'F') ) num = 10 + value - 'A';
   \   00000018   0xF1A0 0x0141      SUB      R1,R0,#+65
   \   0000001C   0x2906             CMP      R1,#+6
   \   0000001E   0xBF34             ITE      CC 
   \   00000020   0x3837             SUBCC    R0,R0,#+55
   \   00000022   0xF44F 0x7080      MOVCS    R0,#+256
    207          	else										num = 0x0100;
    208          
    209          	return (INT8U)num;
   \                     ??atoh_0:
   \   00000026   0xB2C0             UXTB     R0,R0
   \   00000028   0x4770             BX       LR               ;; return
    210          }
    211          #endif

   \                                 In section .text, align 2, keep-with-next
    212          INT16U ByteToWord(INT8U HighByte, INT8U LowByte)
    213          {
    214          	INT16U WordByte = 0;
    215          	
    216          	WordByte = (INT16U)HighByte;
    217          	WordByte = (WordByte << 8)& 0xff00;
    218          	WordByte = WordByte |(INT16U)LowByte;
    219          	return(WordByte);
   \                     ByteToWord:
   \   00000000   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   00000004   0x4770             BX       LR               ;; return
    220          }
    221          
    222          /*******************************************************************************
    223          * Table에서 Search한다.
    224          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    225          INT8U SearchWord(INT8U IsDec,INT8U nLen, INT16U SearchVal, INT16U *Buff)
    226          {
   \                     SearchWord:
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x1E48             SUBS     R0,R1,#+1
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0xB38C             CBZ.N    R4,??SearchWord_0
    227              unsigned char Max = nLen - 1 ,Mid , Min = 0;
    228          
    229          	if(IsDec)///1
    230          	{ /* 정렬이 내림 차순으로 된경우.  RSSI */
    231          		Max = nLen-1;
    232          		Min = 0;
   \   0000000A   0x2100             MOVS     R1,#+0
    233          	    if((Buff[Max] & 0x0FFF) >= SearchVal)    return(Max);
   \   0000000C   0xF833 0x4010      LDRH     R4,[R3, R0, LSL #+1]
   \   00000010   0x0524             LSLS     R4,R4,#+20
   \   00000012   0x0D24             LSRS     R4,R4,#+20
   \   00000014   0x4294             CMP      R4,R2
   \   00000016   0xDB01             BLT.N    ??SearchWord_1
   \                     ??SearchWord_2:
   \   00000018   0xBC70             POP      {R4-R6}
   \   0000001A   0x4770             BX       LR               ;; return
    234          	    if((Buff[Min] & 0x0FFF) <= SearchVal)    return(Min);
   \                     ??SearchWord_1:
   \   0000001C   0x881C             LDRH     R4,[R3, #+0]
   \   0000001E   0x0524             LSLS     R4,R4,#+20
   \   00000020   0xEBB2 0x5F14      CMP      R2,R4, LSR #+20
   \   00000024   0xDA2F             BGE.N    ??SearchWord_3
    235          
    236          	    while(1)
    237          		{
    238          		    if((Min+1) == Max)
   \                     ??SearchWord_4:
   \   00000026   0x1C4C             ADDS     R4,R1,#+1
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD10D             BNE.N    ??SearchWord_5
    239          			{
    240          			    if((Buff[Min] & 0x0FFF)- SearchVal > SearchVal - (Buff[Max] & 0x0FFF))return(Max);
   \   0000002C   0xF833 0x4010      LDRH     R4,[R3, R0, LSL #+1]
   \   00000030   0x0524             LSLS     R4,R4,#+20
   \   00000032   0xEBB2 0x5414      SUBS     R4,R2,R4, LSR #+20
   \   00000036   0xF833 0x3011      LDRH     R3,[R3, R1, LSL #+1]
   \   0000003A   0x051B             LSLS     R3,R3,#+20
   \   0000003C   0x0D1B             LSRS     R3,R3,#+20
   \   0000003E   0x1A9A             SUBS     R2,R3,R2
   \                     ??SearchWord_6:
   \   00000040   0x4294             CMP      R4,R2
   \   00000042   0xDBE9             BLT.N    ??SearchWord_2
    241          				else return(Min);
   \   00000044   0x4608             MOV      R0,R1
   \   00000046   0xE7E7             B.N      ??SearchWord_2
    242          			}
    243          
    244          			Mid = Min + (Max - Min)/2;
   \                     ??SearchWord_5:
   \   00000048   0x1A44             SUBS     R4,R0,R1
   \   0000004A   0xEB04 0x74D4      ADD      R4,R4,R4, LSR #+31
   \   0000004E   0xEB11 0x0464      ADDS     R4,R1,R4, ASR #+1
   \   00000052   0xB2E4             UXTB     R4,R4
   \   00000054   0xF833 0x5014      LDRH     R5,[R3, R4, LSL #+1]
   \   00000058   0x052E             LSLS     R6,R5,#+20
   \   0000005A   0x0D36             LSRS     R6,R6,#+20
   \   0000005C   0x4296             CMP      R6,R2
   \   0000005E   0xD02E             BEQ.N    ??SearchWord_7
    245          			if((Buff[Mid] & 0x0FFF) == SearchVal)  	return(Mid);
    246          			else if((Buff[Mid] & 0x0FFF) > SearchVal) 	Min = Mid;
   \   00000060   0x052D             LSLS     R5,R5,#+20
   \   00000062   0xEBB2 0x5F15      CMP      R2,R5, LSR #+20
   \   00000066   0xBFAC             ITE      GE 
   \   00000068   0x4620             MOVGE    R0,R4
   \   0000006A   0x4621             MOVLT    R1,R4
    247          			else										Max = Mid;
   \   0000006C   0xE7DB             B.N      ??SearchWord_4
    248          		}
    249          	}
    250          	else
    251          	{      /* 정렬이 오름 차순으로 된 경우. PM */
    252          
    253          		Max = nLen - 1;
    254          		Min = 0;
   \                     ??SearchWord_0:
   \   0000006E   0x2100             MOVS     R1,#+0
    255          
    256          	    if((Buff[Max] & 0x0FFF) <= SearchVal)	return(Max);
   \   00000070   0xF833 0x4010      LDRH     R4,[R3, R0, LSL #+1]
   \   00000074   0x0524             LSLS     R4,R4,#+20
   \   00000076   0xEBB2 0x5F14      CMP      R2,R4, LSR #+20
   \   0000007A   0xDACD             BGE.N    ??SearchWord_2
    257          	    if((Buff[Min] & 0x0FFF) >= SearchVal)   return(Min);
   \   0000007C   0x881C             LDRH     R4,[R3, #+0]
   \   0000007E   0x0524             LSLS     R4,R4,#+20
   \   00000080   0x0D24             LSRS     R4,R4,#+20
   \   00000082   0x4294             CMP      R4,R2
   \   00000084   0xDB01             BLT.N    ??SearchWord_8
   \                     ??SearchWord_3:
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xE7C6             B.N      ??SearchWord_2
    258          
    259          	    while(1)
    260          		{
    261          		    if((Min + 1) == Max)
   \                     ??SearchWord_8:
   \   0000008A   0x1C4C             ADDS     R4,R1,#+1
   \   0000008C   0x4284             CMP      R4,R0
   \   0000008E   0xD10A             BNE.N    ??SearchWord_9
    262          			{
    263          			    if((Buff[Min] & 0x0FFF) - SearchVal < SearchVal - (Buff[Max] & 0x0FFF))	return(Max);
   \   00000090   0xF833 0x4011      LDRH     R4,[R3, R1, LSL #+1]
   \   00000094   0x0524             LSLS     R4,R4,#+20
   \   00000096   0x0D24             LSRS     R4,R4,#+20
   \   00000098   0x1AA4             SUBS     R4,R4,R2
   \   0000009A   0xF833 0x3010      LDRH     R3,[R3, R0, LSL #+1]
   \   0000009E   0x051B             LSLS     R3,R3,#+20
   \   000000A0   0xEBB2 0x5213      SUBS     R2,R2,R3, LSR #+20
   \   000000A4   0xE7CC             B.N      ??SearchWord_6
    264          				else																	return(Min);
    265          			}
    266          
    267          			Mid = Min + (Max - Min)/2;
   \                     ??SearchWord_9:
   \   000000A6   0x1A44             SUBS     R4,R0,R1
   \   000000A8   0xEB04 0x74D4      ADD      R4,R4,R4, LSR #+31
   \   000000AC   0xEB11 0x0464      ADDS     R4,R1,R4, ASR #+1
   \   000000B0   0xB2E4             UXTB     R4,R4
   \   000000B2   0xF833 0x5014      LDRH     R5,[R3, R4, LSL #+1]
   \   000000B6   0x052E             LSLS     R6,R5,#+20
   \   000000B8   0x0D36             LSRS     R6,R6,#+20
   \   000000BA   0x4296             CMP      R6,R2
   \   000000BC   0xD101             BNE.N    ??SearchWord_10
    268          			     if((Buff[Mid] & 0x0FFF) == SearchVal)	return(Mid);
   \                     ??SearchWord_7:
   \   000000BE   0x4620             MOV      R0,R4
   \   000000C0   0xE7AA             B.N      ??SearchWord_2
    269          			else if((Buff[Mid] & 0x0FFF) < SearchVal) 	Min = Mid;
   \                     ??SearchWord_10:
   \   000000C2   0x052D             LSLS     R5,R5,#+20
   \   000000C4   0x0D2D             LSRS     R5,R5,#+20
   \   000000C6   0x4295             CMP      R5,R2
   \   000000C8   0xBFAC             ITE      GE 
   \   000000CA   0x4620             MOVGE    R0,R4
   \   000000CC   0x4621             MOVLT    R1,R4
    270          			else										Max = Mid;
   \   000000CE   0xE7DC             B.N      ??SearchWord_8
    271          		}
    272          	}
    273          
    274          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x40020C00         DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     ExpioSem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     EXPIOrawData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x40020C14         DC32     0x40020c14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x40021014         DC32     0x40021014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x4002000C         DC32     0x4002000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x40021010         DC32     0x40021010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x40020C10         DC32     0x40020c10
    275          
    276          ///////////////////////////////////////////////////////////////////////////////
    277          // End of Source File
    278          ////////////////////////
    279          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  ByteToWord
       16  ExpioBitRead
             16 -> ExpioReadData
        8  ExpioBitRst
              0 -> ExpioWriteData
        8  ExpioBitSet
              0 -> ExpioWriteData
       16  ExpioModeChanege
              0 -> GPIOPortInit
             16 -> GPIOPortInit
       32  ExpioReadData
             32 -> ExpioModeChanege
             32 -> OSSemPend
             32 -> OSSemPost
       24  ExpioWriteData
             24 -> ExpioModeChanege
             24 -> OSSemPend
             24 -> OSSemPost
       12  SearchWord
        0  atoh


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
      10  ?Subroutine0
       6  ?Subroutine1
       6  ByteToWord
      40  EXPIOrawData
      30  ExpioBitRead
      32  ExpioBitRst
      30  ExpioBitSet
      80  ExpioCS
     194  ExpioModeChanege
     162  ExpioReadData
     172  ExpioWriteData
     208  SearchWord
      42  atoh

 
    40 bytes in section .bss
 1 008 bytes in section .text
 
 1 008 bytes of CODE memory
    40 bytes of DATA memory

Errors: none
Warnings: none

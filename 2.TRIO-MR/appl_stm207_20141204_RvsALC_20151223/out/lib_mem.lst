###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     08/Feb/2018  09:39:53 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uC-LIB\lib_mem.c                                  #
#    Command line =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uC-LIB\lib_mem.c -lC                              #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\out\ -o D:\Project\TRIO\2.TRIO-MR\appl_stm207_201 #
#                    41204_RvsALC_20151223\out\ --endian=little               #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "D:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\include\ -I D:\Project\TRIO\2.TRIO-MR\appl_stm207 #
#                    _20141204_RvsALC_20151223\STM32F2xx_StdPeriph_Driver_v12 #
#                    12\ -I D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_Rv #
#                    sALC_20151223\STM32F2xx_StdPeriph_Driver_v1212\inc\ -I   #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uC-CPU\ -I D:\Project\TRIO\2.TRIO-MR\appl_stm207_ #
#                    20141204_RvsALC_20151223\uC-LIB\ -I                      #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uCOS-II\Ports\ -I D:\Project\TRIO\2.TRIO-MR\appl_ #
#                    stm207_20141204_RvsALC_20151223\uCOS-II\Source\ -I       #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uC-Probe\ -Oh --use_c++_inline                    #
#    List file    =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\out\lib_mem.lst                                   #
#    Object file  =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\out\lib_mem.o                                     #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20151223\uC-LIB\lib_mem.c
      1          /*
      2          *********************************************************************************************************
      3          *                                               uC/LIB
      4          *                                       CUSTOM LIBRARY MODULES
      5          *
      6          *                          (c) Copyright 2004-2007; Micrium, Inc.; Weston, FL
      7          *
      8          *               All rights reserved.  Protected by international copyright laws.
      9          *
     10          *               uC/LIB is provided in source form for FREE evaluation, for educational
     11          *               use or peaceful research.  If you plan on using uC/LIB in a commercial
     12          *               product you need to contact Micrium to properly license its use in your
     13          *               product.  We provide ALL the source code for your convenience and to
     14          *               help you experience uC/LIB.  The fact that the source code is provided
     15          *               does NOT mean that you can use it without paying a licensing fee.
     16          *
     17          *               Knowledge of the source code may NOT be used to develop a similar product.
     18          *
     19          *               Please help us continue to provide the Embedded community with the finest
     20          *               software available.  Your honesty is greatly appreciated.
     21          *********************************************************************************************************
     22          */
     23          
     24          /*
     25          *********************************************************************************************************
     26          *
     27          *                                     STANDARD MEMORY OPERATIONS
     28          *
     29          * Filename      : lib_mem.c
     30          * Version       : V1.24
     31          * Programmer(s) : ITJ
     32          *********************************************************************************************************
     33          * Note(s)       : (1) NO compiler-supplied standard library functions are used in library or product software.
     34          *
     35          *                     (a) ALL standard library functions are implemented in the custom library modules :
     36          *
     37          *                         (1) \<Custom Library Directory>\lib*.*
     38          *
     39          *                         (2) \<Custom Library Directory>\Ports\<cpu>\<compiler>\lib*_a.*
     40          *
     41          *                               where
     42          *                                       <Custom Library Directory>      directory path for custom library software
     43          *                                       <cpu>                           directory name for specific processor (CPU)
     44          *                                       <compiler>                      directory name for specific compiler
     45          *
     46          *                     (b) Product-specific library functions are implemented in individual products.
     47          *********************************************************************************************************
     48          */
     49          
     50          
     51          /*
     52          *********************************************************************************************************
     53          *                                            INCLUDE FILES
     54          *********************************************************************************************************
     55          */
     56          
     57          #define    LIB_MEM_MODULE
     58          #include  <lib_mem.h>
     59          
     60          
     61          /*$PAGE*/
     62          /*
     63          *********************************************************************************************************
     64          *                                            LOCAL DEFINES
     65          *********************************************************************************************************
     66          */
     67          
     68          
     69          /*
     70          *********************************************************************************************************
     71          *                                           LOCAL CONSTANTS
     72          *********************************************************************************************************
     73          */
     74          
     75          
     76          /*
     77          *********************************************************************************************************
     78          *                                          LOCAL DATA TYPES
     79          *********************************************************************************************************
     80          */
     81          
     82          
     83          /*
     84          *********************************************************************************************************
     85          *                                            LOCAL TABLES
     86          *********************************************************************************************************
     87          */
     88          
     89          
     90          /*
     91          *********************************************************************************************************
     92          *                                       LOCAL GLOBAL VARIABLES
     93          *********************************************************************************************************
     94          */
     95          
     96          
     97          /*
     98          *********************************************************************************************************
     99          *                                      LOCAL FUNCTION PROTOTYPES
    100          *********************************************************************************************************
    101          */
    102          
    103          
    104          /*
    105          *********************************************************************************************************
    106          *                                     LOCAL CONFIGURATION ERRORS
    107          *********************************************************************************************************
    108          */
    109          
    110          
    111          /*$PAGE*/
    112          /*
    113          *********************************************************************************************************
    114          *                                              Mem_Clr()
    115          *
    116          * Description : Clear data buffer (see Note #2).
    117          *
    118          * Argument(s) : pmem        Pointer to memory buffer to clear.
    119          *
    120          *               size        Number of data buffer octets to clear.
    121          *
    122          * Return(s)   : none.
    123          *
    124          * Caller(s)   : various.
    125          *
    126          * Note(s)     : (1) Null clears allowed (i.e. 0-octet size).
    127          *
    128          *                   See also 'Mem_Set()  Note #1'.
    129          *
    130          *               (2) Clear data by setting each data octet to 0.
    131          *********************************************************************************************************
    132          */
    133          

   \                                 In section .text, align 2, keep-with-next
    134          void  Mem_Clr (void        *pmem,
    135                         CPU_SIZE_T   size)
    136          {
    137              Mem_Set((void     *)pmem,
    138                      (CPU_INT08U)0,                                      /* See Note #2.                                         */
    139                      (CPU_SIZE_T)size);
   \                     Mem_Clr:
   \   00000000   0x460A             MOV      R2,R1
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004                      REQUIRE Mem_Set
   \   00000004                      ;; // Fall through to label Mem_Set
    140          }
    141          
    142          
    143          /*$PAGE*/
    144          /*
    145          *********************************************************************************************************
    146          *                                              Mem_Set()
    147          *
    148          * Description : Fill data buffer with specified data octet.
    149          *
    150          * Argument(s) : pmem        Pointer to memory buffer to fill with specified data octet.
    151          *
    152          *               data_val    Data fill octet value.
    153          *
    154          *               size        Number of data buffer octets to fill.
    155          *
    156          * Return(s)   : none.
    157          *
    158          * Caller(s)   : various.
    159          *
    160          * Note(s)     : (1) Null sets allowed (i.e. 0-octet size).
    161          *
    162          *               (2) For best CPU performance, optimized to fill data buffer using 'CPU_ALIGN'-sized data words.
    163          *
    164          *                   (a) Since many word-aligned processors REQUIRE that multi-octet words be accessed on 
    165          *                       word-aligned addresses, 'CPU_ALIGN'd words MUST be accessed on 'CPU_ALIGN'd addresses.
    166          *
    167          *               (3) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    168          *                   address boundary.
    169          *
    170          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus, 
    171          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    172          *                   mem_align_modulo arithmetic operation.
    173          *********************************************************************************************************
    174          */
    175          

   \                                 In section .text, align 2, keep-with-next
    176          void  Mem_Set (void        *pmem,
    177                         CPU_INT08U   data_val,
    178                         CPU_SIZE_T   size)
    179          {
    180              CPU_SIZE_T   size_rem;
    181              CPU_ALIGN    data_align;
    182              CPU_ALIGN   *pmem_align;
    183              CPU_INT08U  *pmem_08;
    184              CPU_INT08U   mem_align_modulo;
    185              CPU_INT08U   i;
    186          
    187          
    188              if (size < 1) {                                             /* See Note #1.                                         */
   \                     Mem_Set:
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0xBF18             IT       NE 
   \   00000004   0x2800             CMPNE    R0,#+0
    189                  return;
    190              }
    191              if (pmem == (void *)0) {
   \   00000006   0xD01F             BEQ.N    ??Mem_Set_0
    192                  return;
    193              }
    194          
    195          
    196              data_align = 0;
    197              for (i = 0; i < sizeof(CPU_ALIGN); i++) {                   /* Fill each data_align octet with data val.            */
    198                  data_align <<=  DEF_OCTET_NBR_BITS;
    199                  data_align  |= (CPU_ALIGN)data_val;
   \   00000008   0xEA41 0x2301      ORR      R3,R1,R1, LSL #+8
   \   0000000C   0xEA41 0x2303      ORR      R3,R1,R3, LSL #+8
   \   00000010   0xEA41 0x2303      ORR      R3,R1,R3, LSL #+8
    200              }
    201          
    202              size_rem         = (CPU_SIZE_T)size;
    203              mem_align_modulo = (CPU_INT08U)((CPU_ADDR)pmem % sizeof(CPU_ALIGN));    /* See Note #3.                             */
   \   00000014   0xF010 0x0C03      ANDS     R12,R0,#0x3
    204          
    205              pmem_08 = (CPU_INT08U *)pmem;
    206              if (mem_align_modulo != 0) {                                /* If leading octets avail,                   ...       */
   \   00000018   0xD00A             BEQ.N    ??Mem_Set_1
    207                  i = mem_align_modulo;
    208                  while ((size_rem > 0) &&                                /* ... start mem buf fill with leading octets ...       */
    209                         (i        < sizeof(CPU_ALIGN ))) {               /* ... until next CPU_ALIGN word boundary.              */
    210                     *pmem_08++ = data_val;
   \                     ??Mem_Set_2:
   \   0000001A   0xF800 0x1B01      STRB     R1,[R0], #+1
    211                      size_rem -= sizeof(CPU_INT08U);
   \   0000001E   0x1E52             SUBS     R2,R2,#+1
    212                      i++;
   \   00000020   0xF10C 0x0C01      ADD      R12,R12,#+1
    213                  }
   \   00000024   0xD004             BEQ.N    ??Mem_Set_1
   \   00000026   0xFA5F 0xFC8C      UXTB     R12,R12
   \   0000002A   0xF1BC 0x0F04      CMP      R12,#+4
   \   0000002E   0xD3F4             BCC.N    ??Mem_Set_2
    214              }
    215          
    216              pmem_align = (CPU_ALIGN *)pmem_08;                          /* See Note #2a.                                        */
   \                     ??Mem_Set_1:
   \   00000030   0x2A04             CMP      R2,#+4
   \   00000032   0xD304             BCC.N    ??Mem_Set_3
    217              while (size_rem >= sizeof(CPU_ALIGN)) {                     /* While mem buf aligned on CPU_ALIGN word boundaries,  */
    218                 *pmem_align++ = data_align;                              /* ... fill mem buf with    CPU_ALIGN-sized data.       */
   \                     ??Mem_Set_4:
   \   00000034   0xF840 0x3B04      STR      R3,[R0], #+4
    219                  size_rem    -= sizeof(CPU_ALIGN);
   \   00000038   0x1F12             SUBS     R2,R2,#+4
   \   0000003A   0x2A04             CMP      R2,#+4
   \   0000003C   0xD2FA             BCS.N    ??Mem_Set_4
    220              }
    221          
    222              pmem_08 = (CPU_INT08U *)pmem_align;
   \                     ??Mem_Set_3:
   \   0000003E   0xB11A             CBZ.N    R2,??Mem_Set_0
    223              while (size_rem > 0) {                                      /* Finish mem buf fill with trailing octets.            */
    224                 *pmem_08++   = data_val;
   \                     ??Mem_Set_5:
   \   00000040   0xF800 0x1B01      STRB     R1,[R0], #+1
    225                  size_rem   -= sizeof(CPU_INT08U);
   \   00000044   0x1E52             SUBS     R2,R2,#+1
   \   00000046   0xD1FB             BNE.N    ??Mem_Set_5
   \                     ??Mem_Set_0:
   \   00000048   0x4770             BX       LR               ;; return
    226              }
    227          }
    228          
    229          
    230          /*$PAGE*/
    231          /*
    232          *********************************************************************************************************
    233          *                                             Mem_Copy()
    234          *
    235          * Description : Copy data octets from one buffer to another buffer.
    236          *
    237          * Argument(s) : pdest       Pointer to destination memory buffer.
    238          *
    239          *               psrc        Pointer to source      memory buffer.
    240          *
    241          *               size        Number of data buffer octets to copy.
    242          *
    243          * Return(s)   : none.
    244          *
    245          * Caller(s)   : various.
    246          *
    247          * Note(s)     : (1) Null copies allowed (i.e. 0-octet size).
    248          *
    249          *               (2) Memory buffers NOT checked for overlapping.
    250          *
    251          *               (3) For best CPU performance, optimized to fill data buffer using 'CPU_ALIGN'-sized data words.
    252          *
    253          *                   (a) Since many word-aligned processors REQUIRE that multi-octet words be accessed on 
    254          *                       word-aligned addresses, 'CPU_ALIGN'd words MUST be accessed on 'CPU_ALIGN'd addresses.
    255          *
    256          *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    257          *                   address boundary.
    258          *
    259          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus, 
    260          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    261          *                   mem_align_modulo arithmetic operation.
    262          *********************************************************************************************************
    263          */
    264          /*$PAGE*/
    265          #if ((!defined(uC_CFG_OPTIMIZE_ASM_EN)) || \
    266               ((defined(uC_CFG_OPTIMIZE_ASM_EN)) && \
    267                        (uC_CFG_OPTIMIZE_ASM_EN   != DEF_ENABLED)))

   \                                 In section .text, align 2, keep-with-next
    268          void  Mem_Copy (void        *pdest,
    269                          void        *psrc,
    270                          CPU_SIZE_T   size)
    271          {
    272              CPU_SIZE_T    size_rem;
    273              CPU_ALIGN    *pmem_align_dest;
    274              CPU_ALIGN    *pmem_align_src;
    275              CPU_INT08U   *pmem_08_dest;
    276              CPU_INT08U   *pmem_08_src;
    277              CPU_INT08U    i;
    278              CPU_INT08U    mem_align_modulo_dest;
    279              CPU_INT08U    mem_align_modulo_src;
    280              CPU_BOOLEAN   mem_aligned;
    281          
    282          
    283              if (size < 1) {                                             /* See Note #1.                                         */
   \                     Mem_Copy:
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0xBF18             IT       NE 
   \   00000004   0x2800             CMPNE    R0,#+0
    284                  return;
    285              }
    286              if (pdest == (void *)0) {
   \   00000006   0xD021             BEQ.N    ??Mem_Copy_0
    287                  return;
    288              }
    289              if (psrc  == (void *)0) {
   \   00000008   0xB301             CBZ.N    R1,??Mem_Copy_0
    290                  return;
    291              }
    292          
    293          
    294              size_rem              = (CPU_SIZE_T  )size;
    295          
    296              pmem_08_dest          = (CPU_INT08U *)pdest;
    297              pmem_08_src           = (CPU_INT08U *)psrc;
    298                                                                          /* See Note #4.                                         */
    299              mem_align_modulo_dest = (CPU_INT08U  )((CPU_ADDR)pmem_08_dest % sizeof(CPU_ALIGN));
   \   0000000A   0xF000 0x0303      AND      R3,R0,#0x3
    300              mem_align_modulo_src  = (CPU_INT08U  )((CPU_ADDR)pmem_08_src  % sizeof(CPU_ALIGN));
    301          
    302              mem_aligned           = (mem_align_modulo_dest == mem_align_modulo_src) ? DEF_YES : DEF_NO;
   \   0000000E   0xF001 0x0C03      AND      R12,R1,#0x3
   \   00000012   0x4563             CMP      R3,R12
   \   00000014   0xD114             BNE.N    ??Mem_Copy_1
    303          
    304              if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
    305                                                                          /* ... optimize copy for mem buf alignment.             */
    306                  if (mem_align_modulo_dest != 0) {                       /* If leading octets avail,                   ...       */
   \   00000016   0xB14B             CBZ.N    R3,??Mem_Copy_2
    307                      i = mem_align_modulo_dest;
    308                      while ((size_rem   >  0) &&                         /* ... start mem buf copy with leading octets ...       */
    309                             (i          <  sizeof(CPU_ALIGN ))) {        /* ... until next CPU_ALIGN word boundary.              */
    310                         *pmem_08_dest++ = *pmem_08_src++;
   \                     ??Mem_Copy_3:
   \   00000018   0xF811 0xCB01      LDRB     R12,[R1], #+1
   \   0000001C   0xF800 0xCB01      STRB     R12,[R0], #+1
    311                          size_rem      -=  sizeof(CPU_INT08U);
   \   00000020   0x1E52             SUBS     R2,R2,#+1
    312                          i++;
   \   00000022   0x1C5B             ADDS     R3,R3,#+1
    313                      }
   \   00000024   0xB112             CBZ.N    R2,??Mem_Copy_2
   \   00000026   0xB2DB             UXTB     R3,R3
   \   00000028   0x2B04             CMP      R3,#+4
   \   0000002A   0xD3F5             BCC.N    ??Mem_Copy_3
    314                  }
    315          
    316                  pmem_align_dest = (CPU_ALIGN *)pmem_08_dest;            /* See Note #3a.                                        */
    317                  pmem_align_src  = (CPU_ALIGN *)pmem_08_src;
   \                     ??Mem_Copy_2:
   \   0000002C   0x2A04             CMP      R2,#+4
   \   0000002E   0xD306             BCC.N    ??Mem_Copy_4
    318                  while (size_rem      >=  sizeof(CPU_ALIGN)) {           /* While mem bufs aligned on CPU_ALIGN word boundaries, */
    319                     *pmem_align_dest++ = *pmem_align_src++;              /* ... copy psrc to pdest with CPU_ALIGN-sized words.   */
   \                     ??Mem_Copy_5:
   \   00000030   0xF851 0x3B04      LDR      R3,[R1], #+4
   \   00000034   0xF840 0x3B04      STR      R3,[R0], #+4
    320                      size_rem         -=  sizeof(CPU_ALIGN);
   \   00000038   0x1F12             SUBS     R2,R2,#+4
   \   0000003A   0x2A04             CMP      R2,#+4
   \   0000003C   0xD2F8             BCS.N    ??Mem_Copy_5
    321                  }
    322          
    323                  pmem_08_dest = (CPU_INT08U *)pmem_align_dest;
    324                  pmem_08_src  = (CPU_INT08U *)pmem_align_src;
    325              }
    326          
    327              while (size_rem > 0) {                                      /* For unaligned mem bufs or trailing octets, ...       */
   \                     ??Mem_Copy_4:
   \   0000003E   0xB12A             CBZ.N    R2,??Mem_Copy_0
    328                 *pmem_08_dest++ = *pmem_08_src++;                        /* ... copy psrc to pdest by octets.                    */
   \                     ??Mem_Copy_1:
   \   00000040   0xF811 0x3B01      LDRB     R3,[R1], #+1
   \   00000044   0xF800 0x3B01      STRB     R3,[R0], #+1
    329                  size_rem      -=  sizeof(CPU_INT08U);
   \   00000048   0x1E52             SUBS     R2,R2,#+1
   \   0000004A   0xD1F9             BNE.N    ??Mem_Copy_1
   \                     ??Mem_Copy_0:
   \   0000004C   0x4770             BX       LR               ;; return
    330              }
    331          }
    332          #endif
    333          
    334          
    335          /*$PAGE*/
    336          /*
    337          *********************************************************************************************************
    338          *                                              Mem_Cmp()
    339          *
    340          * Description : Verify that ALL data octets in two memory buffers are identical in sequence.
    341          *
    342          * Argument(s) : p1_mem      Pointer to first  memory buffer.
    343          *
    344          *               p2_mem      Pointer to second memory buffer.
    345          *
    346          *               size        Number of data buffer octets to compare.
    347          *
    348          * Return(s)   : DEF_YES, if 'size' number of data octets are identical in both memory buffers.
    349          *
    350          *               DEF_NO,  otherwise.
    351          *
    352          * Caller(s)   : various.
    353          *
    354          * Note(s)     : (1) Null compares allowed (i.e. 0-octet size); 'DEF_YES' returned to indicate identical 
    355          *                   null compare.
    356          *
    357          *               (2) Many memory buffer comparisons vary ONLY in the least significant octets -- e.g. 
    358          *                   network address buffers.  Consequently, memory buffer comparison is more efficient 
    359          *                   if the comparison starts from the end of the memory buffers which will abort sooner 
    360          *                   on dissimilar memory buffers that vary only in the least significant octets.
    361          *
    362          *               (3) For best CPU performance, optimized to fill data buffer using 'CPU_ALIGN'-sized data words.
    363          *
    364          *                   (a) Since many word-aligned processors REQUIRE that multi-octet words be accessed on 
    365          *                       word-aligned addresses, 'CPU_ALIGN'd words MUST be accessed on 'CPU_ALIGN'd addresses.
    366          *
    367          *               (4) Modulo arithmetic is used to determine whether a memory buffer starts on a 'CPU_ALIGN'
    368          *                   address boundary.
    369          *
    370          *                   Modulo arithmetic in ANSI-C REQUIREs operations performed on integer values.  Thus, 
    371          *                   address values MUST be cast to an appropriately-sized integer value PRIOR to any
    372          *                   mem_align_modulo arithmetic operation.
    373          ********************************************************************************************************
    374          */
    375          /*$PAGE*/

   \                                 In section .text, align 2, keep-with-next
    376          CPU_BOOLEAN  Mem_Cmp (void        *p1_mem,
    377                                void        *p2_mem,
    378                                CPU_SIZE_T   size)
    379          {
   \                     Mem_Cmp:
   \   00000000   0xB470             PUSH     {R4-R6}
    380              CPU_SIZE_T    size_rem;
    381              CPU_ALIGN    *p1_mem_align;
    382              CPU_ALIGN    *p2_mem_align;
    383              CPU_INT08U   *p1_mem_08;
    384              CPU_INT08U   *p2_mem_08;
    385              CPU_INT08U    i;
    386              CPU_INT08U    mem_align_modulo_1;
    387              CPU_INT08U    mem_align_modulo_2;
    388              CPU_BOOLEAN   mem_aligned;
    389              CPU_BOOLEAN   mem_cmp;
    390          
    391          
    392              if (size < 1) {                                             /* See Note #1.                                         */
   \   00000002   0xB90A             CBNZ.N   R2,??Mem_Cmp_0
    393                  return (DEF_YES);
   \   00000004   0x2001             MOVS     R0,#+1
   \   00000006   0xE020             B.N      ??Mem_Cmp_1
    394              }
    395              if (p1_mem == (void *)0) {
   \                     ??Mem_Cmp_0:
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xBF14             ITE      NE 
   \   0000000C   0x2900             CMPNE    R1,#+0
    396                  return (DEF_NO);
    397              }
    398              if (p2_mem == (void *)0) {
   \   0000000E   0x2000             MOVEQ    R0,#+0
    399                  return (DEF_NO);
   \   00000010   0xD01B             BEQ.N    ??Mem_Cmp_1
    400              }
    401          
    402          
    403              mem_cmp            =  DEF_YES;
   \   00000012   0x2301             MOVS     R3,#+1
    404              size_rem           =  size;
    405                                                                          /* Start @ end of mem bufs (see Note #2).               */
    406              p1_mem_08          = (CPU_INT08U *)p1_mem + size;
   \   00000014   0x1810             ADDS     R0,R2,R0
    407              p2_mem_08          = (CPU_INT08U *)p2_mem + size;
   \   00000016   0x1851             ADDS     R1,R2,R1
    408                                                                          /* See Note #4.                                         */
    409              mem_align_modulo_1 = (CPU_INT08U  )((CPU_ADDR)p1_mem_08 % sizeof(CPU_ALIGN));
   \   00000018   0xF000 0x0403      AND      R4,R0,#0x3
    410              mem_align_modulo_2 = (CPU_INT08U  )((CPU_ADDR)p2_mem_08 % sizeof(CPU_ALIGN));
    411          
    412              mem_aligned        = (mem_align_modulo_1 == mem_align_modulo_2) ? DEF_YES : DEF_NO;
   \   0000001C   0xF001 0x0503      AND      R5,R1,#0x3
   \   00000020   0x42AC             CMP      R4,R5
   \   00000022   0xD123             BNE.N    ??Mem_Cmp_2
    413          
    414              if (mem_aligned == DEF_YES) {                               /* If mem bufs' alignment offset equal, ...             */
    415                                                                          /* ... optimize cmp for mem buf alignment.              */
    416                  if (mem_align_modulo_1 != 0) {                          /* If trailing octets avail,                  ...       */
   \   00000024   0xB1DC             CBZ.N    R4,??Mem_Cmp_3
    417                      i = mem_align_modulo_1;
   \   00000026   0xE004             B.N      ??Mem_Cmp_4
    418                      while ((mem_cmp == DEF_YES) &&                      /* ... cmp mem bufs while identical &         ...       */
    419                             (size_rem > 0)       &&                      /* ... start mem buf cmp with trailing octets ...       */
    420                             (i        > 0)) {                            /* ... until next CPU_ALIGN word boundary.              */
   \                     ??Mem_Cmp_5:
   \   00000028   0x2A00             CMP      R2,#+0
   \   0000002A   0xBF1C             ITT      NE 
   \   0000002C   0xB2E4             UXTBNE   R4,R4
   \   0000002E   0x2C00             CMPNE    R4,#+0
   \   00000030   0xD015             BEQ.N    ??Mem_Cmp_3
    421                          p1_mem_08--;
    422                          p2_mem_08--;
    423                          if (*p1_mem_08 != *p2_mem_08) {                 /* If ANY data octet(s) NOT identical, cmp fails.       */
   \                     ??Mem_Cmp_4:
   \   00000032   0xF810 0x5D01      LDRB     R5,[R0, #-1]!
   \   00000036   0xF811 0x6D01      LDRB     R6,[R1, #-1]!
   \   0000003A   0x42B5             CMP      R5,R6
   \   0000003C   0xBF18             IT       NE 
   \   0000003E   0x2300             MOVNE    R3,#+0
    424                               mem_cmp = DEF_NO;
    425                          }
    426                          size_rem -= sizeof(CPU_INT08U);
   \   00000040   0x1E52             SUBS     R2,R2,#+1
    427                          i--;
   \   00000042   0x1E64             SUBS     R4,R4,#+1
    428                      }
   \   00000044   0x2B00             CMP      R3,#+0
   \   00000046   0xD1EF             BNE.N    ??Mem_Cmp_5
    429                  }
    430          
    431                  if (mem_cmp == DEF_YES) {                               /* If cmp still identical, cmp aligned mem bufs.        */
    432                      p1_mem_align = (CPU_ALIGN *)p1_mem_08;              /* See Note #3a.                                        */
    433                      p2_mem_align = (CPU_ALIGN *)p2_mem_08;
    434          
    435                      while ((mem_cmp  == DEF_YES) &&                     /* Cmp mem bufs while identical & ...                   */
    436                             (size_rem >= sizeof(CPU_ALIGN))) {           /* ... mem bufs aligned on CPU_ALIGN word boundaries.   */
    437                          p1_mem_align--;
    438                          p2_mem_align--;
    439                          if (*p1_mem_align != *p2_mem_align) {           /* If ANY data octet(s) NOT identical, cmp fails.       */
    440                               mem_cmp = DEF_NO;
    441                          }
    442                          size_rem -= sizeof(CPU_ALIGN);
    443                      }
    444          
    445                      p1_mem_08 = (CPU_INT08U *)p1_mem_align;
    446                      p2_mem_08 = (CPU_INT08U *)p2_mem_align;
    447                  }
    448              }
    449          
    450              while ((mem_cmp == DEF_YES) &&                              /* Cmp mem bufs while identical ...                     */
    451                     (size_rem > 0)) {                                    /* ... for unaligned mem bufs or trailing octets.       */
    452                  p1_mem_08--;
    453                  p2_mem_08--;
    454                  if (*p1_mem_08 != *p2_mem_08) {                         /* If ANY data octet(s) NOT identical, cmp fails.       */
    455                       mem_cmp = DEF_NO;
    456                  }
    457                  size_rem -= sizeof(CPU_INT08U);
    458              }
    459          
    460              return (mem_cmp);
   \                     ??Mem_Cmp_6:
   \   00000048   0x4618             MOV      R0,R3
   \                     ??Mem_Cmp_1:
   \   0000004A   0xBC70             POP      {R4-R6}
   \   0000004C   0x4770             BX       LR               ;; return
   \                     ??Mem_Cmp_7:
   \   0000004E   0xF850 0x4D04      LDR      R4,[R0, #-4]!
   \   00000052   0xF851 0x5D04      LDR      R5,[R1, #-4]!
   \   00000056   0x42AC             CMP      R4,R5
   \   00000058   0xBF18             IT       NE 
   \   0000005A   0x2300             MOVNE    R3,#+0
   \   0000005C   0x1F12             SUBS     R2,R2,#+4
   \                     ??Mem_Cmp_3:
   \   0000005E   0xB10B             CBZ.N    R3,??Mem_Cmp_8
   \   00000060   0x2A04             CMP      R2,#+4
   \   00000062   0xD2F4             BCS.N    ??Mem_Cmp_7
   \                     ??Mem_Cmp_8:
   \   00000064   0x2B00             CMP      R3,#+0
   \   00000066   0xBF18             IT       NE 
   \   00000068   0x2A00             CMPNE    R2,#+0
   \   0000006A   0xD0ED             BEQ.N    ??Mem_Cmp_6
   \                     ??Mem_Cmp_2:
   \   0000006C   0xF810 0x4D01      LDRB     R4,[R0, #-1]!
   \   00000070   0xF811 0x5D01      LDRB     R5,[R1, #-1]!
   \   00000074   0x42AC             CMP      R4,R5
   \   00000076   0xBF18             IT       NE 
   \   00000078   0x2300             MOVNE    R3,#+0
   \   0000007A   0x1E52             SUBS     R2,R2,#+1
   \   0000007C   0xE7F2             B.N      ??Mem_Cmp_8
    461          }
    462          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  Mem_Clr
             0 -> Mem_Set
       12  Mem_Cmp
        0  Mem_Copy
        0  Mem_Set


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  Mem_Clr
     126  Mem_Cmp
      78  Mem_Copy
      74  Mem_Set

 
 282 bytes in section .text
 
 282 bytes of CODE memory

Errors: none
Warnings: none

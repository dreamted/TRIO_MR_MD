###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     08/Feb/2018  09:39:16 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uCOS-II\Source\os_core.c                          #
#    Command line =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uCOS-II\Source\os_core.c -lC                      #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\out\ -o D:\Project\TRIO\2.TRIO-MR\appl_stm207_201 #
#                    41204_RvsALC_20151223\out\ --endian=little               #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "D:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\include\ -I D:\Project\TRIO\2.TRIO-MR\appl_stm207 #
#                    _20141204_RvsALC_20151223\STM32F2xx_StdPeriph_Driver_v12 #
#                    12\ -I D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_Rv #
#                    sALC_20151223\STM32F2xx_StdPeriph_Driver_v1212\inc\ -I   #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uC-CPU\ -I D:\Project\TRIO\2.TRIO-MR\appl_stm207_ #
#                    20141204_RvsALC_20151223\uC-LIB\ -I                      #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uCOS-II\Ports\ -I D:\Project\TRIO\2.TRIO-MR\appl_ #
#                    stm207_20141204_RvsALC_20151223\uCOS-II\Source\ -I       #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uC-Probe\ -Oh --use_c++_inline                    #
#    List file    =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\out\os_core.lst                                   #
#    Object file  =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\out\os_core.o                                     #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20151223\uCOS-II\Source\os_core.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                             CORE FUNCTIONS
      6          *
      7          *                          (c) Copyright 1992-2007, Jean J. Labrosse, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_CORE.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.85
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license 
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience 
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          #define  OS_GLOBALS
     26          
     27          #include <ucos_ii.h>

   \                                 In section iram, align 4
   \   __absolute INT8S OSCPUUsage
   \                     OSCPUUsage:
   \   00000000                      DS8 1
   \   __absolute BOOLEAN OSStatRdy
   \                     OSStatRdy:
   \   00000001                      DS8 1
   \   __absolute INT8U OSIntNesting
   \                     OSIntNesting:
   \   00000002                      DS8 1
   \   __absolute INT8U OSLockNesting
   \                     OSLockNesting:
   \   00000003                      DS8 1
   \   __absolute INT8U OSPrioCur
   \                     OSPrioCur:
   \   00000004                      DS8 1
   \   __absolute INT8U OSPrioHighRdy
   \                     OSPrioHighRdy:
   \   00000005                      DS8 1
   \   __absolute INT8U OSRdyGrp
   \                     OSRdyGrp:
   \   00000006                      DS8 1
   \   __absolute BOOLEAN OSRunning
   \                     OSRunning:
   \   00000007                      DS8 1
   \   __absolute INT8U OSTaskCtr
   \                     OSTaskCtr:
   \   00000008                      DS8 1
   \   __absolute INT8U OSTickStepState
   \                     OSTickStepState:
   \   00000009                      DS8 1
   \   0000000A                      DS8 2
   \   __absolute INT8U OSRdyTbl[4]
   \                     OSRdyTbl:
   \   0000000C                      DS8 4
   \   __absolute INT32U OSCtxSwCtr
   \                     OSCtxSwCtr:
   \   00000010                      DS8 4
   \   __absolute INT32U OSIdleCtrMax
   \                     OSIdleCtrMax:
   \   00000014                      DS8 4
   \   __absolute INT32U OSIdleCtrRun
   \                     OSIdleCtrRun:
   \   00000018                      DS8 4
   \   __absolute INT32U volatile OSIdleCtr
   \                     OSIdleCtr:
   \   0000001C                      DS8 4
   \   __absolute struct os_tcb *OSTCBCur
   \                     OSTCBCur:
   \   00000020                      DS8 4
   \   __absolute struct os_tcb *OSTCBFreeList
   \                     OSTCBFreeList:
   \   00000024                      DS8 4
   \   __absolute struct os_tcb *OSTCBHighRdy
   \                     OSTCBHighRdy:
   \   00000028                      DS8 4
   \   __absolute struct os_tcb *OSTCBList
   \                     OSTCBList:
   \   0000002C                      DS8 4
   \   __absolute INT32U volatile OSTime
   \                     OSTime:
   \   00000030                      DS8 4

   \                                 In section iram, align 4
   \   __absolute OS_EVENT OSEventTbl[30]
   \                     OSEventTbl:
   \   00000000                      DS8 480
   \   __absolute OS_TCB OSTCBTbl[18U]
   \                     OSTCBTbl:
   \   000001E0                      DS8 1008
   \   __absolute struct os_event *OSEventFreeList
   \                     OSEventFreeList:
   \   000005D0                      DS8 4
   \   __absolute OS_STK OSTaskStatStk[128]
   \                     OSTaskStatStk:
   \   000005D4                      DS8 512
   \   __absolute OS_STK OSTaskIdleStk[128]
   \                     OSTaskIdleStk:
   \   000007D4                      DS8 512

   \                                 In section iram, align 4
   \   __absolute OS_FLAG_GRP OSFlagTbl[5]
   \                     OSFlagTbl:
   \   00000000                      DS8 140

   \                                 In section iram, align 4
   \   __absolute struct os_flag_grp *OSFlagFreeList
   \                     OSFlagFreeList:
   \   00000000                      DS8 4

   \                                 In section iram, align 4
   \   __absolute struct os_tcb *OSTCBPrioTbl[32]
   \                     OSTCBPrioTbl:
   \   00000000                      DS8 128

   \                                 In section iram, align 4
   \   __absolute struct os_mem *OSMemFreeList
   \                     OSMemFreeList:
   \   00000000                      DS8 4

   \                                 In section iram, align 4
   \   __absolute OS_MEM OSMemTbl[5]
   \                     OSMemTbl:
   \   00000000                      DS8 180

   \                                 In section iram, align 4
   \   __absolute OS_Q *OSQFreeList
   \                     OSQFreeList:
   \   00000000                      DS8 4

   \                                 In section iram, align 4
   \   __absolute OS_Q OSQTbl[4]
   \                     OSQTbl:
   \   00000000                      DS8 96
     28          #endif
     29          
     30          /*
     31          *********************************************************************************************************
     32          *                                       PRIORITY RESOLUTION TABLE
     33          *
     34          * Note: Index into table is bit pattern to resolve highest priority
     35          *       Indexed value corresponds to highest priority bit position (i.e. 0..7)
     36          *********************************************************************************************************
     37          */
     38          

   \                                 In section .text, align 4, keep-with-next
     39          INT8U  const  OSUnMapTbl[256] = {
   \                     OSUnMapTbl:
   \   00000000   0x00 0x00          DC8 0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x04 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01         
   \   00000017   0x00 0x03          DC8 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x05    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00         
   \   0000002E   0x01 0x00          DC8 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2
   \              0x04 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x06 0x00    
   \              0x01 0x00    
   \              0x02         
   \   00000045   0x00 0x01          DC8 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x04    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00         
   \   0000005C   0x02 0x00          DC8 2, 0, 1, 0, 5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1
   \              0x01 0x00    
   \              0x05 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x04 0x00    
   \              0x01         
   \   00000073   0x00 0x02          DC8 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 7, 0, 1, 0, 2, 0, 1, 0, 3, 0
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x07    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00         
   \   0000008A   0x01 0x00          DC8 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x04 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x05         
   \   000000A1   0x00 0x01          DC8 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x04    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00         
   \   000000B8   0x03 0x00          DC8 3, 0, 1, 0, 2, 0, 1, 0, 6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x06 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01         
   \   000000CF   0x00 0x04          DC8 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 5, 0, 1, 0, 2, 0
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x03    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00 0x01    
   \              0x00 0x05    
   \              0x00 0x01    
   \              0x00 0x02    
   \              0x00         
   \   000000E6   0x01 0x00          DC8 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x04 0x00    
   \              0x01 0x00    
   \              0x02 0x00    
   \              0x01 0x00    
   \              0x03 0x00    
   \              0x01 0x00    
   \              0x02         
   \   000000FD   0x00 0x01          DC8 0, 1, 0
   \              0x00         
     40              0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x00 to 0x0F                             */
     41              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x10 to 0x1F                             */
     42              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x20 to 0x2F                             */
     43              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x30 to 0x3F                             */
     44              6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x40 to 0x4F                             */
     45              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x50 to 0x5F                             */
     46              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x60 to 0x6F                             */
     47              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x70 to 0x7F                             */
     48              7, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x80 to 0x8F                             */
     49              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0x90 to 0x9F                             */
     50              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xA0 to 0xAF                             */
     51              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xB0 to 0xBF                             */
     52              6, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xC0 to 0xCF                             */
     53              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xD0 to 0xDF                             */
     54              5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0,       /* 0xE0 to 0xEF                             */
     55              4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0        /* 0xF0 to 0xFF                             */
     56          };
     57          
     58          /*$PAGE*/
     59          /*
     60          *********************************************************************************************************
     61          *                                       FUNCTION PROTOTYPES
     62          *********************************************************************************************************
     63          */
     64          
     65          static  void  OS_InitEventList(void);
     66          
     67          static  void  OS_InitMisc(void);
     68          
     69          static  void  OS_InitRdyList(void);
     70          
     71          static  void  OS_InitTaskIdle(void);
     72          
     73          #if OS_TASK_STAT_EN > 0
     74          static  void  OS_InitTaskStat(void);
     75          #endif
     76          
     77          static  void  OS_InitTCBList(void);
     78          
     79          static  void  OS_SchedNew(void);
     80          
     81          /*$PAGE*/
     82          /*
     83          *********************************************************************************************************
     84          *                         GET THE NAME OF A SEMAPHORE, MUTEX, MAILBOX or QUEUE
     85          *
     86          * Description: This function is used to obtain the name assigned to a semaphore, mutex, mailbox or queue.
     87          *
     88          * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
     89          *                        a mutex, a mailbox or a queue.  Where this function is concerned, the actual
     90          *                        type is irrelevant.
     91          *
     92          *              pname     is a pointer to an ASCII string that will receive the name of the semaphore,
     93          *                        mutex, mailbox or queue.  The string must be able to hold at least
     94          *                        OS_EVENT_NAME_SIZE characters.
     95          *
     96          *              perr      is a pointer to an error code that can contain one of the following values:
     97          *
     98          *                        OS_ERR_NONE                if the name was copied to 'pname'
     99          *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
    100          *                                                   control block type.
    101          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    102          *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
    103          *
    104          * Returns    : The length of the string or 0 if the 'pevent' is a NULL pointer.
    105          *********************************************************************************************************
    106          */
    107          
    108          #if OS_EVENT_EN && (OS_EVENT_NAME_SIZE > 1)
    109          INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
    110          {
    111              INT8U      len;
    112          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    113              OS_CPU_SR  cpu_sr = 0;
    114          #endif
    115          
    116          
    117          
    118          #if OS_ARG_CHK_EN > 0
    119              if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
    120                  return (0);
    121              }
    122              if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
    123                  *perr = OS_ERR_PEVENT_NULL;
    124                  return (0);
    125              }
    126              if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
    127                  *perr = OS_ERR_PNAME_NULL;
    128                  return (0);
    129              }
    130          #endif
    131              if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
    132                  *perr  = OS_ERR_NAME_GET_ISR;
    133                  return (0);
    134              }
    135              switch (pevent->OSEventType) {
    136                  case OS_EVENT_TYPE_SEM:
    137                  case OS_EVENT_TYPE_MUTEX:
    138                  case OS_EVENT_TYPE_MBOX:
    139                  case OS_EVENT_TYPE_Q:
    140                       break;
    141          
    142                  default:
    143                       *perr = OS_ERR_EVENT_TYPE;
    144                       return (0);
    145              }
    146              OS_ENTER_CRITICAL();
    147              len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
    148              OS_EXIT_CRITICAL();
    149              *perr = OS_ERR_NONE;
    150              return (len);
    151          }
    152          #endif
    153          
    154          /*$PAGE*/
    155          /*
    156          *********************************************************************************************************
    157          *                         ASSIGN A NAME TO A SEMAPHORE, MUTEX, MAILBOX or QUEUE
    158          *
    159          * Description: This function assigns a name to a semaphore, mutex, mailbox or queue.
    160          *
    161          * Arguments  : pevent    is a pointer to the event group.  'pevent' can point either to a semaphore,
    162          *                        a mutex, a mailbox or a queue.  Where this function is concerned, it doesn't
    163          *                        matter the actual type.
    164          *
    165          *              pname     is a pointer to an ASCII string that will be used as the name of the semaphore,
    166          *                        mutex, mailbox or queue.  The string must be able to hold at least
    167          *                        OS_EVENT_NAME_SIZE characters.
    168          *
    169          *              perr      is a pointer to an error code that can contain one of the following values:
    170          *
    171          *                        OS_ERR_NONE                if the requested task is resumed
    172          *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to the proper event
    173          *                                                   control block type.
    174          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    175          *                        OS_ERR_PEVENT_NULL         if you passed a NULL pointer for 'pevent'
    176          *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
    177          *
    178          * Returns    : None
    179          *********************************************************************************************************
    180          */
    181          
    182          #if OS_EVENT_EN && (OS_EVENT_NAME_SIZE > 1)
    183          void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
    184          {
    185              INT8U      len;
    186          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    187              OS_CPU_SR  cpu_sr = 0;
    188          #endif
    189          
    190          
    191          
    192          #if OS_ARG_CHK_EN > 0
    193              if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
    194                  return;
    195              }
    196              if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
    197                  *perr = OS_ERR_PEVENT_NULL;
    198                  return;
    199              }
    200              if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
    201                  *perr = OS_ERR_PNAME_NULL;
    202                  return;
    203              }
    204          #endif
    205              if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
    206                  *perr = OS_ERR_NAME_SET_ISR;
    207                  return;
    208              }
    209              switch (pevent->OSEventType) {
    210                  case OS_EVENT_TYPE_SEM:
    211                  case OS_EVENT_TYPE_MUTEX:
    212                  case OS_EVENT_TYPE_MBOX:
    213                  case OS_EVENT_TYPE_Q:
    214                       break;
    215          
    216                  default:
    217                       *perr = OS_ERR_EVENT_TYPE;
    218                       return;
    219              }
    220              OS_ENTER_CRITICAL();
    221              len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
    222              if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
    223                  OS_EXIT_CRITICAL();
    224                  *perr = OS_ERR_EVENT_NAME_TOO_LONG;
    225                  return;
    226              }
    227              (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    228              OS_EXIT_CRITICAL();
    229              *perr = OS_ERR_NONE;
    230          }
    231          #endif
    232          
    233          /*$PAGE*/
    234          /*
    235          *********************************************************************************************************
    236          *                                             INITIALIZATION
    237          *
    238          * Description: This function is used to initialize the internals of uC/OS-II and MUST be called prior to
    239          *              creating any uC/OS-II object and, prior to calling OSStart().
    240          *
    241          * Arguments  : none
    242          *
    243          * Returns    : none
    244          *********************************************************************************************************
    245          */
    246          

   \                                 In section .text, align 2, keep-with-next
    247          void  OSInit (void)
    248          {
   \                     OSInit:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    249              OSInitHookBegin();                                           /* Call port specific initialization code   */
   \   00000002   0x.... 0x....      BL       OSInitHookBegin
    250          
    251              OS_InitMisc();                                               /* Initialize miscellaneous variables       */
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable14
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x6320             STR      R0,[R4, #+48]
   \   0000000E   0x70A0             STRB     R0,[R4, #+2]
   \   00000010   0x70E0             STRB     R0,[R4, #+3]
   \   00000012   0x7220             STRB     R0,[R4, #+8]
   \   00000014   0x71E0             STRB     R0,[R4, #+7]
   \   00000016   0x6120             STR      R0,[R4, #+16]
   \   00000018   0x61E0             STR      R0,[R4, #+28]
   \   0000001A   0x61A0             STR      R0,[R4, #+24]
   \   0000001C   0x6160             STR      R0,[R4, #+20]
   \   0000001E   0x7060             STRB     R0,[R4, #+1]
    252          
    253              OS_InitRdyList();                                            /* Initialize the Ready List                */
   \   00000020   0x71A0             STRB     R0,[R4, #+6]
   \   00000022   0x2104             MOVS     R1,#+4
   \   00000024   0xF104 0x000C      ADD      R0,R4,#+12
   \   00000028   0x.... 0x....      BL       __aeabi_memclr
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x7120             STRB     R0,[R4, #+4]
   \   00000030   0x7160             STRB     R0,[R4, #+5]
   \   00000032   0x62A0             STR      R0,[R4, #+40]
   \   00000034   0x6220             STR      R0,[R4, #+32]
    254          
    255              OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
   \   00000036   0x.... 0x....      LDR.W    R5,??DataTable14_1
   \   0000003A   0xF44F 0x717C      MOV      R1,#+1008
   \   0000003E   0xF205 0x10E0      ADDW     R0,R5,#+480
   \   00000042   0x.... 0x....      BL       OS_MemClr
   \   00000046   0x2180             MOVS     R1,#+128
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable14_2
   \   0000004C   0x.... 0x....      BL       OS_MemClr
   \   00000050   0xF205 0x2118      ADDW     R1,R5,#+536
   \   00000054   0xF8C5 0x11E4      STR      R1,[R5, #+484]
   \   00000058   0xF205 0x2250      ADDW     R2,R5,#+592
   \   0000005C   0x2002             MOVS     R0,#+2
   \                     ??OSInit_0:
   \   0000005E   0x604A             STR      R2,[R1, #+4]
   \   00000060   0xF201 0x0138      ADDW     R1,R1,#+56
   \   00000064   0xF202 0x0238      ADDW     R2,R2,#+56
   \   00000068   0x604A             STR      R2,[R1, #+4]
   \   0000006A   0xF201 0x0138      ADDW     R1,R1,#+56
   \   0000006E   0xF202 0x0238      ADDW     R2,R2,#+56
   \   00000072   0x604A             STR      R2,[R1, #+4]
   \   00000074   0xF201 0x0138      ADDW     R1,R1,#+56
   \   00000078   0xF202 0x0238      ADDW     R2,R2,#+56
   \   0000007C   0x604A             STR      R2,[R1, #+4]
   \   0000007E   0xF201 0x0138      ADDW     R1,R1,#+56
   \   00000082   0xF202 0x0238      ADDW     R2,R2,#+56
   \   00000086   0x604A             STR      R2,[R1, #+4]
   \   00000088   0xF201 0x0138      ADDW     R1,R1,#+56
   \   0000008C   0xF202 0x0238      ADDW     R2,R2,#+56
   \   00000090   0x604A             STR      R2,[R1, #+4]
   \   00000092   0xF201 0x0138      ADDW     R1,R1,#+56
   \   00000096   0xF202 0x0238      ADDW     R2,R2,#+56
   \   0000009A   0x604A             STR      R2,[R1, #+4]
   \   0000009C   0xF201 0x0138      ADDW     R1,R1,#+56
   \   000000A0   0xF202 0x0238      ADDW     R2,R2,#+56
   \   000000A4   0x604A             STR      R2,[R1, #+4]
   \   000000A6   0xF201 0x0138      ADDW     R1,R1,#+56
   \   000000AA   0xF202 0x0238      ADDW     R2,R2,#+56
   \   000000AE   0x1E40             SUBS     R0,R0,#+1
   \   000000B0   0xD1D5             BNE.N    ??OSInit_0
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x6048             STR      R0,[R1, #+4]
   \   000000B6   0x62E0             STR      R0,[R4, #+44]
   \   000000B8   0xF205 0x10E0      ADDW     R0,R5,#+480
   \   000000BC   0x6260             STR      R0,[R4, #+36]
    256          
    257              OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
   \   000000BE   0xF44F 0x71F0      MOV      R1,#+480
   \   000000C2   0x4628             MOV      R0,R5
   \   000000C4   0x.... 0x....      BL       OS_MemClr
   \   000000C8   0x2000             MOVS     R0,#+0
   \   000000CA   0x7028             STRB     R0,[R5, #+0]
   \   000000CC   0xF105 0x0010      ADD      R0,R5,#+16
   \   000000D0   0x6068             STR      R0,[R5, #+4]
   \   000000D2   0xF105 0x0120      ADD      R1,R5,#+32
   \   000000D6   0x2207             MOVS     R2,#+7
   \   000000D8   0x2300             MOVS     R3,#+0
   \                     ??OSInit_1:
   \   000000DA   0xF800 0x3B04      STRB     R3,[R0], #+4
   \   000000DE   0xF840 0x1B0C      STR      R1,[R0], #+12
   \   000000E2   0x3110             ADDS     R1,R1,#+16
   \   000000E4   0xF800 0x3B04      STRB     R3,[R0], #+4
   \   000000E8   0xF840 0x1B0C      STR      R1,[R0], #+12
   \   000000EC   0x3110             ADDS     R1,R1,#+16
   \   000000EE   0xF800 0x3B04      STRB     R3,[R0], #+4
   \   000000F2   0xF840 0x1B0C      STR      R1,[R0], #+12
   \   000000F6   0x3110             ADDS     R1,R1,#+16
   \   000000F8   0xF800 0x3B04      STRB     R3,[R0], #+4
   \   000000FC   0xF840 0x1B0C      STR      R1,[R0], #+12
   \   00000100   0x3110             ADDS     R1,R1,#+16
   \   00000102   0x1E52             SUBS     R2,R2,#+1
   \   00000104   0xD1E9             BNE.N    ??OSInit_1
   \   00000106   0x7003             STRB     R3,[R0, #+0]
   \   00000108   0x6043             STR      R3,[R0, #+4]
   \   0000010A   0xF8C5 0x55D0      STR      R5,[R5, #+1488]
    258          
    259          #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    260              OS_FlagInit();                                               /* Initialize the event flag structures     */
   \   0000010E   0x.... 0x....      BL       OS_FlagInit
    261          #endif
    262          
    263          #if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    264              OS_MemInit();                                                /* Initialize the memory manager            */
   \   00000112   0x.... 0x....      BL       OS_MemInit
    265          #endif
    266          
    267          #if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    268              OS_QInit();                                                  /* Initialize the message queue structures  */
   \   00000116   0x.... 0x....      BL       OS_QInit
    269          #endif
    270          
    271              OS_InitTaskIdle();                                           /* Create the Idle Task                     */
   \   0000011A   0x231F             MOVS     R3,#+31
   \   0000011C   0xF505 0x621D      ADD      R2,R5,#+2512
   \   00000120   0x2100             MOVS     R1,#+0
   \   00000122   0x.... 0x....      ADR.W    R0,OS_TaskIdle
   \   00000126   0x.... 0x....      BL       OSTaskCreate
    272          #if OS_TASK_STAT_EN > 0
    273              OS_InitTaskStat();                                           /* Create the Statistic Task                */
   \   0000012A   0x231E             MOVS     R3,#+30
   \   0000012C   0xF505 0x62FA      ADD      R2,R5,#+2000
   \   00000130   0x2100             MOVS     R1,#+0
   \   00000132   0x.... 0x....      ADR.W    R0,OS_TaskStat
   \   00000136   0x.... 0x....      BL       OSTaskCreate
    274          #endif
    275          
    276          #if OS_TMR_EN > 0
    277              OSTmr_Init();                                                /* Initialize the Timer Manager             */
    278          #endif
    279          
    280              OSInitHookEnd();                                             /* Call port specific init. code            */
   \   0000013A   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   0000013E   0x.... 0x....      B.W      OSInitHookEnd
    281          
    282          #if OS_DEBUG_EN > 0
    283              OSDebugInit();
    284          #endif
    285          }
    286          /*$PAGE*/
    287          /*
    288          *********************************************************************************************************
    289          *                                              ENTER ISR
    290          *
    291          * Description: This function is used to notify uC/OS-II that you are about to service an interrupt
    292          *              service routine (ISR).  This allows uC/OS-II to keep track of interrupt nesting and thus
    293          *              only perform rescheduling at the last nested ISR.
    294          *
    295          * Arguments  : none
    296          *
    297          * Returns    : none
    298          *
    299          * Notes      : 1) This function should be called ith interrupts already disabled
    300          *              2) Your ISR can directly increment OSIntNesting without calling this function because
    301          *                 OSIntNesting has been declared 'global'.
    302          *              3) You MUST still call OSIntExit() even though you increment OSIntNesting directly.
    303          *              4) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
    304          *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
    305          *                 end of the ISR.
    306          *              5) You are allowed to nest interrupts up to 255 levels deep.
    307          *              6) I removed the OS_ENTER_CRITICAL() and OS_EXIT_CRITICAL() around the increment because
    308          *                 OSIntEnter() is always called with interrupts disabled.
    309          *********************************************************************************************************
    310          */
    311          

   \                                 In section .text, align 2, keep-with-next
    312          void  OSIntEnter (void)
    313          {
   \                     OSIntEnter:
   \   00000000   0xB580             PUSH     {R7,LR}
    314          	OS_CPU_SR  cpu_sr;
    315          
    316          	OS_ENTER_CRITICAL();										// Tell uC/OS-II that we are starting an ISR
   \   00000002   0x.... 0x....      BL       OS_CPU_SR_Save
    317          
    318              if (OSRunning == OS_TRUE) {
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable14
   \   0000000A   0x79CA             LDRB     R2,[R1, #+7]
   \   0000000C   0x2A01             CMP      R2,#+1
   \   0000000E   0xD104             BNE.N    ??OSIntEnter_0
    319                  if (OSIntNesting < 255u) {
   \   00000010   0x788A             LDRB     R2,[R1, #+2]
   \   00000012   0x2AFF             CMP      R2,#+255
   \   00000014   0xBF1C             ITT      NE 
   \   00000016   0x1C52             ADDNE    R2,R2,#+1
   \   00000018   0x708A             STRBNE   R2,[R1, #+2]
    320                      OSIntNesting++;                      /* Increment ISR nesting level                        */
    321                  }
    322              }
    323          	OS_EXIT_CRITICAL();
   \                     ??OSIntEnter_0:
   \   0000001A   0xE8BD 0x4002      POP      {R1,LR}
   \   0000001E   0x.... 0x....      B.W      OS_CPU_SR_Restore
    324          }
    325          /*$PAGE*/
    326          /*
    327          *********************************************************************************************************
    328          *                                               EXIT ISR
    329          *
    330          * Description: This function is used to notify uC/OS-II that you have completed serviving an ISR.  When
    331          *              the last nested ISR has completed, uC/OS-II will call the scheduler to determine whether
    332          *              a new, high-priority task, is ready to run.
    333          *
    334          * Arguments  : none
    335          *
    336          * Returns    : none
    337          *
    338          * Notes      : 1) You MUST invoke OSIntEnter() and OSIntExit() in pair.  In other words, for every call
    339          *                 to OSIntEnter() at the beginning of the ISR you MUST have a call to OSIntExit() at the
    340          *                 end of the ISR.
    341          *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
    342          *********************************************************************************************************
    343          */
    344          

   \                                 In section .text, align 2, keep-with-next
    345          void  OSIntExit (void)
    346          {
   \                     OSIntExit:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    347          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    348              OS_CPU_SR  cpu_sr = 0;
    349          #endif
    350          
    351          
    352          
    353              if (OSRunning == OS_TRUE) {
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable14
   \   00000006   0x79E0             LDRB     R0,[R4, #+7]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD11F             BNE.N    ??OSIntExit_0
    354                  OS_ENTER_CRITICAL();
   \   0000000C   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000010   0x4605             MOV      R5,R0
    355                  if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
   \   00000012   0x78A0             LDRB     R0,[R4, #+2]
   \   00000014   0xB108             CBZ.N    R0,??OSIntExit_1
    356                      OSIntNesting--;
   \   00000016   0x1E40             SUBS     R0,R0,#+1
   \   00000018   0x70A0             STRB     R0,[R4, #+2]
    357                  }
    358                  if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
    359                      if (OSLockNesting == 0) {                      /* ... and not locked.                      */
   \                     ??OSIntExit_1:
   \   0000001A   0x78A0             LDRB     R0,[R4, #+2]
   \   0000001C   0x78E1             LDRB     R1,[R4, #+3]
   \   0000001E   0x4308             ORRS     R0,R1,R0
   \   00000020   0xD112             BNE.N    ??OSIntExit_2
    360                          OS_SchedNew();
   \   00000022   0x.... 0x....      BL       OS_SchedNew
    361                          if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
   \   00000026   0x7960             LDRB     R0,[R4, #+5]
   \   00000028   0x7921             LDRB     R1,[R4, #+4]
   \   0000002A   0x4288             CMP      R0,R1
   \   0000002C   0xD00C             BEQ.N    ??OSIntExit_2
    362                              OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   00000032   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000036   0x62A0             STR      R0,[R4, #+40]
    363          #if OS_TASK_PROFILE_EN > 0
    364                              OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
   \   00000038   0x6A41             LDR      R1,[R0, #+36]
   \   0000003A   0x1C49             ADDS     R1,R1,#+1
   \   0000003C   0x6241             STR      R1,[R0, #+36]
    365          #endif
    366                              OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
   \   0000003E   0x6920             LDR      R0,[R4, #+16]
   \   00000040   0x1C40             ADDS     R0,R0,#+1
   \   00000042   0x6120             STR      R0,[R4, #+16]
    367                              OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
   \   00000044   0x.... 0x....      BL       OSIntCtxSw
    368                          }
    369                      }
    370                  }
    371                  OS_EXIT_CRITICAL();
   \                     ??OSIntExit_2:
   \   00000048   0x4628             MOV      R0,R5
   \   0000004A   0x....             B.N      ?Subroutine0
    372              }
    373          }
   \                     ??OSIntExit_0:
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000004   0x.... 0x....      B.W      OS_CPU_SR_Restore
    374          /*$PAGE*/
    375          /*
    376          *********************************************************************************************************
    377          *                                          PREVENT SCHEDULING
    378          *
    379          * Description: This function is used to prevent rescheduling to take place.  This allows your application
    380          *              to prevent context switches until you are ready to permit context switching.
    381          *
    382          * Arguments  : none
    383          *
    384          * Returns    : none
    385          *
    386          * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
    387          *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
    388          *********************************************************************************************************
    389          */
    390          
    391          #if OS_SCHED_LOCK_EN > 0

   \                                 In section .text, align 2, keep-with-next
    392          void  OSSchedLock (void)
    393          {
   \                     OSSchedLock:
   \   00000000   0xB510             PUSH     {R4,LR}
    394          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    395              OS_CPU_SR  cpu_sr = 0;
    396          #endif
    397          
    398          
    399          
    400              if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable14
   \   00000006   0x79E0             LDRB     R0,[R4, #+7]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD109             BNE.N    ??OSSchedLock_0
    401                  OS_ENTER_CRITICAL();
   \   0000000C   0x.... 0x....      BL       OS_CPU_SR_Save
    402                  if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
   \   00000010   0x78A1             LDRB     R1,[R4, #+2]
   \   00000012   0xB921             CBNZ.N   R1,??OSSchedLock_1
    403                      if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
   \   00000014   0x78E1             LDRB     R1,[R4, #+3]
   \   00000016   0x29FF             CMP      R1,#+255
   \   00000018   0xBF1C             ITT      NE 
   \   0000001A   0x1C49             ADDNE    R1,R1,#+1
   \   0000001C   0x70E1             STRBNE   R1,[R4, #+3]
    404                          OSLockNesting++;                 /* Increment lock nesting level                       */
    405                      }
    406                  }
    407                  OS_EXIT_CRITICAL();
   \                     ??OSSchedLock_1:
   \   0000001E   0x....             B.N      ?Subroutine1
    408              }
    409          }
   \                     ??OSSchedLock_0:
   \   00000020   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0xE8BD 0x4010      POP      {R4,LR}
   \   00000004   0x.... 0x....      B.W      OS_CPU_SR_Restore
    410          #endif
    411          
    412          /*$PAGE*/
    413          /*
    414          *********************************************************************************************************
    415          *                                          ENABLE SCHEDULING
    416          *
    417          * Description: This function is used to re-allow rescheduling.
    418          *
    419          * Arguments  : none
    420          *
    421          * Returns    : none
    422          *
    423          * Notes      : 1) You MUST invoke OSSchedLock() and OSSchedUnlock() in pair.  In other words, for every
    424          *                 call to OSSchedLock() you MUST have a call to OSSchedUnlock().
    425          *********************************************************************************************************
    426          */
    427          
    428          #if OS_SCHED_LOCK_EN > 0

   \                                 In section .text, align 2, keep-with-next
    429          void  OSSchedUnlock (void)
    430          {
   \                     OSSchedUnlock:
   \   00000000   0xB510             PUSH     {R4,LR}
    431          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    432              OS_CPU_SR  cpu_sr = 0;
    433          #endif
    434          
    435          
    436          
    437              if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable14
   \   00000006   0x79E0             LDRB     R0,[R4, #+7]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD111             BNE.N    ??OSSchedUnlock_0
    438                  OS_ENTER_CRITICAL();
   \   0000000C   0x.... 0x....      BL       OS_CPU_SR_Save
    439                  if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
   \   00000010   0x78E1             LDRB     R1,[R4, #+3]
   \   00000012   0xB161             CBZ.N    R1,??OSSchedUnlock_1
    440                      OSLockNesting--;                               /* Decrement lock nesting level             */
   \   00000014   0x1E49             SUBS     R1,R1,#+1
   \   00000016   0x70E1             STRB     R1,[R4, #+3]
    441                      if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
   \   00000018   0xB2C9             UXTB     R1,R1
   \   0000001A   0x2900             CMP      R1,#+0
   \   0000001C   0xBF04             ITT      EQ 
   \   0000001E   0x78A1             LDRBEQ   R1,[R4, #+2]
   \   00000020   0x2900             CMPEQ    R1,#+0
    442                          if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
   \   00000022   0xD104             BNE.N    ??OSSchedUnlock_1
    443                              OS_EXIT_CRITICAL();
   \   00000024   0x.... 0x....      BL       OS_CPU_SR_Restore
    444                              OS_Sched();                            /* See if a HPT is ready                    */
   \   00000028   0xE8BD 0x4010      POP      {R4,LR}
   \   0000002C   0x....             B.N      OS_Sched
    445                          } else {
    446                              OS_EXIT_CRITICAL();
    447                          }
    448                      } else {
    449                          OS_EXIT_CRITICAL();
    450                      }
    451                  } else {
    452                      OS_EXIT_CRITICAL();
   \                     ??OSSchedUnlock_1:
   \   0000002E   0x....             B.N      ?Subroutine1
    453                  }
    454              }
    455          }
   \                     ??OSSchedUnlock_0:
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
    456          #endif
    457          
    458          /*$PAGE*/
    459          /*
    460          *********************************************************************************************************
    461          *                                          START MULTITASKING
    462          *
    463          * Description: This function is used to start the multitasking process which lets uC/OS-II manages the
    464          *              task that you have created.  Before you can call OSStart(), you MUST have called OSInit()
    465          *              and you MUST have created at least one task.
    466          *
    467          * Arguments  : none
    468          *
    469          * Returns    : none
    470          *
    471          * Note       : OSStartHighRdy() MUST:
    472          *                 a) Call OSTaskSwHook() then,
    473          *                 b) Set OSRunning to OS_TRUE.
    474          *                 c) Load the context of the task pointed to by OSTCBHighRdy.
    475          *                 d_ Execute the task.
    476          *********************************************************************************************************
    477          */
    478          

   \                                 In section .text, align 2, keep-with-next
    479          void  OSStart (void)
    480          {
   \                     OSStart:
   \   00000000   0xB510             PUSH     {R4,LR}
    481              if (OSRunning == OS_FALSE) {
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable14
   \   00000006   0x79E0             LDRB     R0,[R4, #+7]
   \   00000008   0xB968             CBNZ.N   R0,??OSStart_0
    482                  OS_SchedNew();                               /* Find highest priority's task priority number   */
   \   0000000A   0x.... 0x....      BL       OS_SchedNew
    483                  OSPrioCur     = OSPrioHighRdy;
   \   0000000E   0x7960             LDRB     R0,[R4, #+5]
   \   00000010   0x7120             STRB     R0,[R4, #+4]
    484                  OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable14_2
   \   00000016   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   0000001A   0x62A0             STR      R0,[R4, #+40]
    485                  OSTCBCur      = OSTCBHighRdy;
   \   0000001C   0x6220             STR      R0,[R4, #+32]
    486                  OSStartHighRdy();                            /* Execute target specific code to start task     */
   \   0000001E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000022   0x.... 0x....      B.W      OSStartHighRdy
    487              }
    488          }
   \                     ??OSStart_0:
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
    489          /*$PAGE*/
    490          /*
    491          *********************************************************************************************************
    492          *                                        STATISTICS INITIALIZATION
    493          *
    494          * Description: This function is called by your application to establish CPU usage by first determining
    495          *              how high a 32-bit counter would count to in 1 second if no other tasks were to execute
    496          *              during that time.  CPU usage is then determined by a low priority task which keeps track
    497          *              of this 32-bit counter every second but this time, with other tasks running.  CPU usage is
    498          *              determined by:
    499          *
    500          *                                             OSIdleCtr
    501          *                 CPU Usage (%) = 100 * (1 - ------------)
    502          *                                            OSIdleCtrMax
    503          *
    504          * Arguments  : none
    505          *
    506          * Returns    : none
    507          *********************************************************************************************************
    508          */
    509          
    510          #if OS_TASK_STAT_EN > 0

   \                                 In section .text, align 2, keep-with-next
    511          void  OSStatInit (void)
    512          {
   \                     OSStatInit:
   \   00000000   0xB510             PUSH     {R4,LR}
    513          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    514              OS_CPU_SR  cpu_sr = 0;
    515          #endif
    516          
    517          
    518          
    519              OSTimeDly(2);                                /* Synchronize with clock tick                        */
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x.... 0x....      BL       OSTimeDly
    520              OS_ENTER_CRITICAL();
   \   00000008   0x.... 0x....      BL       OS_CPU_SR_Save
    521              OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable14
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x61E1             STR      R1,[R4, #+28]
    522              OS_EXIT_CRITICAL();
   \   00000014   0x.... 0x....      BL       OS_CPU_SR_Restore
    523              OSTimeDly(OS_TICKS_PER_SEC);            /* Determine MAX. idle counter value for 1/10 second  */
   \   00000018   0xF44F 0x707A      MOV      R0,#+1000
   \   0000001C   0x.... 0x....      BL       OSTimeDly
    524              OS_ENTER_CRITICAL();
   \   00000020   0x.... 0x....      BL       OS_CPU_SR_Save
    525              OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
   \   00000024   0x69E1             LDR      R1,[R4, #+28]
   \   00000026   0x6161             STR      R1,[R4, #+20]
    526              OSStatRdy    = OS_TRUE;
   \   00000028   0x2101             MOVS     R1,#+1
   \   0000002A   0x7061             STRB     R1,[R4, #+1]
    527              OS_EXIT_CRITICAL();
   \   0000002C                      REQUIRE ?Subroutine1
   \   0000002C                      ;; // Fall through to label ?Subroutine1
    528          }
    529          #endif
    530          /*$PAGE*/
    531          /*
    532          *********************************************************************************************************
    533          *                                         PROCESS SYSTEM TICK
    534          *
    535          * Description: This function is used to signal to uC/OS-II the occurrence of a 'system tick' (also known
    536          *              as a 'clock tick').  This function should be called by the ticker ISR but, can also be
    537          *              called by a high priority task.
    538          *
    539          * Arguments  : none
    540          *
    541          * Returns    : none
    542          *********************************************************************************************************
    543          */
    544          

   \                                 In section .text, align 2, keep-with-next
    545          void  OSTimeTick (void)
    546          {
   \                     OSTimeTick:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    547              OS_TCB    *ptcb;
    548          #if OS_TICK_STEP_EN > 0
    549              BOOLEAN    step;
    550          #endif
    551          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    552              OS_CPU_SR  cpu_sr = 0;
    553          #endif
    554          
    555          
    556          
    557          #if OS_TIME_TICK_HOOK_EN > 0
    558              OSTimeTickHook();                                      /* Call user definable hook                     */
   \   00000002   0x.... 0x....      BL       OSTimeTickHook
    559          #endif
    560          #if OS_TIME_GET_SET_EN > 0
    561              OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
   \   00000006   0x.... 0x....      BL       OS_CPU_SR_Save
    562              OSTime++;
   \   0000000A   0x....             LDR.N    R4,??DataTable14
   \   0000000C   0x6B21             LDR      R1,[R4, #+48]
   \   0000000E   0x1C49             ADDS     R1,R1,#+1
   \   00000010   0x6321             STR      R1,[R4, #+48]
    563              OS_EXIT_CRITICAL();
   \   00000012   0x.... 0x....      BL       OS_CPU_SR_Restore
    564          #endif
    565              if (OSRunning == OS_TRUE) {
   \   00000016   0x79E0             LDRB     R0,[R4, #+7]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD133             BNE.N    ??OSTimeTick_0
    566          #if OS_TICK_STEP_EN > 0
    567                  switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
   \   0000001C   0x7A60             LDRB     R0,[R4, #+9]
   \   0000001E   0xB138             CBZ.N    R0,??OSTimeTick_1
   \   00000020   0x2802             CMP      R0,#+2
   \   00000022   0xD001             BEQ.N    ??OSTimeTick_2
   \   00000024   0xD32E             BCC.N    ??OSTimeTick_0
   \   00000026   0xE001             B.N      ??OSTimeTick_3
    568                      case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
    569                           step = OS_TRUE;
    570                           break;
    571          
    572                      case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
    573                           step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
    574                           break;
    575          
    576                      case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
    577                           step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
    578                           OSTickStepState = OS_TICK_STEP_WAIT;
   \                     ??OSTimeTick_2:
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xE000             B.N      ??OSTimeTick_4
    579                           break;
    580          
    581                      default:                                       /* Invalid case, correct situation              */
    582                           step            = OS_TRUE;
    583                           OSTickStepState = OS_TICK_STEP_DIS;
   \                     ??OSTimeTick_3:
   \   0000002C   0x2000             MOVS     R0,#+0
   \                     ??OSTimeTick_4:
   \   0000002E   0x7260             STRB     R0,[R4, #+9]
    584                           break;
    585                  }
    586                  if (step == OS_FALSE) {                            /* Return if waiting for step command           */
    587                      return;
    588                  }
    589          #endif
    590                  ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
   \                     ??OSTimeTick_1:
   \   00000030   0x6AE5             LDR      R5,[R4, #+44]
    591                  while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
   \   00000032   0x7FA8             LDRB     R0,[R5, #+30]
   \   00000034   0x281F             CMP      R0,#+31
   \   00000036   0xD025             BEQ.N    ??OSTimeTick_0
    592                      OS_ENTER_CRITICAL();
   \                     ??OSTimeTick_5:
   \   00000038   0x.... 0x....      BL       OS_CPU_SR_Save
    593                      if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
   \   0000003C   0x1D29             ADDS     R1,R5,#+4
   \   0000003E   0x8ACA             LDRH     R2,[R1, #+22]
   \   00000040   0xB1D2             CBZ.N    R2,??OSTimeTick_6
    594                          if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
   \   00000042   0x1E52             SUBS     R2,R2,#+1
   \   00000044   0x82CA             STRH     R2,[R1, #+22]
   \   00000046   0xB292             UXTH     R2,R2
   \   00000048   0xB9B2             CBNZ.N   R2,??OSTimeTick_6
    595                                                                     /* Check for timeout                            */
    596                              if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
   \   0000004A   0x7E0A             LDRB     R2,[R1, #+24]
   \   0000004C   0x2337             MOVS     R3,#+55
   \   0000004E   0x421A             TST      R2,R3
   \   00000050   0xBF1D             ITTTE    NE 
   \   00000052   0xF002 0x02C8      ANDNE    R2,R2,#0xC8
   \   00000056   0x760A             STRBNE   R2,[R1, #+24]
   \   00000058   0x2201             MOVNE    R2,#+1
   \   0000005A   0x2200             MOVEQ    R2,#+0
    597                                  ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
    598                                  ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
    599                              } else {
    600                                  ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
   \   0000005C   0x764A             STRB     R2,[R1, #+25]
    601                              }
    602          
    603                              if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
   \   0000005E   0x7E0A             LDRB     R2,[R1, #+24]
   \   00000060   0x0712             LSLS     R2,R2,#+28
   \   00000062   0xD409             BMI.N    ??OSTimeTick_6
    604                                  OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
   \   00000064   0x79A2             LDRB     R2,[R4, #+6]
   \   00000066   0x7F8B             LDRB     R3,[R1, #+30]
   \   00000068   0x431A             ORRS     R2,R3,R2
   \   0000006A   0x71A2             STRB     R2,[R4, #+6]
    605                                  OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   0000006C   0x7F0A             LDRB     R2,[R1, #+28]
   \   0000006E   0x1912             ADDS     R2,R2,R4
   \   00000070   0x7B13             LDRB     R3,[R2, #+12]
   \   00000072   0x7F49             LDRB     R1,[R1, #+29]
   \   00000074   0x4319             ORRS     R1,R1,R3
   \   00000076   0x7311             STRB     R1,[R2, #+12]
    606                              }
    607                          }
    608                      }
    609                      ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
   \                     ??OSTimeTick_6:
   \   00000078   0x686D             LDR      R5,[R5, #+4]
    610                      OS_EXIT_CRITICAL();
   \   0000007A   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   0000007E   0x7FA8             LDRB     R0,[R5, #+30]
   \   00000080   0x281F             CMP      R0,#+31
   \   00000082   0xD1D9             BNE.N    ??OSTimeTick_5
   \                     ??OSTimeTick_0:
   \   00000084   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    611                  }
    612              }
    613          }
    614          
    615          /*$PAGE*/
    616          /*
    617          *********************************************************************************************************
    618          *                                             GET VERSION
    619          *
    620          * Description: This function is used to return the version number of uC/OS-II.  The returned value
    621          *              corresponds to uC/OS-II's version number multiplied by 100.  In other words, version 2.00
    622          *              would be returned as 200.
    623          *
    624          * Arguments  : none
    625          *
    626          * Returns    : the version number of uC/OS-II multiplied by 100.
    627          *********************************************************************************************************
    628          */
    629          

   \                                 In section .text, align 2, keep-with-next
    630          INT16U  OSVersion (void)
    631          {
    632              return (OS_VERSION);
   \                     OSVersion:
   \   00000000   0xF240 0x101D      MOVW     R0,#+285
   \   00000004   0x4770             BX       LR               ;; return
    633          }
    634          
    635          /*$PAGE*/
    636          /*
    637          *********************************************************************************************************
    638          *                                            DUMMY FUNCTION
    639          *
    640          * Description: This function doesn't do anything.  It is called by OSTaskDel().
    641          *
    642          * Arguments  : none
    643          *
    644          * Returns    : none
    645          *********************************************************************************************************
    646          */
    647          
    648          #if OS_TASK_DEL_EN > 0

   \                                 In section .text, align 2, keep-with-next
    649          void  OS_Dummy (void)
    650          {
    651          }
   \                     OS_Dummy:
   \   00000000   0x4770             BX       LR               ;; return
    652          #endif
    653          
    654          /*$PAGE*/
    655          /*
    656          *********************************************************************************************************
    657          *                             MAKE TASK READY TO RUN BASED ON EVENT OCCURING
    658          *
    659          * Description: This function is called by other uC/OS-II services and is used to ready a task that was
    660          *              waiting for an event to occur.
    661          *
    662          * Arguments  : pevent      is a pointer to the event control block corresponding to the event.
    663          *
    664          *              pmsg        is a pointer to a message.  This pointer is used by message oriented services
    665          *                          such as MAILBOXEs and QUEUEs.  The pointer is not used when called by other
    666          *                          service functions.
    667          *
    668          *              msk         is a mask that is used to clear the status byte of the TCB.  For example,
    669          *                          OSSemPost() will pass OS_STAT_SEM, OSMboxPost() will pass OS_STAT_MBOX etc.
    670          *
    671          *              pend_stat   is used to indicate the readied task's pending status:
    672          *
    673          *                          OS_STAT_PEND_OK      Task ready due to a post (or delete), not a timeout or
    674          *                                               an abort.
    675          *                          OS_STAT_PEND_ABORT   Task ready due to an abort.
    676          *
    677          * Returns    : none
    678          *
    679          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
    680          *********************************************************************************************************
    681          */
    682          #if OS_EVENT_EN

   \                                 In section .text, align 2, keep-with-next
    683          INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
    684          {
   \                     OS_EventTaskRdy:
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
    685              OS_TCB  *ptcb;
    686              INT8U    x;
    687              INT8U    y;
    688              INT8U    prio;
    689          #if OS_LOWEST_PRIO <= 63
    690              INT8U    bitx;
    691              INT8U    bity;
    692          #else
    693              INT16U   bitx;
    694              INT16U   bity;
    695              INT16U  *ptbl;
    696          #endif
    697          
    698          
    699          #if OS_LOWEST_PRIO <= 63
    700              y     = OSUnMapTbl[pevent->OSEventGrp];             /* Find HPT waiting for message                */
   \   00000002   0x.... 0x....      ADR.W    R4,OSUnMapTbl
   \   00000006   0x7A85             LDRB     R5,[R0, #+10]
   \   00000008   0x5D2D             LDRB     R5,[R5, R4]
    701              bity  = (INT8U)(1 << y);
   \   0000000A   0x2701             MOVS     R7,#+1
   \   0000000C   0xFA07 0xF605      LSL      R6,R7,R5
   \   00000010   0xB2F6             UXTB     R6,R6
    702              x     = OSUnMapTbl[pevent->OSEventTbl[y]];
   \   00000012   0xEB05 0x0C00      ADD      R12,R5,R0
   \   00000016   0xF89C 0xE00B      LDRB     LR,[R12, #+11]
   \   0000001A   0xF81E 0x4004      LDRB     R4,[LR, R4]
    703              bitx  = (INT8U)(1 << x);
   \   0000001E   0x40A7             LSLS     R7,R7,R4
   \   00000020   0xB2FF             UXTB     R7,R7
    704              prio  = (INT8U)((y << 3) + x);                      /* Find priority of task getting the msg       */
   \   00000022   0xEB04 0x04C5      ADD      R4,R4,R5, LSL #+3
    705          #else
    706              if ((pevent->OSEventGrp & 0xFF) != 0) {             /* Find HPT waiting for message                */
    707                  y = OSUnMapTbl[pevent->OSEventGrp & 0xFF];
    708              } else {
    709                  y = OSUnMapTbl[(pevent->OSEventGrp >> 8) & 0xFF] + 8;
    710              }
    711              bity = (INT16U)(1 << y);
    712              ptbl = &pevent->OSEventTbl[y];
    713              if ((*ptbl & 0xFF) != 0) {
    714                  x = OSUnMapTbl[*ptbl & 0xFF];
    715              } else {
    716                  x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    717              }
    718              bitx = (INT16U)(1 << x);
    719              prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
    720          #endif
    721          
    722              pevent->OSEventTbl[y] &= ~bitx;                     /* Remove this task from the waiting list      */
   \   00000026   0xEA3E 0x0E07      BICS     LR,LR,R7
   \   0000002A   0xF88C 0xE00B      STRB     LR,[R12, #+11]
    723              if (pevent->OSEventTbl[y] == 0) {
   \   0000002E   0xD105             BNE.N    ??OS_EventTaskRdy_0
    724                  pevent->OSEventGrp &= ~bity;                    /* Clr group bit if this was only task pending */
   \   00000030   0xF890 0xC00A      LDRB     R12,[R0, #+10]
   \   00000034   0xEA2C 0x0C06      BIC      R12,R12,R6
   \   00000038   0xF880 0xC00A      STRB     R12,[R0, #+10]
    725              }
    726              ptcb                 =  OSTCBPrioTbl[prio];         /* Point to this task's OS_TCB                 */
   \                     ??OS_EventTaskRdy_0:
   \   0000003C   0xB2E4             UXTB     R4,R4
   \   0000003E   0x....             LDR.N    R0,??DataTable14_2
   \   00000040   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
    727              ptcb->OSTCBDly       =  0;                          /* Prevent OSTimeTick() from readying task     */
   \   00000044   0xF04F 0x0C00      MOV      R12,#+0
   \   00000048   0xF8A0 0xC01A      STRH     R12,[R0, #+26]
    728              ptcb->OSTCBEventPtr  = (OS_EVENT *)0;               /* Unlink ECB from this task                   */
   \   0000004C   0xF8C0 0xC00C      STR      R12,[R0, #+12]
    729          #if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    730              ptcb->OSTCBMsg       =  pmsg;                       /* Send message directly to waiting task       */
   \   00000050   0x6101             STR      R1,[R0, #+16]
    731          #else
    732              pmsg                 =  pmsg;                       /* Prevent compiler warning if not used        */
    733          #endif
    734              ptcb->OSTCBStatPend  =  pend_stat;                  /* Set pend status of post or abort            */
   \   00000052   0x7743             STRB     R3,[R0, #+29]
    735              ptcb->OSTCBStat     &= ~msk;                        /* Clear bit associated with event type        */
   \   00000054   0x7F01             LDRB     R1,[R0, #+28]
   \   00000056   0x4391             BICS     R1,R1,R2
   \   00000058   0x7701             STRB     R1,[R0, #+28]
    736              if (ptcb->OSTCBStat ==  OS_STAT_RDY) {              /* See if task is ready (could be susp'd)      */
   \   0000005A   0xD107             BNE.N    ??OS_EventTaskRdy_1
    737                  OSRdyGrp        |=  bity;                       /* Put task in the ready to run list           */
   \   0000005C   0x....             LDR.N    R0,??DataTable14
   \   0000005E   0x7981             LDRB     R1,[R0, #+6]
   \   00000060   0x4331             ORRS     R1,R6,R1
   \   00000062   0x7181             STRB     R1,[R0, #+6]
    738                  OSRdyTbl[y]     |=  bitx;
   \   00000064   0x1828             ADDS     R0,R5,R0
   \   00000066   0x7B01             LDRB     R1,[R0, #+12]
   \   00000068   0x4339             ORRS     R1,R7,R1
   \   0000006A   0x7301             STRB     R1,[R0, #+12]
    739              }
    740              return (prio);
   \                     ??OS_EventTaskRdy_1:
   \   0000006C   0x4620             MOV      R0,R4
   \   0000006E   0xBDF0             POP      {R4-R7,PC}       ;; return
    741          }
    742          #endif
    743          /*$PAGE*/
    744          /*
    745          *********************************************************************************************************
    746          *                                   MAKE TASK WAIT FOR EVENT TO OCCUR
    747          *
    748          * Description: This function is called by other uC/OS-II services to suspend a task because an event has
    749          *              not occurred.
    750          *
    751          * Arguments  : pevent   is a pointer to the event control block for which the task will be waiting for.
    752          *
    753          * Returns    : none
    754          *
    755          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
    756          *********************************************************************************************************
    757          */
    758          #if OS_EVENT_EN

   \                                 In section .text, align 2, keep-with-next
    759          void  OS_EventTaskWait (OS_EVENT *pevent)
    760          {
   \                     OS_EventTaskWait:
   \   00000000   0xB430             PUSH     {R4,R5}
    761              INT8U  y;
    762          
    763          
    764              OSTCBCur->OSTCBEventPtr =  pevent;            /* Store pointer to event control block in TCB       */
   \   00000002   0x....             LDR.N    R1,??DataTable14
   \   00000004   0x6A0A             LDR      R2,[R1, #+32]
   \   00000006   0x60D0             STR      R0,[R2, #+12]
    765              y                       =  OSTCBCur->OSTCBY;  /* Task no longer ready                              */
   \   00000008   0xF202 0x020C      ADDW     R2,R2,#+12
   \   0000000C   0x7D13             LDRB     R3,[R2, #+20]
    766              OSRdyTbl[y]            &= ~OSTCBCur->OSTCBBitX;
   \   0000000E   0x185B             ADDS     R3,R3,R1
   \   00000010   0x7B1C             LDRB     R4,[R3, #+12]
   \   00000012   0x7D55             LDRB     R5,[R2, #+21]
   \   00000014   0x43AC             BICS     R4,R4,R5
   \   00000016   0x731C             STRB     R4,[R3, #+12]
    767              if (OSRdyTbl[y] == 0) {
   \   00000018   0xD103             BNE.N    ??OS_EventTaskWait_0
    768                  OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
   \   0000001A   0x798B             LDRB     R3,[R1, #+6]
   \   0000001C   0x7D94             LDRB     R4,[R2, #+22]
   \   0000001E   0x43A3             BICS     R3,R3,R4
   \   00000020   0x718B             STRB     R3,[R1, #+6]
    769              }
    770              pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;          /* Put task in waiting list  */
   \                     ??OS_EventTaskWait_0:
   \   00000022   0x7D13             LDRB     R3,[R2, #+20]
   \   00000024   0x181B             ADDS     R3,R3,R0
   \   00000026   0x7ADC             LDRB     R4,[R3, #+11]
   \   00000028   0x7D52             LDRB     R2,[R2, #+21]
   \   0000002A   0x4322             ORRS     R2,R2,R4
   \   0000002C   0x72DA             STRB     R2,[R3, #+11]
    771              pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
   \   0000002E   0x7A82             LDRB     R2,[R0, #+10]
   \   00000030   0x6A09             LDR      R1,[R1, #+32]
   \   00000032   0xF891 0x1022      LDRB     R1,[R1, #+34]
   \   00000036   0x4311             ORRS     R1,R1,R2
   \   00000038   0x7281             STRB     R1,[R0, #+10]
    772          }
   \   0000003A   0xBC30             POP      {R4,R5}
   \   0000003C   0x4770             BX       LR               ;; return
    773          #endif
    774          /*$PAGE*/
    775          /*
    776          *********************************************************************************************************
    777          *                          MAKE TASK READY TO RUN BASED ON EVENT TIMEOUT OR ABORT
    778          *
    779          * Description: This function is called by other uC/OS-II services to make a task ready to run because a
    780          *              timeout or abort occurred.
    781          *
    782          * Arguments  : pevent   is a pointer to the event control block which is readying a task.
    783          *
    784          * Returns    : none
    785          *
    786          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
    787          *********************************************************************************************************
    788          */
    789          #if OS_EVENT_EN

   \                                 In section .text, align 2, keep-with-next
    790          void  OS_EventTOAbort (OS_EVENT *pevent)
    791          {
    792              INT8U  y;
    793          
    794          
    795              y                       =  OSTCBCur->OSTCBY;
   \                     OS_EventTOAbort:
   \   00000000   0x....             LDR.N    R1,??DataTable14
   \   00000002   0x6A0A             LDR      R2,[R1, #+32]
   \   00000004   0xF892 0x3020      LDRB     R3,[R2, #+32]
    796              pevent->OSEventTbl[y]  &= ~OSTCBCur->OSTCBBitX;    /* Remove task from wait list                   */
   \   00000008   0x181B             ADDS     R3,R3,R0
   \   0000000A   0xF893 0xC00B      LDRB     R12,[R3, #+11]
   \   0000000E   0xF892 0x2021      LDRB     R2,[R2, #+33]
   \   00000012   0xEA3C 0x0202      BICS     R2,R12,R2
   \   00000016   0x72DA             STRB     R2,[R3, #+11]
    797              if (pevent->OSEventTbl[y] == 0x00) {
   \   00000018   0xD105             BNE.N    ??OS_EventTOAbort_0
    798                  pevent->OSEventGrp &= ~OSTCBCur->OSTCBBitY;
   \   0000001A   0x7A82             LDRB     R2,[R0, #+10]
   \   0000001C   0x6A0B             LDR      R3,[R1, #+32]
   \   0000001E   0xF893 0x3022      LDRB     R3,[R3, #+34]
   \   00000022   0x439A             BICS     R2,R2,R3
   \   00000024   0x7282             STRB     R2,[R0, #+10]
    799              }
    800              OSTCBCur->OSTCBStatPend =  OS_STAT_PEND_OK;        /* Clear pend status                            */
   \                     ??OS_EventTOAbort_0:
   \   00000026   0x6A08             LDR      R0,[R1, #+32]
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x7742             STRB     R2,[R0, #+29]
    801              OSTCBCur->OSTCBStat     =  OS_STAT_RDY;            /* Set status to ready                          */
   \   0000002C   0x6A08             LDR      R0,[R1, #+32]
   \   0000002E   0x7702             STRB     R2,[R0, #+28]
    802              OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;           /* No longer waiting for event                  */
   \   00000030   0x6A08             LDR      R0,[R1, #+32]
   \   00000032   0x60C2             STR      R2,[R0, #+12]
    803          }
   \   00000034   0x4770             BX       LR               ;; return
    804          #endif
    805          /*$PAGE*/
    806          /*
    807          *********************************************************************************************************
    808          *                                 INITIALIZE EVENT CONTROL BLOCK'S WAIT LIST
    809          *
    810          * Description: This function is called by other uC/OS-II services to initialize the event wait list.
    811          *
    812          * Arguments  : pevent    is a pointer to the event control block allocated to the event.
    813          *
    814          * Returns    : none
    815          *
    816          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
    817          *********************************************************************************************************
    818          */
    819          #if OS_EVENT_EN

   \                                 In section .text, align 2, keep-with-next
    820          void  OS_EventWaitListInit (OS_EVENT *pevent)
    821          {
    822          #if OS_LOWEST_PRIO <= 63
    823              INT8U  *ptbl;
    824          #else
    825              INT16U *ptbl;
    826          #endif
    827              INT8U   i;
    828          
    829          
    830              pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
   \                     OS_EventWaitListInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7281             STRB     R1,[R0, #+10]
    831              ptbl               = &pevent->OSEventTbl[0];
    832          
    833              for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
    834                  *ptbl++ = 0;
   \   00000004   0x2104             MOVS     R1,#+4
   \   00000006   0x300B             ADDS     R0,R0,#+11
   \   00000008   0x.... 0x....      B.W      __aeabi_memclr
    835              }
    836          }
    837          #endif
    838          /*$PAGE*/
    839          /*
    840          *********************************************************************************************************
    841          *                                             INITIALIZATION
    842          *                           INITIALIZE THE FREE LIST OF EVENT CONTROL BLOCKS
    843          *
    844          * Description: This function is called by OSInit() to initialize the free list of event control blocks.
    845          *
    846          * Arguments  : none
    847          *
    848          * Returns    : none
    849          *********************************************************************************************************
    850          */
    851          
    852          static  void  OS_InitEventList (void)
    853          {
    854          #if OS_EVENT_EN && (OS_MAX_EVENTS > 0)
    855          #if (OS_MAX_EVENTS > 1)
    856              INT16U     i;
    857              OS_EVENT  *pevent1;
    858              OS_EVENT  *pevent2;
    859          
    860          
    861              OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    862              pevent1 = &OSEventTbl[0];
    863              pevent2 = &OSEventTbl[1];
    864              for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
    865                  pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
    866                  pevent1->OSEventPtr     = pevent2;
    867          #if OS_EVENT_NAME_SIZE > 1
    868                  pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
    869                  pevent1->OSEventName[1] = OS_ASCII_NUL;
    870          #endif
    871                  pevent1++;
    872                  pevent2++;
    873              }
    874              pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
    875              pevent1->OSEventPtr             = (OS_EVENT *)0;
    876          #if OS_EVENT_NAME_SIZE > 1
    877              pevent1->OSEventName[0]         = '?';
    878              pevent1->OSEventName[1]         = OS_ASCII_NUL;
    879          #endif
    880              OSEventFreeList                 = &OSEventTbl[0];
    881          #else
    882              OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
    883              OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
    884              OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
    885          #if OS_EVENT_NAME_SIZE > 1
    886              OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    887              OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
    888          #endif
    889          #endif
    890          #endif
    891          }
    892          /*$PAGE*/
    893          /*
    894          *********************************************************************************************************
    895          *                                             INITIALIZATION
    896          *                                    INITIALIZE MISCELLANEOUS VARIABLES
    897          *
    898          * Description: This function is called by OSInit() to initialize miscellaneous variables.
    899          *
    900          * Arguments  : none
    901          *
    902          * Returns    : none
    903          *********************************************************************************************************
    904          */
    905          
    906          static  void  OS_InitMisc (void)
    907          {
    908          #if OS_TIME_GET_SET_EN > 0
    909              OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
    910          #endif
    911          
    912              OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
    913              OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
    914          
    915              OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
    916          
    917              OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
    918          
    919              OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
    920              OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
    921          
    922          #if OS_TASK_STAT_EN > 0
    923              OSIdleCtrRun  = 0L;
    924              OSIdleCtrMax  = 0L;
    925              OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
    926          #endif
    927          }
    928          /*$PAGE*/
    929          /*
    930          *********************************************************************************************************
    931          *                                             INITIALIZATION
    932          *                                       INITIALIZE THE READY LIST
    933          *
    934          * Description: This function is called by OSInit() to initialize the Ready List.
    935          *
    936          * Arguments  : none
    937          *
    938          * Returns    : none
    939          *********************************************************************************************************
    940          */
    941          
    942          static  void  OS_InitRdyList (void)
    943          {
    944              INT8U    i;
    945          #if OS_LOWEST_PRIO <= 63
    946              INT8U   *prdytbl;
    947          #else
    948              INT16U  *prdytbl;
    949          #endif
    950          
    951          
    952              OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    953              prdytbl       = &OSRdyTbl[0];
    954              for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
    955                  *prdytbl++ = 0;
    956              }
    957          
    958              OSPrioCur     = 0;
    959              OSPrioHighRdy = 0;
    960          
    961              OSTCBHighRdy  = (OS_TCB *)0;
    962              OSTCBCur      = (OS_TCB *)0;
    963          }
    964          
    965          /*$PAGE*/
    966          /*
    967          *********************************************************************************************************
    968          *                                             INITIALIZATION
    969          *                                         CREATING THE IDLE TASK
    970          *
    971          * Description: This function creates the Idle Task.
    972          *
    973          * Arguments  : none
    974          *
    975          * Returns    : none
    976          *********************************************************************************************************
    977          */
    978          
    979          static  void  OS_InitTaskIdle (void)
    980          {
    981          #if OS_TASK_NAME_SIZE > 7
    982              INT8U  err;
    983          #endif
    984          
    985          
    986          #if OS_TASK_CREATE_EXT_EN > 0
    987              #if OS_STK_GROWTH == 1
    988              (void)OSTaskCreateExt(OS_TaskIdle,
    989                                    (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
    990                                    &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Top-Of-Stack                     */
    991                                    OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
    992                                    OS_TASK_IDLE_ID,
    993                                    &OSTaskIdleStk[0],                         /* Set Bottom-Of-Stack                  */
    994                                    OS_TASK_IDLE_STK_SIZE,
    995                                    (void *)0,                                 /* No TCB extension                     */
    996                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
    997              #else
    998              (void)OSTaskCreateExt(OS_TaskIdle,
    999                                    (void *)0,                                 /* No arguments passed to OS_TaskIdle() */
   1000                                    &OSTaskIdleStk[0],                         /* Set Top-Of-Stack                     */
   1001                                    OS_TASK_IDLE_PRIO,                         /* Lowest priority level                */
   1002                                    OS_TASK_IDLE_ID,
   1003                                    &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1], /* Set Bottom-Of-Stack                  */
   1004                                    OS_TASK_IDLE_STK_SIZE,
   1005                                    (void *)0,                                 /* No TCB extension                     */
   1006                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);/* Enable stack checking + clear stack  */
   1007              #endif
   1008          #else
   1009              #if OS_STK_GROWTH == 1
   1010              (void)OSTaskCreate(OS_TaskIdle,
   1011                                 (void *)0,
   1012                                 &OSTaskIdleStk[OS_TASK_IDLE_STK_SIZE - 1],
   1013                                 OS_TASK_IDLE_PRIO);
   1014              #else
   1015              (void)OSTaskCreate(OS_TaskIdle,
   1016                                 (void *)0,
   1017                                 &OSTaskIdleStk[0],
   1018                                 OS_TASK_IDLE_PRIO);
   1019              #endif
   1020          #endif
   1021          
   1022          #if OS_TASK_NAME_SIZE > 14
   1023              OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
   1024          #else
   1025          #if OS_TASK_NAME_SIZE > 7
   1026              OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
   1027          #endif
   1028          #endif
   1029          }
   1030          /*$PAGE*/
   1031          /*
   1032          *********************************************************************************************************
   1033          *                                             INITIALIZATION
   1034          *                                      CREATING THE STATISTIC TASK
   1035          *
   1036          * Description: This function creates the Statistic Task.
   1037          *
   1038          * Arguments  : none
   1039          *
   1040          * Returns    : none
   1041          *********************************************************************************************************
   1042          */
   1043          
   1044          #if OS_TASK_STAT_EN > 0
   1045          static  void  OS_InitTaskStat (void)
   1046          {
   1047          #if OS_TASK_NAME_SIZE > 7
   1048              INT8U  err;
   1049          #endif
   1050          
   1051          
   1052          #if OS_TASK_CREATE_EXT_EN > 0
   1053              #if OS_STK_GROWTH == 1
   1054              (void)OSTaskCreateExt(OS_TaskStat,
   1055                                    (void *)0,                                   /* No args passed to OS_TaskStat()*/
   1056                                    &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],   /* Set Top-Of-Stack               */
   1057                                    OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
   1058                                    OS_TASK_STAT_ID,
   1059                                    &OSTaskStatStk[0],                           /* Set Bottom-Of-Stack            */
   1060                                    OS_TASK_STAT_STK_SIZE,
   1061                                    (void *)0,                                   /* No TCB extension               */
   1062                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
   1063              #else
   1064              (void)OSTaskCreateExt(OS_TaskStat,
   1065                                    (void *)0,                                   /* No args passed to OS_TaskStat()*/
   1066                                    &OSTaskStatStk[0],                           /* Set Top-Of-Stack               */
   1067                                    OS_TASK_STAT_PRIO,                           /* One higher than the idle task  */
   1068                                    OS_TASK_STAT_ID,
   1069                                    &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],   /* Set Bottom-Of-Stack            */
   1070                                    OS_TASK_STAT_STK_SIZE,
   1071                                    (void *)0,                                   /* No TCB extension               */
   1072                                    OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR);  /* Enable stack checking + clear  */
   1073              #endif
   1074          #else
   1075              #if OS_STK_GROWTH == 1
   1076              (void)OSTaskCreate(OS_TaskStat,
   1077                                 (void *)0,                                      /* No args passed to OS_TaskStat()*/
   1078                                 &OSTaskStatStk[OS_TASK_STAT_STK_SIZE - 1],      /* Set Top-Of-Stack               */
   1079                                 OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
   1080              #else
   1081              (void)OSTaskCreate(OS_TaskStat,
   1082                                 (void *)0,                                      /* No args passed to OS_TaskStat()*/
   1083                                 &OSTaskStatStk[0],                              /* Set Top-Of-Stack               */
   1084                                 OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
   1085              #endif
   1086          #endif
   1087          
   1088          #if OS_TASK_NAME_SIZE > 14
   1089              OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
   1090          #else
   1091          #if OS_TASK_NAME_SIZE > 7
   1092              OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
   1093          #endif
   1094          #endif
   1095          }
   1096          #endif
   1097          /*$PAGE*/
   1098          /*
   1099          *********************************************************************************************************
   1100          *                                             INITIALIZATION
   1101          *                            INITIALIZE THE FREE LIST OF TASK CONTROL BLOCKS
   1102          *
   1103          * Description: This function is called by OSInit() to initialize the free list of OS_TCBs.
   1104          *
   1105          * Arguments  : none
   1106          *
   1107          * Returns    : none
   1108          *********************************************************************************************************
   1109          */
   1110          
   1111          static  void  OS_InitTCBList (void)
   1112          {
   1113              INT8U    i;
   1114              OS_TCB  *ptcb1;
   1115              OS_TCB  *ptcb2;
   1116          
   1117          
   1118              OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
   1119              OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
   1120              ptcb1 = &OSTCBTbl[0];
   1121              ptcb2 = &OSTCBTbl[1];
   1122              for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
   1123                  ptcb1->OSTCBNext = ptcb2;
   1124          #if OS_TASK_NAME_SIZE > 1
   1125                  ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
   1126                  ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
   1127          #endif
   1128                  ptcb1++;
   1129                  ptcb2++;
   1130              }
   1131              ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
   1132          #if OS_TASK_NAME_SIZE > 1
   1133              ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
   1134              ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
   1135          #endif
   1136              OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
   1137              OSTCBFreeList           = &OSTCBTbl[0];
   1138          }
   1139          /*$PAGE*/
   1140          /*
   1141          *********************************************************************************************************
   1142          *                                        CLEAR A SECTION OF MEMORY
   1143          *
   1144          * Description: This function is called by other uC/OS-II services to clear a contiguous block of RAM.
   1145          *
   1146          * Arguments  : pdest    is the start of the RAM to clear (i.e. write 0x00 to)
   1147          *
   1148          *              size     is the number of bytes to clear.
   1149          *
   1150          * Returns    : none
   1151          *
   1152          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1153          *              2) Note that we can only clear up to 64K bytes of RAM.  This is not an issue because none
   1154          *                 of the uses of this function gets close to this limit.
   1155          *              3) The clear is done one byte at a time since this will work on any processor irrespective
   1156          *                 of the alignment of the destination.
   1157          *********************************************************************************************************
   1158          */
   1159          

   \                                 In section .text, align 2, keep-with-next
   1160          void  OS_MemClr (INT8U *pdest, INT16U size)
   1161          {
   \                     OS_MemClr:
   \   00000000   0xB131             CBZ.N    R1,??OS_MemClr_0
   1162              while (size > 0) {
   1163                  *pdest++ = (INT8U)0;
   \                     ??OS_MemClr_1:
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0xF800 0x2B01      STRB     R2,[R0], #+1
   1164                  size--;
   \   00000008   0x1E49             SUBS     R1,R1,#+1
   1165              }
   \   0000000A   0xB289             UXTH     R1,R1
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD1F8             BNE.N    ??OS_MemClr_1
   1166          }
   \                     ??OS_MemClr_0:
   \   00000010   0x4770             BX       LR               ;; return
   1167          /*$PAGE*/
   1168          /*
   1169          *********************************************************************************************************
   1170          *                                        COPY A BLOCK OF MEMORY
   1171          *
   1172          * Description: This function is called by other uC/OS-II services to copy a block of memory from one
   1173          *              location to another.
   1174          *
   1175          * Arguments  : pdest    is a pointer to the 'destination' memory block
   1176          *
   1177          *              psrc     is a pointer to the 'source'      memory block
   1178          *
   1179          *              size     is the number of bytes to copy.
   1180          *
   1181          * Returns    : none
   1182          *
   1183          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.  There is
   1184          *                 no provision to handle overlapping memory copy.  However, that's not a problem since this
   1185          *                 is not a situation that will happen.
   1186          *              2) Note that we can only copy up to 64K bytes of RAM
   1187          *              3) The copy is done one byte at a time since this will work on any processor irrespective
   1188          *                 of the alignment of the source and destination.
   1189          *********************************************************************************************************
   1190          */
   1191          

   \                                 In section .text, align 2, keep-with-next
   1192          void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
   1193          {
   \                     OS_MemCopy:
   \   00000000   0xB13A             CBZ.N    R2,??OS_MemCopy_0
   1194              while (size > 0) {
   1195                  *pdest++ = *psrc++;
   \                     ??OS_MemCopy_1:
   \   00000002   0xF811 0x3B01      LDRB     R3,[R1], #+1
   \   00000006   0xF800 0x3B01      STRB     R3,[R0], #+1
   1196                  size--;
   \   0000000A   0x1E52             SUBS     R2,R2,#+1
   1197              }
   \   0000000C   0xB292             UXTH     R2,R2
   \   0000000E   0x2A00             CMP      R2,#+0
   \   00000010   0xD1F7             BNE.N    ??OS_MemCopy_1
   1198          }
   \                     ??OS_MemCopy_0:
   \   00000012   0x4770             BX       LR               ;; return
   1199          /*$PAGE*/
   1200          /*
   1201          *********************************************************************************************************
   1202          *                                              SCHEDULER
   1203          *
   1204          * Description: This function is called by other uC/OS-II services to determine whether a new, high
   1205          *              priority task has been made ready to run.  This function is invoked by TASK level code
   1206          *              and is not used to reschedule tasks from ISRs (see OSIntExit() for ISR rescheduling).
   1207          *
   1208          * Arguments  : none
   1209          *
   1210          * Returns    : none
   1211          *
   1212          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1213          *              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
   1214          *********************************************************************************************************
   1215          */
   1216          

   \                                 In section .text, align 2, keep-with-next
   1217          void  OS_Sched (void)
   1218          {
   \                     OS_Sched:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1219          #if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
   1220              OS_CPU_SR  cpu_sr = 0;
   1221          #endif
   1222          
   1223          
   1224          
   1225              OS_ENTER_CRITICAL();
   \   00000002   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000006   0x4604             MOV      R4,R0
   1226              if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
   1227                  if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
   \   00000008   0x....             LDR.N    R5,??DataTable14
   \   0000000A   0x78A8             LDRB     R0,[R5, #+2]
   \   0000000C   0x78E9             LDRB     R1,[R5, #+3]
   \   0000000E   0x4308             ORRS     R0,R1,R0
   \   00000010   0xD111             BNE.N    ??OS_Sched_0
   1228                      OS_SchedNew();
   \   00000012   0x.... 0x....      BL       OS_SchedNew
   1229                      if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
   \   00000016   0x7968             LDRB     R0,[R5, #+5]
   \   00000018   0x7929             LDRB     R1,[R5, #+4]
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xD00B             BEQ.N    ??OS_Sched_0
   1230                          OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
   \   0000001E   0x....             LDR.N    R1,??DataTable14_2
   \   00000020   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000024   0x62A8             STR      R0,[R5, #+40]
   1231          #if OS_TASK_PROFILE_EN > 0
   1232                          OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
   \   00000026   0x6A41             LDR      R1,[R0, #+36]
   \   00000028   0x1C49             ADDS     R1,R1,#+1
   \   0000002A   0x6241             STR      R1,[R0, #+36]
   1233          #endif
   1234                          OSCtxSwCtr++;                          /* Increment context switch counter             */
   \   0000002C   0x6928             LDR      R0,[R5, #+16]
   \   0000002E   0x1C40             ADDS     R0,R0,#+1
   \   00000030   0x6128             STR      R0,[R5, #+16]
   1235                          OS_TASK_SW();                          /* Perform a context switch                     */
   \   00000032   0x.... 0x....      BL       OSCtxSw
   1236                      }
   1237                  }
   1238              }
   1239              OS_EXIT_CRITICAL();
   \                     ??OS_Sched_0:
   \   00000036   0x4620             MOV      R0,R4
   \   00000038                      REQUIRE ?Subroutine0
   \   00000038                      ;; // Fall through to label ?Subroutine0
   1240          }
   1241          
   1242          
   1243          /*
   1244          *********************************************************************************************************
   1245          *                              FIND HIGHEST PRIORITY TASK READY TO RUN
   1246          *
   1247          * Description: This function is called by other uC/OS-II services to determine the highest priority task
   1248          *              that is ready to run.  The global variable 'OSPrioHighRdy' is changed accordingly.
   1249          *
   1250          * Arguments  : none
   1251          *
   1252          * Returns    : none
   1253          *
   1254          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1255          *              2) Interrupts are assumed to be disabled when this function is called.
   1256          *********************************************************************************************************
   1257          */
   1258          

   \                                 In section .text, align 2, keep-with-next
   1259          static  void  OS_SchedNew (void)
   1260          {
   1261          #if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
   1262              INT8U   y;
   1263          
   1264          
   1265              y             = OSUnMapTbl[OSRdyGrp];
   \                     OS_SchedNew:
   \   00000000   0x....             LDR.N    R0,??DataTable14
   \   00000002   0x.... 0x....      ADR.W    R1,OSUnMapTbl
   \   00000006   0x7982             LDRB     R2,[R0, #+6]
   \   00000008   0x5C52             LDRB     R2,[R2, R1]
   1266              OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
   \   0000000A   0x1813             ADDS     R3,R2,R0
   \   0000000C   0x7B1B             LDRB     R3,[R3, #+12]
   \   0000000E   0x5C59             LDRB     R1,[R3, R1]
   \   00000010   0xEB01 0x01C2      ADD      R1,R1,R2, LSL #+3
   \   00000014   0x7141             STRB     R1,[R0, #+5]
   1267          #else                                            /* We support up to 256 tasks                         */
   1268              INT8U   y;
   1269              INT16U *ptbl;
   1270          
   1271          
   1272              if ((OSRdyGrp & 0xFF) != 0) {
   1273                  y = OSUnMapTbl[OSRdyGrp & 0xFF];
   1274              } else {
   1275                  y = OSUnMapTbl[(OSRdyGrp >> 8) & 0xFF] + 8;
   1276              }
   1277              ptbl = &OSRdyTbl[y];
   1278              if ((*ptbl & 0xFF) != 0) {
   1279                  OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
   1280              } else {
   1281                  OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
   1282              }
   1283          #endif
   1284          }
   \   00000016   0x4770             BX       LR               ;; return
   1285          
   1286          /*$PAGE*/
   1287          /*
   1288          *********************************************************************************************************
   1289          *                                        COPY AN ASCII STRING
   1290          *
   1291          * Description: This function is called by other uC/OS-II services to copy an ASCII string from a 'source'
   1292          *              string to a 'destination' string.
   1293          *
   1294          * Arguments  : pdest    is a pointer to the string that will be receiving the copy.  Note that there MUST
   1295          *                       be sufficient space in the destination storage area to receive this string.
   1296          *
   1297          *              psrc     is a pointer to the source string.  The source string MUST NOT be greater than
   1298          *                       254 characters.
   1299          *
   1300          * Returns    : The size of the string (excluding the NUL terminating character)
   1301          *
   1302          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1303          *********************************************************************************************************
   1304          */
   1305          
   1306          #if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)

   \                                 In section .text, align 2, keep-with-next
   1307          INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
   1308          {
   1309              INT8U  len;
   1310          
   1311          
   1312              len = 0;
   \                     OS_StrCopy:
   \   00000000   0x2200             MOVS     R2,#+0
   \   00000002   0xE004             B.N      ??OS_StrCopy_0
   1313              while (*psrc != OS_ASCII_NUL) {
   1314                  *pdest++ = *psrc++;
   \                     ??OS_StrCopy_1:
   \   00000004   0xF811 0x3B01      LDRB     R3,[R1], #+1
   \   00000008   0xF800 0x3B01      STRB     R3,[R0], #+1
   1315                  len++;
   \   0000000C   0x1C52             ADDS     R2,R2,#+1
   1316              }
   \                     ??OS_StrCopy_0:
   \   0000000E   0x780B             LDRB     R3,[R1, #+0]
   \   00000010   0x2B00             CMP      R3,#+0
   \   00000012   0xD1F7             BNE.N    ??OS_StrCopy_1
   1317              *pdest = OS_ASCII_NUL;
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x7001             STRB     R1,[R0, #+0]
   1318              return (len);
   \   00000018   0xB2D0             UXTB     R0,R2
   \   0000001A   0x4770             BX       LR               ;; return
   1319          }
   1320          #endif
   1321          /*$PAGE*/
   1322          /*
   1323          *********************************************************************************************************
   1324          *                                DETERMINE THE LENGTH OF AN ASCII STRING
   1325          *
   1326          * Description: This function is called by other uC/OS-II services to determine the size of an ASCII string
   1327          *              (excluding the NUL character).
   1328          *
   1329          * Arguments  : psrc     is a pointer to the string for which we need to know the size.
   1330          *
   1331          * Returns    : The size of the string (excluding the NUL terminating character)
   1332          *
   1333          * Notes      : 1) This function is INTERNAL to uC/OS-II and your application should not call it.
   1334          *              2) The string to check must be less than 255 characters long.
   1335          *********************************************************************************************************
   1336          */
   1337          
   1338          #if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)

   \                                 In section .text, align 2, keep-with-next
   1339          INT8U  OS_StrLen (INT8U *psrc)
   1340          {
   1341              INT8U  len;
   1342          
   1343          
   1344              len = 0;
   \                     OS_StrLen:
   \   00000000   0x2100             MOVS     R1,#+0
   1345              while (*psrc != OS_ASCII_NUL) {
   \   00000002   0x7802             LDRB     R2,[R0, #+0]
   \   00000004   0xB122             CBZ.N    R2,??OS_StrLen_0
   1346                  psrc++;
   1347                  len++;
   \                     ??OS_StrLen_1:
   \   00000006   0x1C49             ADDS     R1,R1,#+1
   \   00000008   0xF810 0x2F01      LDRB     R2,[R0, #+1]!
   \   0000000C   0x2A00             CMP      R2,#+0
   \   0000000E   0xD1FA             BNE.N    ??OS_StrLen_1
   1348              }
   1349              return (len);
   \                     ??OS_StrLen_0:
   \   00000010   0xB2C8             UXTB     R0,R1
   \   00000012   0x4770             BX       LR               ;; return
   1350          }
   1351          #endif
   1352          /*$PAGE*/
   1353          /*
   1354          *********************************************************************************************************
   1355          *                                              IDLE TASK
   1356          *
   1357          * Description: This task is internal to uC/OS-II and executes whenever no other higher priority tasks
   1358          *              executes because they are ALL waiting for event(s) to occur.
   1359          *
   1360          * Arguments  : none
   1361          *
   1362          * Returns    : none
   1363          *
   1364          * Note(s)    : 1) OSTaskIdleHook() is called after the critical section to ensure that interrupts will be
   1365          *                 enabled for at least a few instructions.  On some processors (ex. Philips XA), enabling
   1366          *                 and then disabling interrupts didn't allow the processor enough time to have interrupts
   1367          *                 enabled before they were disabled again.  uC/OS-II would thus never recognize
   1368          *                 interrupts.
   1369          *              2) This hook has been added to allow you to do such things as STOP the CPU to conserve
   1370          *                 power.
   1371          *********************************************************************************************************
   1372          */
   1373          extern void LedDisplay(void);
   1374          

   \                                 In section .text, align 4, keep-with-next
   1375          void  OS_TaskIdle (void *p_arg)
   1376          {
   \                     OS_TaskIdle:
   \   00000000   0xB510             PUSH     {R4,LR}
   1377          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
   1378              OS_CPU_SR  cpu_sr = 0;
   1379          #endif
   1380          
   1381          
   1382          
   1383              (void)p_arg;                                 /* Prevent compiler warning for not using 'parg'      */
   1384              for (;;) {
   1385                  OS_ENTER_CRITICAL();
   \                     ??OS_TaskIdle_0:
   \   00000002   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000006   0x4604             MOV      R4,R0
   1386                  OSIdleCtr++;
   \   00000008   0x....             LDR.N    R0,??DataTable14
   \   0000000A   0x69C1             LDR      R1,[R0, #+28]
   \   0000000C   0x1C49             ADDS     R1,R1,#+1
   \   0000000E   0x61C1             STR      R1,[R0, #+28]
   1387          		LedDisplay();
   \   00000010   0x.... 0x....      BL       LedDisplay
   1388                  OS_EXIT_CRITICAL();
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       OS_CPU_SR_Restore
   1389                  OSTaskIdleHook();                        /* Call user definable HOOK                           */
   \   0000001A   0x.... 0x....      BL       OSTaskIdleHook
   \   0000001E   0xE7F0             B.N      ??OS_TaskIdle_0
   1390              }
   1391          }
   1392          /*$PAGE*/
   1393          /*
   1394          *********************************************************************************************************
   1395          *                                            STATISTICS TASK
   1396          *
   1397          * Description: This task is internal to uC/OS-II and is used to compute some statistics about the
   1398          *              multitasking environment.  Specifically, OS_TaskStat() computes the CPU usage.
   1399          *              CPU usage is determined by:
   1400          *
   1401          *                                          OSIdleCtr
   1402          *                 OSCPUUsage = 100 * (1 - ------------)     (units are in %)
   1403          *                                         OSIdleCtrMax
   1404          *
   1405          * Arguments  : parg     this pointer is not used at this time.
   1406          *
   1407          * Returns    : none
   1408          *
   1409          * Notes      : 1) This task runs at a priority level higher than the idle task.  In fact, it runs at the
   1410          *                 next higher priority, OS_TASK_IDLE_PRIO-1.
   1411          *              2) You can disable this task by setting the configuration #define OS_TASK_STAT_EN to 0.
   1412          *              3) You MUST have at least a delay of 2/10 seconds to allow for the system to establish the
   1413          *                 maximum value for the idle counter.
   1414          *********************************************************************************************************
   1415          */
   1416          
   1417          #if OS_TASK_STAT_EN > 0

   \                                 In section .text, align 4, keep-with-next
   1418          void  OS_TaskStat (void *p_arg)
   1419          {
   \                     OS_TaskStat:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   1420              INT32U     run;
   1421              INT32U     max;
   1422              INT8S      usage;
   1423          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
   1424              OS_CPU_SR  cpu_sr = 0;
   1425          #endif
   1426          
   1427          
   1428          
   1429              p_arg = p_arg;                               /* Prevent compiler warning for not using 'parg'      */
   1430              while (OSStatRdy == OS_FALSE) {
   \   00000002   0x....             LDR.N    R4,??DataTable14
   \   00000004   0x7860             LDRB     R0,[R4, #+1]
   \   00000006   0xB928             CBNZ.N   R0,??OS_TaskStat_0
   1431                  OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
   \                     ??OS_TaskStat_1:
   \   00000008   0x20C8             MOVS     R0,#+200
   \   0000000A   0x.... 0x....      BL       OSTimeDly
   \   0000000E   0x7860             LDRB     R0,[R4, #+1]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD0F9             BEQ.N    ??OS_TaskStat_1
   1432              }
   1433              max = OSIdleCtrMax / 100L;
   \                     ??OS_TaskStat_0:
   \   00000014   0x2564             MOVS     R5,#+100
   \   00000016   0x6960             LDR      R0,[R4, #+20]
   \   00000018   0xFBB0 0xF6F5      UDIV     R6,R0,R5
   \   0000001C   0xE009             B.N      ??OS_TaskStat_2
   1434              for (;;) {
   1435                  OS_ENTER_CRITICAL();
   1436                  OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
   1437                  run          = OSIdleCtr;
   1438                  OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
   1439                  OS_EXIT_CRITICAL();
   1440                  if (max > 0L) {
   1441                      usage = (INT8S)(100L - run / max);
   1442                      if (usage >= 0) {                    /* Make sure we don't have a negative percentage      */
   1443                          OSCPUUsage = usage;
   1444                      } else {
   1445                          OSCPUUsage = 0;
   1446                      }
   1447                  } else {
   1448                      OSCPUUsage = 0;
   \                     ??OS_TaskStat_3:
   \   0000001E   0x2000             MOVS     R0,#+0
   1449                      max        = OSIdleCtrMax / 100L;
   \   00000020   0x6961             LDR      R1,[R4, #+20]
   \   00000022   0xFBB1 0xF6F5      UDIV     R6,R1,R5
   \                     ??OS_TaskStat_4:
   \   00000026   0x7020             STRB     R0,[R4, #+0]
   1450                  }
   1451                  OSTaskStatHook();                        /* Invoke user definable hook                         */
   \   00000028   0x.... 0x....      BL       OSTaskStatHook
   1452          #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
   1453                  OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
   1454          #endif
   1455                  OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
   \   0000002C   0x2064             MOVS     R0,#+100
   \   0000002E   0x.... 0x....      BL       OSTimeDly
   \                     ??OS_TaskStat_2:
   \   00000032   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000036   0x69E1             LDR      R1,[R4, #+28]
   \   00000038   0x61A1             STR      R1,[R4, #+24]
   \   0000003A   0x69E7             LDR      R7,[R4, #+28]
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x61E1             STR      R1,[R4, #+28]
   \   00000040   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   00000044   0x2E00             CMP      R6,#+0
   \   00000046   0xD0EA             BEQ.N    ??OS_TaskStat_3
   \   00000048   0xFBB7 0xF0F6      UDIV     R0,R7,R6
   \   0000004C   0xF1C0 0x0064      RSB      R0,R0,#+100
   \   00000050   0xB240             SXTB     R0,R0
   \   00000052   0x2800             CMP      R0,#+0
   \   00000054   0xDAE7             BGE.N    ??OS_TaskStat_4
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0xE7E5             B.N      ??OS_TaskStat_4
   1456              }
   1457          }
   1458          #endif
   1459          /*$PAGE*/
   1460          /*
   1461          *********************************************************************************************************
   1462          *                                      CHECK ALL TASK STACKS
   1463          *
   1464          * Description: This function is called by OS_TaskStat() to check the stacks of each active task.
   1465          *
   1466          * Arguments  : none
   1467          *
   1468          * Returns    : none
   1469          *********************************************************************************************************
   1470          */
   1471          
   1472          #if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
   1473          void  OS_TaskStatStkChk (void)
   1474          {
   1475              OS_TCB      *ptcb;
   1476              OS_STK_DATA  stk_data;
   1477              INT8U        err;
   1478              INT8U        prio;
   1479          
   1480          
   1481              for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
   1482                  err = OSTaskStkChk(prio, &stk_data);
   1483                  if (err == OS_ERR_NONE) {
   1484                      ptcb = OSTCBPrioTbl[prio];
   1485                      if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
   1486                          if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
   1487          #if OS_TASK_PROFILE_EN > 0
   1488                              #if OS_STK_GROWTH == 1
   1489                              ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
   1490                              #else
   1491                              ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
   1492                              #endif
   1493                              ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
   1494          #endif
   1495                          }
   1496                      }
   1497                  }
   1498              }
   1499          }
   1500          #endif
   1501          /*$PAGE*/
   1502          /*
   1503          *********************************************************************************************************
   1504          *                                            INITIALIZE TCB
   1505          *
   1506          * Description: This function is internal to uC/OS-II and is used to initialize a Task Control Block when
   1507          *              a task is created (see OSTaskCreate() and OSTaskCreateExt()).
   1508          *
   1509          * Arguments  : prio          is the priority of the task being created
   1510          *
   1511          *              ptos          is a pointer to the task's top-of-stack assuming that the CPU registers
   1512          *                            have been placed on the stack.  Note that the top-of-stack corresponds to a
   1513          *                            'high' memory location is OS_STK_GROWTH is set to 1 and a 'low' memory
   1514          *                            location if OS_STK_GROWTH is set to 0.  Note that stack growth is CPU
   1515          *                            specific.
   1516          *
   1517          *              pbos          is a pointer to the bottom of stack.  A NULL pointer is passed if called by
   1518          *                            'OSTaskCreate()'.
   1519          *
   1520          *              id            is the task's ID (0..65535)
   1521          *
   1522          *              stk_size      is the size of the stack (in 'stack units').  If the stack units are INT8Us
   1523          *                            then, 'stk_size' contains the number of bytes for the stack.  If the stack
   1524          *                            units are INT32Us then, the stack contains '4 * stk_size' bytes.  The stack
   1525          *                            units are established by the #define constant OS_STK which is CPU
   1526          *                            specific.  'stk_size' is 0 if called by 'OSTaskCreate()'.
   1527          *
   1528          *              pext          is a pointer to a user supplied memory area that is used to extend the task
   1529          *                            control block.  This allows you to store the contents of floating-point
   1530          *                            registers, MMU registers or anything else you could find useful during a
   1531          *                            context switch.  You can even assign a name to each task and store this name
   1532          *                            in this TCB extension.  A NULL pointer is passed if called by OSTaskCreate().
   1533          *
   1534          *              opt           options as passed to 'OSTaskCreateExt()' or,
   1535          *                            0 if called from 'OSTaskCreate()'.
   1536          *
   1537          * Returns    : OS_ERR_NONE         if the call was successful
   1538          *              OS_ERR_TASK_NO_MORE_TCB  if there are no more free TCBs to be allocated and thus, the task cannot
   1539          *                                  be created.
   1540          *
   1541          * Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
   1542          *********************************************************************************************************
   1543          */
   1544          

   \                                 In section .text, align 2, keep-with-next
   1545          INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
   1546          {
   \                     OS_TCBInit:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x460F             MOV      R7,R1
   1547              OS_TCB    *ptcb;
   1548          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
   1549              OS_CPU_SR  cpu_sr = 0;
   1550          #endif
   1551          
   1552          
   1553          
   1554              OS_ENTER_CRITICAL();
   \   00000006   0x.... 0x....      BL       OS_CPU_SR_Save
   1555              ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
   \   0000000A   0x....             LDR.N    R4,??DataTable14
   \   0000000C   0x6A65             LDR      R5,[R4, #+36]
   1556              if (ptcb != (OS_TCB *)0) {
   \   0000000E   0x2D00             CMP      R5,#+0
   \   00000010   0xD04A             BEQ.N    ??OS_TCBInit_0
   1557                  OSTCBFreeList        = ptcb->OSTCBNext;            /* Update pointer to free TCB list          */
   \   00000012   0x6869             LDR      R1,[R5, #+4]
   \   00000014   0x6261             STR      R1,[R4, #+36]
   1558                  OS_EXIT_CRITICAL();
   \   00000016   0x.... 0x....      BL       OS_CPU_SR_Restore
   1559                  ptcb->OSTCBStkPtr    = ptos;                       /* Load Stack pointer in TCB                */
   \   0000001A   0x602F             STR      R7,[R5, #+0]
   1560                  ptcb->OSTCBPrio      = prio;                       /* Load task priority into TCB              */
   \   0000001C   0x77AE             STRB     R6,[R5, #+30]
   1561                  ptcb->OSTCBStat      = OS_STAT_RDY;                /* Task is ready to run                     */
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x7728             STRB     R0,[R5, #+28]
   1562                  ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;            /* Clear pend status                        */
   \   00000022   0x7768             STRB     R0,[R5, #+29]
   1563                  ptcb->OSTCBDly       = 0;                          /* Task is not delayed                      */
   \   00000024   0x8368             STRH     R0,[R5, #+26]
   1564          
   1565          #if OS_TASK_CREATE_EXT_EN > 0
   1566                  ptcb->OSTCBExtPtr    = pext;                       /* Store pointer to TCB extension           */
   1567                  ptcb->OSTCBStkSize   = stk_size;                   /* Store stack size                         */
   1568                  ptcb->OSTCBStkBottom = pbos;                       /* Store pointer to bottom of stack         */
   1569                  ptcb->OSTCBOpt       = opt;                        /* Store task options                       */
   1570                  ptcb->OSTCBId        = id;                         /* Store task ID                            */
   1571          #else
   1572                  pext                 = pext;                       /* Prevent compiler warning if not used     */
   1573                  stk_size             = stk_size;
   1574                  pbos                 = pbos;
   1575                  opt                  = opt;
   1576                  id                   = id;
   1577          #endif
   1578          
   1579          #if OS_TASK_DEL_EN > 0
   1580                  ptcb->OSTCBDelReq    = OS_ERR_NONE;
   \   00000026   0xF885 0x0023      STRB     R0,[R5, #+35]
   1581          #endif
   1582          
   1583          #if OS_LOWEST_PRIO <= 63
   1584                  ptcb->OSTCBY         = (INT8U)(prio >> 3);         /* Pre-compute X, Y, BitX and BitY          */
   \   0000002A   0x08F0             LSRS     R0,R6,#+3
   \   0000002C   0xF885 0x0020      STRB     R0,[R5, #+32]
   1585                  ptcb->OSTCBBitY      = (INT8U)(1 << ptcb->OSTCBY);
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0xFA01 0xF000      LSL      R0,R1,R0
   \   00000036   0xF885 0x0022      STRB     R0,[R5, #+34]
   1586                  ptcb->OSTCBX         = (INT8U)(prio & 0x07);
   \   0000003A   0xF006 0x0007      AND      R0,R6,#0x7
   \   0000003E   0x77E8             STRB     R0,[R5, #+31]
   1587                  ptcb->OSTCBBitX      = (INT8U)(1 << ptcb->OSTCBX);
   \   00000040   0xFA01 0xF000      LSL      R0,R1,R0
   \   00000044   0xF885 0x0021      STRB     R0,[R5, #+33]
   1588          #else
   1589                  ptcb->OSTCBY         = (INT8U)((prio >> 4) & 0xFF);/* Pre-compute X, Y, BitX and BitY          */
   1590                  ptcb->OSTCBBitY      = (INT16U)(1 << ptcb->OSTCBY);
   1591                  ptcb->OSTCBX         = (INT8U)(prio & 0x0F);
   1592                  ptcb->OSTCBBitX      = (INT16U)(1 << ptcb->OSTCBX);
   1593          #endif
   1594          
   1595          #if OS_EVENT_EN
   1596                  ptcb->OSTCBEventPtr  = (OS_EVENT *)0;              /* Task is not pending on an event          */
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x60E8             STR      R0,[R5, #+12]
   1597          #endif
   1598          
   1599          #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
   1600                  ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
   \   0000004C   0x6168             STR      R0,[R5, #+20]
   1601          #endif
   1602          
   1603          #if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
   1604                  ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
   \   0000004E   0x6128             STR      R0,[R5, #+16]
   1605          #endif
   1606          
   1607          #if OS_TASK_PROFILE_EN > 0
   1608                  ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
   \   00000050   0x6268             STR      R0,[R5, #+36]
   1609                  ptcb->OSTCBCyclesStart = 0L;
   \   00000052   0x62E8             STR      R0,[R5, #+44]
   1610                  ptcb->OSTCBCyclesTot   = 0L;
   \   00000054   0x62A8             STR      R0,[R5, #+40]
   1611                  ptcb->OSTCBStkBase     = (OS_STK *)0;
   \   00000056   0x6328             STR      R0,[R5, #+48]
   1612                  ptcb->OSTCBStkUsed     = 0L;
   \   00000058   0x6368             STR      R0,[R5, #+52]
   1613          #endif
   1614          
   1615          #if OS_TASK_NAME_SIZE > 1
   1616                  ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
   1617                  ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
   1618          #endif
   1619          
   1620                  OSTCBInitHook(ptcb);
   \   0000005A   0x4628             MOV      R0,R5
   \   0000005C   0x.... 0x....      BL       OSTCBInitHook
   1621          
   1622                  OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
   \   00000060   0x4628             MOV      R0,R5
   \   00000062   0x.... 0x....      BL       OSTaskCreateHook
   1623          
   1624                  OS_ENTER_CRITICAL();
   \   00000066   0x.... 0x....      BL       OS_CPU_SR_Save
   1625                  OSTCBPrioTbl[prio] = ptcb;
   \   0000006A   0x....             LDR.N    R1,??DataTable14_2
   \   0000006C   0xF841 0x5026      STR      R5,[R1, R6, LSL #+2]
   1626                  ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
   \   00000070   0x6AE1             LDR      R1,[R4, #+44]
   \   00000072   0x6069             STR      R1,[R5, #+4]
   1627                  ptcb->OSTCBPrev    = (OS_TCB *)0;
   \   00000074   0x2100             MOVS     R1,#+0
   \   00000076   0x60A9             STR      R1,[R5, #+8]
   1628                  if (OSTCBList != (OS_TCB *)0) {
   \   00000078   0x6AE1             LDR      R1,[R4, #+44]
   \   0000007A   0xB101             CBZ.N    R1,??OS_TCBInit_1
   1629                      OSTCBList->OSTCBPrev = ptcb;
   \   0000007C   0x608D             STR      R5,[R1, #+8]
   1630                  }
   1631                  OSTCBList               = ptcb;
   \                     ??OS_TCBInit_1:
   \   0000007E   0x62E5             STR      R5,[R4, #+44]
   1632                  OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
   \   00000080   0x79A1             LDRB     R1,[R4, #+6]
   \   00000082   0xF895 0x2022      LDRB     R2,[R5, #+34]
   \   00000086   0x4311             ORRS     R1,R2,R1
   \   00000088   0x71A1             STRB     R1,[R4, #+6]
   1633                  OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   \   0000008A   0xF895 0x1020      LDRB     R1,[R5, #+32]
   \   0000008E   0x1909             ADDS     R1,R1,R4
   \   00000090   0x7B0A             LDRB     R2,[R1, #+12]
   \   00000092   0xF895 0x3021      LDRB     R3,[R5, #+33]
   \   00000096   0x431A             ORRS     R2,R3,R2
   \   00000098   0x730A             STRB     R2,[R1, #+12]
   1634                  OSTaskCtr++;                                       /* Increment the #tasks counter             */
   \   0000009A   0x7A21             LDRB     R1,[R4, #+8]
   \   0000009C   0x1C49             ADDS     R1,R1,#+1
   \   0000009E   0x7221             STRB     R1,[R4, #+8]
   1635                  OS_EXIT_CRITICAL();
   \   000000A0   0x.... 0x....      BL       OS_CPU_SR_Restore
   1636                  return (OS_ERR_NONE);
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xBDF2             POP      {R1,R4-R7,PC}
   1637              }
   1638              OS_EXIT_CRITICAL();
   \                     ??OS_TCBInit_0:
   \   000000A8   0x.... 0x....      BL       OS_CPU_SR_Restore
   1639              return (OS_ERR_TASK_NO_MORE_TCB);
   \   000000AC   0x2042             MOVS     R0,#+66
   \   000000AE   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1640          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   0x........         DC32     OSCPUUsage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_1:
   \   00000000   0x........         DC32     OSEventTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable14_2:
   \   00000000   0x........         DC32     OSTCBPrioTbl

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  OSInit
             16 -> OSInitHookBegin
              0 -> OSInitHookEnd
             16 -> OSTaskCreate
             16 -> OS_FlagInit
             16 -> OS_MemClr
             16 -> OS_MemInit
             16 -> OS_QInit
             16 -> __aeabi_memclr
        8  OSIntEnter
              0 -> OS_CPU_SR_Restore
              8 -> OS_CPU_SR_Save
       16  OSIntExit
             16 -> OSIntCtxSw
              0 -> OS_CPU_SR_Restore
             16 -> OS_CPU_SR_Save
             16 -> OS_SchedNew
        8  OSSchedLock
              0 -> OS_CPU_SR_Restore
              8 -> OS_CPU_SR_Save
        8  OSSchedUnlock
              0 -> OS_CPU_SR_Restore
              8 -> OS_CPU_SR_Restore
              8 -> OS_CPU_SR_Save
              0 -> OS_Sched
        8  OSStart
              0 -> OSStartHighRdy
              8 -> OS_SchedNew
        8  OSStatInit
              8 -> OSTimeDly
              0 -> OS_CPU_SR_Restore
              8 -> OS_CPU_SR_Restore
              8 -> OS_CPU_SR_Save
       16  OSTimeTick
             16 -> OSTimeTickHook
             16 -> OS_CPU_SR_Restore
             16 -> OS_CPU_SR_Save
        0  OSVersion
        0  OS_Dummy
        0  OS_EventTOAbort
       20  OS_EventTaskRdy
        8  OS_EventTaskWait
        0  OS_EventWaitListInit
              0 -> __aeabi_memclr
        0  OS_MemClr
        0  OS_MemCopy
       16  OS_Sched
             16 -> OSCtxSw
              0 -> OS_CPU_SR_Restore
             16 -> OS_CPU_SR_Save
             16 -> OS_SchedNew
        0  OS_SchedNew
        0  OS_StrCopy
        0  OS_StrLen
       24  OS_TCBInit
             24 -> OSTCBInitHook
             24 -> OSTaskCreateHook
             24 -> OS_CPU_SR_Restore
             24 -> OS_CPU_SR_Save
        8  OS_TaskIdle
              8 -> LedDisplay
              8 -> OSTaskIdleHook
              8 -> OS_CPU_SR_Restore
              8 -> OS_CPU_SR_Save
       24  OS_TaskStat
             24 -> OSTaskStatHook
             24 -> OSTimeDly
             24 -> OS_CPU_SR_Restore
             24 -> OS_CPU_SR_Save


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       8  ?Subroutine0
       8  ?Subroutine1
      52  OSCPUUsage
          OSStatRdy
          OSIntNesting
          OSLockNesting
          OSPrioCur
          OSPrioHighRdy
          OSRdyGrp
          OSRunning
          OSTaskCtr
          OSTickStepState
          OSRdyTbl
          OSCtxSwCtr
          OSIdleCtrMax
          OSIdleCtrRun
          OSIdleCtr
          OSTCBCur
          OSTCBFreeList
          OSTCBHighRdy
          OSTCBList
          OSTime
    2516  OSEventTbl
          OSTCBTbl
          OSEventFreeList
          OSTaskStatStk
          OSTaskIdleStk
       4  OSFlagFreeList
     140  OSFlagTbl
     322  OSInit
      34  OSIntEnter
      78  OSIntExit
       4  OSMemFreeList
     180  OSMemTbl
       4  OSQFreeList
      96  OSQTbl
      34  OSSchedLock
      50  OSSchedUnlock
      40  OSStart
      44  OSStatInit
     128  OSTCBPrioTbl
     134  OSTimeTick
     256  OSUnMapTbl
       6  OSVersion
       2  OS_Dummy
      54  OS_EventTOAbort
     112  OS_EventTaskRdy
      62  OS_EventTaskWait
      12  OS_EventWaitListInit
      18  OS_MemClr
      20  OS_MemCopy
      56  OS_Sched
      24  OS_SchedNew
      28  OS_StrCopy
      20  OS_StrLen
     176  OS_TCBInit
      32  OS_TaskIdle
      90  OS_TaskStat

 
 1 732 bytes in section .text
 3 124 bytes in section iram
 
 1 732 bytes of CODE memory
 3 124 bytes of DATA memory

Errors: none
Warnings: none

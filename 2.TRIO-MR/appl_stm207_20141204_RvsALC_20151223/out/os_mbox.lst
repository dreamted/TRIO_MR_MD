###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     08/Feb/2018  09:39:56 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uCOS-II\Source\os_mbox.c                          #
#    Command line =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uCOS-II\Source\os_mbox.c -lC                      #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\out\ -o D:\Project\TRIO\2.TRIO-MR\appl_stm207_201 #
#                    41204_RvsALC_20151223\out\ --endian=little               #
#                    --cpu=Cortex-M3 -e --fpu=None --dlib_config "D:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.0\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\include\ -I D:\Project\TRIO\2.TRIO-MR\appl_stm207 #
#                    _20141204_RvsALC_20151223\STM32F2xx_StdPeriph_Driver_v12 #
#                    12\ -I D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_Rv #
#                    sALC_20151223\STM32F2xx_StdPeriph_Driver_v1212\inc\ -I   #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uC-CPU\ -I D:\Project\TRIO\2.TRIO-MR\appl_stm207_ #
#                    20141204_RvsALC_20151223\uC-LIB\ -I                      #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uCOS-II\Ports\ -I D:\Project\TRIO\2.TRIO-MR\appl_ #
#                    stm207_20141204_RvsALC_20151223\uCOS-II\Source\ -I       #
#                    D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\uC-Probe\ -Oh --use_c++_inline                    #
#    List file    =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\out\os_mbox.lst                                   #
#    Object file  =  D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20 #
#                    151223\out\os_mbox.o                                     #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\TRIO\2.TRIO-MR\appl_stm207_20141204_RvsALC_20151223\uCOS-II\Source\os_mbox.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                       MESSAGE MAILBOX MANAGEMENT
      6          *
      7          *                          (c) Copyright 1992-2007, Jean J. Labrosse, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_MBOX.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.85
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license 
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience 
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          
     26          #include <ucos_ii.h>
     27          #endif
     28          
     29          #if OS_MBOX_EN > 0
     30          /*
     31          *********************************************************************************************************
     32          *                                     ACCEPT MESSAGE FROM MAILBOX
     33          *
     34          * Description: This function checks the mailbox to see if a message is available.  Unlike OSMboxPend(),
     35          *              OSMboxAccept() does not suspend the calling task if a message is not available.
     36          *
     37          * Arguments  : pevent        is a pointer to the event control block
     38          *
     39          * Returns    : != (void *)0  is the message in the mailbox if one is available.  The mailbox is cleared
     40          *                            so the next time OSMboxAccept() is called, the mailbox will be empty.
     41          *              == (void *)0  if the mailbox is empty or,
     42          *                            if 'pevent' is a NULL pointer or,
     43          *                            if you didn't pass the proper event pointer.
     44          *********************************************************************************************************
     45          */
     46          
     47          #if OS_MBOX_ACCEPT_EN > 0

   \                                 In section .text, align 2, keep-with-next
     48          void  *OSMboxAccept (OS_EVENT *pevent)
     49          {
   \                     OSMboxAccept:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
     50              void      *pmsg;
     51          #if OS_CRITICAL_METHOD == 3                               /* Allocate storage for CPU status register  */
     52              OS_CPU_SR  cpu_sr = 0;
     53          #endif
     54          
     55          
     56          
     57          #if OS_ARG_CHK_EN > 0
     58              if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
     59                  return ((void *)0);
     60              }
     61          #endif
     62              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x2801             CMP      R0,#+1
   \   00000008   0xD001             BEQ.N    ??OSMboxAccept_0
     63                  return ((void *)0);
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD32             POP      {R1,R4,R5,PC}
     64              }
     65              OS_ENTER_CRITICAL();
   \                     ??OSMboxAccept_0:
   \   0000000E   0x.... 0x....      BL       OS_CPU_SR_Save
     66              pmsg               = pevent->OSEventPtr;
   \   00000012   0x6865             LDR      R5,[R4, #+4]
     67              pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x6061             STR      R1,[R4, #+4]
     68              OS_EXIT_CRITICAL();
   \   00000018   0x.... 0x....      BL       OS_CPU_SR_Restore
     69              return (pmsg);                                        /* Return the message received (or NULL)     */
   \   0000001C   0x4628             MOV      R0,R5
   \   0000001E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
     70          }
     71          #endif
     72          /*$PAGE*/
     73          /*
     74          *********************************************************************************************************
     75          *                                        CREATE A MESSAGE MAILBOX
     76          *
     77          * Description: This function creates a message mailbox if free event control blocks are available.
     78          *
     79          * Arguments  : pmsg          is a pointer to a message that you wish to deposit in the mailbox.  If
     80          *                            you set this value to the NULL pointer (i.e. (void *)0) then the mailbox
     81          *                            will be considered empty.
     82          *
     83          * Returns    : != (OS_EVENT *)0  is a pointer to the event control clock (OS_EVENT) associated with the
     84          *                                created mailbox
     85          *              == (OS_EVENT *)0  if no event control blocks were available
     86          *********************************************************************************************************
     87          */
     88          

   \                                 In section .text, align 2, keep-with-next
     89          OS_EVENT  *OSMboxCreate (void *pmsg)
     90          {
   \                     OSMboxCreate:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
     91              OS_EVENT  *pevent;
     92          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
     93              OS_CPU_SR  cpu_sr = 0;
     94          #endif
     95          
     96          
     97          
     98              if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
   \   00000004   0x....             LDR.N    R0,??DataTable2
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0xB108             CBZ.N    R0,??OSMboxCreate_0
     99                  return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xBD32             POP      {R1,R4,R5,PC}
    100              }
    101              OS_ENTER_CRITICAL();
   \                     ??OSMboxCreate_0:
   \   0000000E   0x.... 0x....      BL       OS_CPU_SR_Save
    102              pevent = OSEventFreeList;                    /* Get next free event control block                  */
   \   00000012   0x....             LDR.N    R1,??DataTable2_1
   \   00000014   0x680A             LDR      R2,[R1, #+0]
   \   00000016   0x0015             MOVS     R5,R2
    103              if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
   \   00000018   0xBF1C             ITT      NE 
   \   0000001A   0x6852             LDRNE    R2,[R2, #+4]
   \   0000001C   0x600A             STRNE    R2,[R1, #+0]
    104                  OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
    105              }
    106              OS_EXIT_CRITICAL();
   \   0000001E   0x.... 0x....      BL       OS_CPU_SR_Restore
    107              if (pevent != (OS_EVENT *)0) {
   \   00000022   0xB13D             CBZ.N    R5,??OSMboxCreate_1
    108                  pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0x7028             STRB     R0,[R5, #+0]
    109                  pevent->OSEventCnt     = 0;
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x8128             STRH     R0,[R5, #+8]
    110                  pevent->OSEventPtr     = pmsg;           /* Deposit message in event control block             */
   \   0000002C   0x606C             STR      R4,[R5, #+4]
    111          #if OS_EVENT_NAME_SIZE > 1
    112                  pevent->OSEventName[0] = '?';
    113                  pevent->OSEventName[1] = OS_ASCII_NUL;
    114          #endif
    115                  OS_EventWaitListInit(pevent);
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0x.... 0x....      BL       OS_EventWaitListInit
    116              }
    117              return (pevent);                             /* Return pointer to event control block              */
   \                     ??OSMboxCreate_1:
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    118          }
    119          /*$PAGE*/
    120          /*
    121          *********************************************************************************************************
    122          *                                         DELETE A MAIBOX
    123          *
    124          * Description: This function deletes a mailbox and readies all tasks pending on the mailbox.
    125          *
    126          * Arguments  : pevent        is a pointer to the event control block associated with the desired
    127          *                            mailbox.
    128          *
    129          *              opt           determines delete options as follows:
    130          *                            opt == OS_DEL_NO_PEND   Delete the mailbox ONLY if no task pending
    131          *                            opt == OS_DEL_ALWAYS    Deletes the mailbox even if tasks are waiting.
    132          *                                                    In this case, all the tasks pending will be readied.
    133          *
    134          *              perr          is a pointer to an error code that can contain one of the following values:
    135          *                            OS_ERR_NONE             The call was successful and the mailbox was deleted
    136          *                            OS_ERR_DEL_ISR          If you attempted to delete the mailbox from an ISR
    137          *                            OS_ERR_INVALID_OPT      An invalid option was specified
    138          *                            OS_ERR_TASK_WAITING     One or more tasks were waiting on the mailbox
    139          *                            OS_ERR_EVENT_TYPE       If you didn't pass a pointer to a mailbox
    140          *                            OS_ERR_PEVENT_NULL      If 'pevent' is a NULL pointer.
    141          *
    142          * Returns    : pevent        upon error
    143          *              (OS_EVENT *)0 if the mailbox was successfully deleted.
    144          *
    145          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
    146          *                 the mailbox MUST check the return code of OSMboxPend().
    147          *              2) OSMboxAccept() callers will not know that the intended mailbox has been deleted!
    148          *              3) This call can potentially disable interrupts for a long time.  The interrupt disable
    149          *                 time is directly proportional to the number of tasks waiting on the mailbox.
    150          *              4) Because ALL tasks pending on the mailbox will be readied, you MUST be careful in
    151          *                 applications where the mailbox is used for mutual exclusion because the resource(s)
    152          *                 will no longer be guarded by the mailbox.
    153          *********************************************************************************************************
    154          */
    155          
    156          #if OS_MBOX_DEL_EN > 0

   \                                 In section .text, align 2, keep-with-next
    157          OS_EVENT  *OSMboxDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
    158          {
   \                     OSMboxDel:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4615             MOV      R5,R2
    159              BOOLEAN    tasks_waiting;
    160              OS_EVENT  *pevent_return;
    161          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    162              OS_CPU_SR  cpu_sr = 0;
    163          #endif
    164          
    165          
    166          
    167          #if OS_ARG_CHK_EN > 0
    168              if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
    169                  return (pevent);
    170              }
    171              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    172                  *perr = OS_ERR_PEVENT_NULL;
    173                  return (pevent);
    174              }
    175          #endif
    176              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xBF18             IT       NE 
   \   00000010   0x2001             MOVNE    R0,#+1
    177                  *perr = OS_ERR_EVENT_TYPE;
   \   00000012   0xD141             BNE.N    ??OSMboxDel_0
    178                  return (pevent);
    179              }
    180              if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
   \   00000014   0x....             LDR.N    R0,??DataTable2
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0xB108             CBZ.N    R0,??OSMboxDel_1
    181                  *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
   \   0000001A   0x200F             MOVS     R0,#+15
   \   0000001C   0xE03C             B.N      ??OSMboxDel_0
    182                  return (pevent);
    183              }
    184              OS_ENTER_CRITICAL();
   \                     ??OSMboxDel_1:
   \   0000001E   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000022   0x4680             MOV      R8,R0
    185              if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mailbox      */
   \   00000024   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000026   0x1E47             SUBS     R7,R0,#+1
   \   00000028   0x41BF             SBCS     R7,R7,R7
   \   0000002A   0x43F9             MVNS     R1,R7
   \   0000002C   0x0FCF             LSRS     R7,R1,#+31
    186                  tasks_waiting = OS_TRUE;                           /* Yes                                      */
    187              } else {
    188                  tasks_waiting = OS_FALSE;                          /* No                                       */
    189              }
    190              switch (opt) {
   \   0000002E   0xB116             CBZ.N    R6,??OSMboxDel_2
   \   00000030   0x2E01             CMP      R6,#+1
   \   00000032   0xD012             BEQ.N    ??OSMboxDel_3
   \   00000034   0xE02C             B.N      ??OSMboxDel_4
    191                  case OS_DEL_NO_PEND:                               /* Delete mailbox only if no task waiting   */
    192                       if (tasks_waiting == OS_FALSE) {
   \                     ??OSMboxDel_2:
   \   00000036   0xB95F             CBNZ.N   R7,??OSMboxDel_5
    193          #if OS_EVENT_NAME_SIZE > 1
    194                           pevent->OSEventName[0] = '?';             /* Unknown name                             */
    195                           pevent->OSEventName[1] = OS_ASCII_NUL;
    196          #endif
    197                           pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x7020             STRB     R0,[R4, #+0]
    198                           pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
   \   0000003C   0x....             LDR.N    R0,??DataTable2_1
   \   0000003E   0x6801             LDR      R1,[R0, #+0]
   \   00000040   0x6061             STR      R1,[R4, #+4]
    199                           pevent->OSEventCnt  = 0;
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x8121             STRH     R1,[R4, #+8]
    200                           OSEventFreeList     = pevent;             /* Get next free event control block        */
   \   00000046   0x6004             STR      R4,[R0, #+0]
    201                           OS_EXIT_CRITICAL();
   \   00000048   0x4640             MOV      R0,R8
   \   0000004A   0x.... 0x....      BL       OS_CPU_SR_Restore
    202                           *perr               = OS_ERR_NONE;
   \   0000004E   0xE01C             B.N      ??OSMboxDel_6
    203                           pevent_return       = (OS_EVENT *)0;      /* Mailbox has been deleted                 */
    204                       } else {
    205                           OS_EXIT_CRITICAL();
   \                     ??OSMboxDel_5:
   \   00000050   0x4640             MOV      R0,R8
   \   00000052   0x.... 0x....      BL       OS_CPU_SR_Restore
    206                           *perr               = OS_ERR_TASK_WAITING;
   \   00000056   0x2049             MOVS     R0,#+73
    207                           pevent_return       = pevent;
   \   00000058   0xE01E             B.N      ??OSMboxDel_0
    208                       }
    209                       break;
    210          
    211                  case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
    212                       while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mailbox      */
   \                     ??OSMboxDel_3:
   \   0000005A   0xB140             CBZ.N    R0,??OSMboxDel_7
    213                           (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_OK);
   \                     ??OSMboxDel_8:
   \   0000005C   0x2300             MOVS     R3,#+0
   \   0000005E   0x2202             MOVS     R2,#+2
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x.... 0x....      BL       OS_EventTaskRdy
   \   00000068   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000006A   0x2800             CMP      R0,#+0
   \   0000006C   0xD1F6             BNE.N    ??OSMboxDel_8
    214                       }
    215          #if OS_EVENT_NAME_SIZE > 1
    216                       pevent->OSEventName[0] = '?';                 /* Unknown name                             */
    217                       pevent->OSEventName[1] = OS_ASCII_NUL;
    218          #endif
    219                       pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
   \                     ??OSMboxDel_7:
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x7020             STRB     R0,[R4, #+0]
    220                       pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
   \   00000072   0x....             LDR.N    R0,??DataTable2_1
   \   00000074   0x6801             LDR      R1,[R0, #+0]
   \   00000076   0x6061             STR      R1,[R4, #+4]
    221                       pevent->OSEventCnt     = 0;
   \   00000078   0x2100             MOVS     R1,#+0
   \   0000007A   0x8121             STRH     R1,[R4, #+8]
    222                       OSEventFreeList        = pevent;              /* Get next free event control block        */
   \   0000007C   0x6004             STR      R4,[R0, #+0]
    223                       OS_EXIT_CRITICAL();
   \   0000007E   0x4640             MOV      R0,R8
   \   00000080   0x.... 0x....      BL       OS_CPU_SR_Restore
    224                       if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
   \   00000084   0xB10F             CBZ.N    R7,??OSMboxDel_6
    225                           OS_Sched();                               /* Find highest priority task ready to run  */
   \   00000086   0x.... 0x....      BL       OS_Sched
    226                       }
    227                       *perr         = OS_ERR_NONE;
   \                     ??OSMboxDel_6:
   \   0000008A   0x2000             MOVS     R0,#+0
    228                       pevent_return = (OS_EVENT *)0;                /* Mailbox has been deleted                 */
   \   0000008C   0x2400             MOVS     R4,#+0
    229                       break;
   \   0000008E   0xE003             B.N      ??OSMboxDel_0
    230          
    231                  default:
    232                       OS_EXIT_CRITICAL();
   \                     ??OSMboxDel_4:
   \   00000090   0x4640             MOV      R0,R8
   \   00000092   0x.... 0x....      BL       OS_CPU_SR_Restore
    233                       *perr         = OS_ERR_INVALID_OPT;
   \   00000096   0x2007             MOVS     R0,#+7
    234                       pevent_return = pevent;
    235                       break;
   \                     ??OSMboxDel_0:
   \   00000098   0x7028             STRB     R0,[R5, #+0]
    236              }
    237              return (pevent_return);
   \   0000009A   0x4620             MOV      R0,R4
   \   0000009C   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    238          }
    239          #endif
    240          
    241          /*$PAGE*/
    242          /*
    243          *********************************************************************************************************
    244          *                                      PEND ON MAILBOX FOR A MESSAGE
    245          *
    246          * Description: This function waits for a message to be sent to a mailbox
    247          *
    248          * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
    249          *
    250          *              timeout       is an optional timeout period (in clock ticks).  If non-zero, your task will
    251          *                            wait for a message to arrive at the mailbox up to the amount of time
    252          *                            specified by this argument.  If you specify 0, however, your task will wait
    253          *                            forever at the specified mailbox or, until a message arrives.
    254          *
    255          *              perr          is a pointer to where an error message will be deposited.  Possible error
    256          *                            messages are:
    257          *
    258          *                            OS_ERR_NONE         The call was successful and your task received a
    259          *                                                message.
    260          *                            OS_ERR_TIMEOUT      A message was not received within the specified 'timeout'.
    261          *                            OS_ERR_PEND_ABORT   The wait on the mailbox was aborted.
    262          *                            OS_ERR_EVENT_TYPE   Invalid event type
    263          *                            OS_ERR_PEND_ISR     If you called this function from an ISR and the result
    264          *                                                would lead to a suspension.
    265          *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer
    266          *                            OS_ERR_PEND_LOCKED  If you called this function when the scheduler is locked
    267          *
    268          * Returns    : != (void *)0  is a pointer to the message received
    269          *              == (void *)0  if no message was received or,
    270          *                            if 'pevent' is a NULL pointer or,
    271          *                            if you didn't pass the proper pointer to the event control block.
    272          *********************************************************************************************************
    273          */
    274          

   \                                 In section .text, align 2, keep-with-next
    275          void  *OSMboxPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
    276          {
   \                     OSMboxPend:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460F             MOV      R7,R1
   \   00000008   0x4615             MOV      R5,R2
    277              void      *pmsg;
    278              INT8U      pend_stat;
    279          #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    280              OS_CPU_SR  cpu_sr = 0;
    281          #endif
    282          
    283          
    284          
    285          #if OS_ARG_CHK_EN > 0
    286              if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
    287                  return ((void *)0);
    288              }
    289              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    290                  *perr = OS_ERR_PEVENT_NULL;
    291                  return ((void *)0);
    292              }
    293          #endif
    294              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xBF18             IT       NE 
   \   00000010   0x2001             MOVNE    R0,#+1
    295                  *perr = OS_ERR_EVENT_TYPE;
   \   00000012   0xD13A             BNE.N    ??OSMboxPend_0
    296                  return ((void *)0);
    297              }
    298              if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
   \   00000014   0x....             LDR.N    R0,??DataTable2
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0xB108             CBZ.N    R0,??OSMboxPend_1
    299                  *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
   \   0000001A   0x2002             MOVS     R0,#+2
   \   0000001C   0xE035             B.N      ??OSMboxPend_0
    300                  return ((void *)0);
    301              }
    302              if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
   \                     ??OSMboxPend_1:
   \   0000001E   0x....             LDR.N    R0,??DataTable2_2
   \   00000020   0x7800             LDRB     R0,[R0, #+0]
   \   00000022   0xB108             CBZ.N    R0,??OSMboxPend_2
    303                  *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
   \   00000024   0x200D             MOVS     R0,#+13
   \   00000026   0xE030             B.N      ??OSMboxPend_0
    304                  return ((void *)0);
    305              }
    306              OS_ENTER_CRITICAL();
   \                     ??OSMboxPend_2:
   \   00000028   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000002C   0x4680             MOV      R8,R0
    307              pmsg = pevent->OSEventPtr;
   \   0000002E   0x6866             LDR      R6,[R4, #+4]
    308              if (pmsg != (void *)0) {                          /* See if there is already a message             */
   \   00000030   0xB146             CBZ.N    R6,??OSMboxPend_3
    309                  pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x6060             STR      R0,[R4, #+4]
    310                  OS_EXIT_CRITICAL();
   \   00000036   0x4640             MOV      R0,R8
   \   00000038   0x.... 0x....      BL       OS_CPU_SR_Restore
    311                  *perr = OS_ERR_NONE;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x7028             STRB     R0,[R5, #+0]
    312                  return (pmsg);                                /* Return the message received (or NULL)         */
   \   00000040   0x4630             MOV      R0,R6
   \   00000042   0xE031             B.N      ??OSMboxPend_4
    313              }
    314              OSTCBCur->OSTCBStat     |= OS_STAT_MBOX;          /* Message not available, task will pend         */
   \                     ??OSMboxPend_3:
   \   00000044   0x....             LDR.N    R6,??DataTable2_3
   \   00000046   0x6830             LDR      R0,[R6, #+0]
   \   00000048   0x7F01             LDRB     R1,[R0, #+28]
   \   0000004A   0xF041 0x0102      ORR      R1,R1,#0x2
   \   0000004E   0x7701             STRB     R1,[R0, #+28]
    315              OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
   \   00000050   0x6830             LDR      R0,[R6, #+0]
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0x7741             STRB     R1,[R0, #+29]
    316              OSTCBCur->OSTCBDly       = timeout;               /* Load timeout in TCB                           */
   \   00000056   0x6830             LDR      R0,[R6, #+0]
   \   00000058   0x8347             STRH     R7,[R0, #+26]
    317              OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x.... 0x....      BL       OS_EventTaskWait
    318              OS_EXIT_CRITICAL();
   \   00000060   0x4640             MOV      R0,R8
   \   00000062   0x.... 0x....      BL       OS_CPU_SR_Restore
    319              OS_Sched();                                       /* Find next highest priority task ready to run  */
   \   00000066   0x.... 0x....      BL       OS_Sched
    320              OS_ENTER_CRITICAL();
   \   0000006A   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000006E   0x4680             MOV      R8,R0
    321              if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) { /* See if we weren't given the message           */
   \   00000070   0x6830             LDR      R0,[R6, #+0]
   \   00000072   0x7F47             LDRB     R7,[R0, #+29]
   \   00000074   0xB167             CBZ.N    R7,??OSMboxPend_5
    322                  pend_stat = OSTCBCur->OSTCBStatPend;
    323                  OS_EventTOAbort(pevent);                      /* Timed out, Make task ready                    */
   \   00000076   0x4620             MOV      R0,R4
   \   00000078   0x.... 0x....      BL       OS_EventTOAbort
    324                  OS_EXIT_CRITICAL();
   \   0000007C   0x4640             MOV      R0,R8
   \   0000007E   0x.... 0x....      BL       OS_CPU_SR_Restore
    325                  switch (pend_stat) {
   \   00000082   0x2F02             CMP      R7,#+2
   \   00000084   0xBF14             ITE      NE 
   \   00000086   0x200A             MOVNE    R0,#+10
   \   00000088   0x200E             MOVEQ    R0,#+14
    326                      case OS_STAT_PEND_TO:
    327                      default:
    328                           *perr = OS_ERR_TIMEOUT;              /* Indicate that a timeout occured               */
    329                           break;
    330          
    331                      case OS_STAT_PEND_ABORT:
    332                           *perr = OS_ERR_PEND_ABORT;           /* Indicate that we aborted                      */
    333                           break;
   \                     ??OSMboxPend_0:
   \   0000008A   0x7028             STRB     R0,[R5, #+0]
    334                  }
    335                  return ((void *)0);                           /* Return a NULL message                         */
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xE00B             B.N      ??OSMboxPend_4
    336              }
    337              pmsg                    = OSTCBCur->OSTCBMsg;
   \                     ??OSMboxPend_5:
   \   00000090   0x6904             LDR      R4,[R0, #+16]
    338              OSTCBCur->OSTCBMsg      = (void *)0;              /* Yes, clear message received                   */
   \   00000092   0x2100             MOVS     R1,#+0
   \   00000094   0x6101             STR      R1,[R0, #+16]
    339              OSTCBCur->OSTCBStat     = OS_STAT_RDY;
   \   00000096   0x7701             STRB     R1,[R0, #+28]
    340              OSTCBCur->OSTCBEventPtr = (OS_EVENT *)0;          /* No longer waiting for event                   */
   \   00000098   0x6830             LDR      R0,[R6, #+0]
   \   0000009A   0x60C1             STR      R1,[R0, #+12]
    341              OS_EXIT_CRITICAL();
   \   0000009C   0x4640             MOV      R0,R8
   \   0000009E   0x.... 0x....      BL       OS_CPU_SR_Restore
    342              *perr                   = OS_ERR_NONE;
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x7028             STRB     R0,[R5, #+0]
    343              return (pmsg);                                    /* Return the message received                   */
   \   000000A6   0x4620             MOV      R0,R4
   \                     ??OSMboxPend_4:
   \   000000A8   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    344          }
    345          /*$PAGE*/
    346          /*
    347          *********************************************************************************************************
    348          *                                      ABORT WAITING ON A MESSAGE MAILBOX
    349          *
    350          * Description: This function aborts & readies any tasks currently waiting on a mailbox.  This function 
    351          *              should be used to fault-abort the wait on the mailbox, rather than to normally signal
    352          *              the mailbox via OSMboxPost() or OSMboxPostOpt().
    353          *
    354          * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox.
    355          *
    356          *              opt           determines the type of ABORT performed:
    357          *                            OS_PEND_OPT_NONE         ABORT wait for a single task (HPT) waiting on the
    358          *                                                     mailbox
    359          *                            OS_PEND_OPT_BROADCAST    ABORT wait for ALL tasks that are  waiting on the
    360          *                                                     mailbox
    361          *
    362          *              perr          is a pointer to where an error message will be deposited.  Possible error
    363          *                            messages are:
    364          *
    365          *                            OS_ERR_NONE         No tasks were     waiting on the mailbox.
    366          *                            OS_ERR_PEND_ABORT   At least one task waiting on the mailbox was readied
    367          *                                                and informed of the aborted wait; check return value 
    368          *                                                for the number of tasks whose wait on the mailbox 
    369          *                                                was aborted.
    370          *                            OS_ERR_EVENT_TYPE   If you didn't pass a pointer to a mailbox.
    371          *                            OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
    372          *
    373          * Returns    : == 0          if no tasks were waiting on the mailbox, or upon error.
    374          *              >  0          if one or more tasks waiting on the mailbox are now readied and informed.
    375          *********************************************************************************************************
    376          */
    377          
    378          #if OS_MBOX_PEND_ABORT_EN > 0

   \                                 In section .text, align 2, keep-with-next
    379          INT8U  OSMboxPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
    380          {
   \                     OSMboxPendAbort:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460E             MOV      R6,R1
   \   00000008   0x4614             MOV      R4,R2
    381              INT8U      nbr_tasks;
    382          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    383              OS_CPU_SR  cpu_sr = 0;
    384          #endif
    385          
    386          
    387          
    388          #if OS_ARG_CHK_EN > 0
    389              if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
    390                  return (0);
    391              }
    392              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    393                  *perr = OS_ERR_PEVENT_NULL;
    394                  return (0);
    395              }
    396          #endif
    397              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
   \   0000000A   0x7828             LDRB     R0,[R5, #+0]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xBF1E             ITTT     NE 
   \   00000010   0x2001             MOVNE    R0,#+1
   \   00000012   0x7020             STRBNE   R0,[R4, #+0]
   \   00000014   0x2000             MOVNE    R0,#+0
    398                  *perr = OS_ERR_EVENT_TYPE;
    399                  return (0);
   \   00000016   0xD127             BNE.N    ??OSMboxPendAbort_0
    400              }
    401              OS_ENTER_CRITICAL();
   \   00000018   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001C   0x4680             MOV      R8,R0
    402              if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on mailbox?      */
   \   0000001E   0x7AA8             LDRB     R0,[R5, #+10]
   \   00000020   0xB1E8             CBZ.N    R0,??OSMboxPendAbort_1
    403                  nbr_tasks = 0;
   \   00000022   0x2700             MOVS     R7,#+0
    404                  switch (opt) {
   \   00000024   0x2E01             CMP      R6,#+1
   \   00000026   0xD10A             BNE.N    ??OSMboxPendAbort_2
    405                      case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
    406                           while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on mailbox  */
    407                               (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
   \                     ??OSMboxPendAbort_3:
   \   00000028   0x2302             MOVS     R3,#+2
   \   0000002A   0x2202             MOVS     R2,#+2
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0x.... 0x....      BL       OS_EventTaskRdy
    408                               nbr_tasks++;
   \   00000034   0x1C7F             ADDS     R7,R7,#+1
   \   00000036   0x7AA8             LDRB     R0,[R5, #+10]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD1F5             BNE.N    ??OSMboxPendAbort_3
   \   0000003C   0xE006             B.N      ??OSMboxPendAbort_4
    409                           }
    410                           break;
    411                       
    412                      case OS_PEND_OPT_NONE:                         /* No,  ready HPT       waiting on mailbox  */
    413                      default:    
    414                           (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
   \                     ??OSMboxPendAbort_2:
   \   0000003E   0x2302             MOVS     R3,#+2
   \   00000040   0x2202             MOVS     R2,#+2
   \   00000042   0x4639             MOV      R1,R7
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       OS_EventTaskRdy
    415                           nbr_tasks++;
   \   0000004A   0x2701             MOVS     R7,#+1
    416                           break;
    417                  }
    418                  OS_EXIT_CRITICAL();
   \                     ??OSMboxPendAbort_4:
   \   0000004C   0x4640             MOV      R0,R8
   \   0000004E   0x.... 0x....      BL       OS_CPU_SR_Restore
    419                  OS_Sched();                                        /* Find HPT ready to run                    */
   \   00000052   0x.... 0x....      BL       OS_Sched
    420                  *perr = OS_ERR_PEND_ABORT;
   \   00000056   0x200E             MOVS     R0,#+14
   \   00000058   0x7020             STRB     R0,[R4, #+0]
    421                  return (nbr_tasks);
   \   0000005A   0xB2F8             UXTB     R0,R7
   \   0000005C   0xE004             B.N      ??OSMboxPendAbort_0
    422              }
    423              OS_EXIT_CRITICAL();
   \                     ??OSMboxPendAbort_1:
   \   0000005E   0x4640             MOV      R0,R8
   \   00000060   0x.... 0x....      BL       OS_CPU_SR_Restore
    424              *perr = OS_ERR_NONE;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x7020             STRB     R0,[R4, #+0]
    425              return (0);                                            /* No tasks waiting on mailbox              */
   \                     ??OSMboxPendAbort_0:
   \   00000068   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    426          }
    427          #endif
    428          
    429          /*$PAGE*/
    430          /*
    431          *********************************************************************************************************
    432          *                                       POST MESSAGE TO A MAILBOX
    433          *
    434          * Description: This function sends a message to a mailbox
    435          *
    436          * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
    437          *
    438          *              pmsg          is a pointer to the message to send.  You MUST NOT send a NULL pointer.
    439          *
    440          * Returns    : OS_ERR_NONE          The call was successful and the message was sent
    441          *              OS_ERR_MBOX_FULL     If the mailbox already contains a message.  You can can only send one
    442          *                                   message at a time and thus, the message MUST be consumed before you
    443          *                                   are allowed to send another one.
    444          *              OS_ERR_EVENT_TYPE    If you are attempting to post to a non mailbox.
    445          *              OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer
    446          *              OS_ERR_POST_NULL_PTR If you are attempting to post a NULL pointer
    447          *
    448          * Note(s)    : 1) HPT means Highest Priority Task
    449          *********************************************************************************************************
    450          */
    451          
    452          #if OS_MBOX_POST_EN > 0

   \                                 In section .text, align 2, keep-with-next
    453          INT8U  OSMboxPost (OS_EVENT *pevent, void *pmsg)
    454          {
   \                     OSMboxPost:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    455          #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    456              OS_CPU_SR  cpu_sr = 0;
    457          #endif
    458          
    459          
    460          
    461          #if OS_ARG_CHK_EN > 0
    462              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    463                  return (OS_ERR_PEVENT_NULL);
    464              }
    465              if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
    466                  return (OS_ERR_POST_NULL_PTR);
    467              }
    468          #endif
    469              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD001             BEQ.N    ??OSMboxPost_0
    470                  return (OS_ERR_EVENT_TYPE);
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xBD70             POP      {R4-R6,PC}
    471              }
    472              OS_ENTER_CRITICAL();
   \                     ??OSMboxPost_0:
   \   00000010   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000014   0x4606             MOV      R6,R0
    473              if (pevent->OSEventGrp != 0) {                    /* See if any task pending on mailbox            */
   \   00000016   0x7AA0             LDRB     R0,[R4, #+10]
   \   00000018   0xB160             CBZ.N    R0,??OSMboxPost_1
    474                                                                /* Ready HPT waiting on event                    */
    475                  (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0x2202             MOVS     R2,#+2
   \   0000001E   0x4629             MOV      R1,R5
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       OS_EventTaskRdy
    476                  OS_EXIT_CRITICAL();
   \   00000026   0x4630             MOV      R0,R6
   \   00000028   0x.... 0x....      BL       OS_CPU_SR_Restore
    477                  OS_Sched();                                   /* Find highest priority task ready to run       */
   \   0000002C   0x.... 0x....      BL       OS_Sched
    478                  return (OS_ERR_NONE);
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xBD70             POP      {R4-R6,PC}
    479              }
    480              if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
   \                     ??OSMboxPost_1:
   \   00000034   0x6860             LDR      R0,[R4, #+4]
   \   00000036   0xB120             CBZ.N    R0,??OSMboxPost_2
    481                  OS_EXIT_CRITICAL();
   \   00000038   0x4630             MOV      R0,R6
   \   0000003A   0x.... 0x....      BL       OS_CPU_SR_Restore
    482                  return (OS_ERR_MBOX_FULL);
   \   0000003E   0x2014             MOVS     R0,#+20
   \   00000040   0xBD70             POP      {R4-R6,PC}
    483              }
    484              pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
   \                     ??OSMboxPost_2:
   \   00000042   0x6065             STR      R5,[R4, #+4]
    485              OS_EXIT_CRITICAL();
   \   00000044   0x4630             MOV      R0,R6
   \   00000046   0x.... 0x....      BL       OS_CPU_SR_Restore
    486              return (OS_ERR_NONE);
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0xBD70             POP      {R4-R6,PC}       ;; return
    487          }
    488          #endif
    489          
    490          /*$PAGE*/
    491          /*
    492          *********************************************************************************************************
    493          *                                       POST MESSAGE TO A MAILBOX
    494          *
    495          * Description: This function sends a message to a mailbox
    496          *
    497          * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
    498          *
    499          *              pmsg          is a pointer to the message to send.  You MUST NOT send a NULL pointer.
    500          *
    501          *              opt           determines the type of POST performed:
    502          *                            OS_POST_OPT_NONE         POST to a single waiting task
    503          *                                                     (Identical to OSMboxPost())
    504          *                            OS_POST_OPT_BROADCAST    POST to ALL tasks that are waiting on the mailbox
    505          *
    506          *                            OS_POST_OPT_NO_SCHED     Indicates that the scheduler will NOT be invoked
    507          *
    508          * Returns    : OS_ERR_NONE          The call was successful and the message was sent
    509          *              OS_ERR_MBOX_FULL     If the mailbox already contains a message.  You can can only send one
    510          *                                   message at a time and thus, the message MUST be consumed before you
    511          *                                   are allowed to send another one.
    512          *              OS_ERR_EVENT_TYPE    If you are attempting to post to a non mailbox.
    513          *              OS_ERR_PEVENT_NULL   If 'pevent' is a NULL pointer
    514          *              OS_ERR_POST_NULL_PTR If you are attempting to post a NULL pointer
    515          *
    516          * Note(s)    : 1) HPT means Highest Priority Task
    517          *
    518          * Warning    : Interrupts can be disabled for a long time if you do a 'broadcast'.  In fact, the
    519          *              interrupt disable time is proportional to the number of tasks waiting on the mailbox.
    520          *********************************************************************************************************
    521          */
    522          
    523          #if OS_MBOX_POST_OPT_EN > 0

   \                                 In section .text, align 2, keep-with-next
    524          INT8U  OSMboxPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
    525          {
   \                     OSMboxPostOpt:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    526          #if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    527              OS_CPU_SR  cpu_sr = 0;
    528          #endif
    529          
    530          
    531          
    532          #if OS_ARG_CHK_EN > 0
    533              if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
    534                  return (OS_ERR_PEVENT_NULL);
    535              }
    536              if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
    537                  return (OS_ERR_POST_NULL_PTR);
    538              }
    539          #endif
    540              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
   \   00000008   0x7820             LDRB     R0,[R4, #+0]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD001             BEQ.N    ??OSMboxPostOpt_0
    541                  return (OS_ERR_EVENT_TYPE);
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0xBDF2             POP      {R1,R4-R7,PC}
    542              }
    543              OS_ENTER_CRITICAL();
   \                     ??OSMboxPostOpt_0:
   \   00000012   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000016   0x4607             MOV      R7,R0
    544              if (pevent->OSEventGrp != 0) {                    /* See if any task pending on mailbox            */
   \   00000018   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000001A   0xB1D0             CBZ.N    R0,??OSMboxPostOpt_1
    545                  if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
   \   0000001C   0x07F0             LSLS     R0,R6,#+31
   \   0000001E   0xD509             BPL.N    ??OSMboxPostOpt_2
    546                      while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on mailbox     */
    547                          (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
   \                     ??OSMboxPostOpt_3:
   \   00000020   0x2300             MOVS     R3,#+0
   \   00000022   0x2202             MOVS     R2,#+2
   \   00000024   0x4629             MOV      R1,R5
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       OS_EventTaskRdy
   \   0000002C   0x7AA0             LDRB     R0,[R4, #+10]
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD1F6             BNE.N    ??OSMboxPostOpt_3
   \   00000032   0xE005             B.N      ??OSMboxPostOpt_4
    548                      }
    549                  } else {                                      /* No,  Post to HPT waiting on mbox              */
    550                      (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
   \                     ??OSMboxPostOpt_2:
   \   00000034   0x2300             MOVS     R3,#+0
   \   00000036   0x2202             MOVS     R2,#+2
   \   00000038   0x4629             MOV      R1,R5
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       OS_EventTaskRdy
    551                  }
    552                  OS_EXIT_CRITICAL();
   \                     ??OSMboxPostOpt_4:
   \   00000040   0x4638             MOV      R0,R7
   \   00000042   0x.... 0x....      BL       OS_CPU_SR_Restore
    553                  if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
   \   00000046   0x0770             LSLS     R0,R6,#+29
   \   00000048   0xD40E             BMI.N    ??OSMboxPostOpt_5
    554                      OS_Sched();                               /* Find HPT ready to run                         */
   \   0000004A   0x.... 0x....      BL       OS_Sched
    555                  }
    556                  return (OS_ERR_NONE);
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xBDF2             POP      {R1,R4-R7,PC}
    557              }
    558              if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
   \                     ??OSMboxPostOpt_1:
   \   00000052   0x6860             LDR      R0,[R4, #+4]
   \   00000054   0xB120             CBZ.N    R0,??OSMboxPostOpt_6
    559                  OS_EXIT_CRITICAL();
   \   00000056   0x4638             MOV      R0,R7
   \   00000058   0x.... 0x....      BL       OS_CPU_SR_Restore
    560                  return (OS_ERR_MBOX_FULL);
   \   0000005C   0x2014             MOVS     R0,#+20
   \   0000005E   0xBDF2             POP      {R1,R4-R7,PC}
    561              }
    562              pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
   \                     ??OSMboxPostOpt_6:
   \   00000060   0x6065             STR      R5,[R4, #+4]
    563              OS_EXIT_CRITICAL();
   \   00000062   0x4638             MOV      R0,R7
   \   00000064   0x.... 0x....      BL       OS_CPU_SR_Restore
    564              return (OS_ERR_NONE);
   \                     ??OSMboxPostOpt_5:
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    565          }
    566          #endif
    567          
    568          /*$PAGE*/
    569          /*
    570          *********************************************************************************************************
    571          *                                        QUERY A MESSAGE MAILBOX
    572          *
    573          * Description: This function obtains information about a message mailbox.
    574          *
    575          * Arguments  : pevent        is a pointer to the event control block associated with the desired mailbox
    576          *
    577          *              p_mbox_data   is a pointer to a structure that will contain information about the message
    578          *                            mailbox.
    579          *
    580          * Returns    : OS_ERR_NONE         The call was successful and the message was sent
    581          *              OS_ERR_EVENT_TYPE   If you are attempting to obtain data from a non mailbox.
    582          *              OS_ERR_PEVENT_NULL  If 'pevent'      is a NULL pointer
    583          *              OS_ERR_PDATA_NULL   If 'p_mbox_data' is a NULL pointer
    584          *********************************************************************************************************
    585          */
    586          
    587          #if OS_MBOX_QUERY_EN > 0

   \                                 In section .text, align 2, keep-with-next
    588          INT8U  OSMboxQuery (OS_EVENT *pevent, OS_MBOX_DATA *p_mbox_data)
    589          {
   \                     OSMboxQuery:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    590              INT8U      i;
    591          #if OS_LOWEST_PRIO <= 63
    592              INT8U     *psrc;
    593              INT8U     *pdest;
    594          #else
    595              INT16U    *psrc;
    596              INT16U    *pdest;
    597          #endif
    598          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    599              OS_CPU_SR  cpu_sr = 0;
    600          #endif
    601          
    602          
    603          
    604          #if OS_ARG_CHK_EN > 0
    605              if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
    606                  return (OS_ERR_PEVENT_NULL);
    607              }
    608              if (p_mbox_data == (OS_MBOX_DATA *)0) {                /* Validate 'p_mbox_data'                   */
    609                  return (OS_ERR_PDATA_NULL);
    610              }
    611          #endif
    612              if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD001             BEQ.N    ??OSMboxQuery_0
    613                  return (OS_ERR_EVENT_TYPE);
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}
    614              }
    615              OS_ENTER_CRITICAL();
   \                     ??OSMboxQuery_0:
   \   00000010   0x.... 0x....      BL       OS_CPU_SR_Save
    616              p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
   \   00000014   0x7AA1             LDRB     R1,[R4, #+10]
   \   00000016   0x7229             STRB     R1,[R5, #+8]
    617              psrc                    = &pevent->OSEventTbl[0];
   \   00000018   0xF204 0x010B      ADDW     R1,R4,#+11
    618              pdest                   = &p_mbox_data->OSEventTbl[0];
   \   0000001C   0x1D2A             ADDS     R2,R5,#+4
    619              for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
    620                  *pdest++ = *psrc++;
   \   0000001E   0x780B             LDRB     R3,[R1, #+0]
   \   00000020   0x7013             STRB     R3,[R2, #+0]
   \   00000022   0xF811 0x3F01      LDRB     R3,[R1, #+1]!
   \   00000026   0xF802 0x3F01      STRB     R3,[R2, #+1]!
   \   0000002A   0xF811 0x3F01      LDRB     R3,[R1, #+1]!
   \   0000002E   0xF802 0x3F01      STRB     R3,[R2, #+1]!
   \   00000032   0xF811 0x3F01      LDRB     R3,[R1, #+1]!
   \   00000036   0xF802 0x3F01      STRB     R3,[R2, #+1]!
    621              }
    622              p_mbox_data->OSMsg = pevent->OSEventPtr;               /* Get message from mailbox                 */
   \   0000003A   0x6861             LDR      R1,[R4, #+4]
   \   0000003C   0x6029             STR      R1,[R5, #+0]
    623              OS_EXIT_CRITICAL();
   \   0000003E   0x.... 0x....      BL       OS_CPU_SR_Restore
    624              return (OS_ERR_NONE);
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    625          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     OSEventFreeList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     OSLockNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     OSTCBCur
    626          #endif                                                     /* OS_MBOX_QUERY_EN                         */
    627          #endif                                                     /* OS_MBOX_EN                               */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  OSMboxAccept
             16 -> OS_CPU_SR_Restore
             16 -> OS_CPU_SR_Save
       16  OSMboxCreate
             16 -> OS_CPU_SR_Restore
             16 -> OS_CPU_SR_Save
             16 -> OS_EventWaitListInit
       24  OSMboxDel
             24 -> OS_CPU_SR_Restore
             24 -> OS_CPU_SR_Save
             24 -> OS_EventTaskRdy
             24 -> OS_Sched
       24  OSMboxPend
             24 -> OS_CPU_SR_Restore
             24 -> OS_CPU_SR_Save
             24 -> OS_EventTOAbort
             24 -> OS_EventTaskWait
             24 -> OS_Sched
       24  OSMboxPendAbort
             24 -> OS_CPU_SR_Restore
             24 -> OS_CPU_SR_Save
             24 -> OS_EventTaskRdy
             24 -> OS_Sched
       16  OSMboxPost
             16 -> OS_CPU_SR_Restore
             16 -> OS_CPU_SR_Save
             16 -> OS_EventTaskRdy
             16 -> OS_Sched
       24  OSMboxPostOpt
             24 -> OS_CPU_SR_Restore
             24 -> OS_CPU_SR_Save
             24 -> OS_EventTaskRdy
             24 -> OS_Sched
       16  OSMboxQuery
             16 -> OS_CPU_SR_Restore
             16 -> OS_CPU_SR_Save


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
      32  OSMboxAccept
      56  OSMboxCreate
     160  OSMboxDel
     172  OSMboxPend
     108  OSMboxPendAbort
      78  OSMboxPost
     108  OSMboxPostOpt
      70  OSMboxQuery

 
 800 bytes in section .text
 
 800 bytes of CODE memory

Errors: none
Warnings: none

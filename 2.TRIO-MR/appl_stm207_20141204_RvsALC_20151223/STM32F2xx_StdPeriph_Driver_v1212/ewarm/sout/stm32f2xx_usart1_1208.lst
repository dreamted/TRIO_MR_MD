###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     07/Jan/2014  16:08:52 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Project\TRIO\2차버전\3.F_W\appl_stm207_20131104 -     #
#                    복사본\STM32F2xx_StdPeriph_Driver_v1212\src\stm32f2xx_us #
#                    art1_1208.c                                              #
#    Command line =  "C:\Project\TRIO\2차버전\3.F_W\appl_stm207_20131104 -    #
#                    복사본\STM32F2xx_StdPeriph_Driver_v1212\src\stm32f2xx_us #
#                    art1_1208.c" -D NDEBUG -lC "C:\Project\TRIO\2차버전\3.F_ #
#                    W\appl_stm207_20131104 - 복사본\STM32F2xx_StdPeriph_Driv #
#                    er_v1212\ewarm\sout\" -o "C:\Project\TRIO\2차버전\3.F_W\ #
#                    appl_stm207_20131104 - 복사본\STM32F2xx_StdPeriph_Driver #
#                    _v1212\ewarm\sout\" --endian=little --cpu=Cortex-M3 -e   #
#                    --fpu=None --dlib_config "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.0_2\arm\INC\c\DLib_Config_N #
#                    ormal.h" -I "C:\Project\TRIO\2차버전\3.F_W\appl_stm207_2 #
#                    0131104 - 복사본\STM32F2xx_StdPeriph_Driver_v1212\ewarm\ #
#                    ..\" -I "C:\Project\TRIO\2차버전\3.F_W\appl_stm207_20131 #
#                    104 - 복사본\STM32F2xx_StdPeriph_Driver_v1212\ewarm\..\i #
#                    nc\" -I "C:\Project\TRIO\2차버전\3.F_W\appl_stm207_20131 #
#                    104 - 복사본\STM32F2xx_StdPeriph_Driver_v1212\ewarm\..\. #
#                    .\uC-CPU\" -I "C:\Project\TRIO\2차버전\3.F_W\appl_stm207 #
#                    _20131104 - 복사본\STM32F2xx_StdPeriph_Driver_v1212\ewar #
#                    m\..\..\uC-LIB\" -I "C:\Project\TRIO\2차버전\3.F_W\appl_ #
#                    stm207_20131104 - 복사본\STM32F2xx_StdPeriph_Driver_v121 #
#                    2\ewarm\..\..\uCOS-II\Ports\" -I                         #
#                    "C:\Project\TRIO\2차버전\3.F_W\appl_stm207_20131104 -    #
#                    복사본\STM32F2xx_StdPeriph_Driver_v1212\ewarm\..\..\uCOS #
#                    -II\Source\" -Oh                                         #
#    List file    =  C:\Project\TRIO\2차버전\3.F_W\appl_stm207_20131104 -     #
#                    복사본\STM32F2xx_StdPeriph_Driver_v1212\ewarm\sout\stm32 #
#                    f2xx_usart1_1208.lst                                     #
#    Object file  =  C:\Project\TRIO\2차버전\3.F_W\appl_stm207_20131104 -     #
#                    복사본\STM32F2xx_StdPeriph_Driver_v1212\ewarm\sout\stm32 #
#                    f2xx_usart1_1208.o                                       #
#                                                                             #
#                                                                             #
###############################################################################

C:\Project\TRIO\2차버전\3.F_W\appl_stm207_20131104 - 복사본\STM32F2xx_StdPeriph_Driver_v1212\src\stm32f2xx_usart1_1208.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_usart.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    18-April-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Universal synchronous asynchronous receiver
      9            *          transmitter (USART):           
     10            *           - Initialization and Configuration
     11            *           - Data transfers
     12            *           - Multi-Processor Communication
     13            *           - LIN mode
     14            *           - Half-duplex mode
     15            *           - Smartcard mode
     16            *           - IrDA mode
     17            *           - DMA transfers management
     18            *           - Interrupts and flags management 
     19            *           
     20            *  @verbatim
     21            *      
     22            *          ===================================================================
     23            *                                 How to use this driver
     24            *          ===================================================================
     25            *          1. Enable peripheral clock using the follwoing functions
     26            *             RCC_APB2PeriphClockCmd(RCC_APB2Periph_USARTx, ENABLE) for USART1 and USART6 
     27            *             RCC_APB1PeriphClockCmd(RCC_APB1Periph_USARTx, ENABLE) for USART2, USART3, UART4 or UART5.
     28            *
     29            *          2.  According to the USART mode, enable the GPIO clocks using 
     30            *              RCC_AHB1PeriphClockCmd() function. (The I/O can be TX, RX, CTS, 
     31            *              or/and SCLK). 
     32            *
     33            *          3. Peripheral's alternate function: 
     34            *                 - Connect the pin to the desired peripherals' Alternate 
     35            *                   Function (AF) using GPIO_PinAFConfig() function
     36            *                 - Configure the desired pin in alternate function by:
     37            *                   GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     38            *                 - Select the type, pull-up/pull-down and output speed via 
     39            *                   GPIO_PuPd, GPIO_OType and GPIO_Speed members
     40            *                 - Call GPIO_Init() function
     41            *        
     42            *          4. Program the Baud Rate, Word Length , Stop Bit, Parity, Hardware 
     43            *             flow control and Mode(Receiver/Transmitter) using the USART_Init()
     44            *             function.
     45            *
     46            *          5. For synchronous mode, enable the clock and program the polarity,
     47            *             phase and last bit using the USART_ClockInit() function.
     48            *
     49            *          5. Enable the NVIC and the corresponding interrupt using the function 
     50            *             USART_ITConfig() if you need to use interrupt mode. 
     51            *
     52            *          6. When using the DMA mode 
     53            *                   - Configure the DMA using DMA_Init() function
     54            *                   - Active the needed channel Request using USART_DMACmd() function
     55            * 
     56            *          7. Enable the USART using the USART_Cmd() function.
     57            * 
     58            *          8. Enable the DMA using the DMA_Cmd() function, when using DMA mode. 
     59            *
     60            *          Refer to Multi-Processor, LIN, half-duplex, Smartcard, IrDA sub-sections
     61            *          for more details
     62            *          
     63            *          In order to reach higher communication baudrates, it is possible to
     64            *          enable the oversampling by 8 mode using the function USART_OverSampling8Cmd().
     65            *          This function should be called after enabling the USART clock (RCC_APBxPeriphClockCmd())
     66            *          and before calling the function USART_Init().
     67            *          
     68            *  @endverbatim
     69            *        
     70            ******************************************************************************
     71            * @attention
     72            *
     73            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     74            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     75            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     76            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     77            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     78            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     79            *
     80            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     81            ******************************************************************************  
     82            */ 
     83          
     84          /* Includes ------------------------------------------------------------------*/
     85          #include "stm32f2xx_usart1_1208.h"
     86          
     87          /** @addtogroup STM32F2xx_StdPeriph_Driver
     88            * @{
     89            */
     90          
     91          /** @defgroup USART 
     92            * @brief USART driver modules
     93            * @{
     94            */
     95          
     96          /* Private typedef -----------------------------------------------------------*/
     97          /* Private define ------------------------------------------------------------*/
     98          
     99          
    100          /* Private macro -------------------------------------------------------------*/
    101          /* Private variables ---------------------------------------------------------*/
    102          #if !defined (OS_INCLUDED) 
    103          	INT8U Rx1Buff[Rx1BuffLen];
    104          	INT8U Tx1Buff[Tx1BuffLen];
    105          
    106          	INT16U	Rx1RdCnt = 0, Rx1WrCnt = 0;
    107          	INT16U	Tx1RdCnt = 0, Tx1WrCnt = 0;
    108          #else

   \                                 In section iram, align 4
    109          	INT8U Rx1Buff[Rx1BuffLen] @ "iram";
   \                     Rx1Buff:
   \   00000000                      DS8 2048

   \                                 In section iram, align 4
    110          	INT8U Tx1Buff[Tx1BuffLen] @ "iram";
   \                     Tx1Buff:
   \   00000000                      DS8 2048
    111          

   \                                 In section iram, align 4
    112          	INT16U	Rx1RdCnt @ "iram"= 0, Rx1WrCnt @ "iram" = 0;
   \                     Rx1RdCnt:
   \   00000000   0x0000             DC16 0
   \                     Rx1WrCnt:
   \   00000002   0x0000             DC16 0
    113          	INT16U	Tx1RdCnt @ "iram"= 0, Tx1WrCnt @ "iram" = 0;
   \                     Tx1RdCnt:
   \   00000004   0x0000             DC16 0
   \                     Tx1WrCnt:
   \   00000006   0x0000             DC16 0
    114          #endif
    115          
    116          #if !defined (OS_INCLUDED) 
    117          __SerStrPtr pUSART1 = {
    118          
    119          #else
    120          __SerStrPtr pUSART1 @ "iram" = {
   \                     pUSART1:
   \   00000008   0x........         DC32 InitUSART1, USART1CheckByte, USART1RxGetByte, USART1PutStr
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000018   0x........         DC32 USART1Printf, USART1PutChar, USART1PutToBuffer, USART1TxCheckByte
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000028   0x........         DC32 USART1BuffClear, USART1TxClear
   \              0x........   
   \   00000030   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    121          #endif
    122          	InitUSART1,
    123          	USART1CheckByte,
    124          	USART1RxGetByte,
    125          	USART1PutStr,
    126          	USART1Printf,
    127          	USART1PutChar,
    128          	USART1PutToBuffer,
    129          	USART1TxCheckByte,
    130          	USART1BuffClear,
    131          	USART1TxClear
    132          };
    133          /* Private function prototypes -----------------------------------------------*/
    134          /* Private functions ---------------------------------------------------------*/
    135          
    136          /** @defgroup USART_Private_Functions
    137            * @{
    138            */
    139          
    140          /** @defgroup USART_Group1 Initialization and Configuration functions
    141           *  @brief   Initialization and Configuration functions 
    142           *
    143          @verbatim   
    144           ===============================================================================
    145                            Initialization and Configuration functions
    146           ===============================================================================  
    147          
    148            This subsection provides a set of functions allowing to initialize the USART 
    149            in asynchronous and in synchronous modes.
    150             - For the asynchronous mode only these parameters can be configured: 
    151                  - Baud Rate
    152                  - Word Length 
    153                  - Stop Bit
    154                  - Parity: If the parity is enabled, then the MSB bit of the data written
    155                    in the data register is transmitted but is changed by the parity bit.
    156                    Depending on the frame length defined by the M bit (8-bits or 9-bits),
    157                    the possible USART frame formats are as listed in the following table:
    158             +-------------------------------------------------------------+     
    159             |   M bit |  PCE bit  |            USART frame                |
    160             |---------------------|---------------------------------------|             
    161             |    0    |    0      |    | SB | 8 bit data | STB |          |
    162             |---------|-----------|---------------------------------------|  
    163             |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
    164             |---------|-----------|---------------------------------------|  
    165             |    1    |    0      |    | SB | 9 bit data | STB |          |
    166             |---------|-----------|---------------------------------------|  
    167             |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
    168             +-------------------------------------------------------------+            
    169                  - Hardware flow control
    170                  - Receiver/transmitter modes
    171          
    172            The USART_Init() function follows the USART  asynchronous configuration procedure
    173            (details for the procedure are available in reference manual (RM0033)).
    174          
    175            - For the synchronous mode in addition to the asynchronous mode parameters these 
    176              parameters should be also configured:
    177                  - USART Clock Enabled
    178                  - USART polarity
    179                  - USART phase
    180                  - USART LastBit
    181            
    182            These parameters can be configured using the USART_ClockInit() function.
    183          
    184          @endverbatim
    185            * @{
    186            */
    187            
    188          /**
    189            * @brief  Deinitializes the USARTx peripheral registers to their default reset values.
    190            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    191            *         UART peripheral.
    192            * @retval None
    193            */

   \                                 In section .text, align 2, keep-with-next
    194          void InitUSART1(INT32U nBps, INT32U nLCR)
    195          {
   \                     InitUSART1:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460C             MOV      R4,R1
    196          	USART_InitTypeDef USART_InitStructure;
    197          
    198          ///
    199          // PORT INIT
    200          	RCC->__B.AHB1ENR.IOPAEN = ENABLE;
   \   00000008   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40023830
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0xF041 0x0101      ORR      R1,R1,#0x1
   \   00000010   0x6001             STR      R1,[R0, #+0]
    201          	RCC->__B.APB2ENR.USART1EN = ENABLE;
   \   00000012   0x6941             LDR      R1,[R0, #+20]
   \   00000014   0xF041 0x0110      ORR      R1,R1,#0x10
   \   00000018   0x6141             STR      R1,[R0, #+20]
    202          	
    203          	__PA9_U1_TX();
   \   0000001A   0x....             LDR.N    R6,??DataTable9_2  ;; 0x40020000
   \   0000001C   0x2309             MOVS     R3,#+9
   \   0000001E   0x4632             MOV      R2,R6
   \   00000020   0x2107             MOVS     R1,#+7
   \   00000022   0x2062             MOVS     R0,#+98
   \   00000024   0x.... 0x....      BL       GPIOPortInit
    204          	__PA10_U1_RX();
   \   00000028   0x230A             MOVS     R3,#+10
   \   0000002A   0x4632             MOV      R2,R6
   \   0000002C   0x2107             MOVS     R1,#+7
   \   0000002E   0x2062             MOVS     R0,#+98
   \   00000030   0x.... 0x....      BL       GPIOPortInit
    205          
    206          ////////////////////////////////////////////////////////////////////////////////
    207          	USART_InitStructure.USART_BaudRate = nBps;
   \   00000034   0x9500             STR      R5,[SP, #+0]
    208          
    209          	if( ((nLCR >> 4) & 0x01) ==  (_DATA8BIT >> 4)) {
   \   00000036   0x06E0             LSLS     R0,R4,#+27
   \   00000038   0xBF54             ITE      PL 
   \   0000003A   0x2000             MOVPL    R0,#+0
   \   0000003C   0xF44F 0x5080      MOVMI    R0,#+4096
    210          			USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    211          	}
    212          	else	USART_InitStructure.USART_WordLength = USART_WordLength_9b;
   \   00000040   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    213          
    214          ////////////////////////////////////////////////////////////////////////////////
    215          	if( ((nLCR >> 2) & 0x02) ==  (_05STOP >> 2)) {
    216          		USART_InitStructure.USART_StopBits = USART_StopBits_0_5;
    217          	}
    218          	else if( ((nLCR >> 2) & 0x02) ==  (_1_STOP >> 2)) {
   \   00000044   0x08A0             LSRS     R0,R4,#+2
   \   00000046   0x0780             LSLS     R0,R0,#+30
   \   00000048   0xBF54             ITE      PL 
   \   0000004A   0x2000             MOVPL    R0,#+0
   \   0000004C   0xF44F 0x5000      MOVMI    R0,#+8192
    219          			USART_InitStructure.USART_StopBits = USART_StopBits_1;
    220          	}
    221          	else if( ((nLCR >> 2) & 0x02) ==  (_2_STOP >> 2)) {
    222          			USART_InitStructure.USART_StopBits = USART_StopBits_2;
   \   00000050   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    223          	}
    224          	else	USART_InitStructure.USART_StopBits = USART_StopBits_1_5;
    225          	
    226          ////////////////////////////////////////////////////////////////////////////////
    227          	
    228          	if(((nLCR >> 0) & 0x03) == (_NONPARITY >> 0)){
   \   00000054   0xF014 0x0003      ANDS     R0,R4,#0x3
   \   00000058   0xBF08             IT       EQ 
   \   0000005A   0x2000             MOVEQ    R0,#+0
    229          		USART_InitStructure.USART_Parity = USART_Parity_No;
   \   0000005C   0xD005             BEQ.N    ??InitUSART1_0
    230          	}
    231          	else if(((nLCR >> 0) & 0x03) == (_ODDPARITY >> 0)){
   \   0000005E   0x2801             CMP      R0,#+1
   \   00000060   0xBF0C             ITE      EQ 
   \   00000062   0xF44F 0x60C0      MOVEQ    R0,#+1536
   \   00000066   0xF44F 0x6080      MOVNE    R0,#+1024
    232          		USART_InitStructure.USART_Parity = USART_Parity_Odd;
    233          	}
    234          	else{
    235          		USART_InitStructure.USART_Parity = USART_Parity_Even;
   \                     ??InitUSART1_0:
   \   0000006A   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    236          	}
    237          	
    238          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    239          	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \   00000074   0x200C             MOVS     R0,#+12
   \   00000076   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    240          
    241          	/* USART configuration */
    242          	USART_Init(USART1, &USART_InitStructure);
   \   0000007A   0x....             LDR.N    R4,??DataTable9_3  ;; 0x40011000
   \   0000007C   0xA900             ADD      R1,SP,#+0
   \   0000007E   0x4620             MOV      R0,R4
   \   00000080   0x.... 0x....      BL       USART_Init
    243          
    244          #if defined (OS_INCLUDED) 
    245          	pUSART1.sem = OSSemCreate(1);
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0x.... 0x....      BL       OSSemCreate
   \   0000008A   0x....             LDR.N    R1,??DataTable9_4
   \   0000008C   0x6308             STR      R0,[R1, #+48]
    246          #endif
    247          	/* Enable USART */
    248          	USART_Cmd(USART1, ENABLE);
   \   0000008E   0x2101             MOVS     R1,#+1
   \   00000090   0x4620             MOV      R0,R4
   \   00000092   0x.... 0x....      BL       USART_Cmd
    249          
    250          	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
   \   00000096   0x2201             MOVS     R2,#+1
   \   00000098   0xF240 0x5125      MOVW     R1,#+1317
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0x.... 0x....      BL       USART_ITConfig
    251          	NVIC_Init(USART1_IRQn, ENABLE); 
   \   000000A2   0x2101             MOVS     R1,#+1
   \   000000A4   0x2025             MOVS     R0,#+37
   \   000000A6   0x.... 0x....      BL       NVIC_Init
    252          
    253          	USART1Printf("\n");	
   \   000000AA   0x....             ADR.N    R0,??DataTable9  ;; "\n"
   \   000000AC   0x.... 0x....      BL       USART1Printf
    254          }
   \   000000B0   0xB004             ADD      SP,SP,#+16
   \   000000B2   0xBD70             POP      {R4-R6,PC}       ;; return
    255          
    256          /*******************************************************************************
    257            * @brief  Interrupt handler USART1 global interrupt request
    258            * @param  None 
    259            * @retval None
    260            *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    261          void USART1_IRQIntHandler(void)
    262          {
   \                     USART1_IRQIntHandler:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    263          	INT16U tmp = USART1->SR;
   \   00000002   0x....             LDR.N    R4,??DataTable9_3  ;; 0x40011000
   \   00000004   0x8825             LDRH     R5,[R4, #+0]
    264          
    265          #ifdef OS_INCLUDED
    266          	INT32U cpu_sr;
    267          
    268          	CPU_CRITICAL_ENTER();										// Tell uC/OS-II that we are starting an ISR
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
    269          	OSIntNesting++;
   \   0000000A   0x....             LDR.N    R1,??DataTable9_5
   \   0000000C   0x780A             LDRB     R2,[R1, #+0]
   \   0000000E   0x1C52             ADDS     R2,R2,#+1
   \   00000010   0x700A             STRB     R2,[R1, #+0]
    270          	CPU_CRITICAL_EXIT();
   \   00000012   0x.... 0x....      BL       CPU_SR_Restore
    271          #endif /* OS_INCLUDED */
    272          	// Rx Data Received
    273          	if(tmp & ( 1 << __RXNE))
   \   00000016   0x06A8             LSLS     R0,R5,#+26
   \   00000018   0xD50F             BPL.N    ??USART1_IRQIntHandler_0
    274          	{
    275          		Rx1Buff[Rx1WrCnt%Rx1BuffLen] = USART1->DR;		// When the receive register is read, the RDR bit is automatically cleared.
   \   0000001A   0x....             LDR.N    R0,??DataTable9_4
   \   0000001C   0x8841             LDRH     R1,[R0, #+2]
   \   0000001E   0x054A             LSLS     R2,R1,#+21
   \   00000020   0x0D52             LSRS     R2,R2,#+21
   \   00000022   0x....             LDR.N    R3,??DataTable9_6
   \   00000024   0x88A4             LDRH     R4,[R4, #+4]
   \   00000026   0x54D4             STRB     R4,[R2, R3]
    276          		if(++Rx1WrCnt >= Rx1BuffLen) Rx1WrCnt = 0;
   \   00000028   0x1C49             ADDS     R1,R1,#+1
   \   0000002A   0x8041             STRH     R1,[R0, #+2]
   \   0000002C   0xB289             UXTH     R1,R1
   \   0000002E   0xF5B1 0x6F00      CMP      R1,#+2048
   \   00000032   0xD31E             BCC.N    ??USART1_IRQIntHandler_1
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x8041             STRH     R1,[R0, #+2]
   \   00000038   0x....             B.N      ?Subroutine0
    277          	}
    278          	else if(tmp & ( 1 << __TXE))
   \                     ??USART1_IRQIntHandler_0:
   \   0000003A   0x0628             LSLS     R0,R5,#+24
   \   0000003C   0xD518             BPL.N    ??USART1_IRQIntHandler_2
    279          	{
    280          		if(Tx1RdCnt != Tx1WrCnt)
   \   0000003E   0x....             LDR.N    R0,??DataTable9_4
   \   00000040   0x8881             LDRH     R1,[R0, #+4]
   \   00000042   0x88C2             LDRH     R2,[R0, #+6]
   \   00000044   0x4291             CMP      R1,R2
   \   00000046   0xD00E             BEQ.N    ??USART1_IRQIntHandler_3
    281          		{
    282          			USART1->DR = Tx1Buff[Tx1RdCnt%Tx1BuffLen];
   \   00000048   0x0549             LSLS     R1,R1,#+21
   \   0000004A   0x0D49             LSRS     R1,R1,#+21
   \   0000004C   0x....             LDR.N    R2,??DataTable9_7
   \   0000004E   0x5C89             LDRB     R1,[R1, R2]
   \   00000050   0x80A1             STRH     R1,[R4, #+4]
    283          			if(++Tx1RdCnt >= Tx1BuffLen ) Tx1RdCnt = 0;
   \   00000052   0x8881             LDRH     R1,[R0, #+4]
   \   00000054   0x1C49             ADDS     R1,R1,#+1
   \   00000056   0x8081             STRH     R1,[R0, #+4]
   \   00000058   0xB289             UXTH     R1,R1
   \   0000005A   0xF5B1 0x6F00      CMP      R1,#+2048
   \   0000005E   0xD308             BCC.N    ??USART1_IRQIntHandler_1
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x8081             STRH     R1,[R0, #+4]
   \   00000064   0x....             B.N      ?Subroutine0
    284          		}
    285          		else USART1->__B.CR1.TXEIE = DISABLE;
   \                     ??USART1_IRQIntHandler_3:
   \   00000066   0x68E0             LDR      R0,[R4, #+12]
   \   00000068   0xF020 0x0080      BIC      R0,R0,#0x80
   \   0000006C   0x60E0             STR      R0,[R4, #+12]
   \   0000006E   0x....             B.N      ?Subroutine0
    286          	}
    287          	else // error, dummy read
    288          	{
    289          		tmp =  USART1->DR;
   \                     ??USART1_IRQIntHandler_2:
   \   00000070   0x88A0             LDRH     R0,[R4, #+4]
    290          	}
    291          
    292          #ifdef OS_INCLUDED
    293          	OSIntExit();												// Tell uC/OS-II that we are leaving the ISR
   \                     ??USART1_IRQIntHandler_1:
   \   00000072                      REQUIRE ?Subroutine0
   \   00000072                      ;; // Fall through to label ?Subroutine0
    294          #endif /* OS_INCLUDED */
    295          
    296          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000004   0x.... 0x....      B.W      OSIntExit
    297          

   \                                 In section .text, align 2, keep-with-next
    298          unsigned char USART1PutToBuffer(unsigned char Data)
    299          {
   \                     USART1PutToBuffer:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
    300          #ifdef OS_INCLUDED
    301          	INT8U err;
    302          	//////////////////////////////////////////////////
    303          
    304          	OSSemPend(pUSART1.sem, 0, &err);
   \   00000004   0x....             LDR.N    R4,??DataTable9_4
   \   00000006   0xAA00             ADD      R2,SP,#+0
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6B20             LDR      R0,[R4, #+48]
   \   0000000C   0x.... 0x....      BL       OSSemPend
    305          #endif /* OS_INCLUDED */
    306          	//////////////////////////////////////////////////
    307          	Tx1Buff[Tx1WrCnt%Tx1BuffLen] = Data;
   \   00000010   0x88E0             LDRH     R0,[R4, #+6]
   \   00000012   0x0541             LSLS     R1,R0,#+21
   \   00000014   0x0D49             LSRS     R1,R1,#+21
   \   00000016   0x....             LDR.N    R2,??DataTable9_7
   \   00000018   0x548D             STRB     R5,[R1, R2]
    308          	if(++Tx1WrCnt >= Tx1BuffLen) Tx1WrCnt = 0;
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0xB280             UXTH     R0,R0
   \   0000001E   0xF5B0 0x6F00      CMP      R0,#+2048
   \   00000022   0xBF28             IT       CS 
   \   00000024   0x2000             MOVCS    R0,#+0
   \   00000026   0x80E0             STRH     R0,[R4, #+6]
    309          	
    310          	USART1->__B.CR1.TXEIE = ENABLE; 		
   \   00000028   0x....             LDR.N    R0,??DataTable9_8  ;; 0x4001100c
   \   0000002A   0x6801             LDR      R1,[R0, #+0]
   \   0000002C   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000030   0x6001             STR      R1,[R0, #+0]
    311          	///////////////////////////////////////////////////
    312          #ifdef OS_INCLUDED
    313          	OSSemPost(pUSART1.sem);
   \   00000032   0x6B20             LDR      R0,[R4, #+48]
   \   00000034   0x.... 0x....      BL       OSSemPost
    314          #endif /* OS_INCLUDED */
    315          
    316          	return 0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    317          }
    318          
    319          
    320          
    321          //Not using interrupt

   \                                 In section .text, align 2, keep-with-next
    322          unsigned char USART1PutChar(unsigned char Data)
    323          {
   \                     USART1PutChar:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    324          	#ifdef OS_INCLUDED
    325          		INT8U err;
    326          		//////////////////////////////////////////////////
    327          	
    328          		OSSemPend(pUSART1.sem, 0, &err);
   \   00000004   0x....             LDR.N    R5,??DataTable9_4
   \   00000006   0xAA00             ADD      R2,SP,#+0
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6B28             LDR      R0,[R5, #+48]
   \   0000000C   0x.... 0x....      BL       OSSemPend
    329          	#endif /* OS_INCLUDED */
    330          		USART1->__B.DR.DR = Data;
   \   00000010   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40011000
   \   00000012   0x6841             LDR      R1,[R0, #+4]
   \   00000014   0xF364 0x0108      BFI      R1,R4,#+0,#+9
   \   00000018   0x6041             STR      R1,[R0, #+4]
    331          		while(!USART1->__B.SR.TXE);
   \                     ??USART1PutChar_0:
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0x0609             LSLS     R1,R1,#+24
   \   0000001E   0xD5FC             BPL.N    ??USART1PutChar_0
    332          	#ifdef OS_INCLUDED
    333          		OSSemPost(pUSART1.sem);
   \   00000020   0x6B28             LDR      R0,[R5, #+48]
   \   00000022   0x.... 0x....      BL       OSSemPost
    334          	#endif /* OS_INCLUDED */
    335          	return Data;
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    336          }
    337          

   \                                 In section .text, align 2, keep-with-next
    338          unsigned long int USART1Printf( const char *format, ...)
    339          {
   \                     USART1Printf:
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB530             PUSH     {R4,R5,LR}
    340          	unsigned long int i, cnt;
    341          //	char buf[128];
    342          	char *buf = (char *)&Tx1Buff[Tx1BuffLen-256];
    343          	
    344          	va_list argptr;
    345          
    346          	va_start(argptr, format);
   \   00000004   0xAA03             ADD      R2,SP,#+12
    347          	cnt = vsprintf(buf, format, argptr);
   \   00000006   0x....             LDR.N    R4,??DataTable9_9
   \   00000008   0x4601             MOV      R1,R0
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       vsprintf
   \   00000010   0x4605             MOV      R5,R0
    348          	va_end( argptr );
    349          
    350          	for(i = 0;;i++)
   \   00000012   0xE008             B.N      ??USART1Printf_0
    351          	{
    352          		if(buf[i] == 0) break;
    353          		if(buf[i] == '\n') USART1PutToBuffer('\r');
   \                     ??USART1Printf_1:
   \   00000014   0x280A             CMP      R0,#+10
   \   00000016   0xBF04             ITT      EQ 
   \   00000018   0x200D             MOVEQ    R0,#+13
   \   0000001A   0x.... 0x....      BLEQ     USART1PutToBuffer
    354          		USART1PutToBuffer(buf[i]);
   \   0000001E   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   00000022   0x.... 0x....      BL       USART1PutToBuffer
   \                     ??USART1Printf_0:
   \   00000026   0x7820             LDRB     R0,[R4, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD1F3             BNE.N    ??USART1Printf_1
    355          	}
    356          	while(!USART1TxCheckByte())
   \                     ??USART1Printf_2:
   \   0000002C   0x.... 0x....      BL       USART1TxCheckByte
   \   00000030   0xB918             CBNZ.N   R0,??USART1Printf_3
    357          	{
    358          #ifdef OS_INCLUDED
    359          	OSTimeDly(1);
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x.... 0x....      BL       OSTimeDly
   \   00000038   0xE7F8             B.N      ??USART1Printf_2
    360          #endif /* OS_INCLUDED */
    361          	}
    362          
    363          	USART1TxClear();
   \                     ??USART1Printf_3:
   \   0000003A   0x....             LDR.N    R0,??DataTable9_4
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x8081             STRH     R1,[R0, #+4]
   \   00000040   0x80C1             STRH     R1,[R0, #+6]
    364          	
    365          	return cnt;
   \   00000042   0x4628             MOV      R0,R5
   \   00000044   0xBC30             POP      {R4,R5}
   \   00000046   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
    366          }
    367          
    368          //#define OS_INCLUDED
    369          

   \                                 In section .text, align 2, keep-with-next
    370          void USART1PutStr(unsigned char *Str, unsigned short int Length, int iEn)
    371          {
   \                     USART1PutStr:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4617             MOV      R7,R2
    372          	u32 i = 0;
    373          
    374          //	USART1BuffClear();
    375          	
    376          #ifdef OS_INCLUDED
    377          	INT8U err;
    378          	OSSemPend(pUSART1.sem, 0, &err);
   \   00000008   0x....             LDR.N    R4,??DataTable9_4
   \   0000000A   0xAA00             ADD      R2,SP,#+0
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6B20             LDR      R0,[R4, #+48]
   \   00000010   0x.... 0x....      BL       OSSemPend
    379          #endif /* OS_INCLUDED */
    380          
    381          
    382          	for(i = 0; i < Length; i++)
   \   00000014   0x88E0             LDRH     R0,[R4, #+6]
   \   00000016   0xB146             CBZ.N    R6,??USART1PutStr_0
   \   00000018   0x....             LDR.N    R1,??DataTable9_7
    383          	{
    384          		Tx1Buff[Tx1WrCnt++] = Str[i];
   \                     ??USART1PutStr_1:
   \   0000001A   0xF815 0x2B01      LDRB     R2,[R5], #+1
   \   0000001E   0x5442             STRB     R2,[R0, R1]
    385          //		if(Tx1WrCnt >= Tx1BuffLen) Tx1WrCnt = 0;
    386          		Tx1WrCnt %= Tx1BuffLen;
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0x0540             LSLS     R0,R0,#+21
   \   00000024   0x0D40             LSRS     R0,R0,#+21
    387          	}
   \   00000026   0x1E76             SUBS     R6,R6,#+1
   \   00000028   0xD1F7             BNE.N    ??USART1PutStr_1
   \                     ??USART1PutStr_0:
   \   0000002A   0x80E0             STRH     R0,[R4, #+6]
    388          
    389          	if(iEn)
   \   0000002C   0xB127             CBZ.N    R7,??USART1PutStr_2
    390          	{
    391          		USART1->__B.CR1.TXEIE = ENABLE;
   \   0000002E   0x....             LDR.N    R0,??DataTable9_8  ;; 0x4001100c
   \   00000030   0x6801             LDR      R1,[R0, #+0]
   \   00000032   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000036   0x6001             STR      R1,[R0, #+0]
    392          	}	
    393          #ifdef OS_INCLUDED
    394          		OSSemPost(pUSART1.sem);
   \                     ??USART1PutStr_2:
   \   00000038   0x6B20             LDR      R0,[R4, #+48]
   \   0000003A   0x.... 0x....      BL       OSSemPost
    395          #endif /* OS_INCLUDED */
    396          }
   \   0000003E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    397          

   \                                 In section .text, align 2, keep-with-next
    398          signed short int USART1RxGetByte(void)
    399          {
    400          	s16 RetVal = 0;
    401          
    402          #ifndef OS_INCLUDED
    403          	while(Rx1RdCnt == Rx1WrCnt);
    404          #else
    405          	if(Rx1RdCnt == Rx1WrCnt) return -1;
   \                     USART1RxGetByte:
   \   00000000   0x....             LDR.N    R1,??DataTable9_4
   \   00000002   0x880A             LDRH     R2,[R1, #+0]
   \   00000004   0x8848             LDRH     R0,[R1, #+2]
   \   00000006   0x4282             CMP      R2,R0
   \   00000008   0xD102             BNE.N    ??USART1RxGetByte_0
   \   0000000A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000E   0x4770             BX       LR
    406          #endif
    407          
    408          	RetVal = Rx1Buff[Rx1RdCnt%Rx1BuffLen];
   \                     ??USART1RxGetByte_0:
   \   00000010   0x0550             LSLS     R0,R2,#+21
   \   00000012   0x0D40             LSRS     R0,R0,#+21
   \   00000014   0x....             LDR.N    R3,??DataTable9_6
   \   00000016   0x5CC0             LDRB     R0,[R0, R3]
    409          	if(++Rx1RdCnt >= Rx1BuffLen) Rx1RdCnt = 0;
   \   00000018   0x1C52             ADDS     R2,R2,#+1
   \   0000001A   0x800A             STRH     R2,[R1, #+0]
   \   0000001C   0xB292             UXTH     R2,R2
   \   0000001E   0xF5B2 0x6F00      CMP      R2,#+2048
   \   00000022   0xBF24             ITT      CS 
   \   00000024   0x2200             MOVCS    R2,#+0
   \   00000026   0x800A             STRHCS   R2,[R1, #+0]
    410          
    411          	return (RetVal & 0xff);
   \   00000028   0x4770             BX       LR               ;; return
    412          }
    413          

   \                                 In section .text, align 2, keep-with-next
    414          unsigned char USART1CheckByte(unsigned short int ByteCnt, unsigned short int *Recv)
    415          {
   \                     USART1CheckByte:
   \   00000000   0xB430             PUSH     {R4,R5}
    416          	u32 i = 0, j = 0;
    417          	u8 RetVal = TRUE;
   \   00000002   0x2201             MOVS     R2,#+1
    418          
    419          	*Recv = 0;
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x800B             STRH     R3,[R1, #+0]
    420          	i = (u32) Rx1RdCnt;
   \   00000008   0x....             LDR.N    R3,??DataTable9_4
   \   0000000A   0x881C             LDRH     R4,[R3, #+0]
    421          	j = (u32) Rx1WrCnt;
   \   0000000C   0x885B             LDRH     R3,[R3, #+2]
    422          
    423          	if(i == j) RetVal = FALSE;
   \   0000000E   0x429C             CMP      R4,R3
   \   00000010   0xD00E             BEQ.N    ??USART1CheckByte_0
    424          	else if(i < j)
   \   00000012   0x1900             ADDS     R0,R0,R4
   \   00000014   0x429C             CMP      R4,R3
   \   00000016   0xD203             BCS.N    ??USART1CheckByte_1
    425          	{
    426          		*Recv = j - i;
   \   00000018   0x1B1C             SUBS     R4,R3,R4
   \   0000001A   0x800C             STRH     R4,[R1, #+0]
    427          		i = i + ByteCnt;
    428          		if(i > j) RetVal = FALSE;
   \   0000001C   0x4283             CMP      R3,R0
   \   0000001E   0xE006             B.N      ??USART1CheckByte_2
    429          	}
    430          	else if(i > j)
    431          	{
    432          		*Recv = (Rx1BuffLen +j) - i;
   \                     ??USART1CheckByte_1:
   \   00000020   0xF503 0x6500      ADD      R5,R3,#+2048
   \   00000024   0x1B2C             SUBS     R4,R5,R4
   \   00000026   0x800C             STRH     R4,[R1, #+0]
    433          		i = i + ByteCnt;
    434          		j = j + Rx1BuffLen;
    435          		if(i > j) RetVal = FALSE; 
   \   00000028   0xF503 0x6100      ADD      R1,R3,#+2048
   \   0000002C   0x4281             CMP      R1,R0
   \                     ??USART1CheckByte_2:
   \   0000002E   0xD200             BCS.N    ??USART1CheckByte_3
   \                     ??USART1CheckByte_0:
   \   00000030   0x2200             MOVS     R2,#+0
    436          	}
    437          	return (RetVal);
   \                     ??USART1CheckByte_3:
   \   00000032   0x4610             MOV      R0,R2
   \   00000034   0xBC30             POP      {R4,R5}
   \   00000036   0x4770             BX       LR               ;; return
    438          }
    439          

   \                                 In section .text, align 2, keep-with-next
    440          void USART1BuffClear(void)
    441          {
    442          	Rx1RdCnt = 0;
   \                     USART1BuffClear:
   \   00000000   0x....             LDR.N    R0,??DataTable9_4
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x8001             STRH     R1,[R0, #+0]
    443          	Rx1WrCnt = 0;
   \   00000006   0x8041             STRH     R1,[R0, #+2]
    444          	Tx1RdCnt = 0;
   \   00000008   0x....             B.N      ?Subroutine1
    445          	Tx1WrCnt = 0;
    446          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0x8081             STRH     R1,[R0, #+4]
   \   00000002   0x80C1             STRH     R1,[R0, #+6]
   \   00000004   0x4770             BX       LR               ;; return
    447          

   \                                 In section .text, align 2, keep-with-next
    448          void USART1TxClear(void)
    449          {
    450          	Tx1RdCnt = 0;
   \                     USART1TxClear:
   \   00000000   0x....             LDR.N    R0,??DataTable9_4
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004                      REQUIRE ?Subroutine1
   \   00000004                      ;; // Fall through to label ?Subroutine1
    451          	Tx1WrCnt = 0;
    452          }
    453          
    454          /*******************************************************************************
    455            * @brief  if the bytes have been transmitted, retrun true or not
    456            * @param  None
    457            * @retval TRUE/FALSE
    458            ******************************************************************************/
    459          

   \                                 In section .text, align 2, keep-with-next
    460          signed short int USART1TxCheckByte(void)
    461          {
    462          	if(Tx1RdCnt == Tx1WrCnt) return TRUE;
   \                     USART1TxCheckByte:
   \   00000000   0x....             LDR.N    R0,??DataTable9_4
   \   00000002   0x8881             LDRH     R1,[R0, #+4]
   \   00000004   0x88C0             LDRH     R0,[R0, #+6]
   \   00000006   0x4281             CMP      R1,R0
   \   00000008   0xD101             BNE.N    ??USART1TxCheckByte_0
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x4770             BX       LR
    463          	else return FALSE;
   \                     ??USART1TxCheckByte_0:
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4770             BX       LR               ;; return
    464          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x40023830         DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     Rx1RdCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     Rx1Buff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     Tx1Buff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x4001100C         DC32     0x4001100c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x........         DC32     Tx1Buff+0x700

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "\\n">`:
   \   00000000   0x0A 0x00          DC8 "\012"
    465          
    466          
    467          
    468          
    469          /**
    470            * @brief  Initializes the USARTx peripheral Clock according to the 
    471            *         specified parameters in the USART_ClockInitStruct .
    472            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART peripheral.
    473            * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure that
    474            *         contains the configuration information for the specified  USART peripheral.
    475            * @note   The Smart Card and Synchronous modes are not available for UART4 and UART5.    
    476            * @retval None
    477            */
    478          
    479          /**
    480            * @brief  Fills each USART_ClockInitStruct member with its default value.
    481            * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure
    482            *         which will be initialized.
    483            * @retval None
    484            */
    485          
    486          
    487          /**
    488            * @brief  Enables or disables the specified USART peripheral.
    489            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    490            *         UART peripheral.
    491            * @param  NewState: new state of the USARTx peripheral.
    492            *          This parameter can be: ENABLE or DISABLE.
    493            * @retval None
    494            */
    495          
    496          
    497          /**
    498            * @brief  Sets the system clock prescaler.
    499            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    500            *         UART peripheral.
    501            * @param  USART_Prescaler: specifies the prescaler clock. 
    502            * @note   The function is used for IrDA mode with UART4 and UART5.   
    503            * @retval None
    504            */
    505          
    506          /**
    507            * @brief  Enables or disables the USART's 8x oversampling mode.
    508            * @note   This function has to be called before calling USART_Init() function
    509            *         in order to have correct baudrate Divider value.
    510            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    511            *         UART peripheral.
    512            * @param  NewState: new state of the USART 8x oversampling mode.
    513            *          This parameter can be: ENABLE or DISABLE.
    514            * @retval None
    515            */
    516            
    517          
    518          /**
    519            * @brief  Enables or disables the USART's one bit sampling method.
    520            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    521            *         UART peripheral.
    522            * @param  NewState: new state of the USART one bit sampling method.
    523            *          This parameter can be: ENABLE or DISABLE.
    524            * @retval None
    525            */
    526          
    527          /**
    528            * @}
    529            */
    530          
    531          /** @defgroup USART_Group2 Data transfers functions
    532           *  @brief   Data transfers functions 
    533           *
    534          @verbatim   
    535           ===============================================================================
    536                                      Data transfers functions
    537           ===============================================================================  
    538          
    539            This subsection provides a set of functions allowing to manage the USART data 
    540            transfers.
    541            
    542            During an USART reception, data shifts in least significant bit first through 
    543            the RX pin. In this mode, the USART_DR register consists of a buffer (RDR) 
    544            between the internal bus and the received shift register.
    545          
    546            When a transmission is taking place, a write instruction to the USART_DR register 
    547            stores the data in the TDR register and which is copied in the shift register 
    548            at the end of the current transmission.
    549          
    550            The read access of the USART_DR register can be done using the USART_ReceiveData()
    551            function and returns the RDR buffered value. Whereas a write access to the USART_DR 
    552            can be done using USART_SendData() function and stores the written data into 
    553            TDR buffer.
    554          
    555          @endverbatim
    556            * @{
    557            */
    558          
    559          /**
    560            * @brief  Transmits single data through the USARTx peripheral.
    561            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    562            *         UART peripheral.
    563            * @param  Data: the data to transmit.
    564            * @retval None
    565            */
    566          
    567          
    568          /**
    569            * @brief  Returns the most recent received data by the USARTx peripheral.
    570            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    571            *         UART peripheral.
    572            * @retval The received data.
    573            */
    574          
    575          /**
    576            * @}
    577            */
    578          
    579          /** @defgroup USART_Group3 MultiProcessor Communication functions
    580           *  @brief   Multi-Processor Communication functions 
    581           *
    582          @verbatim   
    583           ===============================================================================
    584                              Multi-Processor Communication functions
    585           ===============================================================================  
    586          
    587            This subsection provides a set of functions allowing to manage the USART 
    588            multiprocessor communication.
    589            
    590            For instance one of the USARTs can be the master, its TX output is connected to 
    591            the RX input of the other USART. The others are slaves, their respective TX outputs 
    592            are logically ANDed together and connected to the RX input of the master.
    593          
    594            USART multiprocessor communication is possible through the following procedure:
    595               1. Program the Baud rate, Word length = 9 bits, Stop bits, Parity, Mode transmitter 
    596                  or Mode receiver and hardware flow control values using the USART_Init()
    597                  function.
    598               2. Configures the USART address using the USART_SetAddress() function.
    599               3. Configures the wake up method (USART_WakeUp_IdleLine or USART_WakeUp_AddressMark)
    600                  using USART_WakeUpConfig() function only for the slaves.
    601               4. Enable the USART using the USART_Cmd() function.
    602               5. Enter the USART slaves in mute mode using USART_ReceiverWakeUpCmd() function.
    603          
    604            The USART Slave exit from mute mode when receive the wake up condition.
    605          
    606          @endverbatim
    607            * @{
    608            */
    609          
    610          /**
    611            * @brief  Sets the address of the USART node.
    612            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    613            *         UART peripheral.
    614            * @param  USART_Address: Indicates the address of the USART node.
    615            * @retval None
    616            */
    617          
    618          
    619          /**
    620            * @brief  Determines if the USART is in mute mode or not.
    621            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    622            *         UART peripheral.
    623            * @param  NewState: new state of the USART mute mode.
    624            *          This parameter can be: ENABLE or DISABLE.
    625            * @retval None
    626            */
    627          
    628          /**
    629            * @brief  Selects the USART WakeUp method.
    630            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    631            *         UART peripheral.
    632            * @param  USART_WakeUp: specifies the USART wakeup method.
    633            *          This parameter can be one of the following values:
    634            *            @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection
    635            *            @arg USART_WakeUp_AddressMark: WakeUp by an address mark
    636            * @retval None
    637            */
    638          
    639          
    640          /**
    641            * @}
    642            */
    643          
    644          /** @defgroup USART_Group4 LIN mode functions
    645           *  @brief   LIN mode functions 
    646           *
    647          @verbatim   
    648           ===============================================================================
    649                                          LIN mode functions
    650           ===============================================================================  
    651          
    652            This subsection provides a set of functions allowing to manage the USART LIN 
    653            Mode communication.
    654            
    655            In LIN mode, 8-bit data format with 1 stop bit is required in accordance with 
    656            the LIN standard.
    657          
    658            Only this LIN Feature is supported by the USART IP:
    659              - LIN Master Synchronous Break send capability and LIN slave break detection
    660                capability :  13-bit break generation and 10/11 bit break detection
    661          
    662          
    663            USART LIN Master transmitter communication is possible through the following procedure:
    664               1. Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
    665                  Mode transmitter or Mode receiver and hardware flow control values using 
    666                  the USART_Init() function.
    667               2. Enable the USART using the USART_Cmd() function.
    668               3. Enable the LIN mode using the USART_LINCmd() function.
    669               4. Send the break character using USART_SendBreak() function.
    670          
    671            USART LIN Master receiver communication is possible through the following procedure:
    672               1. Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
    673                  Mode transmitter or Mode receiver and hardware flow control values using 
    674                  the USART_Init() function.
    675               2. Enable the USART using the USART_Cmd() function.
    676               3. Configures the break detection length using the USART_LINBreakDetectLengthConfig()
    677                  function.
    678               4. Enable the LIN mode using the USART_LINCmd() function.
    679          
    680          
    681          @note In LIN mode, the following bits must be kept cleared:
    682                  - CLKEN in the USART_CR2 register,
    683                  - STOP[1:0], SCEN, HDSEL and IREN in the USART_CR3 register.
    684          
    685          @endverbatim
    686            * @{
    687            */
    688          
    689          /**
    690            * @brief  Sets the USART LIN Break detection length.
    691            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    692            *         UART peripheral.
    693            * @param  USART_LINBreakDetectLength: specifies the LIN break detection length.
    694            *          This parameter can be one of the following values:
    695            *            @arg USART_LINBreakDetectLength_10b: 10-bit break detection
    696            *            @arg USART_LINBreakDetectLength_11b: 11-bit break detection
    697            * @retval None
    698            */
    699          
    700          /**
    701            * @brief  Enables or disables the USART's LIN mode.
    702            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    703            *         UART peripheral.
    704            * @param  NewState: new state of the USART LIN mode.
    705            *          This parameter can be: ENABLE or DISABLE.
    706            * @retval None
    707            */
    708          
    709          
    710          /**
    711            * @brief  Transmits break characters.
    712            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    713            *         UART peripheral.
    714            * @retval None
    715            */
    716          
    717          
    718          /**
    719            * @}
    720            */
    721          
    722          /** @defgroup USART_Group5 Halfduplex mode function
    723           *  @brief   Half-duplex mode function 
    724           *
    725          @verbatim   
    726           ===============================================================================
    727                                   Half-duplex mode function
    728           ===============================================================================  
    729          
    730            This subsection provides a set of functions allowing to manage the USART 
    731            Half-duplex communication.
    732            
    733            The USART can be configured to follow a single-wire half-duplex protocol where 
    734            the TX and RX lines are internally connected.
    735          
    736            USART Half duplex communication is possible through the following procedure:
    737               1. Program the Baud rate, Word length, Stop bits, Parity, Mode transmitter 
    738                  or Mode receiver and hardware flow control values using the USART_Init()
    739                  function.
    740               2. Configures the USART address using the USART_SetAddress() function.
    741               3. Enable the USART using the USART_Cmd() function.
    742               4. Enable the half duplex mode using USART_HalfDuplexCmd() function.
    743          
    744          
    745          @note The RX pin is no longer used
    746          @note In Half-duplex mode the following bits must be kept cleared:
    747                  - LINEN and CLKEN bits in the USART_CR2 register.
    748                  - SCEN and IREN bits in the USART_CR3 register.
    749          
    750          @endverbatim
    751            * @{
    752            */
    753          
    754          /**
    755            * @brief  Enables or disables the USART's Half Duplex communication.
    756            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    757            *         UART peripheral.
    758            * @param  NewState: new state of the USART Communication.
    759            *          This parameter can be: ENABLE or DISABLE.
    760            * @retval None
    761            */
    762          
    763          
    764          /**
    765            * @}
    766            */
    767          
    768          
    769          /** @defgroup USART_Group6 Smartcard mode functions
    770           *  @brief   Smartcard mode functions 
    771           *
    772          @verbatim   
    773           ===============================================================================
    774                                         Smartcard mode functions
    775           ===============================================================================  
    776          
    777            This subsection provides a set of functions allowing to manage the USART 
    778            Smartcard communication.
    779            
    780            The Smartcard interface is designed to support asynchronous protocol Smartcards as
    781            defined in the ISO 7816-3 standard.
    782          
    783            The USART can provide a clock to the smartcard through the SCLK output.
    784            In smartcard mode, SCLK is not associated to the communication but is simply derived 
    785            from the internal peripheral input clock through a 5-bit prescaler.
    786          
    787            Smartcard communication is possible through the following procedure:
    788               1. Configures the Smartcard Prescaler using the USART_SetPrescaler() function.
    789               2. Configures the Smartcard Guard Time using the USART_SetGuardTime() function.
    790               3. Program the USART clock using the USART_ClockInit() function as following:
    791                  - USART Clock enabled
    792                  - USART CPOL Low
    793                  - USART CPHA on first edge
    794                  - USART Last Bit Clock Enabled
    795               4. Program the Smartcard interface using the USART_Init() function as following:
    796                  - Word Length = 9 Bits
    797                  - 1.5 Stop Bit
    798                  - Even parity
    799                  - BaudRate = 12096 baud
    800                  - Hardware flow control disabled (RTS and CTS signals)
    801                  - Tx and Rx enabled
    802               5. Optionally you can enable the parity error interrupt using the USART_ITConfig()
    803                  function
    804               6. Enable the USART using the USART_Cmd() function.
    805               7. Enable the Smartcard NACK using the USART_SmartCardNACKCmd() function.
    806               8. Enable the Smartcard interface using the USART_SmartCardCmd() function.
    807          
    808            Please refer to the ISO 7816-3 specification for more details.
    809          
    810          
    811          @note It is also possible to choose 0.5 stop bit for receiving but it is recommended 
    812                to use 1.5 stop bits for both transmitting and receiving to avoid switching 
    813                between the two configurations.
    814          @note In smartcard mode, the following bits must be kept cleared:
    815                  - LINEN bit in the USART_CR2 register.
    816                  - HDSEL and IREN bits in the USART_CR3 register.
    817          @note Smartcard mode is available on USART peripherals only (not available on UART4 
    818                and UART5 peripherals).
    819          
    820          @endverbatim
    821            * @{
    822            */
    823          
    824          /**
    825            * @brief  Sets the specified USART guard time.
    826            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
    827            *         UART peripheral.
    828            * @param  USART_GuardTime: specifies the guard time.   
    829            * @retval None
    830            */
    831          
    832          /**
    833            * @brief  Enables or disables the USART's Smart Card mode.
    834            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
    835            *         UART peripheral.
    836            * @param  NewState: new state of the Smart Card mode.
    837            *          This parameter can be: ENABLE or DISABLE.      
    838            * @retval None
    839            */
    840          
    841          
    842          /**
    843            * @brief  Enables or disables NACK transmission.
    844            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
    845            *         UART peripheral.
    846            * @param  NewState: new state of the NACK transmission.
    847            *          This parameter can be: ENABLE or DISABLE.  
    848            * @retval None
    849            */
    850          
    851          /**
    852            * @}
    853            */
    854          
    855          /** @defgroup USART_Group7 IrDA mode functions
    856           *  @brief   IrDA mode functions 
    857           *
    858          @verbatim   
    859           ===============================================================================
    860                                          IrDA mode functions
    861           ===============================================================================  
    862          
    863            This subsection provides a set of functions allowing to manage the USART 
    864            IrDA communication.
    865            
    866            IrDA is a half duplex communication protocol. If the Transmitter is busy, any data
    867            on the IrDA receive line will be ignored by the IrDA decoder and if the Receiver 
    868            is busy, data on the TX from the USART to IrDA will not be encoded by IrDA.
    869            While receiving data, transmission should be avoided as the data to be transmitted
    870            could be corrupted.
    871          
    872            IrDA communication is possible through the following procedure:
    873               1. Program the Baud rate, Word length = 8 bits, Stop bits, Parity, Transmitter/Receiver 
    874                  modes and hardware flow control values using the USART_Init() function.
    875               2. Enable the USART using the USART_Cmd() function.
    876               3. Configures the IrDA pulse width by configuring the prescaler using  
    877                  the USART_SetPrescaler() function.
    878               4. Configures the IrDA  USART_IrDAMode_LowPower or USART_IrDAMode_Normal mode
    879                  using the USART_IrDAConfig() function.
    880               5. Enable the IrDA using the USART_IrDACmd() function.
    881          
    882          @note A pulse of width less than two and greater than one PSC period(s) may or may
    883                not be rejected.
    884          @note The receiver set up time should be managed by software. The IrDA physical layer
    885                specification specifies a minimum of 10 ms delay between transmission and 
    886                reception (IrDA is a half duplex protocol).
    887          @note In IrDA mode, the following bits must be kept cleared:
    888                  - LINEN, STOP and CLKEN bits in the USART_CR2 register.
    889                  - SCEN and HDSEL bits in the USART_CR3 register.
    890          
    891          @endverbatim
    892            * @{
    893            */
    894          
    895          /**
    896            * @brief  Configures the USART's IrDA interface.
    897            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    898            *         UART peripheral.
    899            * @param  USART_IrDAMode: specifies the IrDA mode.
    900            *          This parameter can be one of the following values:
    901            *            @arg USART_IrDAMode_LowPower
    902            *            @arg USART_IrDAMode_Normal
    903            * @retval None
    904            */
    905          
    906          /**
    907            * @brief  Enables or disables the USART's IrDA interface.
    908            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    909            *         UART peripheral.
    910            * @param  NewState: new state of the IrDA mode.
    911            *          This parameter can be: ENABLE or DISABLE.
    912            * @retval None
    913            */
    914          
    915          
    916          /**
    917            * @}
    918            */
    919          
    920          /** @defgroup USART_Group8 DMA transfers management functions
    921           *  @brief   DMA transfers management functions
    922           *
    923          @verbatim   
    924           ===============================================================================
    925                                DMA transfers management functions
    926           ===============================================================================  
    927          
    928          @endverbatim
    929            * @{
    930            */
    931            
    932          /**
    933            * @brief  Enables or disables the USART's DMA interface.
    934            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    935            *         UART peripheral.
    936            * @param  USART_DMAReq: specifies the DMA request.
    937            *          This parameter can be any combination of the following values:
    938            *            @arg USART_DMAReq_Tx: USART DMA transmit request
    939            *            @arg USART_DMAReq_Rx: USART DMA receive request
    940            * @param  NewState: new state of the DMA Request sources.
    941            *          This parameter can be: ENABLE or DISABLE.   
    942            * @retval None
    943            */
    944          
    945          /**
    946            * @}
    947            */
    948            
    949          /** @defgroup USART_Group9 Interrupts and flags management functions
    950           *  @brief   Interrupts and flags management functions 
    951           *
    952          @verbatim   
    953           ===============================================================================
    954                             Interrupts and flags management functions
    955           ===============================================================================  
    956          
    957            This subsection provides a set of functions allowing to configure the USART 
    958            Interrupts sources, DMA channels requests and check or clear the flags or 
    959            pending bits status.
    960            The user should identify which mode will be used in his application to manage 
    961            the communication: Polling mode, Interrupt mode or DMA mode. 
    962              
    963            Polling Mode
    964            =============
    965            In Polling Mode, the SPI communication can be managed by 10 flags:
    966               1. USART_FLAG_TXE : to indicate the status of the transmit buffer register
    967               2. USART_FLAG_RXNE : to indicate the status of the receive buffer register
    968               3. USART_FLAG_TC : to indicate the status of the transmit operation
    969               4. USART_FLAG_IDLE : to indicate the status of the Idle Line             
    970               5. USART_FLAG_CTS : to indicate the status of the nCTS input
    971               6. USART_FLAG_LBD : to indicate the status of the LIN break detection
    972               7. USART_FLAG_NE : to indicate if a noise error occur
    973               8. USART_FLAG_FE : to indicate if a frame error occur
    974               9. USART_FLAG_PE : to indicate if a parity error occur
    975               10. USART_FLAG_ORE : to indicate if an Overrun error occur
    976          
    977            In this Mode it is advised to use the following functions:
    978                - FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);
    979                - void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG);
    980          
    981            Interrupt Mode
    982            ===============
    983            In Interrupt Mode, the USART communication can be managed by 8 interrupt sources
    984            and 10 pending bits: 
    985          
    986            Pending Bits:
    987            ------------- 
    988               1. USART_IT_TXE : to indicate the status of the transmit buffer register
    989               2. USART_IT_RXNE : to indicate the status of the receive buffer register
    990               3. USART_IT_TC : to indicate the status of the transmit operation
    991               4. USART_IT_IDLE : to indicate the status of the Idle Line             
    992               5. USART_IT_CTS : to indicate the status of the nCTS input
    993               6. USART_IT_LBD : to indicate the status of the LIN break detection
    994               7. USART_IT_NE : to indicate if a noise error occur
    995               8. USART_IT_FE : to indicate if a frame error occur
    996               9. USART_IT_PE : to indicate if a parity error occur
    997               10. USART_IT_ORE : to indicate if an Overrun error occur
    998          
    999            Interrupt Source:
   1000            -----------------
   1001               1. USART_IT_TXE : specifies the interrupt source for the Tx buffer empty 
   1002                                 interrupt. 
   1003               2. USART_IT_RXNE : specifies the interrupt source for the Rx buffer not 
   1004                                  empty interrupt.
   1005               3. USART_IT_TC : specifies the interrupt source for the Transmit complete 
   1006                                 interrupt. 
   1007               4. USART_IT_IDLE : specifies the interrupt source for the Idle Line interrupt.             
   1008               5. USART_IT_CTS : specifies the interrupt source for the CTS interrupt. 
   1009               6. USART_IT_LBD : specifies the interrupt source for the LIN break detection
   1010                                 interrupt. 
   1011               7. USART_IT_PE : specifies the interrupt source for the parity error interrupt. 
   1012               8. USART_IT_ERR :  specifies the interrupt source for the errors interrupt.
   1013          
   1014          @note Some parameters are coded in order to use them as interrupt source or as pending bits.
   1015          
   1016            In this Mode it is advised to use the following functions:
   1017               - void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);
   1018               - ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
   1019               - void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
   1020          
   1021            DMA Mode
   1022            ========
   1023            In DMA Mode, the USART communication can be managed by 2 DMA Channel requests:
   1024               1. USART_DMAReq_Tx: specifies the Tx buffer DMA transfer request
   1025               2. USART_DMAReq_Rx: specifies the Rx buffer DMA transfer request
   1026          
   1027            In this Mode it is advised to use the following function:
   1028               - void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState);
   1029          
   1030          @endverbatim
   1031            * @{
   1032            */
   1033          
   1034          /**
   1035            * @brief  Enables or disables the specified USART interrupts.
   1036            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1037            *         UART peripheral.
   1038            * @param  USART_IT: specifies the USART interrupt sources to be enabled or disabled.
   1039            *          This parameter can be one of the following values:
   1040            *            @arg USART_IT_CTS:  CTS change interrupt
   1041            *            @arg USART_IT_LBD:  LIN Break detection interrupt
   1042            *            @arg USART_IT_TXE:  Transmit Data Register empty interrupt
   1043            *            @arg USART_IT_TC:   Transmission complete interrupt
   1044            *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
   1045            *            @arg USART_IT_IDLE: Idle line detection interrupt
   1046            *            @arg USART_IT_PE:   Parity Error interrupt
   1047            *            @arg USART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
   1048            * @param  NewState: new state of the specified USARTx interrupts.
   1049            *          This parameter can be: ENABLE or DISABLE.
   1050            * @retval None
   1051            */
   1052          
   1053          /**
   1054            * @brief  Checks whether the specified USART flag is set or not.
   1055            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1056            *         UART peripheral.
   1057            * @param  USART_FLAG: specifies the flag to check.
   1058            *          This parameter can be one of the following values:
   1059            *            @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5)
   1060            *            @arg USART_FLAG_LBD:  LIN Break detection flag
   1061            *            @arg USART_FLAG_TXE:  Transmit data register empty flag
   1062            *            @arg USART_FLAG_TC:   Transmission Complete flag
   1063            *            @arg USART_FLAG_RXNE: Receive data register not empty flag
   1064            *            @arg USART_FLAG_IDLE: Idle Line detection flag
   1065            *            @arg USART_FLAG_ORE:  OverRun Error flag
   1066            *            @arg USART_FLAG_NE:   Noise Error flag
   1067            *            @arg USART_FLAG_FE:   Framing Error flag
   1068            *            @arg USART_FLAG_PE:   Parity Error flag
   1069            * @retval The new state of USART_FLAG (SET or RESET).
   1070            */
   1071          
   1072          /**
   1073            * @brief  Clears the USARTx's pending flags.
   1074            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1075            *         UART peripheral.
   1076            * @param  USART_FLAG: specifies the flag to clear.
   1077            *          This parameter can be any combination of the following values:
   1078            *            @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5).
   1079            *            @arg USART_FLAG_LBD:  LIN Break detection flag.
   1080            *            @arg USART_FLAG_TC:   Transmission Complete flag.
   1081            *            @arg USART_FLAG_RXNE: Receive data register not empty flag.
   1082            *   
   1083            * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
   1084            *          error) and IDLE (Idle line detected) flags are cleared by software 
   1085            *          sequence: a read operation to USART_SR register (USART_GetFlagStatus()) 
   1086            *          followed by a read operation to USART_DR register (USART_ReceiveData()).
   1087            * @note   RXNE flag can be also cleared by a read to the USART_DR register 
   1088            *          (USART_ReceiveData()).
   1089            * @note   TC flag can be also cleared by software sequence: a read operation to 
   1090            *          USART_SR register (USART_GetFlagStatus()) followed by a write operation
   1091            *          to USART_DR register (USART_SendData()).
   1092            * @note   TXE flag is cleared only by a write to the USART_DR register 
   1093            *          (USART_SendData()).
   1094            *   
   1095            * @retval None
   1096            */
   1097          
   1098          
   1099          /**
   1100            * @brief  Checks whether the specified USART interrupt has occurred or not.
   1101            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1102            *         UART peripheral.
   1103            * @param  USART_IT: specifies the USART interrupt source to check.
   1104            *          This parameter can be one of the following values:
   1105            *            @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
   1106            *            @arg USART_IT_LBD:  LIN Break detection interrupt
   1107            *            @arg USART_IT_TXE:  Transmit Data Register empty interrupt
   1108            *            @arg USART_IT_TC:   Transmission complete interrupt
   1109            *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
   1110            *            @arg USART_IT_IDLE: Idle line detection interrupt
   1111            *            @arg USART_IT_ORE:  OverRun Error interrupt
   1112            *            @arg USART_IT_NE:   Noise Error interrupt
   1113            *            @arg USART_IT_FE:   Framing Error interrupt
   1114            *            @arg USART_IT_PE:   Parity Error interrupt
   1115            * @retval The new state of USART_IT (SET or RESET).
   1116            */
   1117          
   1118          
   1119          /**
   1120            * @brief  Clears the USARTx's interrupt pending bits.
   1121            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1122            *         UART peripheral.
   1123            * @param  USART_IT: specifies the interrupt pending bit to clear.
   1124            *          This parameter can be one of the following values:
   1125            *            @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
   1126            *            @arg USART_IT_LBD:  LIN Break detection interrupt
   1127            *            @arg USART_IT_TC:   Transmission complete interrupt. 
   1128            *            @arg USART_IT_RXNE: Receive Data register not empty interrupt.
   1129            *
   1130            * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
   1131            *          error) and IDLE (Idle line detected) pending bits are cleared by 
   1132            *          software sequence: a read operation to USART_SR register 
   1133            *          (USART_GetITStatus()) followed by a read operation to USART_DR register 
   1134            *          (USART_ReceiveData()).
   1135            * @note   RXNE pending bit can be also cleared by a read to the USART_DR register 
   1136            *          (USART_ReceiveData()).
   1137            * @note   TC pending bit can be also cleared by software sequence: a read 
   1138            *          operation to USART_SR register (USART_GetITStatus()) followed by a write 
   1139            *          operation to USART_DR register (USART_SendData()).
   1140            * @note   TXE pending bit is cleared only by a write to the USART_DR register 
   1141            *          (USART_SendData()).
   1142            *  
   1143            * @retval None
   1144            */
   1145          
   1146          
   1147          /**
   1148            * @}
   1149            */
   1150          
   1151          /**
   1152            * @}
   1153            */
   1154          
   1155          /**
   1156            * @}
   1157            */
   1158          
   1159          /**
   1160            * @}
   1161            */
   1162          
   1163          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       32  InitUSART1
             32 -> GPIOPortInit
             32 -> NVIC_Init
             32 -> OSSemCreate
             32 -> USART1Printf
             32 -> USART_Cmd
             32 -> USART_ITConfig
             32 -> USART_Init
        0  USART1BuffClear
        8  USART1CheckByte
       24  USART1Printf
             24 -> OSTimeDly
             24 -> USART1PutToBuffer
             24 -> USART1TxCheckByte
             24 -> vsprintf
       16  USART1PutChar
             16 -> OSSemPend
             16 -> OSSemPost
       24  USART1PutStr
             24 -> OSSemPend
             24 -> OSSemPost
       16  USART1PutToBuffer
             16 -> OSSemPend
             16 -> OSSemPost
        0  USART1RxGetByte
        0  USART1TxCheckByte
        0  USART1TxClear
       16  USART1_IRQIntHandler
             16 -> CPU_SR_Restore
             16 -> CPU_SR_Save
              0 -> OSIntExit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Constant "\n">
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
       8  ?Subroutine0
       6  ?Subroutine1
     180  InitUSART1
    2048  Rx1Buff
      52  Rx1RdCnt
          Rx1WrCnt
          Tx1RdCnt
          Tx1WrCnt
          pUSART1
    2048  Tx1Buff
      10  USART1BuffClear
      56  USART1CheckByte
      74  USART1Printf
      42  USART1PutChar
      64  USART1PutStr
      60  USART1PutToBuffer
      42  USART1RxGetByte
      18  USART1TxCheckByte
       4  USART1TxClear
     114  USART1_IRQIntHandler

 
     2 bytes in section .rodata
   718 bytes in section .text
 4 148 bytes in section iram
 
   718 bytes of CODE  memory
     2 bytes of CONST memory
 4 148 bytes of DATA  memory

Errors: none
Warnings: none

###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     07/Jan/2014  16:08:56 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Project\TRIO\2차버전\3.F_W\appl_stm207_20131104 -     #
#                    복사본\STM32F2xx_StdPeriph_Driver_v1212\stm32f2xx_system #
#                    .c                                                       #
#    Command line =  "C:\Project\TRIO\2차버전\3.F_W\appl_stm207_20131104 -    #
#                    복사본\STM32F2xx_StdPeriph_Driver_v1212\stm32f2xx_system #
#                    .c" -D NDEBUG -lC "C:\Project\TRIO\2차버전\3.F_W\appl_st #
#                    m207_20131104 - 복사본\STM32F2xx_StdPeriph_Driver_v1212\ #
#                    ewarm\sout\" -o "C:\Project\TRIO\2차버전\3.F_W\appl_stm2 #
#                    07_20131104 - 복사본\STM32F2xx_StdPeriph_Driver_v1212\ew #
#                    arm\sout\" --endian=little --cpu=Cortex-M3 -e            #
#                    --fpu=None --dlib_config "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.0_2\arm\INC\c\DLib_Config_N #
#                    ormal.h" -I "C:\Project\TRIO\2차버전\3.F_W\appl_stm207_2 #
#                    0131104 - 복사본\STM32F2xx_StdPeriph_Driver_v1212\ewarm\ #
#                    ..\" -I "C:\Project\TRIO\2차버전\3.F_W\appl_stm207_20131 #
#                    104 - 복사본\STM32F2xx_StdPeriph_Driver_v1212\ewarm\..\i #
#                    nc\" -I "C:\Project\TRIO\2차버전\3.F_W\appl_stm207_20131 #
#                    104 - 복사본\STM32F2xx_StdPeriph_Driver_v1212\ewarm\..\. #
#                    .\uC-CPU\" -I "C:\Project\TRIO\2차버전\3.F_W\appl_stm207 #
#                    _20131104 - 복사본\STM32F2xx_StdPeriph_Driver_v1212\ewar #
#                    m\..\..\uC-LIB\" -I "C:\Project\TRIO\2차버전\3.F_W\appl_ #
#                    stm207_20131104 - 복사본\STM32F2xx_StdPeriph_Driver_v121 #
#                    2\ewarm\..\..\uCOS-II\Ports\" -I                         #
#                    "C:\Project\TRIO\2차버전\3.F_W\appl_stm207_20131104 -    #
#                    복사본\STM32F2xx_StdPeriph_Driver_v1212\ewarm\..\..\uCOS #
#                    -II\Source\" -Oh                                         #
#    List file    =  C:\Project\TRIO\2차버전\3.F_W\appl_stm207_20131104 -     #
#                    복사본\STM32F2xx_StdPeriph_Driver_v1212\ewarm\sout\stm32 #
#                    f2xx_system.lst                                          #
#    Object file  =  C:\Project\TRIO\2차버전\3.F_W\appl_stm207_20131104 -     #
#                    복사본\STM32F2xx_StdPeriph_Driver_v1212\ewarm\sout\stm32 #
#                    f2xx_system.o                                            #
#                                                                             #
#                                                                             #
###############################################################################

C:\Project\TRIO\2차버전\3.F_W\appl_stm207_20131104 - 복사본\STM32F2xx_StdPeriph_Driver_v1212\stm32f2xx_system.c
      1          /**
      2            ******************************************************************************
      3            * @file    system_stm32f2xx.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    18-April-2011
      7            * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer System Source File.
      8            *          This file contains the system clock configuration for STM32F2xx devices,
      9            *          and is generated by the clock configuration tool
     10            *          "STM32f2xx_Clock_Configuration_V1.0.0.xls"
     11            *             
     12            * 1.  This file provides two functions and one global variable to be called from 
     13            *     user application:
     14            *      - SystemInit(): Setups the system clock (System clock source, PLL Multiplier
     15            *                      and Divider factors, AHB/APBx prescalers and Flash settings),
     16            *                      depending on the configuration made in the clock xls tool. 
     17            *                      This function is called at startup just after reset and 
     18            *                      before branch to main program. This call is made inside
     19            *                      the "startup_stm32f2xx.s" file.
     20            *
     21            *      - SystemCoreClock variable: Contains the core clock (HCLK), it can be used
     22            *                                  by the user application to setup the SysTick 
     23            *                                  timer or configure other parameters.
     24            *                                     
     25            *      - SystemCoreClockUpdate(): Updates the variable SystemCoreClock and must
     26            *                                 be called whenever the core clock is changed
     27            *                                 during program execution.
     28            *
     29            * 2. After each device reset the HSI (16 MHz) is used as system clock source.
     30            *    Then SystemInit() function is called, in "startup_stm32f2xx.s" file, to
     31            *    configure the system clock before to branch to main program.
     32            *
     33            * 3. If the system clock source selected by user fails to startup, the SystemInit()
     34            *    function will do nothing and HSI still used as system clock source. User can 
     35            *    add some code to deal with this issue inside the SetSysClock() function.
     36            *
     37            * 4. The default value of HSE crystal is set to 25MHz, refer to "HSE_VALUE" define
     38            *    in "stm32f2xx.h" file. When HSE is used as system clock source, directly or
     39            *    through PLL, and you are using different crystal you have to adapt the HSE
     40            *    value to your own configuration.
     41            *
     42            * 5. This file configures the system clock as follows:
     43            *=============================================================================
     44            *=============================================================================
     45            *        Supported STM32F2xx device revision    | Rev B and Y
     46            *-----------------------------------------------------------------------------
     47            *        System Clock source                    | PLL (HSE)
     48            *-----------------------------------------------------------------------------
     49            *        SYSCLK(Hz)                             | 120000000
     50            *-----------------------------------------------------------------------------
     51            *        HCLK(Hz)                               | 120000000
     52            *-----------------------------------------------------------------------------
     53            *        AHB Prescaler                          | 1
     54            *-----------------------------------------------------------------------------
     55            *        APB1 Prescaler                         | 4
     56            *-----------------------------------------------------------------------------
     57            *        APB2 Prescaler                         | 2
     58            *-----------------------------------------------------------------------------
     59            *        HSE Frequency(Hz)                      | 25000000
     60            *-----------------------------------------------------------------------------
     61            *        PLL_M                                  | 25
     62            *-----------------------------------------------------------------------------
     63            *        PLL_N                                  | 240
     64            *-----------------------------------------------------------------------------
     65            *        PLL_P                                  | 2
     66            *-----------------------------------------------------------------------------
     67            *        PLL_Q                                  | 5
     68            *-----------------------------------------------------------------------------
     69            *        PLLI2S_N                               | NA
     70            *-----------------------------------------------------------------------------
     71            *        PLLI2S_R                               | NA
     72            *-----------------------------------------------------------------------------
     73            *        I2S input clock                        | NA
     74            *-----------------------------------------------------------------------------
     75            *        VDD(V)                                 | 3.3
     76            *-----------------------------------------------------------------------------
     77            *        Flash Latency(WS)                      | 3
     78            *-----------------------------------------------------------------------------
     79            *        Prefetch Buffer                        | ON
     80            *-----------------------------------------------------------------------------
     81            *        Instruction cache                      | ON
     82            *-----------------------------------------------------------------------------
     83            *        Data cache                             | ON
     84            *-----------------------------------------------------------------------------
     85            *        Require 48MHz for USB OTG FS,          | Enabled
     86            *        SDIO and RNG clock                     |
     87            *-----------------------------------------------------------------------------
     88            *=============================================================================
     89            ****************************************************************************** 
     90            * @attention
     91            *
     92            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     93            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     94            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     95            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     96            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     97            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     98            *
     99            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
    100            ******************************************************************************  
    101            */
    102          
    103          /** @addtogroup CMSIS
    104            * @{
    105            */
    106          
    107          /** @addtogroup stm32f2xx_system
    108            * @{
    109            */  
    110            
    111          /** @addtogroup STM32F2xx_System_Private_Includes
    112            * @{
    113            */
    114          #include "stm32f2xx_1212.h"
    115          /**
    116            * @}
    117            */
    118          
    119          /** @addtogroup STM32F2xx_System_Private_TypesDefinitions
    120            * @{
    121            */
    122          
    123          /**
    124            * @}
    125            */
    126          
    127          /** @addtogroup STM32F2xx_System_Private_Defines
    128            * @{
    129            */
    130          
    131          /*!< Uncomment the following line if you need to use external SRAM mounted
    132               on STM322xG_EVAL board as data memory  */
    133          /* #define DATA_IN_ExtSRAM */
    134          
    135          /**
    136            * @}
    137            */
    138          
    139          /** @addtogroup STM32F2xx_System_Private_Macros
    140            * @{
    141            */
    142          
    143          /**
    144            * @}
    145            */
    146          
    147          /** @addtogroup STM32F2xx_System_Private_Variables
    148            * @{
    149            */
    150          

   \                                 In section .data, align 4
    151            uint32_t SystemCoreClock = 120000000;
    152          
    153            __I uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
   \                     AHBPrescTable:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x01 0x02    
   \              0x03 0x04    
   \              0x06 0x07    
   \              0x08 0x09    
   \                     SystemCoreClock:
   \   00000010   0x07270E00         DC32 120000000
    154          
    155          /**
    156            * @}
    157            */
    158          
    159          
    160          
    161          /** @addtogroup STM32F2xx_System_Private_Functions
    162            * @{
    163            */
    164          
    165          /**
    166            * @brief  Setup the microcontroller system
    167            *         Initialize the Embedded Flash Interface, the PLL and update the 
    168            *         SystemFrequency variable.
    169            * @param  None
    170            * @retval None
    171            */
    172          

   \                                 In section .text, align 2, keep-with-next
    173          void SystemInit(void)
    174          {
   \                     SystemInit:
   \   00000000   0xB580             PUSH     {R7,LR}
    175          	/* Reset the RCC clock configuration to the default reset state ------------*/
    176          	/* Set HSION bit */
    177          	/* Reset HSEON, CSSON and PLLON bits */
    178          	RCC->CR &= (uint32_t)0xFEF6FFFF;
   \   00000002   0x....             LDR.N    R0,??DataTable2  ;; 0x40023800
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x....             LDR.N    R2,??DataTable2_1  ;; 0xfef6ffff
   \   00000008   0x4011             ANDS     R1,R2,R1
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    179          
    180          	/* Reset PLLCFGR register */
    181          	RCC->PLLCFGR = 0x24003010;
   \   0000000C   0x....             LDR.N    R1,??DataTable2_2  ;; 0x24003010
   \   0000000E   0x6041             STR      R1,[R0, #+4]
    182          
    183          	/* Reset HSEBYP bit */
    184          	RCC->CR &= (uint32_t)0xFFFBFFFF;
   \   00000010   0x6801             LDR      R1,[R0, #+0]
   \   00000012   0xF421 0x2180      BIC      R1,R1,#0x40000
   \   00000016   0x6001             STR      R1,[R0, #+0]
    185          
    186          	/* Disable all interrupts */
    187          	RCC->CIR = 0x00000000;
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x60C1             STR      R1,[R0, #+12]
    188          
    189          #ifdef DATA_IN_ExtSRAM
    190            	SystemInit_ExtMemCtl(); 
    191          #endif /* DATA_IN_ExtSRAM */
    192          	/* Configure the System clock source, PLL Multiplier and Divider factors, 
    193              	AHB/APBx prescalers and Flash settings ----------------------------------*/
    194          #ifdef OS_INCLUDED
    195          	SetSysClock(TRUE);//SetSysClock(TRUE);
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0x.... 0x....      BL       SetSysClock
    196          #else
    197          	SetSysClock(FALSE);
    198          #endif /* OS_INCLUDED */
    199            	/* Configure the Vector Table location add offset address ------------------*/
    200          #ifdef VECT_TAB_SRAM
    201          	SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; 	/* Vector Table Relocation in Internal SRAM */
    202          #else
    203          	#ifndef OS_INCLUDED
    204          		SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; 	/* Vector Table Relocation in Internal FLASH */
    205          	#else
    206          		__iar_program_start();
   \   00000022   0xE8BD 0x4001      POP      {R0,LR}
   \   00000026   0x.... 0x....      B.W      __iar_program_start
    207          	#endif /* OS_INCLUDED */
    208          #endif /* VECT_TAB_SRAM */
    209          
    210          }
    211          
    212          /**
    213            * @brief  Update SystemCoreClock variable according to Clock Register Values.
    214            *         The SystemCoreClock variable contains the core clock (HCLK), it can
    215            *         be used by the user application to setup the SysTick timer or configure
    216            *         other parameters.
    217            *           
    218            * @note   Each time the core clock (HCLK) changes, this function must be called
    219            *         to update SystemCoreClock variable value. Otherwise, any configuration
    220            *         based on this variable will be incorrect.         
    221            *     
    222            * @note   - The system frequency computed by this function is not the real 
    223            *           frequency in the chip. It is calculated based on the predefined 
    224            *           constant and the selected clock source:
    225            *             
    226            *           - If SYSCLK source is HSI, SystemCoreClock will contain the HSI_VALUE(*)
    227            *                                              
    228            *           - If SYSCLK source is HSE, SystemCoreClock will contain the HSE_VALUE(**)
    229            *                          
    230            *           - If SYSCLK source is PLL, SystemCoreClock will contain the HSE_VALUE(**) 
    231            *             or HSI_VALUE(*) multiplied/divided by the PLL factors.
    232            *         
    233            *         (*) HSI_VALUE is a constant defined in stm32f2xx.h file (default value
    234            *             16 MHz) but the real value may vary depending on the variations
    235            *             in voltage and temperature.   
    236            *    
    237            *         (**) HSE_VALUE is a constant defined in stm32f2xx.h file (default value
    238            *              25 MHz), user has to ensure that HSE_VALUE is same as the real
    239            *              frequency of the crystal used. Otherwise, this function may
    240            *              have wrong result.
    241            *                
    242            *         - The result of this function could be not correct when using fractional
    243            *           value for HSE crystal.
    244            *     
    245            * @param  None
    246            * @retval None
    247            */

   \                                 In section .text, align 2, keep-with-next
    248          void SystemCoreClockUpdate(void)
    249          {
    250          	uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
    251            
    252          	/* Get SYSCLK source -------------------------------------------------------*/
    253          	tmp = RCC->CFGR & RCC_CFGR_SWS;
   \                     SystemCoreClockUpdate:
   \   00000000   0x....             LDR.N    R0,??DataTable2_3  ;; 0x40023804
   \   00000002   0x6841             LDR      R1,[R0, #+4]
    254          
    255          	switch (tmp)
   \   00000004   0xF001 0x010C      AND      R1,R1,#0xC
   \   00000008   0x2904             CMP      R1,#+4
   \   0000000A   0xD002             BEQ.N    ??SystemCoreClockUpdate_0
   \   0000000C   0x2908             CMP      R1,#+8
   \   0000000E   0xD002             BEQ.N    ??SystemCoreClockUpdate_1
   \   00000010   0xE017             B.N      ??SystemCoreClockUpdate_2
    256          	{
    257          		case 0x00:  /* HSI used as system clock source */
    258          		  SystemCoreClock = HSI_VALUE;
    259          		  break;
    260          		case 0x04:  /* HSE used as system clock source */
    261          		  SystemCoreClock = HSE_VALUE;
   \                     ??SystemCoreClockUpdate_0:
   \   00000012   0x....             LDR.N    R1,??DataTable2_4  ;; 0x17d7840
    262          		  break;
   \   00000014   0xE016             B.N      ??SystemCoreClockUpdate_3
    263          		case 0x08:  /* PLL used as system clock source */
    264          
    265          		  /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
    266          		     SYSCLK = PLL_VCO / PLL_P
    267          		     */    
    268          		  pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
   \                     ??SystemCoreClockUpdate_1:
   \   00000016   0x6801             LDR      R1,[R0, #+0]
    269          		  pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
   \   00000018   0x6802             LDR      R2,[R0, #+0]
   \   0000001A   0xF002 0x023F      AND      R2,R2,#0x3F
    270          		  
    271          		  if (pllsource != 0)
   \   0000001E   0x0249             LSLS     R1,R1,#+9
   \   00000020   0xBF4C             ITE      MI 
   \   00000022   0x....             LDRMI.N  R1,??DataTable2_4  ;; 0x17d7840
   \   00000024   0x....             LDRPL.N  R1,??DataTable2_5  ;; 0xf42400
    272          		  {
    273          		    /* HSE used as PLL clock source */
    274          		    pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
    275          		  }
    276          		  else
    277          		  {
    278          		    /* HSI used as PLL clock source */
    279          		    pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
   \   00000026   0xFBB1 0xF1F2      UDIV     R1,R1,R2
   \   0000002A   0x6802             LDR      R2,[R0, #+0]
   \   0000002C   0xF3C2 0x1288      UBFX     R2,R2,#+6,#+9
   \   00000030   0x4351             MULS     R1,R2,R1
    280          		  }
    281          
    282          		  pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
   \   00000032   0x6802             LDR      R2,[R0, #+0]
    283          		  SystemCoreClock = pllvco/pllp;
   \   00000034   0xF3C2 0x4201      UBFX     R2,R2,#+16,#+2
   \   00000038   0x1C52             ADDS     R2,R2,#+1
   \   0000003A   0x0052             LSLS     R2,R2,#+1
   \   0000003C   0xFBB1 0xF1F2      UDIV     R1,R1,R2
    284          		  break;
   \   00000040   0xE000             B.N      ??SystemCoreClockUpdate_3
    285          		default:
    286          		  SystemCoreClock = HSI_VALUE;
   \                     ??SystemCoreClockUpdate_2:
   \   00000042   0x....             LDR.N    R1,??DataTable2_5  ;; 0xf42400
    287          		  break;
   \                     ??SystemCoreClockUpdate_3:
   \   00000044   0x....             LDR.N    R2,??DataTable2_6
   \   00000046   0x6111             STR      R1,[R2, #+16]
    288          	}
    289          	/* Compute HCLK frequency --------------------------------------------------*/
    290          	/* Get HCLK prescaler */
    291          	tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
    292          	/* HCLK frequency */
    293          	SystemCoreClock >>= tmp;
   \   00000048   0x6840             LDR      R0,[R0, #+4]
   \   0000004A   0xF3C0 0x1003      UBFX     R0,R0,#+4,#+4
   \   0000004E   0x5C80             LDRB     R0,[R0, R2]
   \   00000050   0xFA21 0xF000      LSR      R0,R1,R0
   \   00000054   0x6110             STR      R0,[R2, #+16]
    294          }
   \   00000056   0x4770             BX       LR               ;; return
    295          
    296          /**
    297            * @brief  Configures the System clock source, PLL Multiplier and Divider factors, 
    298            *         AHB/APBx prescalers and Flash settings
    299            * @Note   This function should be called only once the RCC clock configuration  
    300            *         is reset to the default reset state (done in SystemInit() function).   
    301            * @param  None
    302            * @retval None
    303            */

   \                                 In section .text, align 2, keep-with-next
    304          u8 SetSysClock(u8 IsItHSE)
    305          {
   \                     SetSysClock:
   \   00000000   0xB083             SUB      SP,SP,#+12
    306          /******************************************************************************/
    307          /*            PLL (clocked by HSE) used as System clock source                */
    308          /******************************************************************************/
    309          	__IO uint32_t StartUpCounter = 0, HSEStatus = 0x01;
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x9101             STR      R1,[SP, #+4]
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x9102             STR      R1,[SP, #+8]
    310          
    311          	vu32 PLLM = 0;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x9100             STR      R1,[SP, #+0]
    312          	
    313            	/* Enable HSE */
    314          	if(IsItHSE)
   \   0000000E   0xB1C0             CBZ.N    R0,??SetSysClock_0
    315          	{
    316          		RCC->CR |= ((uint32_t)RCC_CR_HSEON);
   \   00000010   0x....             LDR.N    R1,??DataTable2  ;; 0x40023800
   \   00000012   0x6808             LDR      R0,[R1, #+0]
   \   00000014   0xF440 0x3080      ORR      R0,R0,#0x10000
   \   00000018   0x6008             STR      R0,[R1, #+0]
    317          
    318          		/* Wait till HSE is ready and if Time out is reached exit */
    319          		do
    320          		{
    321          			HSEStatus = RCC->CR & RCC_CR_HSERDY;
   \                     ??SetSysClock_1:
   \   0000001A   0x6808             LDR      R0,[R1, #+0]
   \   0000001C   0xF400 0x3000      AND      R0,R0,#0x20000
   \   00000020   0x9002             STR      R0,[SP, #+8]
    322          			StartUpCounter++;
   \   00000022   0x9801             LDR      R0,[SP, #+4]
   \   00000024   0x1C40             ADDS     R0,R0,#+1
   \   00000026   0x9001             STR      R0,[SP, #+4]
    323          		} while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
   \   00000028   0x9802             LDR      R0,[SP, #+8]
   \   0000002A   0xB918             CBNZ.N   R0,??SetSysClock_2
   \   0000002C   0x9801             LDR      R0,[SP, #+4]
   \   0000002E   0xF5B0 0x6FA0      CMP      R0,#+1280
   \   00000032   0xD1F2             BNE.N    ??SetSysClock_1
    324          
    325          		if ((RCC->CR & RCC_CR_HSERDY) != RESET)	IsItHSE = SET;
   \                     ??SetSysClock_2:
   \   00000034   0x6808             LDR      R0,[R1, #+0]
    326          		else									IsItHSE = RESET;
   \   00000036   0x0C40             LSRS     R0,R0,#+17
   \   00000038   0xF010 0x0001      ANDS     R0,R0,#0x1
    327          	}
    328          	else{
    329          
    330          	}
    331          
    332          	if(IsItHSE)
   \   0000003C   0xBF18             IT       NE 
   \   0000003E   0x2119             MOVNE    R1,#+25
    333          	{
    334          		PLLM = HSE_VALUE/1000000;
   \   00000040   0xD100             BNE.N    ??SetSysClock_3
    335          
    336          	}
    337          	else
    338          	{
    339          		PLLM = HSI_VALUE/1000000;
   \                     ??SetSysClock_0:
   \   00000042   0x2110             MOVS     R1,#+16
   \                     ??SetSysClock_3:
   \   00000044   0x9100             STR      R1,[SP, #+0]
    340          	}
    341          
    342          	{
    343          	    /* HCLK = SYSCLK / 1*/
    344          	    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
   \   00000046   0x....             LDR.N    R1,??DataTable2  ;; 0x40023800
   \   00000048   0x688A             LDR      R2,[R1, #+8]
   \   0000004A   0x608A             STR      R2,[R1, #+8]
    345          	      
    346          	    /* PCLK2 = HCLK / 2*/
    347          	    RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
   \   0000004C   0x688A             LDR      R2,[R1, #+8]
   \   0000004E   0xF442 0x4200      ORR      R2,R2,#0x8000
   \   00000052   0x608A             STR      R2,[R1, #+8]
    348          	    
    349          	    /* PCLK1 = HCLK / 4*/
    350          	    RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
   \   00000054   0x688A             LDR      R2,[R1, #+8]
   \   00000056   0xF442 0x52A0      ORR      R2,R2,#0x1400
   \   0000005A   0x608A             STR      R2,[R1, #+8]
    351          
    352          	    /* Configure the main PLL */
    353          	    RCC->__B.PLLCFGR.PLLP = (PLL_P >> 1)-1;
   \   0000005C   0x684A             LDR      R2,[R1, #+4]
   \   0000005E   0xF422 0x32C0      BIC      R2,R2,#0x18000
   \   00000062   0x604A             STR      R2,[R1, #+4]
    354          	    RCC->__B.PLLCFGR.PLLM = PLLM;
   \   00000064   0x9A00             LDR      R2,[SP, #+0]
   \   00000066   0x684B             LDR      R3,[R1, #+4]
   \   00000068   0xF362 0x0305      BFI      R3,R2,#+0,#+6
   \   0000006C   0x604B             STR      R3,[R1, #+4]
    355          	    RCC->__B.PLLCFGR.PLLN = PLL_N;
   \   0000006E   0x684A             LDR      R2,[R1, #+4]
   \   00000070   0xF422 0x527F      BIC      R2,R2,#0x3FC0
   \   00000074   0xF442 0x5270      ORR      R2,R2,#0x3C00
   \   00000078   0x604A             STR      R2,[R1, #+4]
    356          	    RCC->__B.PLLCFGR.PLLQ = PLL_Q;
   \   0000007A   0x684A             LDR      R2,[R1, #+4]
   \   0000007C   0xF022 0x62F0      BIC      R2,R2,#0x7800000
   \   00000080   0xF042 0x7220      ORR      R2,R2,#0x2800000
   \   00000084   0x604A             STR      R2,[R1, #+4]
    357          	    RCC->__B.PLLCFGR.PLLSRC = IsItHSE;
   \   00000086   0x684A             LDR      R2,[R1, #+4]
   \   00000088   0xF360 0x5255      BFI      R2,R0,#+21,#+1
   \   0000008C   0x604A             STR      R2,[R1, #+4]
    358          
    359          	    /* Enable the main PLL */
    360          	    RCC->CR |= RCC_CR_PLLON;
   \   0000008E   0x680A             LDR      R2,[R1, #+0]
   \   00000090   0xF042 0x7280      ORR      R2,R2,#0x1000000
   \   00000094   0x600A             STR      R2,[R1, #+0]
    361          
    362          	    /* Wait till the main PLL is ready */
    363          	    while((RCC->CR & RCC_CR_PLLRDY) == 0)
   \                     ??SetSysClock_4:
   \   00000096   0x680A             LDR      R2,[R1, #+0]
   \   00000098   0x0192             LSLS     R2,R2,#+6
   \   0000009A   0xD5FC             BPL.N    ??SetSysClock_4
    364          	    {
    365          	    }
    366          	   
    367          	    /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
    368          	    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN | FLASH_ACR_DCEN | FLASH_ACR_LATENCY_3WS;
   \   0000009C   0x....             LDR.N    R2,??DataTable2_7  ;; 0x40023c00
   \   0000009E   0xF240 0x7303      MOVW     R3,#+1795
   \   000000A2   0x6013             STR      R3,[R2, #+0]
    369          
    370          	    /* Select the main PLL as system clock source */
    371          	    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
   \   000000A4   0x688A             LDR      R2,[R1, #+8]
   \   000000A6   0x0892             LSRS     R2,R2,#+2
   \   000000A8   0x0092             LSLS     R2,R2,#+2
   \   000000AA   0x608A             STR      R2,[R1, #+8]
    372          	    RCC->CFGR |= RCC_CFGR_SW_PLL;
   \   000000AC   0x688A             LDR      R2,[R1, #+8]
   \   000000AE   0xF042 0x0202      ORR      R2,R2,#0x2
   \   000000B2   0x608A             STR      R2,[R1, #+8]
    373          
    374          	    /* Wait till the main PLL is used as system clock source */
    375          	    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
   \                     ??SetSysClock_5:
   \   000000B4   0x688A             LDR      R2,[R1, #+8]
   \   000000B6   0xF002 0x020C      AND      R2,R2,#0xC
   \   000000BA   0x2A08             CMP      R2,#+8
   \   000000BC   0xD1FA             BNE.N    ??SetSysClock_5
    376          	    {
    377          
    378          	    }
    379          	}
    380          	/* LSI ON to use watchdog */
    381          	RCC->__B.CSR.LSION = ENABLE;
   \   000000BE   0x6F4A             LDR      R2,[R1, #+116]
   \   000000C0   0xF042 0x0201      ORR      R2,R2,#0x1
   \   000000C4   0x674A             STR      R2,[R1, #+116]
    382          	/* Wait till LSI is ready */
    383          	while(!RCC->__B.CSR.LSIRDY){};
   \                     ??SetSysClock_6:
   \   000000C6   0x6F4A             LDR      R2,[R1, #+116]
   \   000000C8   0x0792             LSLS     R2,R2,#+30
   \   000000CA   0xD5FC             BPL.N    ??SetSysClock_6
    384          
    385              return IsItHSE;
   \   000000CC   0xB003             ADD      SP,SP,#+12
   \   000000CE   0x4770             BX       LR               ;; return
    386          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x40023800         DC32     0x40023800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0xFEF6FFFF         DC32     0xfef6ffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x24003010         DC32     0x24003010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x40023804         DC32     0x40023804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x017D7840         DC32     0x17d7840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x00F42400         DC32     0xf42400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x........         DC32     AHBPrescTable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x40023C00         DC32     0x40023c00
    387          
    388          /**
    389            * @brief  Setup the external memory controller. Called in startup_stm32f2xx.s
    390            *         before jump to __main
    391            * @param  None
    392            * @retval None
    393            */
    394          #ifdef DATA_IN_ExtSRAM
    395          /**
    396            * @brief  Setup the external memory controller.
    397            *         Called in startup_stm32f2xx.s before jump to main.
    398            *         This function configures the external SRAM mounted on STM322xG_EVAL board
    399            *         This SRAM will be used as program data memory (including heap and stack).
    400            * @param  None
    401            * @retval None
    402            */
    403          void SystemInit_ExtMemCtl(void)
    404          {
    405          /*-- GPIOs Configuration -----------------------------------------------------*/
    406          /*
    407           +-------------------+--------------------+------------------+------------------+
    408           +                       SRAM pins assignment                                  +
    409           +-------------------+--------------------+------------------+------------------+
    410           | PD0  <-> FSMC_D2  | PE0  <-> FSMC_NBL0 | PF0  <-> FSMC_A0 | PG0 <-> FSMC_A10 |
    411           | PD1  <-> FSMC_D3  | PE1  <-> FSMC_NBL1 | PF1  <-> FSMC_A1 | PG1 <-> FSMC_A11 |
    412           | PD4  <-> FSMC_NOE | PE7  <-> FSMC_D4   | PF2  <-> FSMC_A2 | PG2 <-> FSMC_A12 |
    413           | PD5  <-> FSMC_NWE | PE8  <-> FSMC_D5   | PF3  <-> FSMC_A3 | PG3 <-> FSMC_A13 |
    414           | PD8  <-> FSMC_D13 | PE9  <-> FSMC_D6   | PF4  <-> FSMC_A4 | PG4 <-> FSMC_A14 |
    415           | PD9  <-> FSMC_D14 | PE10 <-> FSMC_D7   | PF5  <-> FSMC_A5 | PG5 <-> FSMC_A15 |
    416           | PD10 <-> FSMC_D15 | PE11 <-> FSMC_D8   | PF12 <-> FSMC_A6 | PG9 <-> FSMC_NE2 |
    417           | PD11 <-> FSMC_A16 | PE12 <-> FSMC_D9   | PF13 <-> FSMC_A7 |------------------+
    418           | PD12 <-> FSMC_A17 | PE13 <-> FSMC_D10  | PF14 <-> FSMC_A8 | 
    419           | PD14 <-> FSMC_D0  | PE14 <-> FSMC_D11  | PF15 <-> FSMC_A9 | 
    420           | PD15 <-> FSMC_D1  | PE15 <-> FSMC_D12  |------------------+
    421           +-------------------+--------------------+
    422          */
    423             /* Enable GPIOD, GPIOE, GPIOF and GPIOG interface clock */
    424            RCC->AHB1ENR   = 0x00000078;
    425            
    426            /* Connect PDx pins to FSMC Alternate function */
    427            GPIOD->AFR[0]  = 0x00cc00cc;
    428            GPIOD->AFR[1]  = 0xcc0ccccc;
    429            /* Configure PDx pins in Alternate function mode */  
    430            GPIOD->MODER   = 0xa2aa0a0a;
    431            /* Configure PDx pins speed to 100 MHz */  
    432            GPIOD->OSPEEDR = 0xf3ff0f0f;
    433            /* Configure PDx pins Output type to push-pull */  
    434            GPIOD->OTYPER  = 0x00000000;
    435            /* No pull-up, pull-down for PDx pins */ 
    436            GPIOD->PUPDR   = 0x00000000;
    437          
    438            /* Connect PEx pins to FSMC Alternate function */
    439            GPIOE->AFR[0]  = 0xc00000cc;
    440            GPIOE->AFR[1]  = 0xcccccccc;
    441            /* Configure PEx pins in Alternate function mode */ 
    442            GPIOE->MODER   = 0xaaaa800a;
    443            /* Configure PEx pins speed to 100 MHz */ 
    444            GPIOE->OSPEEDR = 0xffffc00f;
    445            /* Configure PEx pins Output type to push-pull */  
    446            GPIOE->OTYPER  = 0x00000000;
    447            /* No pull-up, pull-down for PEx pins */ 
    448            GPIOE->PUPDR   = 0x00000000;
    449          
    450            /* Connect PFx pins to FSMC Alternate function */
    451            GPIOF->AFR[0]  = 0x00cccccc;
    452            GPIOF->AFR[1]  = 0xcccc0000;
    453            /* Configure PFx pins in Alternate function mode */   
    454            GPIOF->MODER   = 0xaa000aaa;
    455            /* Configure PFx pins speed to 100 MHz */ 
    456            GPIOF->OSPEEDR = 0xff000fff;
    457            /* Configure PFx pins Output type to push-pull */  
    458            GPIOF->OTYPER  = 0x00000000;
    459            /* No pull-up, pull-down for PFx pins */ 
    460            GPIOF->PUPDR   = 0x00000000;
    461          
    462            /* Connect PGx pins to FSMC Alternate function */
    463            GPIOG->AFR[0]  = 0x00cccccc;
    464            GPIOG->AFR[1]  = 0x000000c0;
    465            /* Configure PGx pins in Alternate function mode */ 
    466            GPIOG->MODER   = 0x00080aaa;
    467            /* Configure PGx pins speed to 100 MHz */ 
    468            GPIOG->OSPEEDR = 0x000c0fff;
    469            /* Configure PGx pins Output type to push-pull */  
    470            GPIOG->OTYPER  = 0x00000000;
    471            /* No pull-up, pull-down for PGx pins */ 
    472            GPIOG->PUPDR   = 0x00000000;
    473            
    474          /*-- FSMC Configuration ------------------------------------------------------*/
    475            /* Enable the FSMC interface clock */
    476            RCC->AHB3ENR         = 0x00000001;
    477          
    478            /* Configure and enable Bank1_SRAM2 */
    479            FSMC_Bank1->BTCR[2]  = 0x00001015;
    480            FSMC_Bank1->BTCR[3]  = 0x00010400;
    481            FSMC_Bank1E->BWTR[2] = 0x0fffffff;
    482          /*
    483            Bank1_SRAM2 is configured as follow:
    484          
    485            p.FSMC_AddressSetupTime = 0;
    486            p.FSMC_AddressHoldTime = 0;
    487            p.FSMC_DataSetupTime = 4;
    488            p.FSMC_BusTurnAroundDuration = 1;
    489            p.FSMC_CLKDivision = 0;
    490            p.FSMC_DataLatency = 0;
    491            p.FSMC_AccessMode = FSMC_AccessMode_A;
    492          
    493            FSMC_NORSRAMInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM2;
    494            FSMC_NORSRAMInitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable;
    495            FSMC_NORSRAMInitStructure.FSMC_MemoryType = FSMC_MemoryType_PSRAM;
    496            FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;
    497            FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
    498            FSMC_NORSRAMInitStructure.FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;  
    499            FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
    500            FSMC_NORSRAMInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable;
    501            FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
    502            FSMC_NORSRAMInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable;
    503            FSMC_NORSRAMInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable;
    504            FSMC_NORSRAMInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
    505            FSMC_NORSRAMInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable;
    506            FSMC_NORSRAMInitStructure.FSMC_ReadWriteTimingStruct = &p;
    507            FSMC_NORSRAMInitStructure.FSMC_WriteTimingStruct = &p;
    508          */
    509            
    510          }
    511          #endif /* DATA_IN_ExtSRAM */
    512          
    513          
    514          /**
    515            * @}
    516            */
    517          
    518          /**
    519            * @}
    520            */
    521            
    522          /**
    523            * @}
    524            */
    525          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       12  SetSysClock
        0  SystemCoreClockUpdate
        8  SystemInit
             8 -> SetSysClock
             0 -> __iar_program_start


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
      20  AHBPrescTable
          SystemCoreClock
     208  SetSysClock
      88  SystemCoreClockUpdate
      42  SystemInit

 
  20 bytes in section .data
 370 bytes in section .text
 
 370 bytes of CODE memory
  20 bytes of DATA memory

Errors: none
Warnings: none

###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     07/Jan/2014  16:08:57 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Project\TRIO\2차버전\3.F_W\appl_stm207_20131104 -     #
#                    복사본\STM32F2xx_StdPeriph_Driver_v1212\src\stm32f2xx_us #
#                    art4_1208.c                                              #
#    Command line =  "C:\Project\TRIO\2차버전\3.F_W\appl_stm207_20131104 -    #
#                    복사본\STM32F2xx_StdPeriph_Driver_v1212\src\stm32f2xx_us #
#                    art4_1208.c" -D NDEBUG -lC "C:\Project\TRIO\2차버전\3.F_ #
#                    W\appl_stm207_20131104 - 복사본\STM32F2xx_StdPeriph_Driv #
#                    er_v1212\ewarm\sout\" -o "C:\Project\TRIO\2차버전\3.F_W\ #
#                    appl_stm207_20131104 - 복사본\STM32F2xx_StdPeriph_Driver #
#                    _v1212\ewarm\sout\" --endian=little --cpu=Cortex-M3 -e   #
#                    --fpu=None --dlib_config "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.0_2\arm\INC\c\DLib_Config_N #
#                    ormal.h" -I "C:\Project\TRIO\2차버전\3.F_W\appl_stm207_2 #
#                    0131104 - 복사본\STM32F2xx_StdPeriph_Driver_v1212\ewarm\ #
#                    ..\" -I "C:\Project\TRIO\2차버전\3.F_W\appl_stm207_20131 #
#                    104 - 복사본\STM32F2xx_StdPeriph_Driver_v1212\ewarm\..\i #
#                    nc\" -I "C:\Project\TRIO\2차버전\3.F_W\appl_stm207_20131 #
#                    104 - 복사본\STM32F2xx_StdPeriph_Driver_v1212\ewarm\..\. #
#                    .\uC-CPU\" -I "C:\Project\TRIO\2차버전\3.F_W\appl_stm207 #
#                    _20131104 - 복사본\STM32F2xx_StdPeriph_Driver_v1212\ewar #
#                    m\..\..\uC-LIB\" -I "C:\Project\TRIO\2차버전\3.F_W\appl_ #
#                    stm207_20131104 - 복사본\STM32F2xx_StdPeriph_Driver_v121 #
#                    2\ewarm\..\..\uCOS-II\Ports\" -I                         #
#                    "C:\Project\TRIO\2차버전\3.F_W\appl_stm207_20131104 -    #
#                    복사본\STM32F2xx_StdPeriph_Driver_v1212\ewarm\..\..\uCOS #
#                    -II\Source\" -Oh                                         #
#    List file    =  C:\Project\TRIO\2차버전\3.F_W\appl_stm207_20131104 -     #
#                    복사본\STM32F2xx_StdPeriph_Driver_v1212\ewarm\sout\stm32 #
#                    f2xx_usart4_1208.lst                                     #
#    Object file  =  C:\Project\TRIO\2차버전\3.F_W\appl_stm207_20131104 -     #
#                    복사본\STM32F2xx_StdPeriph_Driver_v1212\ewarm\sout\stm32 #
#                    f2xx_usart4_1208.o                                       #
#                                                                             #
#                                                                             #
###############################################################################

C:\Project\TRIO\2차버전\3.F_W\appl_stm207_20131104 - 복사본\STM32F2xx_StdPeriph_Driver_v1212\src\stm32f2xx_usart4_1208.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_usart.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    18-April-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Universal synchronous asynchronous receiver
      9            *          transmitter (USART):           
     10            *           - Initialization and Configuration
     11            *           - Data transfers
     12            *           - Multi-Processor Communication
     13            *           - LIN mode
     14            *           - Half-duplex mode
     15            *           - Smartcard mode
     16            *           - IrDA mode
     17            *           - DMA transfers management
     18            *           - Interrupts and flags management 
     19            *           
     20            *  @verbatim
     21            *      
     22            *          ===================================================================
     23            *                                 How to use this driver
     24            *          ===================================================================
     25            *          1. Enable peripheral clock using the follwoing functions
     26            *             RCC_APB2PeriphClockCmd(RCC_APB2Periph_USARTx, ENABLE) for USART1 and USART6 
     27            *             RCC_APB1PeriphClockCmd(RCC_APB1Periph_USARTx, ENABLE) for USART2, USART3, UART4 or UART5.
     28            *
     29            *          2.  According to the USART mode, enable the GPIO clocks using 
     30            *              RCC_AHB1PeriphClockCmd() function. (The I/O can be TX, RX, CTS, 
     31            *              or/and SCLK). 
     32            *
     33            *          3. Peripheral's alternate function: 
     34            *                 - Connect the pin to the desired peripherals' Alternate 
     35            *                   Function (AF) using GPIO_PinAFConfig() function
     36            *                 - Configure the desired pin in alternate function by:
     37            *                   GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     38            *                 - Select the type, pull-up/pull-down and output speed via 
     39            *                   GPIO_PuPd, GPIO_OType and GPIO_Speed members
     40            *                 - Call GPIO_Init() function
     41            *        
     42            *          4. Program the Baud Rate, Word Length , Stop Bit, Parity, Hardware 
     43            *             flow control and Mode(Receiver/Transmitter) using the USART_Init()
     44            *             function.
     45            *
     46            *          5. For synchronous mode, enable the clock and program the polarity,
     47            *             phase and last bit using the USART_ClockInit() function.
     48            *
     49            *          5. Enable the NVIC and the corresponding interrupt using the function 
     50            *             USART_ITConfig() if you need to use interrupt mode. 
     51            *
     52            *          6. When using the DMA mode 
     53            *                   - Configure the DMA using DMA_Init() function
     54            *                   - Active the needed channel Request using USART_DMACmd() function
     55            * 
     56            *          7. Enable the USART using the USART_Cmd() function.
     57            * 
     58            *          8. Enable the DMA using the DMA_Cmd() function, when using DMA mode. 
     59            *
     60            *          Refer to Multi-Processor, LIN, half-duplex, Smartcard, IrDA sub-sections
     61            *          for more details
     62            *          
     63            *          In order to reach higher communication baudrates, it is possible to
     64            *          enable the oversampling by 8 mode using the function USART_OverSampling8Cmd().
     65            *          This function should be called after enabling the USART clock (RCC_APBxPeriphClockCmd())
     66            *          and before calling the function USART_Init().
     67            *          
     68            *  @endverbatim
     69            *        
     70            ******************************************************************************
     71            * @attention
     72            *
     73            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     74            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     75            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     76            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     77            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     78            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     79            *
     80            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     81            ******************************************************************************  
     82            */ 
     83          
     84          /* Includes ------------------------------------------------------------------*/
     85          #include "stm32f2xx_usart4_1208.h"
     86          
     87          /** @addtogroup STM32F2xx_StdPeriph_Driver
     88            * @{
     89            */
     90          
     91          /** @defgroup USART 
     92            * @brief USART driver modules
     93            * @{
     94            */
     95          
     96          /* Private typedef -----------------------------------------------------------*/
     97          /* Private define ------------------------------------------------------------*/
     98          
     99          
    100          /* Private macro -------------------------------------------------------------*/
    101          /* Private variables ---------------------------------------------------------*/
    102          #if !defined (OS_INCLUDED) 
    103          	INT8U Rx4Buff[Rx4BuffLen];
    104          	INT8U Tx4Buff[Tx4BuffLen];
    105          
    106          	INT16U	Rx4RdCnt = 0, Rx4WrCnt = 0;
    107          	INT16U	Tx4RdCnt = 0, Tx4WrCnt = 0;
    108          #else

   \                                 In section iram, align 4
    109          	INT8U Rx4Buff[Rx4BuffLen] @ "iram";
   \                     Rx4Buff:
   \   00000000                      DS8 1024

   \                                 In section iram, align 4
    110          	INT8U Tx4Buff[Tx4BuffLen] @ "iram";
   \                     Tx4Buff:
   \   00000000                      DS8 1024
    111          

   \                                 In section iram, align 4
    112          	INT16U	Rx4RdCnt @ "iram"= 0, Rx4WrCnt @ "iram" = 0;
   \                     Rx4RdCnt:
   \   00000000   0x0000             DC16 0
   \                     Rx4WrCnt:
   \   00000002   0x0000             DC16 0
    113          	INT16U	Tx4RdCnt @ "iram"= 0, Tx4WrCnt @ "iram" = 0;
   \                     Tx4RdCnt:
   \   00000004   0x0000             DC16 0
   \                     Tx4WrCnt:
   \   00000006   0x0000             DC16 0
    114          #endif
    115          
    116          #if !defined (OS_INCLUDED) 
    117          __SerStrPtr pUSART4 = {
    118          
    119          #else
    120          __SerStrPtr pUSART4 @ "iram" = {
   \                     pUSART4:
   \   00000008   0x........         DC32 InitUSART4, USART4CheckByte, USART4RxGetByte, USART4PutStr
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000018   0x........         DC32 USART4Printf, USART4PutChar, USART4PutToBuffer, USART4TxCheckByte
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000028   0x........         DC32 USART4BuffClear, USART4TxClear
   \              0x........   
   \   00000030   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    121          #endif
    122          	InitUSART4,
    123          	USART4CheckByte,
    124          	USART4RxGetByte,
    125          	USART4PutStr,
    126          	USART4Printf,
    127          	USART4PutChar,
    128          	USART4PutToBuffer,
    129          	USART4TxCheckByte,
    130          	USART4BuffClear,
    131          	USART4TxClear
    132          };
    133          /* Private function prototypes -----------------------------------------------*/
    134          /* Private functions ---------------------------------------------------------*/
    135          
    136          /** @defgroup USART_Private_Functions
    137            * @{
    138            */
    139          
    140          /** @defgroup USART_Group1 Initialization and Configuration functions
    141           *  @brief   Initialization and Configuration functions 
    142           *
    143          @verbatim   
    144           ===============================================================================
    145                            Initialization and Configuration functions
    146           ===============================================================================  
    147          
    148            This subsection provides a set of functions allowing to initialize the USART 
    149            in asynchronous and in synchronous modes.
    150             - For the asynchronous mode only these parameters can be configured: 
    151                  - Baud Rate
    152                  - Word Length 
    153                  - Stop Bit
    154                  - Parity: If the parity is enabled, then the MSB bit of the data written
    155                    in the data register is transmitted but is changed by the parity bit.
    156                    Depending on the frame length defined by the M bit (8-bits or 9-bits),
    157                    the possible USART frame formats are as listed in the following table:
    158             +-------------------------------------------------------------+     
    159             |   M bit |  PCE bit  |            USART frame                |
    160             |---------------------|---------------------------------------|             
    161             |    0    |    0      |    | SB | 8 bit data | STB |          |
    162             |---------|-----------|---------------------------------------|  
    163             |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
    164             |---------|-----------|---------------------------------------|  
    165             |    1    |    0      |    | SB | 9 bit data | STB |          |
    166             |---------|-----------|---------------------------------------|  
    167             |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
    168             +-------------------------------------------------------------+            
    169                  - Hardware flow control
    170                  - Receiver/transmitter modes
    171          
    172            The USART_Init() function follows the USART  asynchronous configuration procedure
    173            (details for the procedure are available in reference manual (RM0033)).
    174          
    175            - For the synchronous mode in addition to the asynchronous mode parameters these 
    176              parameters should be also configured:
    177                  - USART Clock Enabled
    178                  - USART polarity
    179                  - USART phase
    180                  - USART LastBit
    181            
    182            These parameters can be configured using the USART_ClockInit() function.
    183          
    184          @endverbatim
    185            * @{
    186            */
    187            
    188          /**
    189            * @brief  Deinitializes the USARTx peripheral registers to their default reset values.
    190            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    191            *         UART peripheral.
    192            * @retval None
    193            */

   \                                 In section .text, align 2, keep-with-next
    194          void InitUSART4(INT32U nBps, INT32U nLCR)
    195          {
   \                     InitUSART4:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460C             MOV      R4,R1
    196          	USART_InitTypeDef USART_InitStructure;
    197          
    198          ///
    199          // PORT INIT
    200          	RCC->__B.AHB1ENR.IOPCEN = ENABLE;
   \   00000008   0x....             LDR.N    R0,??DataTable9_1  ;; 0x40023830
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0xF041 0x0104      ORR      R1,R1,#0x4
   \   00000010   0x6001             STR      R1,[R0, #+0]
    201          	RCC->__B.APB1ENR.UART4EN = ENABLE;
   \   00000012   0x6901             LDR      R1,[R0, #+16]
   \   00000014   0xF441 0x2100      ORR      R1,R1,#0x80000
   \   00000018   0x6101             STR      R1,[R0, #+16]
    202          	
    203          	__PC10_U4_TX(); 			// USART4_TX
   \   0000001A   0x....             LDR.N    R6,??DataTable9_2  ;; 0x40020800
   \   0000001C   0x230A             MOVS     R3,#+10
   \   0000001E   0x4632             MOV      R2,R6
   \   00000020   0x2108             MOVS     R1,#+8
   \   00000022   0x2062             MOVS     R0,#+98
   \   00000024   0x.... 0x....      BL       GPIOPortInit
    204          	__PC11_U4_RX(); 			// USART4_RX
   \   00000028   0x230B             MOVS     R3,#+11
   \   0000002A   0x4632             MOV      R2,R6
   \   0000002C   0x2108             MOVS     R1,#+8
   \   0000002E   0x2062             MOVS     R0,#+98
   \   00000030   0x.... 0x....      BL       GPIOPortInit
    205          
    206          ////////////////////////////////////////////////////////////////////////////////
    207          	USART_InitStructure.USART_BaudRate = nBps;
   \   00000034   0x9500             STR      R5,[SP, #+0]
    208          
    209          	if( ((nLCR >> 4) & 0x01) ==  (_DATA8BIT >> 4)) {
   \   00000036   0x06E0             LSLS     R0,R4,#+27
   \   00000038   0xBF54             ITE      PL 
   \   0000003A   0x2000             MOVPL    R0,#+0
   \   0000003C   0xF44F 0x5080      MOVMI    R0,#+4096
    210          			USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    211          	}
    212          	else	USART_InitStructure.USART_WordLength = USART_WordLength_9b;
   \   00000040   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    213          
    214          ////////////////////////////////////////////////////////////////////////////////
    215          	if( ((nLCR >> 2) & 0x02) ==  (_05STOP >> 2)) {
    216          		USART_InitStructure.USART_StopBits = USART_StopBits_0_5;
    217          	}
    218          	else if( ((nLCR >> 2) & 0x02) ==  (_1_STOP >> 2)) {
   \   00000044   0x08A0             LSRS     R0,R4,#+2
   \   00000046   0x0780             LSLS     R0,R0,#+30
   \   00000048   0xBF54             ITE      PL 
   \   0000004A   0x2000             MOVPL    R0,#+0
   \   0000004C   0xF44F 0x5000      MOVMI    R0,#+8192
    219          			USART_InitStructure.USART_StopBits = USART_StopBits_1;
    220          	}
    221          	else if( ((nLCR >> 2) & 0x02) ==  (_2_STOP >> 2)) {
    222          			USART_InitStructure.USART_StopBits = USART_StopBits_2;
   \   00000050   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    223          	}
    224          	else	USART_InitStructure.USART_StopBits = USART_StopBits_1_5;
    225          	
    226          ////////////////////////////////////////////////////////////////////////////////
    227          	
    228          	if(((nLCR >> 0) & 0x03) == (_NONPARITY >> 0)){
   \   00000054   0xF014 0x0003      ANDS     R0,R4,#0x3
   \   00000058   0xBF08             IT       EQ 
   \   0000005A   0x2000             MOVEQ    R0,#+0
    229          		USART_InitStructure.USART_Parity = USART_Parity_No;
   \   0000005C   0xD005             BEQ.N    ??InitUSART4_0
    230          	}
    231          	else if(((nLCR >> 0) & 0x03) == (_ODDPARITY >> 0)){
   \   0000005E   0x2801             CMP      R0,#+1
   \   00000060   0xBF0C             ITE      EQ 
   \   00000062   0xF44F 0x60C0      MOVEQ    R0,#+1536
   \   00000066   0xF44F 0x6080      MOVNE    R0,#+1024
    232          		USART_InitStructure.USART_Parity = USART_Parity_Odd;
    233          	}
    234          	else{
    235          		USART_InitStructure.USART_Parity = USART_Parity_Even;
   \                     ??InitUSART4_0:
   \   0000006A   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    236          	}
    237          	
    238          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    239          	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \   00000074   0x200C             MOVS     R0,#+12
   \   00000076   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    240          
    241          	/* USART configuration */
    242          	USART_Init(UART4, &USART_InitStructure);
   \   0000007A   0x....             LDR.N    R4,??DataTable9_3  ;; 0x40004c00
   \   0000007C   0xA900             ADD      R1,SP,#+0
   \   0000007E   0x4620             MOV      R0,R4
   \   00000080   0x.... 0x....      BL       USART_Init
    243          
    244          #if defined (OS_INCLUDED) 
    245          	pUSART4.sem = OSSemCreate(1);
   \   00000084   0x2001             MOVS     R0,#+1
   \   00000086   0x.... 0x....      BL       OSSemCreate
   \   0000008A   0x....             LDR.N    R1,??DataTable9_4
   \   0000008C   0x6308             STR      R0,[R1, #+48]
    246          #endif
    247          	/* Enable USART */
    248          	USART_Cmd(UART4, ENABLE);
   \   0000008E   0x2101             MOVS     R1,#+1
   \   00000090   0x4620             MOV      R0,R4
   \   00000092   0x.... 0x....      BL       USART_Cmd
    249          
    250          	USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);
   \   00000096   0x2201             MOVS     R2,#+1
   \   00000098   0xF240 0x5125      MOVW     R1,#+1317
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0x.... 0x....      BL       USART_ITConfig
    251          	NVIC_Init(UART4_IRQn, ENABLE); 
   \   000000A2   0x2101             MOVS     R1,#+1
   \   000000A4   0x2034             MOVS     R0,#+52
   \   000000A6   0x.... 0x....      BL       NVIC_Init
    252          
    253          	USART4Printf("\n");	
   \   000000AA   0x....             ADR.N    R0,??DataTable9  ;; "\n"
   \   000000AC   0x.... 0x....      BL       USART4Printf
    254          }
   \   000000B0   0xB004             ADD      SP,SP,#+16
   \   000000B2   0xBD70             POP      {R4-R6,PC}       ;; return
    255          
    256          /*******************************************************************************
    257            * @brief  Interrupt handler USART4 global interrupt request
    258            * @param  None 
    259            * @retval None
    260            *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    261          void USART4_IRQIntHandler(void)
    262          {
   \                     USART4_IRQIntHandler:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    263          
    264          	INT16U tmp = UART4->SR;
   \   00000002   0x....             LDR.N    R4,??DataTable9_3  ;; 0x40004c00
   \   00000004   0x8825             LDRH     R5,[R4, #+0]
    265          
    266          #ifdef OS_INCLUDED
    267          	INT32U cpu_sr;
    268          	CPU_CRITICAL_ENTER();                                       // Tell uC/OS-II that we are starting an ISR
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
    269          	OSIntNesting++;
   \   0000000A   0x....             LDR.N    R1,??DataTable9_5
   \   0000000C   0x780A             LDRB     R2,[R1, #+0]
   \   0000000E   0x1C52             ADDS     R2,R2,#+1
   \   00000010   0x700A             STRB     R2,[R1, #+0]
    270          	CPU_CRITICAL_EXIT();
   \   00000012   0x.... 0x....      BL       CPU_SR_Restore
    271          #endif /* OS_INCLUDED */
    272          	// Rx Data Received
    273          	if(tmp & ( 1 << __RXNE))
   \   00000016   0x06A8             LSLS     R0,R5,#+26
   \   00000018   0xD50F             BPL.N    ??USART4_IRQIntHandler_0
    274          	{
    275          		Rx4Buff[Rx4WrCnt%Rx4BuffLen] = UART4->DR;		// When the receive register is read, the RDR bit is automatically cleared.
   \   0000001A   0x....             LDR.N    R0,??DataTable9_4
   \   0000001C   0x8841             LDRH     R1,[R0, #+2]
   \   0000001E   0x058A             LSLS     R2,R1,#+22
   \   00000020   0x0D92             LSRS     R2,R2,#+22
   \   00000022   0x....             LDR.N    R3,??DataTable9_6
   \   00000024   0x88A4             LDRH     R4,[R4, #+4]
   \   00000026   0x54D4             STRB     R4,[R2, R3]
    276          		if(++Rx4WrCnt >= Rx4BuffLen) Rx4WrCnt = 0;
   \   00000028   0x1C49             ADDS     R1,R1,#+1
   \   0000002A   0x8041             STRH     R1,[R0, #+2]
   \   0000002C   0xB289             UXTH     R1,R1
   \   0000002E   0xF5B1 0x6F80      CMP      R1,#+1024
   \   00000032   0xD31E             BCC.N    ??USART4_IRQIntHandler_1
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x8041             STRH     R1,[R0, #+2]
   \   00000038   0x....             B.N      ?Subroutine0
    277          	}
    278          	else if(tmp & ( 1 << __TXE))
   \                     ??USART4_IRQIntHandler_0:
   \   0000003A   0x0628             LSLS     R0,R5,#+24
   \   0000003C   0xD518             BPL.N    ??USART4_IRQIntHandler_2
    279          	{
    280          		if(Tx4RdCnt != Tx4WrCnt)
   \   0000003E   0x....             LDR.N    R0,??DataTable9_4
   \   00000040   0x8881             LDRH     R1,[R0, #+4]
   \   00000042   0x88C2             LDRH     R2,[R0, #+6]
   \   00000044   0x4291             CMP      R1,R2
   \   00000046   0xD00E             BEQ.N    ??USART4_IRQIntHandler_3
    281          		{
    282          			UART4->DR = Tx4Buff[Tx4RdCnt%Tx4BuffLen];
   \   00000048   0x0589             LSLS     R1,R1,#+22
   \   0000004A   0x0D89             LSRS     R1,R1,#+22
   \   0000004C   0x....             LDR.N    R2,??DataTable9_7
   \   0000004E   0x5C89             LDRB     R1,[R1, R2]
   \   00000050   0x80A1             STRH     R1,[R4, #+4]
    283          			if(++Tx4RdCnt >= Tx4BuffLen ) Tx4RdCnt = 0;
   \   00000052   0x8881             LDRH     R1,[R0, #+4]
   \   00000054   0x1C49             ADDS     R1,R1,#+1
   \   00000056   0x8081             STRH     R1,[R0, #+4]
   \   00000058   0xB289             UXTH     R1,R1
   \   0000005A   0xF5B1 0x6F80      CMP      R1,#+1024
   \   0000005E   0xD308             BCC.N    ??USART4_IRQIntHandler_1
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x8081             STRH     R1,[R0, #+4]
   \   00000064   0x....             B.N      ?Subroutine0
    284          		}
    285          		else UART4->__B.CR1.TXEIE = DISABLE;
   \                     ??USART4_IRQIntHandler_3:
   \   00000066   0x68E0             LDR      R0,[R4, #+12]
   \   00000068   0xF020 0x0080      BIC      R0,R0,#0x80
   \   0000006C   0x60E0             STR      R0,[R4, #+12]
   \   0000006E   0x....             B.N      ?Subroutine0
    286          	}
    287          	else // error, dummy read
    288          	{
    289          		tmp =  UART4->DR;
   \                     ??USART4_IRQIntHandler_2:
   \   00000070   0x88A0             LDRH     R0,[R4, #+4]
    290          	}
    291          
    292          #ifdef OS_INCLUDED
    293          	OSIntExit();												// Tell uC/OS-II that we are leaving the ISR
   \                     ??USART4_IRQIntHandler_1:
   \   00000072                      REQUIRE ?Subroutine0
   \   00000072                      ;; // Fall through to label ?Subroutine0
    294          #endif /* OS_INCLUDED */
    295          
    296          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000004   0x.... 0x....      B.W      OSIntExit
    297          

   \                                 In section .text, align 2, keep-with-next
    298          unsigned char USART4PutToBuffer(unsigned char Data)
    299          {
   \                     USART4PutToBuffer:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
    300          #ifdef OS_INCLUDED
    301          	INT8U err;
    302          	//////////////////////////////////////////////////
    303          
    304          	OSSemPend(pUSART4.sem, 0, &err);
   \   00000004   0x....             LDR.N    R4,??DataTable9_4
   \   00000006   0xAA00             ADD      R2,SP,#+0
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6B20             LDR      R0,[R4, #+48]
   \   0000000C   0x.... 0x....      BL       OSSemPend
    305          #endif /* OS_INCLUDED */
    306          	//////////////////////////////////////////////////
    307          	Tx4Buff[Tx4WrCnt%Tx4BuffLen] = Data;
   \   00000010   0x88E0             LDRH     R0,[R4, #+6]
   \   00000012   0x0581             LSLS     R1,R0,#+22
   \   00000014   0x0D89             LSRS     R1,R1,#+22
   \   00000016   0x....             LDR.N    R2,??DataTable9_7
   \   00000018   0x548D             STRB     R5,[R1, R2]
    308          	if(++Tx4WrCnt >= Tx4BuffLen) Tx4WrCnt = 0;
   \   0000001A   0x1C40             ADDS     R0,R0,#+1
   \   0000001C   0xB280             UXTH     R0,R0
   \   0000001E   0xF5B0 0x6F80      CMP      R0,#+1024
   \   00000022   0xBF28             IT       CS 
   \   00000024   0x2000             MOVCS    R0,#+0
   \   00000026   0x80E0             STRH     R0,[R4, #+6]
    309          	
    310          	UART4->__B.CR1.TXEIE = ENABLE; 		
   \   00000028   0x....             LDR.N    R0,??DataTable9_8  ;; 0x40004c0c
   \   0000002A   0x6801             LDR      R1,[R0, #+0]
   \   0000002C   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000030   0x6001             STR      R1,[R0, #+0]
    311          	///////////////////////////////////////////////////
    312          #ifdef OS_INCLUDED
    313          	OSSemPost(pUSART4.sem);
   \   00000032   0x6B20             LDR      R0,[R4, #+48]
   \   00000034   0x.... 0x....      BL       OSSemPost
    314          #endif /* OS_INCLUDED */
    315          
    316          	return 0;
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    317          }
    318          
    319          
    320          
    321          //Not using interrupt

   \                                 In section .text, align 2, keep-with-next
    322          unsigned char USART4PutChar(unsigned char Data)
    323          {
   \                     USART4PutChar:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    324          	#ifdef OS_INCLUDED
    325          		INT8U err;
    326          		//////////////////////////////////////////////////
    327          	
    328          		OSSemPend(pUSART4.sem, 0, &err);
   \   00000004   0x....             LDR.N    R5,??DataTable9_4
   \   00000006   0xAA00             ADD      R2,SP,#+0
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6B28             LDR      R0,[R5, #+48]
   \   0000000C   0x.... 0x....      BL       OSSemPend
    329          	#endif /* OS_INCLUDED */
    330          		UART4->__B.DR.DR = Data;
   \   00000010   0x....             LDR.N    R0,??DataTable9_3  ;; 0x40004c00
   \   00000012   0x6841             LDR      R1,[R0, #+4]
   \   00000014   0xF364 0x0108      BFI      R1,R4,#+0,#+9
   \   00000018   0x6041             STR      R1,[R0, #+4]
    331          		while(!UART4->__B.SR.TXE);
   \                     ??USART4PutChar_0:
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0x0609             LSLS     R1,R1,#+24
   \   0000001E   0xD5FC             BPL.N    ??USART4PutChar_0
    332          	#ifdef OS_INCLUDED
    333          		OSSemPost(pUSART4.sem);
   \   00000020   0x6B28             LDR      R0,[R5, #+48]
   \   00000022   0x.... 0x....      BL       OSSemPost
    334          	#endif /* OS_INCLUDED */
    335          	return Data;
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    336          }
    337          

   \                                 In section .text, align 2, keep-with-next
    338          unsigned long int USART4Printf( const char *format, ...)
    339          {
   \                     USART4Printf:
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB530             PUSH     {R4,R5,LR}
    340          	unsigned long int i, cnt;
    341          //	char buf[128];
    342          	char *buf = (char *)&Tx4Buff[Tx4BuffLen-256];
    343          	
    344          	va_list argptr;
    345          
    346          	va_start(argptr, format);
   \   00000004   0xAA03             ADD      R2,SP,#+12
    347          	cnt = vsprintf(buf, format, argptr);
   \   00000006   0x....             LDR.N    R4,??DataTable9_9
   \   00000008   0x4601             MOV      R1,R0
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       vsprintf
   \   00000010   0x4605             MOV      R5,R0
    348          	va_end( argptr );
    349          
    350          	for(i = 0;;i++)
   \   00000012   0xE008             B.N      ??USART4Printf_0
    351          	{
    352          		if(buf[i] == 0) break;
    353          		if(buf[i] == '\n') USART4PutToBuffer('\r');
   \                     ??USART4Printf_1:
   \   00000014   0x280A             CMP      R0,#+10
   \   00000016   0xBF04             ITT      EQ 
   \   00000018   0x200D             MOVEQ    R0,#+13
   \   0000001A   0x.... 0x....      BLEQ     USART4PutToBuffer
    354          		USART4PutToBuffer(buf[i]);
   \   0000001E   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   00000022   0x.... 0x....      BL       USART4PutToBuffer
   \                     ??USART4Printf_0:
   \   00000026   0x7820             LDRB     R0,[R4, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD1F3             BNE.N    ??USART4Printf_1
    355          	}
    356          
    357          	while(!USART4TxCheckByte())
   \                     ??USART4Printf_2:
   \   0000002C   0x.... 0x....      BL       USART4TxCheckByte
   \   00000030   0xB918             CBNZ.N   R0,??USART4Printf_3
    358          	{
    359          #ifdef OS_INCLUDED
    360          	OSTimeDly(1);
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x.... 0x....      BL       OSTimeDly
   \   00000038   0xE7F8             B.N      ??USART4Printf_2
    361          #endif /* OS_INCLUDED */
    362          	}
    363          
    364          	return cnt;
   \                     ??USART4Printf_3:
   \   0000003A   0x4628             MOV      R0,R5
   \   0000003C   0xBC30             POP      {R4,R5}
   \   0000003E   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
    365          }
    366          
    367          //#define OS_INCLUDED
    368          

   \                                 In section .text, align 2, keep-with-next
    369          void USART4PutStr(unsigned char *Str, unsigned short int Length, int iEn)
    370          {
   \                     USART4PutStr:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4617             MOV      R7,R2
    371          	u32 i = 0;
    372          
    373          	USART4BuffClear();
   \   00000008   0x.... 0x....      BL       USART4BuffClear
    374          	
    375          #ifdef OS_INCLUDED
    376          	INT8U err;
    377          	OSSemPend(pUSART4.sem, 0, &err);
   \   0000000C   0x....             LDR.N    R4,??DataTable9_4
   \   0000000E   0xAA00             ADD      R2,SP,#+0
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6B20             LDR      R0,[R4, #+48]
   \   00000014   0x.... 0x....      BL       OSSemPend
    378          #endif /* OS_INCLUDED */
    379          
    380          
    381          	for(i = 0; i < Length; i++)
   \   00000018   0x88E0             LDRH     R0,[R4, #+6]
   \   0000001A   0xB15E             CBZ.N    R6,??USART4PutStr_0
   \   0000001C   0x....             LDR.N    R1,??DataTable9_7
    382          	{
    383          		Tx4Buff[Tx4WrCnt++] = Str[i];
   \                     ??USART4PutStr_1:
   \   0000001E   0x782A             LDRB     R2,[R5, #+0]
   \   00000020   0x5442             STRB     R2,[R0, R1]
   \   00000022   0x1C40             ADDS     R0,R0,#+1
    384          		if(Tx4WrCnt >= Tx4BuffLen) Tx4WrCnt = 0;
   \   00000024   0xB280             UXTH     R0,R0
   \   00000026   0xF5B0 0x6F80      CMP      R0,#+1024
   \   0000002A   0xBF28             IT       CS 
   \   0000002C   0x2000             MOVCS    R0,#+0
    385          	}
   \   0000002E   0x1C6D             ADDS     R5,R5,#+1
   \   00000030   0x1E76             SUBS     R6,R6,#+1
   \   00000032   0xD1F4             BNE.N    ??USART4PutStr_1
   \                     ??USART4PutStr_0:
   \   00000034   0x80E0             STRH     R0,[R4, #+6]
    386          
    387          	if(iEn)
   \   00000036   0xB127             CBZ.N    R7,??USART4PutStr_2
    388          	{
    389          		UART4->__B.CR1.TXEIE = ENABLE;
   \   00000038   0x....             LDR.N    R0,??DataTable9_8  ;; 0x40004c0c
   \   0000003A   0x6801             LDR      R1,[R0, #+0]
   \   0000003C   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000040   0x6001             STR      R1,[R0, #+0]
    390          	}	
    391          #ifdef OS_INCLUDED
    392          		OSSemPost(pUSART4.sem);
   \                     ??USART4PutStr_2:
   \   00000042   0x6B20             LDR      R0,[R4, #+48]
   \   00000044   0x.... 0x....      BL       OSSemPost
    393          #endif /* OS_INCLUDED */
    394          }
   \   00000048   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    395          

   \                                 In section .text, align 2, keep-with-next
    396          signed short int USART4RxGetByte(void)
    397          {
    398          	s16 RetVal = 0;
    399          
    400          #ifndef OS_INCLUDED
    401          	while(Rx4RdCnt == Rx4WrCnt);
    402          #else
    403          	if(Rx4RdCnt == Rx4WrCnt) return -1;
   \                     USART4RxGetByte:
   \   00000000   0x....             LDR.N    R1,??DataTable9_4
   \   00000002   0x880A             LDRH     R2,[R1, #+0]
   \   00000004   0x8848             LDRH     R0,[R1, #+2]
   \   00000006   0x4282             CMP      R2,R0
   \   00000008   0xD102             BNE.N    ??USART4RxGetByte_0
   \   0000000A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000E   0x4770             BX       LR
    404          #endif
    405          
    406          	RetVal = Rx4Buff[Rx4RdCnt%Rx4BuffLen];
   \                     ??USART4RxGetByte_0:
   \   00000010   0x0590             LSLS     R0,R2,#+22
   \   00000012   0x0D80             LSRS     R0,R0,#+22
   \   00000014   0x....             LDR.N    R3,??DataTable9_6
   \   00000016   0x5CC0             LDRB     R0,[R0, R3]
    407          	if(++Rx4RdCnt >= Rx4BuffLen) Rx4RdCnt = 0;
   \   00000018   0x1C52             ADDS     R2,R2,#+1
   \   0000001A   0x800A             STRH     R2,[R1, #+0]
   \   0000001C   0xB292             UXTH     R2,R2
   \   0000001E   0xF5B2 0x6F80      CMP      R2,#+1024
   \   00000022   0xBF24             ITT      CS 
   \   00000024   0x2200             MOVCS    R2,#+0
   \   00000026   0x800A             STRHCS   R2,[R1, #+0]
    408          
    409          	return (RetVal & 0xff);
   \   00000028   0x4770             BX       LR               ;; return
    410          }
    411          

   \                                 In section .text, align 2, keep-with-next
    412          unsigned char USART4CheckByte(unsigned short int ByteCnt, unsigned short int *Recv)
    413          {
   \                     USART4CheckByte:
   \   00000000   0xB430             PUSH     {R4,R5}
    414          	u32 i = 0, j = 0;
    415          	u8 RetVal = TRUE;
   \   00000002   0x2201             MOVS     R2,#+1
    416          
    417          	*Recv = 0;
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x800B             STRH     R3,[R1, #+0]
    418          	i = (u32) Rx4RdCnt;
   \   00000008   0x....             LDR.N    R3,??DataTable9_4
   \   0000000A   0x881C             LDRH     R4,[R3, #+0]
    419          	j = (u32) Rx4WrCnt;
   \   0000000C   0x885B             LDRH     R3,[R3, #+2]
    420          
    421          	if(i == j) RetVal = FALSE;
   \   0000000E   0x429C             CMP      R4,R3
   \   00000010   0xD00E             BEQ.N    ??USART4CheckByte_0
    422          	else if(i < j)
   \   00000012   0x1900             ADDS     R0,R0,R4
   \   00000014   0x429C             CMP      R4,R3
   \   00000016   0xD203             BCS.N    ??USART4CheckByte_1
    423          	{
    424          		*Recv = j - i;
   \   00000018   0x1B1C             SUBS     R4,R3,R4
   \   0000001A   0x800C             STRH     R4,[R1, #+0]
    425          		i = i + ByteCnt;
    426          		if(i > j) RetVal = FALSE;
   \   0000001C   0x4283             CMP      R3,R0
   \   0000001E   0xE006             B.N      ??USART4CheckByte_2
    427          	}
    428          	else if(i > j)
    429          	{
    430          		*Recv = (Rx4BuffLen +j) - i;
   \                     ??USART4CheckByte_1:
   \   00000020   0xF503 0x6580      ADD      R5,R3,#+1024
   \   00000024   0x1B2C             SUBS     R4,R5,R4
   \   00000026   0x800C             STRH     R4,[R1, #+0]
    431          		i = i + ByteCnt;
    432          		j = j + Rx4BuffLen;
    433          		if(i > j) RetVal = FALSE; 
   \   00000028   0xF503 0x6180      ADD      R1,R3,#+1024
   \   0000002C   0x4281             CMP      R1,R0
   \                     ??USART4CheckByte_2:
   \   0000002E   0xD200             BCS.N    ??USART4CheckByte_3
   \                     ??USART4CheckByte_0:
   \   00000030   0x2200             MOVS     R2,#+0
    434          	}
    435          	return (RetVal);
   \                     ??USART4CheckByte_3:
   \   00000032   0x4610             MOV      R0,R2
   \   00000034   0xBC30             POP      {R4,R5}
   \   00000036   0x4770             BX       LR               ;; return
    436          }
    437          

   \                                 In section .text, align 2, keep-with-next
    438          void USART4BuffClear(void)
    439          {
    440          	Rx4RdCnt = 0;
   \                     USART4BuffClear:
   \   00000000   0x....             LDR.N    R0,??DataTable9_4
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x8001             STRH     R1,[R0, #+0]
    441          	Rx4WrCnt = 0;
   \   00000006   0x8041             STRH     R1,[R0, #+2]
    442          	Tx4RdCnt = 0;
   \   00000008   0x....             B.N      ?Subroutine1
    443          	Tx4WrCnt = 0;
    444          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0x8081             STRH     R1,[R0, #+4]
   \   00000002   0x80C1             STRH     R1,[R0, #+6]
   \   00000004   0x4770             BX       LR               ;; return
    445          

   \                                 In section .text, align 2, keep-with-next
    446          void USART4TxClear(void)
    447          {
    448          	Tx4RdCnt = 0;
   \                     USART4TxClear:
   \   00000000   0x....             LDR.N    R0,??DataTable9_4
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004                      REQUIRE ?Subroutine1
   \   00000004                      ;; // Fall through to label ?Subroutine1
    449          	Tx4WrCnt = 0;
    450          }
    451          
    452          /*******************************************************************************
    453            * @brief  if the bytes have been transmitted, retrun true or not
    454            * @param  None
    455            * @retval TRUE/FALSE
    456            ******************************************************************************/
    457          

   \                                 In section .text, align 2, keep-with-next
    458          signed short int USART4TxCheckByte(void)
    459          {
    460          	if(Tx4RdCnt == Tx4WrCnt) return TRUE;
   \                     USART4TxCheckByte:
   \   00000000   0x....             LDR.N    R0,??DataTable9_4
   \   00000002   0x8881             LDRH     R1,[R0, #+4]
   \   00000004   0x88C0             LDRH     R0,[R0, #+6]
   \   00000006   0x4281             CMP      R1,R0
   \   00000008   0xD101             BNE.N    ??USART4TxCheckByte_0
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x4770             BX       LR
    461          	else return FALSE;
   \                     ??USART4TxCheckByte_0:
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4770             BX       LR               ;; return
    462          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x40023830         DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x40004C00         DC32     0x40004c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     Rx4RdCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     Rx4Buff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     Tx4Buff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x40004C0C         DC32     0x40004c0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x........         DC32     Tx4Buff+0x300

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "\\n">`:
   \   00000000   0x0A 0x00          DC8 "\012"
    463          
    464          
    465          
    466          
    467          /**
    468            * @brief  Initializes the USARTx peripheral Clock according to the 
    469            *         specified parameters in the USART_ClockInitStruct .
    470            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART peripheral.
    471            * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure that
    472            *         contains the configuration information for the specified  USART peripheral.
    473            * @note   The Smart Card and Synchronous modes are not available for UART4 and UART5.    
    474            * @retval None
    475            */
    476          
    477          /**
    478            * @brief  Fills each USART_ClockInitStruct member with its default value.
    479            * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure
    480            *         which will be initialized.
    481            * @retval None
    482            */
    483          
    484          
    485          /**
    486            * @brief  Enables or disables the specified USART peripheral.
    487            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    488            *         UART peripheral.
    489            * @param  NewState: new state of the USARTx peripheral.
    490            *          This parameter can be: ENABLE or DISABLE.
    491            * @retval None
    492            */
    493          
    494          
    495          /**
    496            * @brief  Sets the system clock prescaler.
    497            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    498            *         UART peripheral.
    499            * @param  USART_Prescaler: specifies the prescaler clock. 
    500            * @note   The function is used for IrDA mode with UART4 and UART5.   
    501            * @retval None
    502            */
    503          
    504          /**
    505            * @brief  Enables or disables the USART's 8x oversampling mode.
    506            * @note   This function has to be called before calling USART_Init() function
    507            *         in order to have correct baudrate Divider value.
    508            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    509            *         UART peripheral.
    510            * @param  NewState: new state of the USART 8x oversampling mode.
    511            *          This parameter can be: ENABLE or DISABLE.
    512            * @retval None
    513            */
    514            
    515          
    516          /**
    517            * @brief  Enables or disables the USART's one bit sampling method.
    518            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    519            *         UART peripheral.
    520            * @param  NewState: new state of the USART one bit sampling method.
    521            *          This parameter can be: ENABLE or DISABLE.
    522            * @retval None
    523            */
    524          
    525          /**
    526            * @}
    527            */
    528          
    529          /** @defgroup USART_Group2 Data transfers functions
    530           *  @brief   Data transfers functions 
    531           *
    532          @verbatim   
    533           ===============================================================================
    534                                      Data transfers functions
    535           ===============================================================================  
    536          
    537            This subsection provides a set of functions allowing to manage the USART data 
    538            transfers.
    539            
    540            During an USART reception, data shifts in least significant bit first through 
    541            the RX pin. In this mode, the USART_DR register consists of a buffer (RDR) 
    542            between the internal bus and the received shift register.
    543          
    544            When a transmission is taking place, a write instruction to the USART_DR register 
    545            stores the data in the TDR register and which is copied in the shift register 
    546            at the end of the current transmission.
    547          
    548            The read access of the USART_DR register can be done using the USART_ReceiveData()
    549            function and returns the RDR buffered value. Whereas a write access to the USART_DR 
    550            can be done using USART_SendData() function and stores the written data into 
    551            TDR buffer.
    552          
    553          @endverbatim
    554            * @{
    555            */
    556          
    557          /**
    558            * @brief  Transmits single data through the USARTx peripheral.
    559            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    560            *         UART peripheral.
    561            * @param  Data: the data to transmit.
    562            * @retval None
    563            */
    564          
    565          
    566          /**
    567            * @brief  Returns the most recent received data by the USARTx peripheral.
    568            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    569            *         UART peripheral.
    570            * @retval The received data.
    571            */
    572          
    573          /**
    574            * @}
    575            */
    576          
    577          /** @defgroup USART_Group3 MultiProcessor Communication functions
    578           *  @brief   Multi-Processor Communication functions 
    579           *
    580          @verbatim   
    581           ===============================================================================
    582                              Multi-Processor Communication functions
    583           ===============================================================================  
    584          
    585            This subsection provides a set of functions allowing to manage the USART 
    586            multiprocessor communication.
    587            
    588            For instance one of the USARTs can be the master, its TX output is connected to 
    589            the RX input of the other USART. The others are slaves, their respective TX outputs 
    590            are logically ANDed together and connected to the RX input of the master.
    591          
    592            USART multiprocessor communication is possible through the following procedure:
    593               1. Program the Baud rate, Word length = 9 bits, Stop bits, Parity, Mode transmitter 
    594                  or Mode receiver and hardware flow control values using the USART_Init()
    595                  function.
    596               2. Configures the USART address using the USART_SetAddress() function.
    597               3. Configures the wake up method (USART_WakeUp_IdleLine or USART_WakeUp_AddressMark)
    598                  using USART_WakeUpConfig() function only for the slaves.
    599               4. Enable the USART using the USART_Cmd() function.
    600               5. Enter the USART slaves in mute mode using USART_ReceiverWakeUpCmd() function.
    601          
    602            The USART Slave exit from mute mode when receive the wake up condition.
    603          
    604          @endverbatim
    605            * @{
    606            */
    607          
    608          /**
    609            * @brief  Sets the address of the USART node.
    610            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    611            *         UART peripheral.
    612            * @param  USART_Address: Indicates the address of the USART node.
    613            * @retval None
    614            */
    615          
    616          
    617          /**
    618            * @brief  Determines if the USART is in mute mode or not.
    619            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    620            *         UART peripheral.
    621            * @param  NewState: new state of the USART mute mode.
    622            *          This parameter can be: ENABLE or DISABLE.
    623            * @retval None
    624            */
    625          
    626          /**
    627            * @brief  Selects the USART WakeUp method.
    628            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    629            *         UART peripheral.
    630            * @param  USART_WakeUp: specifies the USART wakeup method.
    631            *          This parameter can be one of the following values:
    632            *            @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection
    633            *            @arg USART_WakeUp_AddressMark: WakeUp by an address mark
    634            * @retval None
    635            */
    636          
    637          
    638          /**
    639            * @}
    640            */
    641          
    642          /** @defgroup USART_Group4 LIN mode functions
    643           *  @brief   LIN mode functions 
    644           *
    645          @verbatim   
    646           ===============================================================================
    647                                          LIN mode functions
    648           ===============================================================================  
    649          
    650            This subsection provides a set of functions allowing to manage the USART LIN 
    651            Mode communication.
    652            
    653            In LIN mode, 8-bit data format with 1 stop bit is required in accordance with 
    654            the LIN standard.
    655          
    656            Only this LIN Feature is supported by the USART IP:
    657              - LIN Master Synchronous Break send capability and LIN slave break detection
    658                capability :  13-bit break generation and 10/11 bit break detection
    659          
    660          
    661            USART LIN Master transmitter communication is possible through the following procedure:
    662               1. Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
    663                  Mode transmitter or Mode receiver and hardware flow control values using 
    664                  the USART_Init() function.
    665               2. Enable the USART using the USART_Cmd() function.
    666               3. Enable the LIN mode using the USART_LINCmd() function.
    667               4. Send the break character using USART_SendBreak() function.
    668          
    669            USART LIN Master receiver communication is possible through the following procedure:
    670               1. Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
    671                  Mode transmitter or Mode receiver and hardware flow control values using 
    672                  the USART_Init() function.
    673               2. Enable the USART using the USART_Cmd() function.
    674               3. Configures the break detection length using the USART_LINBreakDetectLengthConfig()
    675                  function.
    676               4. Enable the LIN mode using the USART_LINCmd() function.
    677          
    678          
    679          @note In LIN mode, the following bits must be kept cleared:
    680                  - CLKEN in the USART_CR2 register,
    681                  - STOP[1:0], SCEN, HDSEL and IREN in the USART_CR3 register.
    682          
    683          @endverbatim
    684            * @{
    685            */
    686          
    687          /**
    688            * @brief  Sets the USART LIN Break detection length.
    689            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    690            *         UART peripheral.
    691            * @param  USART_LINBreakDetectLength: specifies the LIN break detection length.
    692            *          This parameter can be one of the following values:
    693            *            @arg USART_LINBreakDetectLength_10b: 10-bit break detection
    694            *            @arg USART_LINBreakDetectLength_11b: 11-bit break detection
    695            * @retval None
    696            */
    697          
    698          /**
    699            * @brief  Enables or disables the USART's LIN mode.
    700            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    701            *         UART peripheral.
    702            * @param  NewState: new state of the USART LIN mode.
    703            *          This parameter can be: ENABLE or DISABLE.
    704            * @retval None
    705            */
    706          
    707          
    708          /**
    709            * @brief  Transmits break characters.
    710            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    711            *         UART peripheral.
    712            * @retval None
    713            */
    714          
    715          
    716          /**
    717            * @}
    718            */
    719          
    720          /** @defgroup USART_Group5 Halfduplex mode function
    721           *  @brief   Half-duplex mode function 
    722           *
    723          @verbatim   
    724           ===============================================================================
    725                                   Half-duplex mode function
    726           ===============================================================================  
    727          
    728            This subsection provides a set of functions allowing to manage the USART 
    729            Half-duplex communication.
    730            
    731            The USART can be configured to follow a single-wire half-duplex protocol where 
    732            the TX and RX lines are internally connected.
    733          
    734            USART Half duplex communication is possible through the following procedure:
    735               1. Program the Baud rate, Word length, Stop bits, Parity, Mode transmitter 
    736                  or Mode receiver and hardware flow control values using the USART_Init()
    737                  function.
    738               2. Configures the USART address using the USART_SetAddress() function.
    739               3. Enable the USART using the USART_Cmd() function.
    740               4. Enable the half duplex mode using USART_HalfDuplexCmd() function.
    741          
    742          
    743          @note The RX pin is no longer used
    744          @note In Half-duplex mode the following bits must be kept cleared:
    745                  - LINEN and CLKEN bits in the USART_CR2 register.
    746                  - SCEN and IREN bits in the USART_CR3 register.
    747          
    748          @endverbatim
    749            * @{
    750            */
    751          
    752          /**
    753            * @brief  Enables or disables the USART's Half Duplex communication.
    754            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    755            *         UART peripheral.
    756            * @param  NewState: new state of the USART Communication.
    757            *          This parameter can be: ENABLE or DISABLE.
    758            * @retval None
    759            */
    760          
    761          
    762          /**
    763            * @}
    764            */
    765          
    766          
    767          /** @defgroup USART_Group6 Smartcard mode functions
    768           *  @brief   Smartcard mode functions 
    769           *
    770          @verbatim   
    771           ===============================================================================
    772                                         Smartcard mode functions
    773           ===============================================================================  
    774          
    775            This subsection provides a set of functions allowing to manage the USART 
    776            Smartcard communication.
    777            
    778            The Smartcard interface is designed to support asynchronous protocol Smartcards as
    779            defined in the ISO 7816-3 standard.
    780          
    781            The USART can provide a clock to the smartcard through the SCLK output.
    782            In smartcard mode, SCLK is not associated to the communication but is simply derived 
    783            from the internal peripheral input clock through a 5-bit prescaler.
    784          
    785            Smartcard communication is possible through the following procedure:
    786               1. Configures the Smartcard Prescaler using the USART_SetPrescaler() function.
    787               2. Configures the Smartcard Guard Time using the USART_SetGuardTime() function.
    788               3. Program the USART clock using the USART_ClockInit() function as following:
    789                  - USART Clock enabled
    790                  - USART CPOL Low
    791                  - USART CPHA on first edge
    792                  - USART Last Bit Clock Enabled
    793               4. Program the Smartcard interface using the USART_Init() function as following:
    794                  - Word Length = 9 Bits
    795                  - 1.5 Stop Bit
    796                  - Even parity
    797                  - BaudRate = 12096 baud
    798                  - Hardware flow control disabled (RTS and CTS signals)
    799                  - Tx and Rx enabled
    800               5. Optionally you can enable the parity error interrupt using the USART_ITConfig()
    801                  function
    802               6. Enable the USART using the USART_Cmd() function.
    803               7. Enable the Smartcard NACK using the USART_SmartCardNACKCmd() function.
    804               8. Enable the Smartcard interface using the USART_SmartCardCmd() function.
    805          
    806            Please refer to the ISO 7816-3 specification for more details.
    807          
    808          
    809          @note It is also possible to choose 0.5 stop bit for receiving but it is recommended 
    810                to use 1.5 stop bits for both transmitting and receiving to avoid switching 
    811                between the two configurations.
    812          @note In smartcard mode, the following bits must be kept cleared:
    813                  - LINEN bit in the USART_CR2 register.
    814                  - HDSEL and IREN bits in the USART_CR3 register.
    815          @note Smartcard mode is available on USART peripherals only (not available on UART4 
    816                and UART5 peripherals).
    817          
    818          @endverbatim
    819            * @{
    820            */
    821          
    822          /**
    823            * @brief  Sets the specified USART guard time.
    824            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
    825            *         UART peripheral.
    826            * @param  USART_GuardTime: specifies the guard time.   
    827            * @retval None
    828            */
    829          
    830          /**
    831            * @brief  Enables or disables the USART's Smart Card mode.
    832            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
    833            *         UART peripheral.
    834            * @param  NewState: new state of the Smart Card mode.
    835            *          This parameter can be: ENABLE or DISABLE.      
    836            * @retval None
    837            */
    838          
    839          
    840          /**
    841            * @brief  Enables or disables NACK transmission.
    842            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
    843            *         UART peripheral.
    844            * @param  NewState: new state of the NACK transmission.
    845            *          This parameter can be: ENABLE or DISABLE.  
    846            * @retval None
    847            */
    848          
    849          /**
    850            * @}
    851            */
    852          
    853          /** @defgroup USART_Group7 IrDA mode functions
    854           *  @brief   IrDA mode functions 
    855           *
    856          @verbatim   
    857           ===============================================================================
    858                                          IrDA mode functions
    859           ===============================================================================  
    860          
    861            This subsection provides a set of functions allowing to manage the USART 
    862            IrDA communication.
    863            
    864            IrDA is a half duplex communication protocol. If the Transmitter is busy, any data
    865            on the IrDA receive line will be ignored by the IrDA decoder and if the Receiver 
    866            is busy, data on the TX from the USART to IrDA will not be encoded by IrDA.
    867            While receiving data, transmission should be avoided as the data to be transmitted
    868            could be corrupted.
    869          
    870            IrDA communication is possible through the following procedure:
    871               1. Program the Baud rate, Word length = 8 bits, Stop bits, Parity, Transmitter/Receiver 
    872                  modes and hardware flow control values using the USART_Init() function.
    873               2. Enable the USART using the USART_Cmd() function.
    874               3. Configures the IrDA pulse width by configuring the prescaler using  
    875                  the USART_SetPrescaler() function.
    876               4. Configures the IrDA  USART_IrDAMode_LowPower or USART_IrDAMode_Normal mode
    877                  using the USART_IrDAConfig() function.
    878               5. Enable the IrDA using the USART_IrDACmd() function.
    879          
    880          @note A pulse of width less than two and greater than one PSC period(s) may or may
    881                not be rejected.
    882          @note The receiver set up time should be managed by software. The IrDA physical layer
    883                specification specifies a minimum of 10 ms delay between transmission and 
    884                reception (IrDA is a half duplex protocol).
    885          @note In IrDA mode, the following bits must be kept cleared:
    886                  - LINEN, STOP and CLKEN bits in the USART_CR2 register.
    887                  - SCEN and HDSEL bits in the USART_CR3 register.
    888          
    889          @endverbatim
    890            * @{
    891            */
    892          
    893          /**
    894            * @brief  Configures the USART's IrDA interface.
    895            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    896            *         UART peripheral.
    897            * @param  USART_IrDAMode: specifies the IrDA mode.
    898            *          This parameter can be one of the following values:
    899            *            @arg USART_IrDAMode_LowPower
    900            *            @arg USART_IrDAMode_Normal
    901            * @retval None
    902            */
    903          
    904          /**
    905            * @brief  Enables or disables the USART's IrDA interface.
    906            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    907            *         UART peripheral.
    908            * @param  NewState: new state of the IrDA mode.
    909            *          This parameter can be: ENABLE or DISABLE.
    910            * @retval None
    911            */
    912          
    913          
    914          /**
    915            * @}
    916            */
    917          
    918          /** @defgroup USART_Group8 DMA transfers management functions
    919           *  @brief   DMA transfers management functions
    920           *
    921          @verbatim   
    922           ===============================================================================
    923                                DMA transfers management functions
    924           ===============================================================================  
    925          
    926          @endverbatim
    927            * @{
    928            */
    929            
    930          /**
    931            * @brief  Enables or disables the USART's DMA interface.
    932            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    933            *         UART peripheral.
    934            * @param  USART_DMAReq: specifies the DMA request.
    935            *          This parameter can be any combination of the following values:
    936            *            @arg USART_DMAReq_Tx: USART DMA transmit request
    937            *            @arg USART_DMAReq_Rx: USART DMA receive request
    938            * @param  NewState: new state of the DMA Request sources.
    939            *          This parameter can be: ENABLE or DISABLE.   
    940            * @retval None
    941            */
    942          
    943          /**
    944            * @}
    945            */
    946            
    947          /** @defgroup USART_Group9 Interrupts and flags management functions
    948           *  @brief   Interrupts and flags management functions 
    949           *
    950          @verbatim   
    951           ===============================================================================
    952                             Interrupts and flags management functions
    953           ===============================================================================  
    954          
    955            This subsection provides a set of functions allowing to configure the USART 
    956            Interrupts sources, DMA channels requests and check or clear the flags or 
    957            pending bits status.
    958            The user should identify which mode will be used in his application to manage 
    959            the communication: Polling mode, Interrupt mode or DMA mode. 
    960              
    961            Polling Mode
    962            =============
    963            In Polling Mode, the SPI communication can be managed by 10 flags:
    964               1. USART_FLAG_TXE : to indicate the status of the transmit buffer register
    965               2. USART_FLAG_RXNE : to indicate the status of the receive buffer register
    966               3. USART_FLAG_TC : to indicate the status of the transmit operation
    967               4. USART_FLAG_IDLE : to indicate the status of the Idle Line             
    968               5. USART_FLAG_CTS : to indicate the status of the nCTS input
    969               6. USART_FLAG_LBD : to indicate the status of the LIN break detection
    970               7. USART_FLAG_NE : to indicate if a noise error occur
    971               8. USART_FLAG_FE : to indicate if a frame error occur
    972               9. USART_FLAG_PE : to indicate if a parity error occur
    973               10. USART_FLAG_ORE : to indicate if an Overrun error occur
    974          
    975            In this Mode it is advised to use the following functions:
    976                - FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);
    977                - void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG);
    978          
    979            Interrupt Mode
    980            ===============
    981            In Interrupt Mode, the USART communication can be managed by 8 interrupt sources
    982            and 10 pending bits: 
    983          
    984            Pending Bits:
    985            ------------- 
    986               1. USART_IT_TXE : to indicate the status of the transmit buffer register
    987               2. USART_IT_RXNE : to indicate the status of the receive buffer register
    988               3. USART_IT_TC : to indicate the status of the transmit operation
    989               4. USART_IT_IDLE : to indicate the status of the Idle Line             
    990               5. USART_IT_CTS : to indicate the status of the nCTS input
    991               6. USART_IT_LBD : to indicate the status of the LIN break detection
    992               7. USART_IT_NE : to indicate if a noise error occur
    993               8. USART_IT_FE : to indicate if a frame error occur
    994               9. USART_IT_PE : to indicate if a parity error occur
    995               10. USART_IT_ORE : to indicate if an Overrun error occur
    996          
    997            Interrupt Source:
    998            -----------------
    999               1. USART_IT_TXE : specifies the interrupt source for the Tx buffer empty 
   1000                                 interrupt. 
   1001               2. USART_IT_RXNE : specifies the interrupt source for the Rx buffer not 
   1002                                  empty interrupt.
   1003               3. USART_IT_TC : specifies the interrupt source for the Transmit complete 
   1004                                 interrupt. 
   1005               4. USART_IT_IDLE : specifies the interrupt source for the Idle Line interrupt.             
   1006               5. USART_IT_CTS : specifies the interrupt source for the CTS interrupt. 
   1007               6. USART_IT_LBD : specifies the interrupt source for the LIN break detection
   1008                                 interrupt. 
   1009               7. USART_IT_PE : specifies the interrupt source for the parity error interrupt. 
   1010               8. USART_IT_ERR :  specifies the interrupt source for the errors interrupt.
   1011          
   1012          @note Some parameters are coded in order to use them as interrupt source or as pending bits.
   1013          
   1014            In this Mode it is advised to use the following functions:
   1015               - void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);
   1016               - ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
   1017               - void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
   1018          
   1019            DMA Mode
   1020            ========
   1021            In DMA Mode, the USART communication can be managed by 2 DMA Channel requests:
   1022               1. USART_DMAReq_Tx: specifies the Tx buffer DMA transfer request
   1023               2. USART_DMAReq_Rx: specifies the Rx buffer DMA transfer request
   1024          
   1025            In this Mode it is advised to use the following function:
   1026               - void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState);
   1027          
   1028          @endverbatim
   1029            * @{
   1030            */
   1031          
   1032          /**
   1033            * @brief  Enables or disables the specified USART interrupts.
   1034            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1035            *         UART peripheral.
   1036            * @param  USART_IT: specifies the USART interrupt sources to be enabled or disabled.
   1037            *          This parameter can be one of the following values:
   1038            *            @arg USART_IT_CTS:  CTS change interrupt
   1039            *            @arg USART_IT_LBD:  LIN Break detection interrupt
   1040            *            @arg USART_IT_TXE:  Transmit Data Register empty interrupt
   1041            *            @arg USART_IT_TC:   Transmission complete interrupt
   1042            *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
   1043            *            @arg USART_IT_IDLE: Idle line detection interrupt
   1044            *            @arg USART_IT_PE:   Parity Error interrupt
   1045            *            @arg USART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
   1046            * @param  NewState: new state of the specified USARTx interrupts.
   1047            *          This parameter can be: ENABLE or DISABLE.
   1048            * @retval None
   1049            */
   1050          
   1051          /**
   1052            * @brief  Checks whether the specified USART flag is set or not.
   1053            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1054            *         UART peripheral.
   1055            * @param  USART_FLAG: specifies the flag to check.
   1056            *          This parameter can be one of the following values:
   1057            *            @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5)
   1058            *            @arg USART_FLAG_LBD:  LIN Break detection flag
   1059            *            @arg USART_FLAG_TXE:  Transmit data register empty flag
   1060            *            @arg USART_FLAG_TC:   Transmission Complete flag
   1061            *            @arg USART_FLAG_RXNE: Receive data register not empty flag
   1062            *            @arg USART_FLAG_IDLE: Idle Line detection flag
   1063            *            @arg USART_FLAG_ORE:  OverRun Error flag
   1064            *            @arg USART_FLAG_NE:   Noise Error flag
   1065            *            @arg USART_FLAG_FE:   Framing Error flag
   1066            *            @arg USART_FLAG_PE:   Parity Error flag
   1067            * @retval The new state of USART_FLAG (SET or RESET).
   1068            */
   1069          
   1070          /**
   1071            * @brief  Clears the USARTx's pending flags.
   1072            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1073            *         UART peripheral.
   1074            * @param  USART_FLAG: specifies the flag to clear.
   1075            *          This parameter can be any combination of the following values:
   1076            *            @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5).
   1077            *            @arg USART_FLAG_LBD:  LIN Break detection flag.
   1078            *            @arg USART_FLAG_TC:   Transmission Complete flag.
   1079            *            @arg USART_FLAG_RXNE: Receive data register not empty flag.
   1080            *   
   1081            * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
   1082            *          error) and IDLE (Idle line detected) flags are cleared by software 
   1083            *          sequence: a read operation to USART_SR register (USART_GetFlagStatus()) 
   1084            *          followed by a read operation to USART_DR register (USART_ReceiveData()).
   1085            * @note   RXNE flag can be also cleared by a read to the USART_DR register 
   1086            *          (USART_ReceiveData()).
   1087            * @note   TC flag can be also cleared by software sequence: a read operation to 
   1088            *          USART_SR register (USART_GetFlagStatus()) followed by a write operation
   1089            *          to USART_DR register (USART_SendData()).
   1090            * @note   TXE flag is cleared only by a write to the USART_DR register 
   1091            *          (USART_SendData()).
   1092            *   
   1093            * @retval None
   1094            */
   1095          
   1096          
   1097          /**
   1098            * @brief  Checks whether the specified USART interrupt has occurred or not.
   1099            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1100            *         UART peripheral.
   1101            * @param  USART_IT: specifies the USART interrupt source to check.
   1102            *          This parameter can be one of the following values:
   1103            *            @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
   1104            *            @arg USART_IT_LBD:  LIN Break detection interrupt
   1105            *            @arg USART_IT_TXE:  Transmit Data Register empty interrupt
   1106            *            @arg USART_IT_TC:   Transmission complete interrupt
   1107            *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
   1108            *            @arg USART_IT_IDLE: Idle line detection interrupt
   1109            *            @arg USART_IT_ORE:  OverRun Error interrupt
   1110            *            @arg USART_IT_NE:   Noise Error interrupt
   1111            *            @arg USART_IT_FE:   Framing Error interrupt
   1112            *            @arg USART_IT_PE:   Parity Error interrupt
   1113            * @retval The new state of USART_IT (SET or RESET).
   1114            */
   1115          
   1116          
   1117          /**
   1118            * @brief  Clears the USARTx's interrupt pending bits.
   1119            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1120            *         UART peripheral.
   1121            * @param  USART_IT: specifies the interrupt pending bit to clear.
   1122            *          This parameter can be one of the following values:
   1123            *            @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
   1124            *            @arg USART_IT_LBD:  LIN Break detection interrupt
   1125            *            @arg USART_IT_TC:   Transmission complete interrupt. 
   1126            *            @arg USART_IT_RXNE: Receive Data register not empty interrupt.
   1127            *
   1128            * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
   1129            *          error) and IDLE (Idle line detected) pending bits are cleared by 
   1130            *          software sequence: a read operation to USART_SR register 
   1131            *          (USART_GetITStatus()) followed by a read operation to USART_DR register 
   1132            *          (USART_ReceiveData()).
   1133            * @note   RXNE pending bit can be also cleared by a read to the USART_DR register 
   1134            *          (USART_ReceiveData()).
   1135            * @note   TC pending bit can be also cleared by software sequence: a read 
   1136            *          operation to USART_SR register (USART_GetITStatus()) followed by a write 
   1137            *          operation to USART_DR register (USART_SendData()).
   1138            * @note   TXE pending bit is cleared only by a write to the USART_DR register 
   1139            *          (USART_SendData()).
   1140            *  
   1141            * @retval None
   1142            */
   1143          
   1144          
   1145          /**
   1146            * @}
   1147            */
   1148          
   1149          /**
   1150            * @}
   1151            */
   1152          
   1153          /**
   1154            * @}
   1155            */
   1156          
   1157          /**
   1158            * @}
   1159            */
   1160          
   1161          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       32  InitUSART4
             32 -> GPIOPortInit
             32 -> NVIC_Init
             32 -> OSSemCreate
             32 -> USART4Printf
             32 -> USART_Cmd
             32 -> USART_ITConfig
             32 -> USART_Init
        0  USART4BuffClear
        8  USART4CheckByte
       24  USART4Printf
             24 -> OSTimeDly
             24 -> USART4PutToBuffer
             24 -> USART4TxCheckByte
             24 -> vsprintf
       16  USART4PutChar
             16 -> OSSemPend
             16 -> OSSemPost
       24  USART4PutStr
             24 -> OSSemPend
             24 -> OSSemPost
             24 -> USART4BuffClear
       16  USART4PutToBuffer
             16 -> OSSemPend
             16 -> OSSemPost
        0  USART4RxGetByte
        0  USART4TxCheckByte
        0  USART4TxClear
       16  USART4_IRQIntHandler
             16 -> CPU_SR_Restore
             16 -> CPU_SR_Save
              0 -> OSIntExit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Constant "\n">
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
       8  ?Subroutine0
       6  ?Subroutine1
     180  InitUSART4
    1024  Rx4Buff
      52  Rx4RdCnt
          Rx4WrCnt
          Tx4RdCnt
          Tx4WrCnt
          pUSART4
    1024  Tx4Buff
      10  USART4BuffClear
      56  USART4CheckByte
      66  USART4Printf
      42  USART4PutChar
      74  USART4PutStr
      60  USART4PutToBuffer
      42  USART4RxGetByte
      18  USART4TxCheckByte
       4  USART4TxClear
     114  USART4_IRQIntHandler

 
     2 bytes in section .rodata
   720 bytes in section .text
 2 100 bytes in section iram
 
   720 bytes of CODE  memory
     2 bytes of CONST memory
 2 100 bytes of DATA  memory

Errors: none
Warnings: none

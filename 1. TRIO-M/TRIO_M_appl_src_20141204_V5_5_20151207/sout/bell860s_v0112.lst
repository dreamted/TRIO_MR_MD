###############################################################################
#                                                                             #
#                                                       19/May/2017  23:29:00 #
# IAR ANSI C/C++ Compiler V5.50.5.21995/W32 EVALUATION for ARM                #
# Copyright (C) 1999-2010 IAR Systems AB.                                     #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Project\TRIO\1. TRIO-M\TRIO_M_appl_src_20141204_V5_5_ #
#                    20151207\dev\bellwave\bell860s_v0112.c                   #
#    Command line =  "D:\Project\TRIO\1. TRIO-M\TRIO_M_appl_src_20141204_V5_5 #
#                    _20151207\dev\bellwave\bell860s_v0112.c" -D _MIMO_Type   #
#                    -D __2rd -D __PLLEnToggle -lcN "D:\Project\TRIO\1.       #
#                    TRIO-M\TRIO_M_appl_src_20141204_V5_5_20151207\sout\" -o  #
#                    "D:\Project\TRIO\1. TRIO-M\TRIO_M_appl_src_20141204_V5_5 #
#                    _20151207\sout\" --endian=little --cpu=Cortex-M3 -e      #
#                    --require_prototypes --warnings_are_errors --fpu=None    #
#                    --dlib_config "D:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 5.4                           #
#                    Evaluation\arm\INC\DLib_Config_Normal.h" -I              #
#                    "D:\Project\TRIO\1. TRIO-M\TRIO_M_appl_src_20141204_V5_5 #
#                    _20151207\include\" -I "D:\Project\TRIO\1.               #
#                    TRIO-M\TRIO_M_appl_src_20141204_V5_5_20151207\lib_stm32\ #
#                    inc\" -I "D:\Project\TRIO\1.                             #
#                    TRIO-M\TRIO_M_appl_src_20141204_V5_5_20151207\lib_stm32\ #
#                    src\" -I "D:\Project\TRIO\1.                             #
#                    TRIO-M\TRIO_M_appl_src_20141204_V5_5_20151207\uC-CPU\"   #
#                    -I "D:\Project\TRIO\1. TRIO-M\TRIO_M_appl_src_20141204_V #
#                    5_5_20151207\uC-LIB\" -I "D:\Project\TRIO\1.             #
#                    TRIO-M\TRIO_M_appl_src_20141204_V5_5_20151207\uCOS-II\Po #
#                    rts\" -I "D:\Project\TRIO\1.                             #
#                    TRIO-M\TRIO_M_appl_src_20141204_V5_5_20151207\uCOS-II\So #
#                    urce\" -I "D:\Project\TRIO\1.                            #
#                    TRIO-M\TRIO_M_appl_src_20141204_V5_5_20151207\uC-Probe\" #
#                     -I "D:\Program Files (x86)\IAR Systems\Embedded         #
#                    Workbench 5.4 Evaluation\arm\INC\" -Oh                   #
#    List file    =  D:\Project\TRIO\1. TRIO-M\TRIO_M_appl_src_20141204_V5_5_ #
#                    20151207\sout\bell860s_v0112.lst                         #
#    Object file  =  D:\Project\TRIO\1. TRIO-M\TRIO_M_appl_src_20141204_V5_5_ #
#                    20151207\sout\bell860s_v0112.o                           #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\TRIO\1. TRIO-M\TRIO_M_appl_src_20141204_V5_5_20151207\dev\bellwave\bell860s_v0112.c
      1          /*******************************************************************************
      2           *
      3           * This module contains the function 7092 original header file, a function
      4           * whole things  initializations - global, include function and so on
      5           *
      6           *
      7           * Note that this function is called before the data segments are
      8           * initialized, this means that this function cannot rely on the
      9           * values of global or static variables.
     10           *
     11           *
     12           *
     13           * &Revision:
     14           * &Revision date: 
     15           ******************************************************************************/
     16          
     17          #define __BELL_C
     18           
     19          
     20          #include <stdarg.h>
     21          #include <stdlib.h>
     22          #include <stdio.h>
     23          #include <string.h>
     24          #include "../include/main.h"
     25          
     26          #define ____	USART1Printf("%s %d\n", __FUNCTION__, __LINE__);
     27          
     28          
     29          void BcMdemDebug(INT32U nDebug, INT32S *DebugPtr)
     30          {
     31          	BcMdebug = nDebug;
     32          	if(DebugPtr != NULL) dUartPtr = (__SerStrPtr *)(DebugPtr);
     33          	else				 dUartPtr = (__SerStrPtr *)(&pUSART1);
     34          
     35          }
     36          
     37          INT8S BcMdemInit(__SerStrPtr *uPtr, INT16U TimerRx)
     38          {
     39              INT8U CmdStep = RstCmd;
     40          	INT8U result = 0;
     41          	INT16U i = 0;
     42          	INT8U Ptr[100];
     43          	
     44          
     45          	// memory Allocation
     46          	if(dUartPtr == NULL)				return -1;			// error: debuguart not allocated --> BcMDebug excuted befor
     47          	if( (eUartPtr = uPtr) == NULL)		return -2;			// error: Excution Ptr not allocated --> 
     48          	
     49          	if( (BcMTimerRx = TimerRx) == NULL)	return -3;			// error: TimerValue Error
     50          	
     51          INIT_SEQUENCE : 
     52          
     53          //	USART1Printf("0 : CmdStep[%d][%d]>[%d] \n",CmdStep,ModemType,BcMRtryNo);
     54          
     55          	switch(CmdStep)
     56          	{
     57          		case RstCmd: 				BcMdemXmit(CdmaRstCmd); 			result = 0; break;
     58          		case ModemHangUpCmd : 		BcMdemXmit(CdmaModemHangUpCmd); 	result = 3; break;
     59          //		case ModemRptModeSetCmd :	BcMdemXmit(CdmaRptModeSetCmd); 		result = 1; break;
     60          		case VersionCmd : 			BcMdemXmit(CdmaVersionCmd); 		result = 2; break;
     61          		case ModemMinNumCmd : 		BcMdemXmit(CdmaModemMinNumCmd); 	result = 2; break;
     62          		case ModemEsnCmd :			
     63          		{
     64          //			if((BcMType == 0x0C)||(BcMType == 0x0D))
     65          				
     66          			if( ModemType == _WCMDA_Modem)
     67          			{
     68          				BcMdemXmit(WcdmaModemICCIDCmd); 	result = 2; break;
     69          			}
     70          			else
     71          			{
     72          				BcMdemXmit(CdmaModemEsnCmd);		result = 2; break;
     73          			}
     74          		}
     75          		case ModemTimeCmd : 		BcMdemXmit(CdmaModemTimeCmd); 		result = 2; break;
     76          
     77           	}
     78          		
     79          	switch(result)
     80          	{
     81          		case 0:
     82          			if(BcMdemSyncProtocolCheck())
     83          			{
     84          				if(BcMdemSyncCheck((char *)RxCdmaData) == 14) break;
     85          			}	
     86          			else return FALSE;
     87          			
     88          			if(BcMdemSyncProtocolCheck())
     89          			{
     90          				if(BcMdemSyncCheck((char *)RxCdmaData) != 14) return FALSE;
     91          			}
     92          			else return FALSE;
     93          		break;
     94          
     95          		case 1:
     96          			if(BcMdemSyncProtocolCheck())
     97          			{
     98          				if(BcMdemSyncCheck((char *)RxCdmaData) != 14) return FALSE;
     99          			}
    100          			else return FALSE;
    101          		break;
    102          
    103          		case 2:
    104          			if(BcMdemSyncProtocolCheck())
    105          			{
    106          				if(!BcMdemDataProtocolCheck(CmdStep))return FALSE;
    107          
    108          				if(CmdStep == ModemMinNumCmd)break;
    109          				
    110          				if(!BcMdemSyncProtocolCheck())							 return FALSE;
    111          				if(BcMdemSyncCheck((char *)RxCdmaData) != 14)			 return FALSE;
    112          			}
    113          			else return FALSE;
    114          		break;
    115          
    116          		case 3:
    117          			if(BcMdemSyncProtocolCheck())
    118          			{
    119          				for(i = 0; i < strlen(RspmsgHangup);i++)Ptr[i] = RxCdmaData[i];
    120          				Ptr[i] = 0;
    121          				if(BcMdemSyncCheck((char *)Ptr) != 30)return FALSE;
    122          				
    123          //				if(RxCdmaData[i] != '1')return FALSE;
    124          //				if(RxCdmaData[i] != '1')return TRUE;
    125          			}
    126          			else return FALSE;
    127          		break;
    128          		
    129          	}
    130          
    131          	if(CmdStep++ == ModemTimeCmd)	return TRUE;
    132          
    133          	goto INIT_SEQUENCE;
    134          }
    135          
    136          void BcMdemXmit(INT8U *dataPtr)
    137          {	
    138          	if(!eUartPtr) return;
    139          	eUartPtr->BuffClear();
    140          	eUartPtr->printf("%s\n", (char *)dataPtr);
    141          	if(BcMdebug) dUartPtr->printf("%s\n", (char *)dataPtr);
    142          }
    143          
    144          
    145          INT32S BcMdemMSGTx(char *DstTel, char *dataPtr, INT16U nlen)
    146          {
    147          	INT16U i = 0;
    148          	
    149          	INT8U Ptr[200];
    150          	INT32S nRet = TRUE;
    151          
    152          	if(nlen > SmsMaxLen) return -3;
    153          	if(nlen > SmsWanLen) nRet = 3;	
    154          
    155          
    156            	if(ModemType == _WCMDA_Modem)
    157          	{
    158          		sprintf((char *)TxCdmaData, "%s%s,%s,4098,0,0,0,", CdmaTxDataToSMSCmd, DstTel, BcMSrcTel);
    159           	}
    160           	else
    161          	{
    162          		sprintf((char *)TxCdmaData, "%s%s,%s,4098,,,,", CdmaTxDataToSMSCmd, DstTel, BcMSrcTel);
    163          	}
    164          
    165          	for(i = 0; i < nlen; i++)
    166          	{
    167          		sprintf((char *)Ptr, "%02X", dataPtr[i]);
    168          		strcat((char *)TxCdmaData, (const char *)Ptr);
    169          	}
    170          
    171          	BcMdemXmit((INT8U *)TxCdmaData);
    172           
    173          	if(BcMdemSyncProtocolCheck())
    174          	{
    175              	if(BcMdemSyncCheck((char *)RxCdmaData) == 14)
    176              	{
    177              	    if(nRet == 3) nRet = 4;
    178              	    else          nRet = 2;
    179              	} 
    180          		else  nRet = -2;
    181          		
    182          	}	
    183          	else return FALSE;
    184          
    185          	OSTimeDly(Time100mSec);
    186          
    187          	for(i = 0 ;i < 4; i++)
    188          		{
    189          			if(BcMdemSyncProtocolCheck())
    190          			{
    191          				if(BcMdemSyncCheck((char *)RxCdmaData) == 10)
    192          				{
    193          				         if(nRet == 4) nRet = 5;
    194          				    else if(nRet == 2) nRet = 6;
    195          				    else nRet = TRUE;
    196          				}
    197          				else  nRet = -1;
    198          			}
    199          			if( nRet != 2) break;
    200          			OSTimeDly(Time100mSec*2L);
    201          		}
    202          	
    203          	//  6: Sms Len Over 80 Bytes(Waringin), But Success, 1st Response OK, but 1st resonse data error, 2nd Response Data NOK
    204              //  5: Sms Len Over 80 Bytes(Waringin), But Success, 1st Response OK, but 1st resonse data error, 2nd Response Data OK
    205          	//  4: Sms Len over 80 Bytes(Warning) But Success, 1st Response OK, but 1st resonse data error, 2nd Rsponse No response
    206          	//  2: 1st Response OK, but 1st resonse data error, 2nd Rsponse No response
    207          	//  1: Modem Send Success
    208          	//  0: Modem No Response
    209          	// -1: 2nd Response Data Error
    210          	// -2: 1st Response Data Error, 2nd Response No response
    211          	// -3: Max Buffer Error
    212          	return nRet;
    213          }
    214          
    215          
    216          INT32S BcMdemMSGSentTx(char *DstTel,char *SentTel, char *dataPtr, INT16U nlen)
    217          {
    218          	INT16U i = 0;
    219          	
    220          	INT8U Ptr[200];
    221          	INT32S nRet = TRUE;
    222          
    223          	if(nlen > SmsMaxLen) return -3;
    224          	if(nlen > SmsWanLen) nRet = 3;	
    225          
    226          
    227          //	if((BcMType == 0x0C)||(BcMType == 0x0D))
    228          //	if( ModemType == _WCMDA_Modem)
    229          
    230          
    231          	if(ModemType == _WCMDA_Modem)
    232          	{
    233          		sprintf((char *)TxCdmaData, "%s%s,%s,4098,0,0,0,", CdmaTxDataToSMSCmd, DstTel, BcMSrcTel);
    234          	}
    235          	else
    236          	{
    237          		sprintf((char *)TxCdmaData, "%s%s,%s,4098,,,,", CdmaTxDataToSMSCmd, DstTel, BcMSrcTel);
    238          	}
    239          
    240          	for(i = 0; i < nlen; i++)
    241          	{
    242          		sprintf((char *)Ptr, "%02X", dataPtr[i]);
    243          		strcat((char *)TxCdmaData, (const char *)Ptr);
    244          	}
    245          
    246          	BcMdemXmit((INT8U *)TxCdmaData);
    247          
    248          	if(BcMdemSyncProtocolCheck())
    249          	{
    250              	if(BcMdemSyncCheck((char *)RxCdmaData) == 14)
    251              	{
    252              	    if(nRet == 3) nRet = 4;
    253              	    else          nRet = 2;
    254              	} 
    255          		else  nRet = -2;
    256          		
    257          	}	
    258          	else return FALSE;
    259          
    260          	OSTimeDly(Time100mSec);
    261          
    262          	for(i = 0 ;i < 4; i++)
    263          		{
    264          			if(BcMdemSyncProtocolCheck())
    265          			{
    266          				if(BcMdemSyncCheck((char *)RxCdmaData) == 10)
    267          				{
    268          				         if(nRet == 4) nRet = 5;
    269          				    else if(nRet == 2) nRet = 6;
    270          				    else nRet = TRUE;
    271          				}
    272          				else  nRet = -1;
    273          			}
    274          			if( nRet != 2) break;
    275          			OSTimeDly(Time100mSec*2L);
    276          		}
    277          	return nRet;
    278          }
    279          
    280          
    281          
    282          INT32S BcMdemTCPTx(char *dataPtr, INT16U nlen)
    283          {
    284          
    285              INT16U i;
    286          	INT8U Ptr[200];
    287          	INT32S nRet = TRUE;
    288          
    289          	sprintf((char *)TxCdmaData, "%s", CdmaModemTcpWrCmd);
    290          
    291          	for(i = 0; i < nlen; i++)
    292          	{
    293          		sprintf((char *)Ptr, "%02X", dataPtr[i]);
    294          		strcat((char *)TxCdmaData, (const char *)Ptr);
    295          	}
    296          
    297          	BcMdemXmit((INT8U *)TxCdmaData);
    298          
    299          	if(BcMdemSyncProtocolCheck())
    300          	{
    301          		if(BcMdemSyncCheck((char *)RxCdmaData) != 14) return FALSE;
    302          	}	
    303          	else return FALSE;
    304          
    305          	if(BcMdemSyncProtocolCheck())
    306          	{
    307          		if(BcMdemSyncCheck((char *)RxCdmaData) != 24) return FALSE;
    308          	}
    309          	else return FALSE;
    310          
    311          	return nRet;
    312          }
    313          
    314          INT32S BcMdemTCPRxCheck(INT8U *rbuf)
    315          {	
    316          	INT32S nRet = 0;
    317          	INT32U i = 0, j = 0, len = 0;
    318          	INT8S CheckDataBuff[20];
    319          	INT8U *tPtr = RxCdmaData;
    320          
    321          	if(BcMdemSyncProtocolCheck())
    322          	{
    323          		eUartPtr->BuffClear();
    324          		
    325          		for(i = 0; i < strlen(CdmaModemTcpRdCmd); i++)CheckDataBuff[i] = *tPtr++;
    326          
    327          		CheckDataBuff[i] = 0;
    328          
    329          		if(BcMdemSyncCheck((char *)CheckDataBuff) != 25)return FALSE;
    330          		
    331          		for(j = 0; *tPtr != 0; j++)
    332          		{
    333          			INT8U temp;
    334          
    335          			//if((*tPtr == 0x0D)||(*tPtr == 0x0A)) break;
    336          			
    337          			temp = atoh(*tPtr++);
    338          			temp = atoh(*tPtr++) + ( temp << 4 );
    339          			
    340          			rbuf[len++] = temp;
    341          		}
    342          				
    343          		nRet = len;
    344          		rbuf[len++] = 0;	// null data insert
    345          				
    346          	}	
    347          	else
    348          	{
    349          		nRet = FALSE;
    350          		eUartPtr->BuffClear();
    351          	}
    352          	
    353          	return nRet;
    354          }
    355          
    356          INT32S BcMdemSyncProtocolCheck(void)
    357          {
    358          	INT16U	Recv;
    359          	INT32S  DataCnt = 0;
    360          
    361          	TimerRegist(BcMTimerRx, Time1Sec * 15L);
    362          	//TimerRegist(BcMTimerRx, 600L*100L); // 1분
    363          
    364          	while(1)
    365          	{
    366          		if(TimeOverCheck(BcMTimerRx)) return FALSE;
    367          		/*
    368          		if(eUartPtr->CheckByte(1, &Recv))
    369          		{
    370          			RxCdmaData[DataCnt] = eUartPtr->RxGetByte();
    371          
    372          			if(BcMdebug) dUartPtr->PutChar(RxCdmaData[DataCnt]);	// debug
    373          
    374          			if ((DataCnt == 0)&&((RxCdmaData[DataCnt] == 0x0d)||(RxCdmaData[DataCnt] == 0x0a))) continue;
    375          		
    376          			if ( RxCdmaData[DataCnt++] == 0x0d )
    377          			{
    378          				RxCdmaData[DataCnt++] = 0x0a;
    379          				RxCdmaData[DataCnt++] = 0;		// insert null point
    380          
    381          				//if(RxCdmaData[0] == '$')
    382          				//{
    383          				//	Ret = BcMdemSyncCheck((char *)RxCdmaData);
    384          					
    385          				//	if((Ret == 15)||(Ret == 16))
    386          				//	{
    387          				//		DataCnt = 0;
    388          				//		continue;
    389          				//	}
    390          				//}
    391          				//Ser0Printf("DataCnt: %d, DataCnt - 3, %d \n", DataCnt, DataCnt-3);
    392          				return(DataCnt - 3);	// received length(2005.05.17 by bgyoon)
    393          			}
    394          			if(DataCnt > CdmaBuffLen ) return FALSE;
    395          		
    396          		}
    397          		else OSTimeDly(_OS_1ms);
    398          		*/
    399          
    400          		while(eUartPtr->CheckByte(1, &Recv))
    401          		{
    402          			RxCdmaData[DataCnt] = eUartPtr->RxGetByte();
    403          
    404          			if(BcMdebug) dUartPtr->PutChar(RxCdmaData[DataCnt]);	// debug
    405          
    406          			if ((DataCnt == 0)&&((RxCdmaData[DataCnt] == 0x0d)||(RxCdmaData[DataCnt] == 0x0a))) continue;
    407          		
    408          			if ( RxCdmaData[DataCnt++] == 0x0d )
    409          			{
    410          				RxCdmaData[DataCnt++] = 0x0a;
    411          				RxCdmaData[DataCnt++] = 0;		// insert null point
    412          
    413          				//if(RxCdmaData[0] == '$')
    414          				//{
    415          				//	Ret = BcMdemSyncCheck((char *)RxCdmaData);
    416          					
    417          				//	if((Ret == 15)||(Ret == 16))
    418          				//	{
    419          				//		DataCnt = 0;
    420          				//		continue;
    421          				//	}
    422          				//}
    423          //				USART1Printf("DataCnt: %d, DataCnt - 3, %d \n", DataCnt, DataCnt-3);
    424          				return(DataCnt - 3);	// received length(2005.05.17 by bgyoon)
    425          			}
    426          #if 0
    427          			RxCdmaData[DataCnt + 1] = 0x0A;
    428          			RxCdmaData[DataCnt + 2] = 0x00;
    429          			
    430          			if(BcMdebug) pPrintf(WaveDebugMode, "%s\r\n ", RxCdmaData);
    431          #endif			
    432          			
    433          			if(DataCnt >= CdmaBuffLen ) return FALSE;
    434          
    435          		}
    436          		OSTimeDly(1);
    437          	}
    438          }
    439          
    440          INT32S BcMdemSyncCheck(char *Ptr)
    441          {
    442          
    443          	if(Ptr == NULL || strlen(Ptr) == 0) 						return 0;
    444          
    445          	if(!strncmp(Ptr, RspTxAckmsg, strlen(RspTxAckmsg))) 		return 10;
    446          	if(!strncmp(Ptr, Rspconnect, strlen(Rspconnect))) 			return 11;
    447          	if(!strncmp(Ptr, Rspnocarr, strlen(Rspnocarr))) 			return 12;
    448          
    449          	if(!strncmp(Ptr, CdmaErr, strlen(CdmaErr))) 				return 13;
    450          	if(!strncmp(Ptr, CdmaOk, strlen(CdmaOk))) 					return 14;
    451          
    452          	if(!strncmp(Ptr, Rspmsg0Rx, strlen(Rspmsg0Rx))) 			return 15;
    453          	if(!strncmp(Ptr, Rspmsg1Rx, strlen(Rspmsg1Rx))) 			return 16;
    454          
    455          	if(!strncmp(Ptr, RspTxmsg, strlen(RspTxmsg))) 				return 17;
    456          
    457          	if(!strncmp(Ptr, RspTcpOpenOk, strlen(RspTcpOpenOk))) 		return 18;
    458          	if(!strncmp(Ptr, RspmsgRxCnt,  strlen(RspmsgRxCnt))) 		return 19;
    459          	if(!strncmp(Ptr, RspmsgRxMsg,  strlen(RspmsgRxMsg))) 		return 20;
    460          	if(!strncmp(Ptr, RspmsgRxEsn,  strlen(RspmsgRxEsn))) 		return 21;
    461          	if(!strncmp(Ptr, RspmsgRxRfSts,  strlen(RspmsgRxRfSts))) 	return 22;
    462          	if(!strncmp(Ptr, RspmsgTraffic,  strlen(RspmsgTraffic)))	return 23;
    463          	
    464          	if(!strncmp(Ptr, CdmaModemTcpSendDone, strlen(CdmaModemTcpSendDone)))return 24;
    465          	if(!strncmp(Ptr, CdmaModemTcpRdCmd,  strlen(CdmaModemTcpRdCmd)))	return 25;
    466          	if(!strncmp(Ptr, RspTcpCloseOk,  strlen(RspTcpCloseOk)))			return 26;
    467          	if(!strncmp(Ptr, RspmsgSwRst,  strlen(RspmsgSwRst)))				return 27;
    468          	if(!strncmp(Ptr, RspmsgCallAck,  strlen(RspmsgCallAck)))			return 28;
    469          	if(!strncmp(Ptr, RspmsgCallConnect,  strlen(RspmsgCallConnect)))	return 29;
    470          	if(!strncmp(Ptr, RspmsgHangup,  strlen(RspmsgHangup)))				return 30;
    471          	if(!strncmp(Ptr, RspmsgPilot,  strlen(RspmsgPilot)))				return 31;
    472          	if(!strncmp(Ptr, RspmsgMinNum,  strlen(RspmsgMinNum)))				return 32;
    473          	if(!strncmp(Ptr, RspmsgCallingCmd,  strlen(RspmsgCallingCmd)))		return 33;
    474          
    475          	if(!strncmp(Ptr, RspICCID,  strlen(RspICCID)))						return 34;
    476          
    477          	if(!strncmp(Ptr, RspLockOrder,	strlen(RspLockOrder)))				return 35;
    478          	
    479          	if(!strncmp(Ptr, RspGMMLockOrder, strlen(RspGMMLockOrder)))			return 36;
    480          	return -1;	// Normal Data
    481          }
    482          
    483          	
    484          INT8S  BcMdemDataProtocolCheck(INT8S Command)
    485          {
    486          	INT8S nRet = 0;
    487          	INT8U i = 0, j = 0 ;
    488          	INT8S CheckDataBuff[20];
    489          	
    490          	INT8U DataCnt=0, DataCnt2=0 ;
    491          
    492          	switch(Command)
    493          	{
    494          		case VersionCmd:
    495          
    496          			for(i = 0; RxCdmaData[i] != 0x0d; i++) {}
    497          
    498          			if(i < 6)return FALSE;
    499          
    500          			//////////////////////////////////////////////////////////////////////////
    501          			 // 단말기 제조사
    502          			if( (strstr(((char*)RxCdmaData), ((char*)"SAT"))) != NULL )
    503          			{
    504          				BcMMaker = 0x04;
    505          			}
    506          			else if( (strstr(((char*)RxCdmaData), ((char*)"KST"))) != NULL )
    507          			{
    508          				BcMMaker = 0x02;
    509          			}
    510          			else if( (strstr(((char*)RxCdmaData), ((char*)"ATS"))) != NULL )
    511          			{
    512          				BcMMaker = 0x03;
    513          			}
    514          			else if( (strstr(((char*)RxCdmaData), ((char*)"x05"))) != NULL )
    515          			{
    516          				BcMMaker = 0x05;
    517          			}
    518          			else if( (strstr(((char*)RxCdmaData), ((char*)"x06"))) != NULL )
    519          			{
    520          				BcMMaker = 0x06;////ANTS
    521          			}
    522          			else
    523          			{
    524          
    525          
    526          			}
    527          			//////////////////////////////////////////////////////////////////////////
    528          			// 단말기 Type
    529          			if( (strstr(((char*)RxCdmaData), ((char*)"ZZB3"))) != NULL )
    530          			{
    531          				BcMType = 0x05;
    532          				ModemType = _CMDA_Modem;
    533          			}
    534          			else if( (strstr(((char*)RxCdmaData), ((char*)"ZZB4"))) != NULL )
    535          			{
    536          				//SXC-2080
    537          				BcMType = 0x04;
    538          				ModemType = _CMDA_Modem;
    539          			}
    540          			else if( (strstr(((char*)RxCdmaData), ((char*)"ZZB5"))) != NULL )
    541          			{
    542          				BcMType = 0x06;
    543          				ModemType = _CMDA_Modem;
    544          			}
    545          			else if( (strstr(((char*)RxCdmaData), ((char*)"0x0C"))) != NULL )
    546          			{
    547          				BcMType = 0x0C;
    548          				
    549          				ModemType = _WCMDA_Modem;
    550          			}
    551          			else if( (strstr(((char*)RxCdmaData), ((char*)"0x0D"))) != NULL )
    552          			{
    553          				BcMType = 0x0D;   //////0x0D : ANTS-E300SWA(WCDMA내장형)
    554          				ModemType = _WCMDA_Modem;
    555          			}
    556          			else
    557          			{
    558          				ModemType = _WCMDA_Modem;
    559          			}
    560          
    561          			BcMVerNum[0] = RxCdmaData[i-3];
    562          			BcMVerNum[1] = RxCdmaData[i-2];
    563          			BcMVerNum[2] = RxCdmaData[i-1];
    564          
    565          			nRet = TRUE;
    566          		break;
    567          		
    568          		case ModemMinNumCmd:
    569          			for(i = 0; i < strlen(RspmsgMinNum);i++)
    570          			{
    571          				CheckDataBuff[i] = RxCdmaData[i];
    572          			}
    573          			CheckDataBuff[i] = 0;
    574          
    575          			if(BcMdemSyncCheck((char *)CheckDataBuff) != 32)return FALSE;
    576          		
    577          			nRet = TRUE;
    578          
    579          			for ( i=0; i<TelNo; i++ ) if ( RxCdmaData[strlen(RspmsgMinNum)+ (DataCnt++)] == '-' ) break;
    580            			{
    581          				INT8U Data,k = 0;
    582           				for ( j=0; j < TelNo; j++ )
    583          				{
    584          					Data = RxCdmaData[strlen(RspmsgMinNum)+ j];
    585           					if ( Data == 0x0d ) break;
    586          					if('-' == Data) 
    587          					{
    588          //						BcMSrcTel[j] = RxCdmaData[strlen(RspmsgMinNum)+ j];
    589          					}
    590          					else
    591          					{
    592          
    593          						BcMSrcTel[k++] = Data;
    594          					}
    595          					DataCnt2 = k;
    596           				}
    597           				DataCnt2 = DataCnt2;
    598           			}
    599            		break;
    600          
    601          		case ModemEsnCmd:
    602           			if( ModemType == _WCMDA_Modem)
    603          			{
    604          
    605          				for(i = 0; i < strlen(RspICCID);i++)CheckDataBuff[i] = RxCdmaData[i];
    606          
    607          				CheckDataBuff[i] = 0;
    608          				
    609          				if(BcMdemSyncCheck((char *)CheckDataBuff) != 34)return FALSE;
    610          				
    611          				for(j = 0; j < 19; j++, i++)ICCIDNum[j] = RxCdmaData[i];
    612          			
    613          				nRet = TRUE;
    614          			}
    615          			else
    616          			{
    617          				for(i = 0; i < strlen(RspmsgRxEsn);i++)CheckDataBuff[i] = RxCdmaData[i];
    618          
    619          				CheckDataBuff[i] = 0;
    620          				
    621          				if(BcMdemSyncCheck((char *)CheckDataBuff) != 21)return FALSE;
    622          				
    623          				for(j = 0; j < 8; j++, i++)BcMEsnNum[j] = RxCdmaData[i];
    624          			
    625          				nRet = TRUE;
    626          			}
    627          		break;
    628          		
    629          		case MsgCheckCmd:
    630          		{
    631          			for(i = 0; i < strlen(RspmsgRxCnt);i++)CheckDataBuff[i] = RxCdmaData[i];
    632          			
    633          			CheckDataBuff[i] = 0;
    634          
    635          			if(BcMdemSyncCheck((char *)CheckDataBuff) != 19) return FALSE;
    636          #if 0
    637          			if((RxCdmaData[i] < '0')||(RxCdmaData[i] > '9')) nRet = FALSE;
    638          			else if(RxCdmaData[i] == '0')					 nRet = NOT_DATA;
    639          			else 											 nRet = TRUE;
    640          #endif		
    641          
    642          #if 1
    643          			if(RxCdmaData[i] == '0')					 			 nRet = NOT_DATA;
    644          			else if((RxCdmaData[i] < '0')||(RxCdmaData[i] > '9'))	 nRet = FALSE;
    645          			else 													 nRet = TRUE;
    646          #endif		
    647          //			if(BcMdebug) dUartPtr->printf("1: MsgCheckCnt[%d]> %d\n", MsgCheckCnt,nRet);
    648          		}
    649          		break;
    650          		
    651          		case MsgReciveCmd:
    652          			for(i = 0; i < strlen(RspmsgRxMsg);i++)CheckDataBuff[i] = RxCdmaData[i];
    653          
    654          			CheckDataBuff[i] = 0;
    655          
    656          			if(BcMdemSyncCheck((char *)CheckDataBuff) != 20)return FALSE;
    657          			
    658          			if((RxCdmaData[i] < '0')||(RxCdmaData[i] > '9'))nRet = FALSE;
    659          			//else if(RxCdmaData[i] == '0')	nRet = NOT_DATA;			
    660          			else nRet = TRUE;
    661          
    662          			//if(RxCdmaData[i] == 0x22)i++;
    663          							
    664          			for(j = 0; RxCdmaData[i] != 0; j++,i++) RxBcMData[j] = RxCdmaData[i];
    665          			RxBcMData[j] = 0;
    666          
    667          		break;
    668          		
    669          		case ModemTimeCmd:
    670          
    671          			for(i = 0; i < strlen(RspmsgTraffic);i++)CheckDataBuff[i] = RxCdmaData[i];
    672          
    673          			CheckDataBuff[i] = 0;
    674          
    675          			if(BcMdemSyncCheck((char *)CheckDataBuff) != 23)return FALSE;
    676          			
    677          			i += 2; // Traffic Status skip
    678          
    679          			// Init
    680          			for(j = 0; j < sizeof(BcMTimeStr); j++) *((INT8U *)BcMpresentTime + j) = 0;
    681          
    682          			for(j = 0; j < 14; j++, i++) *((char *)BcMpresentTime + j) = RxCdmaData[i];
    683          			
    684          			nRet = TRUE;
    685          			
    686          		break;
    687          
    688          		case ModemRfStsCmd:
    689          			
    690          			for(i = 0; i < strlen(RspmsgRxRfSts);i++)CheckDataBuff[i] = RxCdmaData[i];
    691          
    692          			CheckDataBuff[i] = 0;
    693          
    694          			if(BcMdemSyncCheck((char *)CheckDataBuff) != 22)return FALSE;
    695          			
    696          			if((RxCdmaData[i] < '0')||(RxCdmaData[i] > '9'))return FALSE;
    697          
    698          			nRet = BcMFreqStateCheck( (INT8U *)&RxCdmaData[i] );
    699          			
    700          		break;
    701          
    702          		case ModemTrafficCmd:
    703          			
    704          			for(i = 0; i < strlen(RspmsgTraffic);i++)CheckDataBuff[i] = RxCdmaData[i];
    705          
    706          			CheckDataBuff[i] = 0;
    707          
    708          			if(BcMdemSyncCheck((char *)CheckDataBuff) != 23)return FALSE;
    709          
    710          			nRet = RxCdmaData[i];
    711            		break;
    712          
    713          		case ModemPilotCmd:
    714          			
    715          			for(i = 0; i < strlen(RspmsgPilot);i++)CheckDataBuff[i] = RxCdmaData[i];
    716          
    717          			CheckDataBuff[i] = 0;
    718          
    719           			if(BcMdemSyncCheck((char *)CheckDataBuff) != 31)return FALSE;
    720          			nRet = BcMPilotStateCheck( (INT8U *)&RxCdmaData[i]);
    721          		break;
    722          
    723          		case ModemLockOrderCmd:
    724           			{
    725          
    726          				for(i = 0; i < strlen(RspLockOrder);i++)CheckDataBuff[i] = RxCdmaData[i];
    727          
    728          				CheckDataBuff[i] = 0;
    729          				
    730          				if(BcMdemSyncCheck((char *)CheckDataBuff) != 35)return FALSE;
    731           			
    732          				nRet = TRUE;
    733          			}
    734           		break;
    735          		
    736          
    737          
    738          		
    739          		default : return FALSE;
    740          	}	
    741          
    742          	return nRet;
    743          	
    744          }
    745          
    746          INT8S BcMFreqStateCheck ( INT8U *DataBuff )
    747          {
    748           	if( ModemType == _WCMDA_Modem)
    749          	{
    750          		INT8U	i, j, k = 0, DataCnt=0, DataCnt2=0, pw;
    751          		INT16S	TempCopy, Power, Actch = 0, chlist = 0;
    752          		INT16S	PSClist = 0;
    753          
    754          
    755                  k = k;
    756                  Actch = Actch;
    757                  chlist = chlist;
    758          		//================//
    759          		// Active Channel //
    760          		//========================================================================//
    761          		DataCnt2 = DataCnt;
    762          		TempCopy = 0;
    763          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
    764          		for ( j=0; j<i; j++ )
    765          		{
    766          			if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
    767          			for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
    768          			TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
    769          		}
    770          		
    771          		Actch = TempCopy;
    772          		BcMRfStatus->ActChannel = TempCopy;
    773          
    774          //		USART1Printf("BcMRfStatus->ActChannel : %d \n", BcMRfStatus->ActChannel);
    775          
    776          		//=====================//
    777          		// Number Of Channel //
    778          		//========================================================================//
    779          		DataCnt2 = DataCnt;
    780          		TempCopy = 0;
    781          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
    782          		for ( j=0; j<i; j++ )
    783          		{
    784          			if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
    785          			for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
    786          			TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
    787          		}
    788          		
    789          		BcMRfStatus->NumberOfChannel = TempCopy;
    790          		
    791          		if ( TempCopy == 0 ) return(FALSE);
    792          		
    793          		//SWaveStatus->ChannelList = ( ((TempCopy/10)<<4) + (TempCopy%10) );
    794          		chlist = TempCopy;
    795          
    796          //		USART1Printf("chlist : %d \n", chlist);
    797          		//==============//
    798          		// Channel List //
    799          		//========================================================================//
    800          		for ( k=0; k<chlist; k++ )
    801          		{
    802          			DataCnt2 = DataCnt;
    803          			TempCopy = 0;
    804          			for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
    805          			
    806          //			USART1Printf("0: PN_Vaule : [%d][%d][%d] \n", i,k,BcMRfStatus->PN_Vaule[k]);
    807          			if ( i > 6 ) return(FALSE);
    808          
    809          			for ( j=0; j<i; j++ )
    810          			{
    811          //				USART1Printf("1: PN_Vaule : [%d][%d] \n", k,BcMRfStatus->PN_Vaule[k]);
    812          
    813          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
    814          				for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
    815          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
    816          			}
    817          			
    818          			BcMRfStatus->PN_Vaule[k] = TempCopy;
    819          			if ( Actch == TempCopy ){}
    820          
    821          //			USART1Printf("2: PN_Vaule : [%d][%d] \n", k,BcMRfStatus->PN_Vaule[k]);
    822          		}		
    823          
    824          		//================//
    825          		// Active PSC     //
    826          		//========================================================================//
    827          		DataCnt2 = DataCnt;
    828          		TempCopy = 0;
    829          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
    830          		for ( j=0; j<i; j++ )
    831          		{
    832          			if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
    833          			for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
    834          			TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
    835          		}
    836          		
    837          		BcMRfStatus->PSClist = TempCopy;
    838          		
    839          		if ( TempCopy == 0 ) return(FALSE);
    840          		
    841          		//SWaveStatus->ChannelList = ( ((TempCopy/10)<<4) + (TempCopy%10) );
    842          		PSClist = TempCopy;
    843          
    844          //		USART1Printf("PSClist : %d \n", PSClist);
    845          
    846          		//==============//
    847          		// PSC List //
    848          		//========================================================================//
    849          		for ( k=0; k<PSClist; k++ )
    850          		{
    851          			DataCnt2 = DataCnt;
    852          			TempCopy = 0;
    853          		
    854          			for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == '(' ) break;
    855          			
    856          			if ( i > 6 ) return(FALSE);
    857          			for ( j=0; j<i; j++ )
    858          			{
    859          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
    860          				for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
    861          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
    862          			}
    863          			
    864          			BcMRfStatus->PSC_Vaule[k] = TempCopy;
    865          //			USART1Printf("0: PSC_Vaule : [%d][%d] \n", k,BcMRfStatus->PSC_Vaule[k]);
    866          			DataCnt2 = DataCnt;
    867          			TempCopy = 0;
    868          			for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ')' ) break;
    869          			DataCnt++;		// Remove ','
    870          			
    871          			if ( DataBuff[DataCnt2] == '-' )
    872          			{
    873          				DataCnt2++;
    874          				for ( j=0; j<i-1; j++ )
    875          				{
    876          					if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
    877          					for ( Power=1,pw=j; pw<i-2; pw++ ) Power *= 10;
    878          					TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
    879          				}
    880          				TempCopy = -TempCopy;
    881          				BcMRfStatus->EcIo[k] = TempCopy;
    882          			}
    883          			else
    884          			{
    885          				for ( j=0; j<i; j++ )
    886          				{
    887          					if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
    888          					for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
    889          					TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
    890          				}
    891          				BcMRfStatus->EcIo[k] = TempCopy;
    892          			}
    893          //			USART1Printf("2: EcIo : [%d][%d][%d] \n", i,k,BcMRfStatus->EcIo[k]);
    894          		}
    895          
    896          //		FER_VAULE:
    897          		//===========//
    898          		// BER Value //
    899          		//========================================================================//
    900          		DataCnt2 = DataCnt;
    901          		TempCopy = 0;
    902          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
    903          		for ( j=0; j<i; j++ )
    904          		{
    905          			if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
    906          			for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
    907          			TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
    908          		}
    909          		
    910          		BcMRfStatus->BER = TempCopy;
    911          //		USART1Printf("2: BER : [%d] \n",BcMRfStatus->BER);
    912          		//==========//
    913          		// RX Value //
    914          		//========================================================================//
    915          		DataCnt2 = DataCnt;
    916          		TempCopy = 0;
    917          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
    918          		if ( DataBuff[DataCnt2] == '-' )
    919          		{
    920          			DataCnt2++;
    921          			for ( j=0; j<i-1; j++ )
    922          			{
    923          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
    924          				for ( Power=1,pw=j; pw<i-2; pw++ ) Power *= 10;
    925          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
    926          			}
    927          			TempCopy = -TempCopy;
    928          			BcMRfStatus->RxValue = TempCopy;
    929          		}
    930          		else
    931          		{
    932          			for ( j=0; j<i; j++ )
    933          			{
    934          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
    935          				for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
    936          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
    937          			}
    938          			BcMRfStatus->RxValue = TempCopy;
    939          		}
    940          //		USART1Printf("2: RxValue : [%d] \n",BcMRfStatus->RxValue);
    941          
    942          		//========================================================================//
    943          		if ( TempCopy > 0 ) return(FALSE);
    944          
    945          		//==========//
    946          		// TX Value //
    947          		//========================================================================//
    948          		DataCnt2 = DataCnt;
    949          		TempCopy = 0;
    950          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
    951          		if ( DataBuff[DataCnt2] == '-' )
    952          		{
    953          			DataCnt2++;
    954          			for ( j=0; j<i-1; j++ )
    955          			{
    956          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
    957          				for ( Power=1,pw=j; pw<i-2; pw++ ) Power *= 10;
    958          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
    959          			}
    960          			TempCopy = -TempCopy;
    961          			BcMRfStatus->TxValue = TempCopy;
    962          		}
    963          		else
    964          		{
    965          			for ( j=0; j<i; j++ )
    966          			{
    967          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
    968          				for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
    969          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
    970          			}
    971          			BcMRfStatus->TxValue = TempCopy;
    972          		}
    973          
    974          //		USART1Printf("2: TxValue : [%d] \n",BcMRfStatus->TxValue);
    975           	
    976          		//===========//
    977          		// ADJ Value //
    978          		//========================================================================//
    979          		DataCnt2 = DataCnt;
    980          		TempCopy = 0;
    981          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == 0x0d ) break;
    982          		if ( DataBuff[DataCnt2] == '-' )
    983          		{
    984          			DataCnt2++;
    985          			for ( j=0; j<i-1; j++ )
    986          			{
    987          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
    988          				for ( Power=1,pw=j; pw<i-2; pw++ ) Power *= 10;
    989          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
    990          			}
    991          			TempCopy = -TempCopy;
    992          			BcMRfStatus->AdjValue = TempCopy;
    993          			
    994          		}
    995          		else
    996          		{
    997          			for ( j=0; j<i; j++ )
    998          			{
    999          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   1000          				for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   1001          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   1002          			}
   1003          			BcMRfStatus->AdjValue = TempCopy;
   1004          		}
   1005          //		USART1Printf("2: AdjValue : [%d] \n",BcMRfStatus->AdjValue);
   1006           	}
   1007          	else
   1008          	{
   1009          		INT8U	i, j, k, DataCnt=0, DataCnt2=0, pw;
   1010          		INT16S		TempCopy, Power, Actch, chlist;
   1011          		//================//
   1012          		// Active Channel //
   1013          		//========================================================================//
   1014          		DataCnt2 = DataCnt;
   1015          		TempCopy = 0;
   1016          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   1017          		for ( j=0; j<i; j++ )
   1018          		{
   1019          			if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   1020          			for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   1021          			TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   1022          		}
   1023          		Actch = TempCopy;
   1024          		BcMRfStatus->ActChannel = TempCopy;
   1025          
   1026          		//SWaveStatus->OneFAStatus = 0x03;		// Current FA
   1027          		//========================================================================//
   1028          
   1029          		//=====================//
   1030          		// Number Of Channel //
   1031          		//========================================================================//
   1032          		DataCnt2 = DataCnt;
   1033          		TempCopy = 0;
   1034          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   1035          		for ( j=0; j<i; j++ )
   1036          		{
   1037          			if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   1038          			for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   1039          			TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   1040          		}
   1041          
   1042          		BcMRfStatus->NumberOfChannel = TempCopy;
   1043          
   1044          		if ( TempCopy == 0 ) return(FALSE);
   1045          
   1046          		//SWaveStatus->ChannelList = ( ((TempCopy/10)<<4) + (TempCopy%10) );
   1047          		chlist = TempCopy;
   1048          
   1049          		//==============//
   1050          		// Channel List //
   1051          		//========================================================================//
   1052          		for ( k=0; k<chlist; k++ )
   1053          		{
   1054          			DataCnt2 = DataCnt;
   1055          			TempCopy = 0;
   1056          			for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   1057          			if ( i > 4 ) return(FALSE);
   1058          			for ( j=0; j<i; j++ )
   1059          			{
   1060          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   1061          				for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   1062          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   1063          			}
   1064          			
   1065          			BcMRfStatus->PN_Vaule[k] = TempCopy;
   1066          			if ( Actch == TempCopy ){}
   1067          				
   1068          		}
   1069          		//========================================================================//
   1070          
   1071          		//=======================//
   1072          		// Number Of Active PN	//
   1073          		//========================================================================//
   1074          		DataCnt2 = DataCnt;
   1075          		TempCopy = 0;
   1076          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   1077          		if ( i > 1 ) return(FALSE);
   1078          
   1079          		if(DataBuff[DataCnt2]  == '0')goto FER_VAULE;
   1080          
   1081          		for ( j=0; j<i; j++ )
   1082          		{
   1083          			if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   1084          			for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   1085          			TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   1086          		}
   1087          		BcMRfStatus->ActPN = TempCopy;
   1088          		//	Ser0Printf("ActPN : %d	\n", Rf_sts.ActPN);
   1089          
   1090          		if ( (TempCopy > 6)||(TempCopy < 1 ) ) return(FALSE);
   1091          		chlist = TempCopy;
   1092          		//========================================================================//
   1093          
   1094          
   1095          		//============================//
   1096          		// Active Channel Ec/Io Value //
   1097          		//========================================================================//
   1098          		for ( k=0; k<chlist; k++ )
   1099          		{
   1100          			DataCnt2 = DataCnt;
   1101          			TempCopy = 0;
   1102          
   1103          			for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == '(' ) break;
   1104          			if ( i > 4 ) return(FALSE);
   1105          			for ( j=0; j<i; j++ )
   1106          			{
   1107          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   1108          				for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   1109          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   1110          			}
   1111          			
   1112          			BcMRfStatus->PN_Vaule[k] = TempCopy;
   1113          			
   1114          			DataCnt2 = DataCnt;
   1115          			TempCopy = 0;
   1116          			for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ')' ) break;
   1117          			DataCnt++;		// Remove ','
   1118          			if ( DataBuff[DataCnt2] == '-' )
   1119          			{
   1120          				DataCnt2++;
   1121          				for ( j=0; j<i-1; j++ )
   1122          				{
   1123          					if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   1124          					for ( Power=1,pw=j; pw<i-2; pw++ ) Power *= 10;
   1125          					TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   1126          				}
   1127          				TempCopy = -TempCopy;
   1128          				BcMRfStatus->EcIo[k] = TempCopy;
   1129          			}
   1130          			else
   1131          			{
   1132          				for ( j=0; j<i; j++ )
   1133          				{
   1134          					if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   1135          					for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   1136          					TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   1137          				}
   1138          				BcMRfStatus->EcIo[k] = TempCopy;
   1139          			}
   1140          		}
   1141          		///////
   1142          
   1143          		for ( k=chlist; k<6; k++ )
   1144          		{
   1145          			BcMRfStatus->PN_Vaule[k] = 0;
   1146          			BcMRfStatus->EcIo[k]	 = 0;
   1147          		}
   1148          		//========================================================================//
   1149          
   1150          		FER_VAULE:
   1151          		//===========//
   1152          		// FER Value //
   1153          		//========================================================================//
   1154          		DataCnt2 = DataCnt;
   1155          		TempCopy = 0;
   1156          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   1157          		for ( j=0; j<i; j++ )
   1158          		{
   1159          			if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   1160          			for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   1161          			TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   1162          		}
   1163          
   1164          		BcMRfStatus->FerValue = TempCopy;
   1165          		//========================================================================//
   1166          
   1167          		//==========//
   1168          		// RX Value //
   1169          		//========================================================================//
   1170          		DataCnt2 = DataCnt;
   1171          		TempCopy = 0;
   1172          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   1173          		if ( DataBuff[DataCnt2] == '-' )
   1174          		{
   1175          			DataCnt2++;
   1176          			for ( j=0; j<i-1; j++ )
   1177          			{
   1178          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   1179          				for ( Power=1,pw=j; pw<i-2; pw++ ) Power *= 10;
   1180          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   1181          			}
   1182          			TempCopy = -TempCopy;
   1183          			BcMRfStatus->RxValue = TempCopy;
   1184          		}
   1185          		else
   1186          		{
   1187          			for ( j=0; j<i; j++ )
   1188          			{
   1189          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   1190          				for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   1191          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   1192          			}
   1193          			BcMRfStatus->RxValue = TempCopy;
   1194          		}
   1195          
   1196          		//========================================================================//
   1197          		if ( TempCopy > 0 ) return(FALSE);
   1198          
   1199          		//==========//
   1200          		// TX Value //
   1201          		//========================================================================//
   1202          		DataCnt2 = DataCnt;
   1203          		TempCopy = 0;
   1204          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   1205          		if ( DataBuff[DataCnt2] == '-' )
   1206          		{
   1207          			DataCnt2++;
   1208          			for ( j=0; j<i-1; j++ )
   1209          			{
   1210          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   1211          				for ( Power=1,pw=j; pw<i-2; pw++ ) Power *= 10;
   1212          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   1213          			}
   1214          			TempCopy = -TempCopy;
   1215          			BcMRfStatus->TxValue = TempCopy;
   1216          		}
   1217          		else
   1218          		{
   1219          			for ( j=0; j<i; j++ )
   1220          			{
   1221          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   1222          				for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   1223          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   1224          			}
   1225          			BcMRfStatus->TxValue = TempCopy;
   1226          		}
   1227          
   1228          		//===========//
   1229          		// ADJ Value //
   1230          		//========================================================================//
   1231          		DataCnt2 = DataCnt;
   1232          		TempCopy = 0;
   1233          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == 0x0d ) break;
   1234          		if ( DataBuff[DataCnt2] == '-' )
   1235          		{
   1236          			DataCnt2++;
   1237          			for ( j=0; j<i-1; j++ )
   1238          			{
   1239          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   1240          				for ( Power=1,pw=j; pw<i-2; pw++ ) Power *= 10;
   1241          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   1242          			}
   1243          			TempCopy = -TempCopy;
   1244          			BcMRfStatus->AdjValue = TempCopy;
   1245          			
   1246          		}
   1247          		else
   1248          		{
   1249          			for ( j=0; j<i; j++ )
   1250          			{
   1251          				if ( (DataBuff[DataCnt2] < 0x30)||(DataBuff[DataCnt2] > 0x39) ) return(FALSE);
   1252          				for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   1253          				TempCopy = TempCopy + (DataBuff[DataCnt2++]-'0')*Power;
   1254          			}
   1255          			BcMRfStatus->AdjValue = TempCopy;
   1256          		}
   1257          		//========================================================================//
   1258          	}
   1259          	return(TRUE);
   1260          }
   1261          
   1262          INT8S BcMPilotStateCheck ( INT8U *DataBuff )
   1263          {
   1264          	INT8U 	i, j, DataCnt=0, DataCnt2=0, pw;
   1265          	INT8U   k;
   1266          	INT16S	TempCopy, Power;
   1267          	INT8U	uTemp;
   1268           
   1269          	//============================//
   1270          	// Active Channel Ec/Io Value //
   1271          	//========================================================================//
   1272          
   1273          	DataCnt = 0;
   1274          	TempCopy = 0;
   1275          
   1276          
   1277          	for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   1278          	for ( j=0; j<(DataCnt-1); j++ )
   1279          	{
   1280          		for ( Power=1,pw=j; pw<i-1; pw++ ) Power *= 10;
   1281          		TempCopy = TempCopy + (DataBuff[j]-'0')*Power;
   1282          	}
   1283          	BcMPilotStatus->PN_Vaule[0] = TempCopy;
   1284          
   1285          	if (DataBuff[DataCnt] == '-' )DataCnt++;
   1286          
   1287          	DataCnt2 = DataCnt;
   1288          	TempCopy = 0;
   1289          	k = DataCnt;		
   1290          
   1291           	for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   1292          	for ( i=0; i<10; i++ ) if ( DataBuff[k++] == '.' ) break;
   1293          	if(i>(DataCnt-DataCnt2))	{k=DataCnt; i=DataCnt-DataCnt2-1;}			// 130304
   1294          
   1295          	for ( j = DataCnt2; j < (k-1); j++ )
   1296          	{
   1297          		for ( Power=1,pw = (j - DataCnt2) ; pw < (i - 1); pw++ ) Power =  Power * 10;
   1298          		TempCopy = TempCopy + (DataBuff[j]-'0')*Power;
   1299          	}
   1300          	BcMPilotStatus->EcIo[0] = TempCopy;
   1301           
   1302          	DataCnt2 = DataCnt;
   1303          	TempCopy = 0;
   1304          
   1305          	for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   1306          	for ( j=DataCnt2; j<(DataCnt-1); j++ )
   1307          	{
   1308          		for ( Power=1,pw = (j - DataCnt2) ; pw < (i - 1); pw++ ) Power =  Power * 10;
   1309          		TempCopy = TempCopy + (DataBuff[j]-'0')*Power;
   1310          	}
   1311          	BcMPilotStatus->PN_Vaule[1] = TempCopy;;
   1312          
   1313          	{
   1314          		
   1315           		if (DataBuff[DataCnt] == '-' )DataCnt++;
   1316          
   1317          		DataCnt2 = DataCnt;
   1318          		TempCopy = 0;
   1319          		k = DataCnt;
   1320           
   1321          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   1322          		for ( i=0; i<10; i++ ) if ( DataBuff[k++] == '.' ) break;
   1323          		if(i>(DataCnt-DataCnt2)) {k=DataCnt; i=DataCnt-DataCnt2-1;}				// 130304
   1324          
   1325          		
   1326          
   1327          		for ( j = DataCnt2; j < (k-1); j++ )
   1328          		{
   1329           			for ( Power=1,pw = (j - DataCnt2) ; pw < (i - 1); pw++ ) Power =  Power * 10;
   1330          			TempCopy = TempCopy + (DataBuff[j]-'0')*Power;
   1331            		}
   1332          		BcMPilotStatus->EcIo[1] = TempCopy;;
   1333          
   1334           		DataCnt2 = DataCnt;
   1335          		TempCopy = 0;
   1336          		for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   1337          
   1338          
   1339          		for ( j=DataCnt2; j<(DataCnt-1); j++ )
   1340          		{
   1341          			for ( Power=1,pw = (j - DataCnt2) ; pw < (i - 1); pw++ ) Power =  Power * 10;
   1342           			TempCopy = TempCopy + (DataBuff[j]-'0')*Power;
   1343           		}
   1344          		BcMPilotStatus->PN_Vaule[2] = (INT8U )TempCopy;;
   1345           	}
   1346          
   1347          	
   1348           	if (DataBuff[DataCnt] == '-' )DataCnt++;
   1349          
   1350          	DataCnt2 = DataCnt;
   1351          	TempCopy = 0;
   1352          	k = DataCnt;		
   1353          
   1354          	for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   1355          	for ( i=0; i<10; i++ ) if ( DataBuff[k++] == '.' ) break;
   1356          	if(i>(DataCnt-DataCnt2)) {k=DataCnt; i=DataCnt-DataCnt2-1;} 			// 130304
   1357           
   1358          	for ( j = DataCnt2; j < (k-1); j++ )
   1359          	{
   1360          		for ( Power=1,pw = (j - DataCnt2) ; pw < (i - 1); pw++ ) Power =  Power * 10;
   1361          		TempCopy = TempCopy + (DataBuff[j]-'0')*Power;
   1362          	}
   1363          	BcMPilotStatus->EcIo[2] = TempCopy;
   1364          
   1365          	DataCnt2 = DataCnt;
   1366          	TempCopy = 0;
   1367          
   1368          	for ( i=0; i<10; i++ ) if ( DataBuff[DataCnt++] == ',' ) break;
   1369          
   1370          	for ( j=DataCnt2; j<(DataCnt-1); j++ )
   1371          	{
   1372          		for ( Power=1,pw = (j - DataCnt2) ; pw < (i - 1); pw++ ) Power =  Power * 10;
   1373          		TempCopy = TempCopy + (DataBuff[j]-'0')*Power;
   1374          	}
   1375          
   1376          	BcMPilotStatus->PN_Vaule[3] = TempCopy;
   1377          
   1378           // EcIO 3	
   1379          	if (DataBuff[DataCnt] == '-' )DataCnt++;
   1380          
   1381          	DataCnt2 = DataCnt;
   1382          	TempCopy = 0;
   1383          	k = DataCnt;		
   1384          
   1385          	for ( i=0; i<10; i++ )
   1386          	{
   1387          		uTemp = DataBuff[DataCnt++];
   1388          		if ((uTemp == ',') || (uTemp == NULL)|| (uTemp == 0x0d))	break;		// 130304
   1389          	}
   1390          	for ( i=0; i<10; i++ ) if ( DataBuff[k++] == '.' ) break;
   1391          	if(i>(DataCnt-DataCnt2))	{k=DataCnt; i=DataCnt-DataCnt2-1;}				// 130304
   1392          
   1393          
   1394          	for ( j = DataCnt2; j < (k-1); j++ )
   1395          	{
   1396          		for ( Power=1,pw = (j - DataCnt2) ; pw < (i - 1); pw++ ) Power =  Power * 10;
   1397          		TempCopy = TempCopy + (DataBuff[j]-'0')*Power;
   1398          	}
   1399          	BcMPilotStatus->EcIo[3] = TempCopy;;
   1400            	return(TRUE);
   1401          }
   1402          
   1403          
   1404          INT32S BcMdemTcpConnect(INT8U *ConnectIP, INT8U IPLen, INT32U PortNum)
   1405          {
   1406              INT8U CmdStep = 0,result = 0;
   1407          	INT8U CmdStepCnt = 0;
   1408          
   1409          	INT8U Tmp = FALSE;
   1410          
   1411          	CmdStep = ModemTcpModeCmd;
   1412          	
   1413          TCP_INIT_SEQUENCE : 
   1414          
   1415          	if( CmdStepCnt > 4) return FALSE;
   1416          
   1417          	switch(CmdStep)
   1418          	{
   1419          		case ModemTcpModeCmd: 	BcMdemXmit(CdmaModemTcpModeCmd); 	result = 0; break;
   1420          		case ModemTcpIdCmd: 	BcMdemXmit(CdmaModemTcpIdCmd); 		result = 0; break;
   1421          		case ModemTcpPwCmd: 	BcMdemXmit(CdmaModemTcpPwCmd); 		result = 0; break;
   1422          		case ModemTcpConnect: 	BcMdemXmit(CdmaModemTcpConnect); 	result = 1; break;
   1423          		case ModemTcpOpenCmd: 	
   1424          
   1425          			ConnectIP[IPLen] = 0; //Insert Null
   1426          			sprintf((char *)TxCdmaData, "%s%s,%d", CdmaModemTcpOpenCmd,ConnectIP, PortNum);
   1427          			BcMdemXmit((INT8U *)TxCdmaData);
   1428          	
   1429          			result = 2; 
   1430          		break;
   1431          	}
   1432          	OSTimeDly(500L);
   1433          	CmdStepCnt++;
   1434          	switch(result)
   1435          	{
   1436          		case 0:
   1437          			if(BcMdemSyncProtocolCheck())
   1438          			{
   1439          				if(BcMdemSyncCheck((char *)RxCdmaData) != 14)return FALSE;
   1440          			}
   1441          			else return FALSE;
   1442          			CmdStepCnt = 0;		
   1443          			Tmp = TRUE;
   1444          		break;
   1445          
   1446          		case 1:
   1447          			if(BcMdemSyncProtocolCheck())
   1448          			{	
   1449          				if(BcMdemSyncCheck((char *)RxCdmaData) == 11)
   1450          				{
   1451          					Tmp = TRUE;
   1452          					break;  		//"CONNECT"	
   1453          				}
   1454          				if(BcMdemSyncCheck((char *)RxCdmaData) != 14)return FALSE; 	//"OK"
   1455          			}
   1456          			else return FALSE;
   1457          			
   1458          			if(BcMdemSyncProtocolCheck())
   1459          			{
   1460          				if(BcMdemSyncCheck((char *)RxCdmaData) != 11)return FALSE;
   1461          			}
   1462          			else return FALSE;
   1463          			CmdStepCnt = 0;		
   1464          			Tmp = TRUE;
   1465          		break;
   1466          
   1467          		case 2:
   1468          			if(BcMdemSyncProtocolCheck())
   1469          			{
   1470          				if(BcMdemSyncCheck((char *)RxCdmaData) != 14)return FALSE;
   1471          			}
   1472          			else return FALSE;
   1473          			
   1474          			if(BcMdemSyncProtocolCheck())
   1475          			{	
   1476          				if(BcMdemSyncCheck((char *)RxCdmaData) != 18)return FALSE;
   1477          				
   1478          			}
   1479          			else return FALSE;
   1480          			CmdStepCnt = 0;		
   1481          			Tmp = TRUE;
   1482          		break;
   1483          		
   1484          	}
   1485          
   1486          	if(CmdStep == ModemTcpOpenCmd)return TRUE;
   1487          //	CmdStep++;
   1488          	if(	Tmp == TRUE )	CmdStep++;
   1489          	goto TCP_INIT_SEQUENCE;
   1490          }
   1491          
   1492          INT32S BcMdemTcpExit(void)
   1493          { 
   1494          	INT8U nRet = TRUE;
   1495          	
   1496          	BcMdemXmit(CdmaModemTcpCloseCmd);
   1497          
   1498          	if(BcMdemSyncProtocolCheck())
   1499          	{
   1500          		if(BcMdemSyncCheck((char *)RxCdmaData) != 14)return 1;
   1501          
   1502          	}
   1503          	else return FALSE;
   1504          	
   1505          	OSTimeDly(Time10mSec);
   1506          
   1507          	if(BcMdemSyncProtocolCheck())
   1508          	{
   1509          		if(BcMdemSyncCheck((char *)RxCdmaData) != 26)return 2;
   1510          	}
   1511          	else return FALSE;
   1512          
   1513          	OSTimeDly(Time10mSec);
   1514          	
   1515          	BcMdemXmit(CdmaModemTcpExitCmd);
   1516          
   1517          	if(BcMdemSyncProtocolCheck())
   1518          	{
   1519          		if(BcMdemSyncCheck((char *)RxCdmaData) != 14)return 3;
   1520          	}
   1521          	else return FALSE;
   1522          
   1523          	OSTimeDly(Time10mSec);
   1524          
   1525          	if(BcMdemSyncProtocolCheck())
   1526          	{
   1527          		if(BcMdemSyncCheck((char *)RxCdmaData) != 12)return 4;
   1528          	}
   1529          	else return FALSE;
   1530          
   1531          	return nRet;
   1532          }	
   1533          
   1534          INT32S BcMdemSwReset(void)
   1535          { 
   1536          	INT8U nRet = TRUE;
   1537          	
   1538          	BcMdemXmit(CdmaModemSwRstCmd);
   1539          
   1540          	if(BcMdemSyncProtocolCheck())
   1541          	{
   1542          		if(BcMdemSyncCheck((char *)RxCdmaData) != 27)return FALSE;
   1543          	}
   1544          	else return FALSE;
   1545          
   1546          	OSTimeDly(Time10mSec);
   1547          
   1548          	if(BcMdemSyncProtocolCheck())
   1549          	{
   1550          		if(BcMdemSyncCheck((char *)RxCdmaData) != 14)return FALSE;
   1551          	}
   1552          	else return FALSE;
   1553          
   1554          	return nRet;
   1555          }	
   1556          
   1557          // RETRUN DEFINE
   1558          // -1 : *SKT*ORI Error
   1559          // -2 : OK Error
   1560          // -3 : *SKT*VCALL Error
   1561          // -4 : *SKT*VOICECONNECT Error
   1562          
   1563          INT32S BcMdemCalling(char *DstTel)
   1564          { 
   1565          	INT16U i = 0, j = 0;
   1566          	INT8U Ptr[100];
   1567          	INT32S nRet = TRUE;
   1568          	
   1569          	sprintf((char *)TxCdmaData, "%s%s", CdmaCallingCmd, DstTel);
   1570          
   1571          	BcMdemXmit((INT8U *)TxCdmaData);
   1572          
   1573          	if(BcMdemSyncProtocolCheck()) // *SKT*ORI=
   1574          	{
   1575          		if(BcMdemSyncCheck((char *)RxCdmaData) != 33)return -1; 
   1576          	}
   1577          	else return -1;
   1578          
   1579          	if(BcMdemSyncProtocolCheck()) // OK
   1580          	{
   1581          		if(BcMdemSyncCheck((char *)RxCdmaData) != 14)return -2; 
   1582          	}
   1583          	else return -2;
   1584          	
   1585          	if(BcMdemSyncProtocolCheck()) // *SKT*VCALL:
   1586          	{
   1587          		for(i = 0; i < strlen(RspmsgCallAck);i++)Ptr[i] = RxCdmaData[i];
   1588          		Ptr[i] = 0;
   1589          		if(BcMdemSyncCheck((char *)Ptr) != 28)return -3;
   1590          		
   1591          		for(j = 0; j < strlen(DstTel); j++, i++)
   1592          		{
   1593          			if(DstTel[j] != RxCdmaData[i])return -3;
   1594          		}
   1595          	}
   1596          	else return -3;
   1597          
   1598          	if(BcMdemSyncProtocolCheck()) // *SKT*VOICECONNECT
   1599          	{
   1600          		if(BcMdemSyncCheck((char *)RxCdmaData) != 29)return -4; 
   1601          	}
   1602          	else return -4;
   1603          	
   1604          	return nRet;
   1605          }
   1606          
   1607          
   1608          INT32S CdmaModemTrafficCheck(void)
   1609          { 
   1610          	INT8U nRet = TRUE;
   1611          	
   1612          	nRet = BcMdemCommad(ModemTrafficCmd);
   1613          
   1614          	return nRet;
   1615          }
   1616          
   1617          INT32S CdmaModemHangUp(void)
   1618          { 
   1619          	INT8U nRet = TRUE;
   1620          	
   1621          	nRet = BcMdemCommad(ModemHangUpCmd);
   1622          
   1623          	return nRet;
   1624          }
   1625          
   1626          
   1627          
   1628          INT32S ModemHangUp(void)
   1629          { 
   1630          	INT8U nRet = TRUE;
   1631          	
   1632          	nRet = BcMdemCommad(ModemHangUpCommand);
   1633          
   1634          	return nRet;
   1635          }
   1636          
   1637          
   1638          
   1639          
   1640          INT32S ModemLockOrder(void)
   1641          { 
   1642          	INT8U nRet = TRUE;
   1643          	
   1644          	nRet = BcMdemCommad(ModemLockOrderCmd);
   1645          
   1646          	return nRet;
   1647          }
   1648          
   1649          
   1650          INT32S ModemGMMLockOrder(void)
   1651          { 
   1652          	INT8U nRet = TRUE;
   1653          	
   1654          	nRet = BcMdemCommad(ModemGMMLockOrderCmd);
   1655          
   1656          	return nRet;
   1657          }
   1658          
   1659          INT32S ModemPwrOFF(void)
   1660          { 
   1661          	INT8U nRet = TRUE;
   1662          	
   1663          	nRet = BcMdemCommad(ModemPWROFFCmd);
   1664          
   1665          	return nRet;
   1666          }
   1667          
   1668          
   1669          
   1670          INT32S BcMdemCommad(INT8U Commad)
   1671          {
   1672          	INT16U i = 0;
   1673          	INT32S nlen = 0;
   1674          	INT32S nRet = 0;
   1675          	INT8U Ptr[100];
   1676            
   1677          	switch(Commad)
   1678          	{
   1679          		case MsgReciveCmd: 			BcMdemXmit(CdmaMsgReciveCmd); 	break;
   1680          		case MsgCheckCmd: 			BcMdemXmit(CdmaMsgCheckCmd); 	break;
   1681          		case ModemTimeCmd: 			BcMdemXmit(CdmaModemTimeCmd); 	break;
   1682          		case ModemRfStsCmd: 		BcMdemXmit(CdmaModemRfStsCmd); 	break;
   1683          		case ModemHangUpCmd: 		BcMdemXmit(CdmaModemHangUpCmd); break;
   1684          		case ModemTrafficCmd:		BcMdemXmit(CdmaModemTrafficCmd);break;
   1685          		case ModemPilotCmd: 		BcMdemXmit(CdmaModemPilotCmd); 	break; 
   1686          		case ModemLockOrderCmd: 	BcMdemXmit(LockOrderCmd); 		break; 
   1687          		case ModemGMMLockOrderCmd: 	BcMdemXmit(GMMLockOrderCmd); 	break; 
   1688          		case ModemPWROFFCmd: 		BcMdemXmit(ModemPWROFF); 		break; 
   1689          
   1690          
   1691          		case ModemHangUpCommand: 	BcMdemXmit(PhoneHangUpCmd); break;
   1692          
   1693          
   1694          		default : return FALSE;
   1695          	}
   1696          
   1697          	switch(Commad)
   1698          	{
   1699          		case MsgReciveCmd:
   1700          		
   1701          			if((nlen = BcMdemSyncProtocolCheck()) != FALSE)
   1702          			{
   1703          				nRet = BcMdemDataProtocolCheck(Commad);
   1704          				if(!nRet)return FALSE;
   1705          				if(nRet > 0) nRet = nlen;	// normal case 이면.. len을 return한다.
   1706          			}
   1707          			else return FALSE;
   1708          		break;	
   1709          
   1710          		case ModemPilotCmd:
   1711          		case MsgCheckCmd: 	
   1712          		case ModemTimeCmd:
   1713          		case ModemRfStsCmd:
   1714          		case ModemTrafficCmd:
   1715          		case ModemPWROFFCmd:	
   1716          			if((nlen = BcMdemSyncProtocolCheck()) != FALSE)
   1717          			{
   1718          				nRet = BcMdemDataProtocolCheck(Commad);
   1719          
   1720          				if(!nRet)return FALSE;
   1721          				if(!BcMdemSyncProtocolCheck())return FALSE;
   1722          				
   1723          				if((BcMdemSyncCheck((char *)RxCdmaData) != 14))	return FALSE;
   1724          
   1725          				if(Commad == MsgCheckCmd)
   1726          				{
   1727          //					nRet = nlen;
   1728          				}
   1729           				else if(Commad != ModemTrafficCmd)
   1730          				{
   1731          					if(nRet > 0) nRet = nlen;	// normal case 이면.. len을 return한다.
   1732          				}	
   1733          			}
   1734          			else return FALSE;
   1735          		break;	
   1736           		case ModemHangUpCmd:
   1737          		case ModemHangUpCommand:
   1738          			
   1739          			if(BcMdemSyncProtocolCheck())
   1740          			{
   1741          				for(i = 0; i < strlen(RspmsgHangup);i++)Ptr[i] = RxCdmaData[i];
   1742          				Ptr[i] = 0;
   1743          				if(BcMdemSyncCheck((char *)Ptr) != 30)return FALSE;
   1744          				
   1745          				if(RxCdmaData[i] != '1')return FALSE;
   1746          			}
   1747          			else return FALSE;
   1748          			
   1749          		break; 
   1750          		case ModemLockOrderCmd:
   1751          			
   1752          			if(BcMdemSyncProtocolCheck())
   1753          			{
   1754          				for(i = 0; i < strlen(RspLockOrder);i++)Ptr[i] = RxCdmaData[i];
   1755          				Ptr[i] = 0;
   1756          				if(BcMdemSyncCheck((char *)Ptr) != 35)	return FALSE;
   1757          
   1758          				{
   1759          					INT8U *tPtr = RxCdmaData;
   1760          
   1761          					for(; i < 20; i++)
   1762          					{
   1763          						if(*tPtr == ',')
   1764          						{	
   1765          							*tPtr++;
   1766          							break;
   1767          						}
   1768          						else
   1769          						{
   1770          							tPtr++;
   1771          
   1772          						}
   1773          						
   1774          //						Ser3Ptr->printf("[%c]",*tPtr);
   1775          					}
   1776          //					Ser3Ptr->printf("\n");
   1777          					
   1778          					LockOrder = atoh(*tPtr);
   1779          	//				Ser3Ptr->printf("RxCdmaData [%d][%d]>[%d]\n",i, *tPtr,LockOrder);
   1780          				}
   1781          			}
   1782          			else return FALSE;
   1783          
   1784          			
   1785          		break; 
   1786          		case ModemGMMLockOrderCmd:
   1787          			if(BcMdemSyncProtocolCheck())
   1788          			{
   1789          				for(i = 0; i < strlen(RspGMMLockOrder);i++)Ptr[i] = RxCdmaData[i];
   1790          				Ptr[i] = 0;
   1791          				if(BcMdemSyncCheck((char *)Ptr) != 36)return FALSE;
   1792          
   1793          				GMMLockOrder = atoh(RxCdmaData[i]);
   1794          			}
   1795          			else return FALSE;
   1796          
   1797          			
   1798          		break; 
   1799          
   1800           	}
   1801          	return nRet;
   1802          }
   1803          
   1804          INT32S BcdemTimeGet(BcMTimeStr *nPtr)
   1805          {
   1806          	INT8U i = 0;
   1807          	INT8U *tPtr = (INT8U *)nPtr;
   1808          	INT32S nRet = TRUE;
   1809          		
   1810          S_START:
   1811          
   1812          	if(BcMRtryNo >= MaxTryNo) return FALSE;	// Max Try Error
   1813          
   1814          	nRet = BcMdemCommad(ModemTimeCmd);
   1815          
   1816          //	USART1Printf("1: BcdemTimeGet : [%d][%d]\n",BcMRtryNo,nRet);
   1817          
   1818          	if(nRet == FALSE)
   1819          	{
   1820          		BcMRtryNo++;
   1821          		OSTimeDly(1500);
   1822          		goto S_START;
   1823          	}
   1824          
   1825          	
   1826          	// mem init
   1827          	for(i = 0; i < sizeof(BcMTimeStr); i++)  *tPtr++ = 0;
   1828          	
   1829          	for(i = 0; i < 4; i++) nPtr->Year[i] = BcMpresentTime->Year[i];
   1830          	for(i = 0; i < 2; i++)
   1831          	{
   1832          		nPtr->Month[i]	= BcMpresentTime->Month[i];
   1833          		nPtr->Day[i]	= BcMpresentTime->Day[i];
   1834          		nPtr->Hour[i]	= BcMpresentTime->Hour[i];
   1835          		nPtr->Min[i]	= BcMpresentTime->Min[i];
   1836          		nPtr->Sec[i]	= BcMpresentTime->Sec[i];
   1837          	}	
   1838          
   1839          	OSTimeDly(1500);
   1840          	return nRet;
   1841          }
   1842          
   1843          INT32S BcdemRfStsGet(BcMRfStsStr *nPtr)
   1844          {
   1845          	INT8U i = 0;
   1846          //	INT16S *tPtr = (INT16S *)nPtr;
   1847          //	INT8U *tPtr = (INT8U *)nPtr;
   1848          
   1849          	INT32S nRet = TRUE;
   1850          //	USART1Printf("01 :BcdemRfStsGet : [%d][%x] \n", tPtr,&tPtr);
   1851          
   1852          	
   1853          RF_START:
   1854          	if(BcMRtryNo >= MaxTryNo) return FALSE;	// Max Try Error
   1855          
   1856          	nRet = BcMdemCommad(ModemRfStsCmd);
   1857          
   1858          	if(nRet == FALSE)
   1859          	{
   1860          		BcMRtryNo++;
   1861          		OSTimeDly(1000);
   1862          		goto RF_START;
   1863          	}
   1864          	// mem init
   1865          //	for(i = 0; i < sizeof(BcMRfStsStr); i++)  *tPtr++ = 0;
   1866          
   1867          	nPtr->ActChannel =	BcMRfStatus->ActChannel;
   1868          //	USART1Printf("01 :ActChannel : [%d][%d] \n", BcMRfStatus->ActChannel,nPtr->ActChannel);
   1869          	
   1870          	for(i = 0; i < 6; i++)
   1871          	{
   1872          		nPtr->PN_Vaule[i] 	= BcMRfStatus->PN_Vaule[i];
   1873          		nPtr->EcIo[i] 	  	= BcMRfStatus->EcIo[i];
   1874          		nPtr->PSC_Vaule[i]	= BcMRfStatus->PSC_Vaule[i];
   1875          	}
   1876          
   1877          	nPtr->FerValue 	=	BcMRfStatus->FerValue;
   1878          	nPtr->RxValue 	=	BcMRfStatus->RxValue;
   1879          	nPtr->TxValue 	=	BcMRfStatus->TxValue;
   1880          	nPtr->AdjValue 	=	BcMRfStatus->AdjValue;
   1881          
   1882          	nPtr->NumberOfChannel = BcMRfStatus->NumberOfChannel;
   1883          	nPtr->ActPN = BcMRfStatus->ActPN;	
   1884          
   1885          	nPtr->PSClist 	= BcMRfStatus->PSClist;	
   1886          	nPtr->BER 		= BcMRfStatus->BER;	
   1887          
   1888          	return nRet;
   1889          }
   1890          
   1891          INT32S BcMdemFuncselect(void)
   1892          {
   1893          	// Modem Status Check.
   1894          ////////////////////////////////////////////////////////////////////////////////////////	
   1895          	// error Case
   1896          	if(BcMRtryNo >= MaxTryNo)
   1897          	{
   1898          		TimeReqCnt = 0;
   1899          		BcMRtryNo = 0;
   1900          		return  MAX_TRY;
   1901          	}
   1902          
   1903          	if(++TimeReqCnt > 5)
   1904          	{
   1905          		TimeReqCnt = 0;
   1906          		return SELF_TIME;
   1907          	}
   1908          	else if(TimeReqCnt%2)	return SELF_RECV;
   1909          	else					return SELF_SEND;
   1910          }
   1911          
   1912          INT32S BcMdemRecv(INT8U *rbuf, INT8U *sTel, BcMTimeStr *rtime)
   1913          {
   1914          	INT32S len = 0;
   1915          	INT32S nRet = 0;
   1916          	// 0: Fail
   1917          	// -1: Not Data
   1918          	
   1919          S_START:
   1920          
   1921          	if(BcMRtryNo >= MaxTryNo) return  FALSE;
   1922          	
   1923          	nRet = BcMdemCommad(MsgCheckCmd);
   1924          
   1925          	if(nRet == FALSE)
   1926          	{
   1927          		BcMRtryNo++;
   1928          		OSTimeDly(1500);
   1929          		goto S_START;
   1930          	}
   1931          	else if(nRet == NOT_DATA)
   1932          	{
   1933          		nRet = NOT_DATA;
   1934          	}
   1935          	else if(nRet > 0)//(nRet == TRUE)										// protocol ok --> data read
   1936          	{
   1937          		nRet = BcMdemCommad(MsgReciveCmd);
   1938          		if(nRet == FALSE)
   1939          		{
   1940          			BcMRtryNo++;
   1941          			OSTimeDly(1500);
   1942          			goto S_START;
   1943          		}
   1944          		//else if(nRet < 0)
   1945          		//{
   1946          		//	nRet = len;
   1947          		//}
   1948          		else if(nRet > 0)
   1949          		{
   1950          			//len = len;
   1951          			// RxCdmaData
   1952          			{
   1953          				INT16U i = 0, cnt = 0, tcnt = 0;
   1954          				INT8U *tPtr = RxBcMData;
   1955          
   1956          				////////////////////////////////////////////////////////////////
   1957          				for(i = 0; i < sizeof(BcMTimeStr); i++) *((INT8U *)rtime + i) = 0;
   1958          				//////////////////////////////////////////////////////////////////////
   1959          				for(i = 0; i < 4; i++, cnt++) rtime->Year[i] = *tPtr++;
   1960          				for(i = 0; i < 2; i++, cnt++) rtime->Month[i]= *tPtr++;
   1961          				for(i = 0; i < 2; i++, cnt++) rtime->Day[i]= *tPtr++;
   1962          				for(i = 0; i < 2; i++, cnt++) rtime->Hour[i]= *tPtr++;
   1963          				for(i = 0; i < 2; i++, cnt++) rtime->Min[i]= *tPtr++;
   1964          				for(i = 0; i < 2; i++, cnt++) rtime->Sec[i]= *tPtr++;
   1965          
   1966          				*tPtr++; cnt++;		// ','
   1967          				
   1968          				for(; cnt < nRet; cnt++)
   1969          				{
   1970          					if(*tPtr != ',')
   1971          					{	
   1972          						if(tcnt == 0)
   1973          						{
   1974          							*sTel++ = *tPtr++;
   1975          						}
   1976          						else if(tcnt == 1) tPtr++;
   1977          						else if(tcnt == 2) tPtr++;
   1978          						else if(tcnt == 3) tPtr++;
   1979          						else
   1980          						{
   1981          							INT8U temp;
   1982          							temp = atoh(*tPtr++);
   1983          							temp = atoh(*tPtr++) + ( temp << 4 );
   1984          							rbuf[len++] = temp;
   1985          							cnt++;
   1986          						}
   1987          					}
   1988          					else
   1989          					{
   1990          						tPtr++;
   1991          						tcnt++;
   1992          					}
   1993          				}				
   1994          				nRet = len;
   1995          				rbuf[len++] = 0;	// null data insert
   1996          				*sTel++ = 0;		// null data insert
   1997          
   1998          			//Ser0Printf(" rDATA: %s", RxBcMData);
   1999          			//Ser0Printf(" DATA: %s", rbuf);
   2000          			//Ser0Printf(" len: %d \n", nRet);
   2001          			}
   2002          		}
   2003          	}
   2004          	OSTimeDly(1500);
   2005          
   2006          	return nRet;
   2007          }
   2008          
   2009          INT32S BcdemPilotGet(BcMPilotStsStr *nPtr)
   2010          {
   2011          	INT8U i = 0;
   2012          //	INT16S *tPtr = (INT16S *)nPtr;
   2013          	INT8U *tPtr = (INT8U *)nPtr;
   2014          	INT32S nRet = TRUE;
   2015          
   2016          	nRet = BcMdemCommad(ModemPilotCmd);
   2017          //	USART1Printf("01 :BcdemPilotGet : [%d][%x] \n", tPtr,&tPtr);
   2018          
   2019          	// mem init
   2020          	for(i = 0; i < sizeof(BcMPilotStsStr); i++)  *tPtr++ = 0;
   2021          
   2022          	for(i = 0; i < 4; i++)
   2023          	{
   2024          		nPtr->PN_Vaule[i] = BcMPilotStatus->PN_Vaule[i];
   2025          		nPtr->EcIo[i] 	  = BcMPilotStatus->EcIo[i];
   2026           	}
   2027          	return nRet;
   2028          }
   2029          
   2030          int vSprintf(char * buf, const char *fmt, ...)
   2031          {
   2032          	va_list args;
   2033          	int i;
   2034          
   2035          	va_start(args, fmt);
   2036          	i=vsprintf(buf,fmt,args);
   2037          	va_end(args);
   2038          	return i;
   2039          }
   2040          #if 0
   2041          
   2042          int snprintf(char *str,size_t count,const char *fmt,...)
   2043          {
   2044          	size_t ret;
   2045          	va_list ap;
   2046              
   2047          	va_start(ap, fmt);
   2048          	ret = vsnprintf(str, count, fmt, ap);
   2049          	va_end(ap);
   2050          	return ret;
   2051          }
   2052          #endif
   2053          
   2054          
   2055          ////////////////////////////////////////////////////////////////////////////////
   2056          // End of Source File
   2057          /////////////////////
   2058          

   Maximum stack usage in bytes:

     Function                .cstack
     --------                -------
     BcMFreqStateCheck           44
     BcMPilotStateCheck          28
     BcMdemCalling              128
     BcMdemCommad               120
     BcMdemDataProtocolCheck     40
     BcMdemDebug                  0
     BcMdemFuncselect             0
     BcMdemInit                 128
     BcMdemMSGSentTx            232
     BcMdemMSGTx                232
     BcMdemRecv                  40
     BcMdemSwReset                8
     BcMdemSyncCheck             16
     BcMdemSyncProtocolCheck     24
     BcMdemTCPRxCheck            40
     BcMdemTCPTx                224
     BcMdemTcpConnect            48
     BcMdemTcpExit               16
     BcMdemXmit                  16
     BcdemPilotGet               16
     BcdemRfStsGet               16
     BcdemTimeGet                24
     CdmaModemHangUp              8
     CdmaModemTrafficCheck        8
     ModemGMMLockOrder            8
     ModemHangUp                  8
     ModemLockOrder               8
     ModemPwrOFF                  8
     vSprintf                    16


   Section sizes:

     Function/Label                    Bytes
     --------------                    -----
     RxCdmaData                        2056
     TxCdmaData
     RxBcMData                         1028
     Send2Buf                           256
     LockOrder                            2
     GMMLockOrder
     PN0_Vaule                            4
     PN1_Vaule                            4
     PN2_Vaule                            4
     PN3_Vaule                            4
     EcIo0_Vaule                          4
     EcIo1_Vaule                          4
     EcIo2_Vaule                          4
     EcIo3_Vaule                          4
     ModemVersion                        52
     BcMpresentTimeB                     20
     BcMRfStatusB                        68
     BcMVerNum                           72
     BcMdebug
     TimeReqCnt
     BcMRtryNo
     BcMMaker
     BcMType
     ModemType
     BcMSrcTel
     BcMEsnNum
     ICCIDNum
     BcMTimerRx
     dUartPtr
     eUartPtr
     BcMpresentTime
     BcMRfStatus
     BcMPilotStatusB                     16
     BcMPilotStatus                       4
     MsgCheckCnt                          1
     BcMdemDebug                         16
     BcMdemInit                         272
     ?Subroutine0                         6
     BcMdemXmit                          44
     BcMdemMSGTx                        216
     ?Subroutine1                         6
     BcMdemMSGSentTx                    214
     BcMdemTCPTx                        114
     BcMdemTCPRxCheck                   106
     BcMdemSyncProtocolCheck            126
     BcMdemSyncCheck                    564
     BcMdemDataProtocolCheck            830
     BcMFreqStateCheck                 3404
     BcMPilotStateCheck                 892
     BcMdemTcpConnect                   270
     BcMdemTcpExit                      134
     BcMdemSwReset                       66
     BcMdemCalling                      180
     CdmaModemTrafficCheck                6
     ?Subroutine2                         8
     CdmaModemHangUp                      4
     ModemHangUp                          6
     ModemLockOrder                       6
     ModemGMMLockOrder                    6
     ModemPwrOFF                          6
     BcMdemCommad                       372
     BcdemTimeGet                       130
     BcdemRfStsGet                      112
     BcMdemFuncselect                    52
     BcMdemRecv                         348
     BcdemPilotGet                       54
     vSprintf                            16
     ??DataTable6                         4
     ??DataTable6_1                       4
     ??DataTable7                         4
     ??DataTable8                         4
     ??DataTable8_1                       4
     ??DataTable8_2                       4
     ??DataTable8_3                       4
     ??DataTable8_4                       4
     ??DataTable8_5                       4
     ??DataTable8_6                       4
     ??DataTable8_7                       4
     ??DataTable8_8                       4
     ??DataTable8_9                       4
     ??DataTable8_10                      4
     ??DataTable8_11                      4
     ??DataTable8_12                      4
     ??DataTable9                         4
     ??DataTable19                        4
     ??DataTable19_1                      4
     ??DataTable19_2                      4
     ??DataTable19_3                      4
     ??DataTable19_4                      4
     ??DataTable19_5                      4
     ??DataTable19_6                      4
     ??DataTable19_7                      4
     ??DataTable19_8                      4
     ??DataTable19_9                      4
     ??DataTable19_10                     4
     ??DataTable19_11                     4
     ??DataTable19_12                     4
     ??DataTable19_13                     4
     ??DataTable19_14                     4
     ??DataTable19_15                     4
     ??DataTable19_16                     4
     ??DataTable19_17                     4
     ??DataTable19_18                     4
     ?<Constant "ATE0">                 196
     ?<Constant "*SKT*REL:">            336
     ?<Constant "%s\n">                   4
     ?<Constant "%s%s,%s,4098,0,0,0,">   80
     ?<Constant "%s">                     4
     ?<Constant "OK">                     4
     ?<Constant "x06">                    4
     ?<Constant "x05">                    4
     ?<Constant "ATS">                    4
     ?<Constant "KST">                    4
     ?<Constant "SAT">                    4
     ?<Constant "0x0D">                  40
     ?<Constant "AT+CRM=251">            80
     ?<Constant "AT$TCPCLOSE">           24
     ?<Constant "AT*SKT*RESET">          16
     ?<Constant "%s%s">                  20

 
 3 531 bytes in section .bss
    76 bytes in section .data
   824 bytes in section .rodata
 8 730 bytes in section .text
 
 8 730 bytes of CODE  memory
   824 bytes of CONST memory
 3 607 bytes of DATA  memory

Errors: none
Warnings: none

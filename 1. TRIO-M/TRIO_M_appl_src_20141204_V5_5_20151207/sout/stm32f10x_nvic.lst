###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.2.51295/W32 for ARM     02/Apr/2012  19:03:54 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\lib_stm32\s #
#                    rc\stm32f10x_nvic.c                                      #
#    Command line =  D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\lib_stm32\s #
#                    rc\stm32f10x_nvic.c -D NDEBUG -lcN                       #
#                    D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\sout\ -o    #
#                    D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\sout\       #
#                    --debug --endian=little --cpu=Cortex-M3 -e               #
#                    --warnings_are_errors --fpu=None --dlib_config           #
#                    "C:\Program Files\IAR Systems\Embedded Workbench         #
#                    5.4\arm\INC\DLib_Config_Normal.h" -I                     #
#                    D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\include\    #
#                    -I D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\lib_stm3 #
#                    2\inc\ -I D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\l #
#                    ib_stm32\src\ -I D:\Project\TRIO\3.F_W\TRIO_appl_src_201 #
#                    20401\uC-CPU\ -I D:\Project\TRIO\3.F_W\TRIO_appl_src_201 #
#                    20401\uC-LIB\ -I D:\Project\TRIO\3.F_W\TRIO_appl_src_201 #
#                    20401\uCOS-II\Ports\ -I D:\Project\TRIO\3.F_W\TRIO_appl_ #
#                    src_20120401\uCOS-II\Source\ -I                          #
#                    D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\uC-Probe\   #
#                    -I "C:\Program Files\IAR Systems\Embedded Workbench      #
#                    5.4\arm\INC\" -Oh                                        #
#    List file    =  D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\sout\stm32f #
#                    10x_nvic.lst                                             #
#    Object file  =  D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\sout\stm32f #
#                    10x_nvic.o                                               #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\lib_stm32\src\stm32f10x_nvic.c
      1          /******************** (C) COPYRIGHT 2007 STMicroelectronics ********************
      2          * File Name          : stm32f10x_nvic.c
      3          * Author             : MCD Application Team
      4          * Date First Issued  : 09/29/2006
      5          * Description        : This file provides all the NVIC firmware functions.
      6          ********************************************************************************
      7          * History:
      8          * 05/21/2007: V0.3
      9          * 04/02/2007: V0.2
     10          * 02/05/2007: V0.1
     11          * 09/29/2006: V0.01
     12          ********************************************************************************
     13          * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     14          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     15          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     16          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     17          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     18          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     19          *******************************************************************************/
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "stm32f10x_conf.h"
     23          
     24          /* Private macro -------------------------------------------------------------*/
     25          /* Private variables ---------------------------------------------------------*/
     26          /* Private function prototypes -----------------------------------------------*/
     27          /* Private functions ---------------------------------------------------------*/
     28          
     29          /*******************************************************************************
     30          * Function Name  : NVIC_DeInit
     31          * Description    : Deinitializes the NVIC peripheral registers to their default
     32          *                  reset values.
     33          * Input          : None
     34          * Output         : None
     35          * Return         : None
     36          *******************************************************************************/
     37          void NVIC_DeInit(void)
     38          {
     39          	u32 index = 0;
     40            
     41          	NVIC->Disable[0] = 0xFFFFFFFF;
     42          	NVIC->Disable[1] = 0x000007FF;
     43          	NVIC->Clear[0] = 0xFFFFFFFF;
     44          	NVIC->Clear[1] = 0x000007FF;
     45            
     46          	for(index = 0; index < 0x0B; index++) NVIC->Priority[index] = 0x00000000;
     47          }
     48          
     49          /*******************************************************************************
     50          * Function Name  : NVIC_SCBDeInit
     51          * Description    : Deinitializes the SCB peripheral registers to their default 
     52          *                  reset values.
     53          * Input          : None
     54          * Output         : None
     55          * Return         : None
     56          *******************************************************************************/
     57          void NVIC_SCBDeInit(void)
     58          {
     59              u32 index = 0x00;
     60              
     61              SCB->IRQControlState = 0x0A000000;
     62              SCB->ExceptionTableOffset = 0x00000000;
     63              SCB->AIRC.Data = AIRC_VECTKEY_MASK;
     64              SCB->SysCtrl = 0x00000000;
     65              SCB->ConfigCtrl = 0x00000000;
     66              for(index = 0; index < 0x03; index++)
     67              {
     68                  SCB->SystemPriority[index] = 0;
     69              }
     70              SCB->SysHandlerCtrl = 0x00000000;
     71              SCB->ConfigFaultStatus = 0xFFFFFFFF;
     72              SCB->HardFaultStatus = 0xFFFFFFFF;
     73              SCB->DebugFaultStatus = 0xFFFFFFFF;
     74          }
     75          
     76          /*******************************************************************************
     77          * Function Name  : NVIC_PriorityGroupConfig
     78          * Description    : Configures the priority grouping: pre-emption priority
     79          *                  and subpriority.
     80          * Input          : - NVIC_PriorityGroup: specifies the priority grouping bits
     81          *                    length. This parameter can be one of the following values:
     82          *                       - NVIC_PriorityGroup_0: 0 bits for pre-emption priority
     83          *                         4 bits for subpriority
     84          *                       - NVIC_PriorityGroup_1: 1 bits for pre-emption priority
     85          *                         3 bits for subpriority
     86          *                       - NVIC_PriorityGroup_2: 2 bits for pre-emption priority
     87          *                         2 bits for subpriority
     88          *                       - NVIC_PriorityGroup_3: 3 bits for pre-emption priority
     89          *                         1 bits for subpriority
     90          *                       - NVIC_PriorityGroup_4: 4 bits for pre-emption priority
     91          *                         0 bits for subpriority
     92          * Output         : None
     93          * Return         : None
     94          *******************************************************************************/
     95          void NVIC_PriorityGroupConfig(u32 NVIC_PriorityGroup)
     96          {
     97            /* Check the parameters */
     98            assert(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
     99            
    100            /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
    101            SCB->AIRC.Data = AIRC_VECTKEY_MASK | NVIC_PriorityGroup;
    102          }
    103          
    104          /*******************************************************************************
    105          * Function Name  : NVIC_Init
    106          * Description    : Initializes the NVIC peripheral according to the specified
    107          *                  parameters in the NVIC_InitStruct.
    108          * Input          : - NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure
    109          *                    that contains the configuration information for the
    110          *                    specified NVIC peripheral.
    111          * Output         : None
    112          * Return         : None
    113          *******************************************************************************/
    114          void NVIC_Init(u32 NVIC_IRQChannel, u32 NVIC_IRQChannelCmd)
    115          {
    116          	if(NVIC_IRQChannelCmd == ENABLE)
    117          	{
    118          		// Enable the Selected IRQ Channels ----------------------------------------
    119          		NVIC->Enable[(NVIC_IRQChannel >> 0x05)] = (u32)0x01 << (NVIC_IRQChannel & (u8)0x1F);
    120          	}
    121          	else
    122          	{
    123          		// Disable the Selected IRQ Channels ---------------------------------------
    124          		NVIC->Disable[(NVIC_IRQChannel >> 0x05)] = (u32)0x01 << (NVIC_IRQChannel & (u8)0x1F);
    125          	}
    126          }
    127          
    128          /*******************************************************************************
    129          * Function Name  : NVIC_StructInit
    130          * Description    : Fills each NVIC_InitStruct member with its default value.
    131          * Input          : - NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure which
    132          *                    will be initialized.
    133          * Output         : None
    134          * Return         : None
    135          *******************************************************************************/
    136          void NVIC_StructInit(NVIC_InitTypeDef* NVIC_InitStruct)
    137          {
    138            /* NVIC_InitStruct members default value */
    139            NVIC_InitStruct->NVIC_IRQChannel = 0x00;
    140            NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority = 0x00;
    141            NVIC_InitStruct->NVIC_IRQChannelSubPriority = 0x00;
    142            NVIC_InitStruct->NVIC_IRQChannelCmd = DISABLE;
    143          }
    144          
    145          /*******************************************************************************
    146          * Function Name  : NVIC_SETPRIMASK
    147          * Description    : Enables the PRIMASK priority: Raises the execution priority to 0.
    148          * Input          : None
    149          * Output         : None
    150          * Return         : None
    151          *******************************************************************************/
    152          void NVIC_SETPRIMASK(void)
    153          {
    154            __SETPRIMASK();
    155          }
    156          
    157          /*******************************************************************************
    158          * Function Name  : NVIC_RESETPRIMASK
    159          * Description    : Disables the PRIMASK priority.
    160          * Input          : None
    161          * Output         : None
    162          * Return         : None
    163          *******************************************************************************/
    164          void NVIC_RESETPRIMASK(void)
    165          {
    166            __RESETPRIMASK();
    167          }
    168          
    169          /*******************************************************************************
    170          * Function Name  : NVIC_SETFAULTMASK
    171          * Description    : Enables the FAULTMASK priority: Raises the execution priority to -1.
    172          * Input          : None
    173          * Output         : None
    174          * Return         : None
    175          *******************************************************************************/
    176          void NVIC_SETFAULTMASK(void)
    177          {
    178            __SETFAULTMASK();
    179          }
    180          
    181          /*******************************************************************************
    182          * Function Name  : NVIC_RESETFAULTMASK
    183          * Description    : Disables the FAULTMASK priority.
    184          * Input          : None
    185          * Output         : None
    186          * Return         : None
    187          *******************************************************************************/
    188          void NVIC_RESETFAULTMASK(void)
    189          {
    190            __RESETFAULTMASK();
    191          }
    192          
    193          /*******************************************************************************
    194          * Function Name  : NVIC_BASEPRICONFIG
    195          * Description    : The execution priority can be changed from 15 (lowest 
    196                             configurable priority) to 1.
    197          * Input          : None
    198          * Output         : None
    199          * Return         : None
    200          *******************************************************************************/
    201          void NVIC_BASEPRICONFIG(u32 NewPriority)
    202          {
    203            /* Check the parameters */
    204            assert(IS_NVIC_BASE_PRI(NewPriority));
    205            
    206            __BASEPRICONFIG(NewPriority << 0x04);
    207          }
    208          
    209          /*******************************************************************************
    210          * Function Name  : NVIC_GetBASEPRI
    211          * Description    : Returns the BASEPRI mask value.
    212          * Input          : None
    213          * Output         : None
    214          * Return         : BASEPRI register value
    215          *******************************************************************************/
    216          u32 NVIC_GetBASEPRI(void)
    217          {
    218            return (__GetBASEPRI());
    219          }
    220          
    221          /*******************************************************************************
    222          * Function Name  : NVIC_GetCurrentPendingIRQChannel
    223          * Description    : Returns the current pending IRQ channel identifier.
    224          * Input          : None
    225          * Output         : None
    226          * Return         : Pending IRQ Channel Identifier.
    227          *******************************************************************************/
    228          u16 NVIC_GetCurrentPendingIRQChannel(void)
    229          {
    230            return ((u16)((SCB->IRQControlState & (u32)0x003FF000) >> 0x0C));
    231          }
    232          
    233          /*******************************************************************************
    234          * Function Name  : NVIC_GetIRQChannelPendingBitStatus
    235          * Description    : Checks whether the specified IRQ Channel pending bit is set
    236          *                  or not.
    237          * Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to check.
    238          * Output         : None
    239          * Return         : The new state of IRQ Channel pending bit(SET or RESET).
    240          *******************************************************************************/
    241          ITStatus NVIC_GetIRQChannelPendingBitStatus(u8 NVIC_IRQChannel)
    242          {
    243            ITStatus pendingirqstatus = RESET;
    244            u32 tmp = 0x00;
    245            
    246            tmp = ((u32)0x01 << (NVIC_IRQChannel & (u32)0x1F));
    247          
    248            if (((NVIC->Set[(NVIC_IRQChannel >> 0x05)]) & tmp) == tmp)
    249            {
    250              pendingirqstatus = SET;
    251            }
    252            else
    253            {
    254              pendingirqstatus = RESET;
    255            }
    256            return pendingirqstatus;
    257          }
    258          
    259          /*******************************************************************************
    260          * Function Name  : NVIC_SetIRQChannelPendingBit
    261          * Description    : Sets the NVIC’s interrupt pending bit.
    262          * Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to Set.
    263          * Output         : None
    264          * Return         : None
    265          *******************************************************************************/
    266          void NVIC_SetIRQChannelPendingBit(u8 NVIC_IRQChannel)
    267          {
    268            /* Check the parameters */
    269            *(u32*)0xE000EF00 = (u32)NVIC_IRQChannel;
    270          }
    271          
    272          /*******************************************************************************
    273          * Function Name  : NVIC_ClearIRQChannelPendingBit
    274          * Description    : Clears the NVIC’s interrupt pending bit.
    275          * Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to clear.
    276          * Output         : None
    277          * Return         : None
    278          *******************************************************************************/
    279          void NVIC_ClearIRQChannelPendingBit(u8 NVIC_IRQChannel)
    280          {
    281            /* Check the parameters */
    282            NVIC->Clear[(NVIC_IRQChannel >> 0x05)] = (u32)0x01 << (NVIC_IRQChannel & (u32)0x1F);
    283          }
    284          
    285          /*******************************************************************************
    286          * Function Name  : NVIC_GetCurrentActiveHandler
    287          * Description    : Returns the current active Handler (IRQ Channel and
    288          *                  SystemHandler) identifier.
    289          * Input          : None
    290          * Output         : None
    291          * Return         : Active Handler Identifier.
    292          *******************************************************************************/
    293          u16 NVIC_GetCurrentActiveHandler(void)
    294          {
    295            return ((u16)(SCB->IRQControlState & (u32)0x3FF));
    296          }
    297          
    298          /*******************************************************************************
    299          * Function Name  : NVIC_GetIRQChannelActiveBitStatus
    300          * Description    : Checks whether the specified IRQ Channel active bit is set
    301          *                  or not.
    302          * Input          : - NVIC_IRQChannel: specifies the interrupt active bit to check.
    303          * Output         : None
    304          * Return         : The new state of IRQ Channel active bit(SET or RESET).
    305          *******************************************************************************/
    306          ITStatus NVIC_GetIRQChannelActiveBitStatus(u8 NVIC_IRQChannel)
    307          {
    308            ITStatus activeirqstatus = RESET;
    309            u32 tmp = 0x00;
    310          
    311            /* Check the parameters */
    312            assert(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
    313            
    314            tmp = ((u32)0x01 << (NVIC_IRQChannel & (u32)0x1F));
    315          
    316            if (((NVIC->Active[(NVIC_IRQChannel >> 0x05)]) & tmp) == tmp )
    317            {
    318              activeirqstatus = SET;
    319            }
    320            else
    321            {
    322              activeirqstatus = RESET;
    323            }
    324            return activeirqstatus;
    325          }
    326          
    327          /*******************************************************************************
    328          * Function Name  : NVIC_GetCPUID
    329          * Description    : Returns the ID number, the version number and the implementation
    330          *                  details of the Cortex-M3 core.
    331          * Input          : None
    332          * Output         : None
    333          * Return         : CPU ID.
    334          *******************************************************************************/
    335          u32 NVIC_GetCPUID(void)
    336          {
    337            return (SCB->CPUID);
    338          }
    339          
    340          void NVIC_SetVectorTable(u32 Addr)
    341          {
    342          	SCB->ExceptionTableOffset = Addr & 0x3FFFFF80;
    343          }
    344          
    345          /*******************************************************************************
    346          * Function Name  : NVIC_SystemLPConfig
    347          * Description    : Selects the condition for the system to enter low power mode.
    348          * Input          : - LowPowerMode: Specifies the new mode for the system to enter
    349          *                    low power mode.
    350          *                    This parameter can be one of the following values:
    351          *                       - NVIC_LP_SEVONPEND
    352          *                       - NVIC_LP_SLEEPDEEP
    353          *                       - NVIC_LP_SLEEPONEXIT
    354          *                  - NewState: new state of LP condition.
    355          *                    This parameter can be: ENABLE or DISABLE.
    356          * Output         : None
    357          * Return         : None
    358          *******************************************************************************/
    359          void NVIC_SystemLPConfig(u8 LowPowerMode, u32 NewState)
    360          {
    361              // Check the parameters
    362              assert(IS_NVIC_LP(LowPowerMode));
    363              assert(IS_FUNCTIONAL_STATE(NewState));  
    364              
    365              if (NewState != DISABLE)
    366              {
    367                  SCB->SysCtrl |= LowPowerMode;
    368              }
    369              else
    370              {
    371                  SCB->SysCtrl &= (u32)(~(u32)LowPowerMode);
    372              }
    373          }
    374          
    375          /*******************************************************************************
    376          * Function Name  : NVIC_SystemHandlerConfig
    377          * Description    : Enables or disables the specified System Handlers.
    378          * Input          : - SystemHandler: specifies the system handler to be enabled
    379          *                    or disabled.
    380          *                    This parameter can be one of the following values:
    381          *                       - SystemHandler_MemoryManage
    382          *                       - SystemHandler_BusFault
    383          *                       - SystemHandler_UsageFault
    384          *                  - NewState: new state of  specified System Handlers.
    385          *                    This parameter can be: ENABLE or DISABLE.
    386          * Output         : None
    387          * Return         : None
    388          *******************************************************************************/
    389          void NVIC_SystemHandlerConfig(u32 SystemHandler, u32 NewState)
    390          {
    391            u32 tmpreg = 0x00;
    392          
    393              // Check the parameters
    394              assert(IS_CONFIG_SYSTEM_HANDLER(SystemHandler));
    395              assert(IS_FUNCTIONAL_STATE(NewState)); 
    396              
    397              tmpreg =  (u32)0x01 << (SystemHandler & (u32)0x1F);
    398            
    399              if (NewState != DISABLE)
    400              {
    401                  SCB->SysHandlerCtrl |= tmpreg;
    402              }
    403              else
    404              {
    405                  SCB->SysHandlerCtrl &= ~tmpreg;
    406              }
    407          }
    408          
    409          /*******************************************************************************
    410          * Function Name  : NVIC_SystemHandlerPriorityConfig
    411          * Description    : Configures the specified System Handlers priority.
    412          * Input          : - SystemHandler: specifies the system handler to be
    413          *                    enabled or disabled.
    414          *                    This parameter can be one of the following values:
    415          *                       - SystemHandler_MemoryManage
    416          *                       - SystemHandler_BusFault
    417          *                       - SystemHandler_UsageFault
    418          *                       - SystemHandler_SVCall
    419          *                       - SystemHandler_DebugMonitor
    420          *                       - SystemHandler_PSV
    421          *                       - SystemHandler_SysTick
    422          *                  - SystemHandlerPreemptionPriority: new priority group of the
    423          *                    specified system handlers.
    424          *                  - SystemHandlerSubPriority: new sub priority of the specified
    425          *                    system handlers.
    426          * Output         : None
    427          * Return         : None
    428          *******************************************************************************/
    429          void NVIC_SystemHandlerPriorityConfig(u32 SystemHandler, u8 SystemHandlerPreemptionPriority,
    430                                                u8 SystemHandlerSubPriority)
    431          {
    432              u32 tmp1 = 0x00, tmp2 = 0xFF, handlermask = 0x00;
    433              u32 tmppriority = 0x00;
    434            
    435              /* Check the parameters */
    436              assert(IS_PRIORITY_SYSTEM_HANDLER(SystemHandler));
    437              assert(IS_NVIC_PREEMPTION_PRIORITY(SystemHandlerPreemptionPriority));  
    438              assert(IS_NVIC_SUB_PRIORITY(SystemHandlerSubPriority));
    439                
    440              tmppriority = (0x700 - (SCB->AIRC.Data & (u32)0x700))>> 0x08;
    441              tmp1 = (0x4 - tmppriority);
    442              tmp2 = tmp2 >> tmppriority;
    443                
    444              tmppriority = (u32)SystemHandlerPreemptionPriority << tmp1;
    445              tmppriority |=  SystemHandlerSubPriority & tmp2;
    446            
    447              tmppriority = tmppriority << 0x04;
    448              tmp1 = SystemHandler & (u32)0xC0;
    449              tmp1 = tmp1 >> 0x06; 
    450              tmp2 = (SystemHandler >> 0x08) & (u32)0x03;
    451              tmppriority = tmppriority << (tmp2 * 0x08);
    452              handlermask = (u32)0xFF << (tmp2 * 0x08);
    453              
    454              SCB->SystemPriority[tmp1] &= ~handlermask;
    455              SCB->SystemPriority[tmp1] |= tmppriority;
    456          }
    457          
    458          /*******************************************************************************
    459          * Function Name  : NVIC_GetSystemHandlerPendingBitStatus
    460          * Description    : Checks whether the specified System handlers pending bit is
    461          *                  set or not.
    462          * Input          : - SystemHandler: specifies the system handler pending bit to
    463          *                    check.
    464          *                    This parameter can be one of the following values:
    465          *                       - SystemHandler_MemoryManage
    466          *                       - SystemHandler_BusFault
    467          *                       - SystemHandler_SVCall
    468          * Output         : None
    469          * Return         : The new state of System Handler pending bit(SET or RESET).
    470          *******************************************************************************/
    471          ITStatus NVIC_GetSystemHandlerPendingBitStatus(u32 SystemHandler)
    472          {
    473            ITStatus bitstatus  = RESET;
    474            u32 tmp = 0x00, tmppos = 0x00;
    475          
    476            /* Check the parameters */
    477            assert(IS_GET_PENDING_SYSTEM_HANDLER(SystemHandler));
    478            
    479            tmppos = (SystemHandler >> 0x0A);
    480            tmppos &= (u32)0x0F;
    481          
    482            tmppos = (u32)0x01 << tmppos;
    483          
    484            tmp = SCB->SysHandlerCtrl & tmppos;
    485          
    486            if (tmp == tmppos)
    487            {
    488              bitstatus = SET;
    489            }
    490            else
    491            {
    492              bitstatus = RESET;
    493            }
    494            return bitstatus;
    495          }
    496          
    497          /*******************************************************************************
    498          * Function Name  : NVIC_SetSystemHandlerPendingBit
    499          * Description    : Sets System Handler pending bit.
    500          * Input          : - SystemHandler: specifies the system handler pending bit
    501          *                    to be set.
    502          *                    This parameter can be one of the following values:
    503          *                       - SystemHandler_NMI
    504          *                       - SystemHandler_PSV
    505          *                       - SystemHandler_SysTick
    506          * Output         : None
    507          * Return         : None
    508          *******************************************************************************/
    509          void NVIC_SetSystemHandlerPendingBit(u32 SystemHandler)
    510          {
    511            u32 tmp = 0x00;
    512          
    513            /* Check the parameters */
    514            assert(IS_SET_PENDING_SYSTEM_HANDLER(SystemHandler));
    515            
    516            /* Get the System Handler pending bit position */
    517            tmp = SystemHandler & (u32)0x1F;
    518            /* Set the corresponding System Handler pending bit */
    519            SCB->IRQControlState |= ((u32)0x01 << tmp);
    520          }
    521          
    522          /*******************************************************************************
    523          * Function Name  : NVIC_ClearSystemHandlerPendingBit
    524          * Description    : Clears System Handler pending bit.
    525          * Input          : - SystemHandler: specifies the system handler pending bit to
    526          *                    be clear.
    527          *                    This parameter can be one of the following values:
    528          *                       - SystemHandler_PSV
    529          *                       - SystemHandler_SysTick
    530          * Output         : None
    531          * Return         : None
    532          *******************************************************************************/
    533          void NVIC_ClearSystemHandlerPendingBit(u32 SystemHandler)
    534          {
    535            u32 tmp = 0x00;
    536          
    537            /* Check the parameters */
    538            assert(IS_CLEAR_SYSTEM_HANDLER(SystemHandler));
    539            
    540            /* Get the System Handler pending bit position */
    541            tmp = SystemHandler & (u32)0x1F;
    542            /* Clear the corresponding System Handler pending bit */
    543            SCB->IRQControlState |= ((u32)0x01 << (tmp - 0x01));
    544          }
    545          
    546          /*******************************************************************************
    547          * Function Name  : NVIC_GetSystemHandlerActiveBitStatus
    548          * Description    : Checks whether the specified System handlers active bit is
    549          *                  set or not.
    550          * Input          : - SystemHandler: specifies the system handler active bit to
    551          *                    check.
    552          *                    This parameter can be one of the following values:
    553          *                       - SystemHandler_MemoryManage
    554          *                       - SystemHandler_BusFault
    555          *                       - SystemHandler_UsageFault
    556          *                       - SystemHandler_SVCall
    557          *                       - SystemHandler_DebugMonitor
    558          *                       - SystemHandler_PSV
    559          *                       - SystemHandler_SysTick
    560          * Output         : None
    561          * Return         : The new state of System Handler active bit(SET or RESET).
    562          *******************************************************************************/
    563          ITStatus NVIC_GetSystemHandlerActiveBitStatus(u32 SystemHandler)
    564          {
    565            ITStatus bitstatus  = RESET;
    566          
    567            u32 tmp = 0x00, tmppos = 0x00;
    568          
    569            /* Check the parameters */
    570            assert(IS_GET_ACTIVE_SYSTEM_HANDLER(SystemHandler));
    571            
    572            tmppos = (SystemHandler >> 0x0E) & (u32)0x0F;
    573          
    574            tmppos = (u32)0x01 << tmppos;
    575          
    576            tmp = SCB->SysHandlerCtrl & tmppos;
    577          
    578            if (tmp == tmppos)
    579            {
    580              bitstatus = SET;
    581            }
    582            else
    583            {
    584              bitstatus = RESET;
    585            }
    586            return bitstatus;
    587          }
    588          
    589          /*******************************************************************************
    590          * Function Name  : NVIC_GetFaultHandlerSources
    591          * Description    : Returns the system fault handlers sources.
    592          * Input          : - SystemHandler: specifies the system handler to get its fault
    593          *                    sources.
    594          *                    This parameter can be one of the following values:
    595          *                       - SystemHandler_HardFault
    596          *                       - SystemHandler_MemoryManage
    597          *                       - SystemHandler_BusFault
    598          *                       - SystemHandler_UsageFault
    599          *                       - SystemHandler_DebugMonitor
    600          * Output         : None
    601          * Return         : Source of the fault handler.
    602          *******************************************************************************/
    603          u32 NVIC_GetFaultHandlerSources(u32 SystemHandler)
    604          {
    605            u32 faultsources = 0x00;
    606            u32 tmpreg = 0x00, tmppos = 0x00;
    607          
    608            /* Check the parameters */
    609            assert(IS_FAULT_SOURCE_SYSTEM_HANDLER(SystemHandler));
    610            
    611            tmpreg = (SystemHandler >> 0x12) & (u32)0x03;
    612            tmppos = (SystemHandler >> 0x14) & (u32)0x03;
    613          
    614            if (tmpreg == 0x00)
    615            {
    616              faultsources = SCB->HardFaultStatus;
    617            }
    618            else if (tmpreg == 0x01)
    619            {
    620              faultsources = SCB->ConfigFaultStatus >> (tmppos * 0x08);
    621              if (tmppos != 0x02)
    622              {
    623                faultsources &= (u32)0x0F;
    624              }
    625              else
    626              {
    627                faultsources &= (u32)0xFF;
    628              }
    629            }
    630            else
    631            {
    632              faultsources = SCB->DebugFaultStatus;
    633            }
    634            return faultsources;
    635          }
    636          
    637          /*******************************************************************************
    638          * Function Name  : NVIC_GetFaultAddress
    639          * Description    : Returns the address of the location that generated a fault
    640          *                  handler.
    641          * Input          : - SystemHandler: specifies the system handler to get its
    642          *                    fault address.
    643          *                    This parameter can be one of the following values:
    644          *                       - SystemHandler_MemoryManage
    645          *                       - SystemHandler_BusFault
    646          * Output         : None
    647          * Return         : Fault address.
    648          *******************************************************************************/
    649          u32 NVIC_GetFaultAddress(u32 SystemHandler)
    650          {
    651            u32 faultaddress = 0x00;
    652            u32 tmp = 0x00;
    653          
    654            /* Check the parameters */
    655            assert(IS_FAULT_ADDRESS_SYSTEM_HANDLER(SystemHandler));
    656            
    657            tmp = (SystemHandler >> 0x16) & (u32)0x01;
    658          
    659            if (tmp == 0x00)
    660            {
    661              faultaddress = SCB->MemoryManageFaultAddr;
    662            }
    663            else
    664            {
    665              faultaddress = SCB->BusFaultAddr;
    666            }
    667            return faultaddress;
    668          }
    669          
    670          /******************* (C) COPYRIGHT 2007 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     NVIC_BASEPRICONFIG                  8
     NVIC_ClearIRQChannelPendingBit      0
     NVIC_ClearSystemHandlerPendingBit
                                         0
     NVIC_DeInit                         8
     NVIC_GetBASEPRI                     8
     NVIC_GetCPUID                       0
     NVIC_GetCurrentActiveHandler        0
     NVIC_GetCurrentPendingIRQChannel
                                         0
     NVIC_GetFaultAddress                0
     NVIC_GetFaultHandlerSources         0
     NVIC_GetIRQChannelActiveBitStatus
                                         0
     NVIC_GetIRQChannelPendingBitStatus
                                         0
     NVIC_GetSystemHandlerActiveBitStatus
                                         0
     NVIC_GetSystemHandlerPendingBitStatus
                                         0
     NVIC_Init                           0
     NVIC_PriorityGroupConfig            0
     NVIC_RESETFAULTMASK                 8
     NVIC_RESETPRIMASK                   8
     NVIC_SCBDeInit                      0
     NVIC_SETFAULTMASK                   8
     NVIC_SETPRIMASK                     8
     NVIC_SetIRQChannelPendingBit        0
     NVIC_SetSystemHandlerPendingBit
                                         0
     NVIC_SetVectorTable                 0
     NVIC_StructInit                     0
     NVIC_SystemHandlerConfig            0
     NVIC_SystemHandlerPriorityConfig
                                        16
     NVIC_SystemLPConfig                 0


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     NVIC_DeInit                      32
     NVIC_SCBDeInit                   42
     NVIC_PriorityGroupConfig         10
     NVIC_Init                        28
     NVIC_StructInit                  12
     NVIC_SETPRIMASK                   4
     NVIC_RESETPRIMASK                 4
     NVIC_SETFAULTMASK                 4
     NVIC_RESETFAULTMASK               4
     NVIC_BASEPRICONFIG                6
     NVIC_GetBASEPRI                   4
     NVIC_GetCurrentPendingIRQChannel
                                      16
     NVIC_GetIRQChannelPendingBitStatus
                                      36
     NVIC_SetIRQChannelPendingBit     12
     NVIC_ClearIRQChannelPendingBit   20
     NVIC_GetCurrentActiveHandler     10
     NVIC_GetIRQChannelActiveBitStatus
                                      36
     NVIC_GetCPUID                    12
     NVIC_SetVectorTable              20
     NVIC_SystemLPConfig              24
     NVIC_SystemHandlerConfig         28
     NVIC_SystemHandlerPriorityConfig
                                      88
     NVIC_GetSystemHandlerPendingBitStatus
                                      30
     NVIC_SetSystemHandlerPendingBit
                                      12
     ?Subroutine0                     10
     NVIC_ClearSystemHandlerPendingBit
                                      14
     NVIC_GetSystemHandlerActiveBitStatus
                                      30
     NVIC_GetFaultHandlerSources      52
     NVIC_GetFaultAddress             20
     ??DataTable4                      4
     ??DataTable6                      4
     ??DataTable8                      4
     ??DataTable11                     4
     ??DataTable14                     4
     ??DataTable15                     4

 
 644 bytes in section .text
 
 644 bytes of CODE memory

Errors: none
Warnings: none

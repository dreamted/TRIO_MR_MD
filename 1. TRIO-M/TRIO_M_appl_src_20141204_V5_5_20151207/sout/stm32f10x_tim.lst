###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.2.51295/W32 for ARM     02/Apr/2012  19:04:01 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\lib_stm32\s #
#                    rc\stm32f10x_tim.c                                       #
#    Command line =  D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\lib_stm32\s #
#                    rc\stm32f10x_tim.c -D NDEBUG -lcN                        #
#                    D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\sout\ -o    #
#                    D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\sout\       #
#                    --debug --endian=little --cpu=Cortex-M3 -e               #
#                    --warnings_are_errors --fpu=None --dlib_config           #
#                    "C:\Program Files\IAR Systems\Embedded Workbench         #
#                    5.4\arm\INC\DLib_Config_Normal.h" -I                     #
#                    D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\include\    #
#                    -I D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\lib_stm3 #
#                    2\inc\ -I D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\l #
#                    ib_stm32\src\ -I D:\Project\TRIO\3.F_W\TRIO_appl_src_201 #
#                    20401\uC-CPU\ -I D:\Project\TRIO\3.F_W\TRIO_appl_src_201 #
#                    20401\uC-LIB\ -I D:\Project\TRIO\3.F_W\TRIO_appl_src_201 #
#                    20401\uCOS-II\Ports\ -I D:\Project\TRIO\3.F_W\TRIO_appl_ #
#                    src_20120401\uCOS-II\Source\ -I                          #
#                    D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\uC-Probe\   #
#                    -I "C:\Program Files\IAR Systems\Embedded Workbench      #
#                    5.4\arm\INC\" -Oh                                        #
#    List file    =  D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\sout\stm32f #
#                    10x_tim.lst                                              #
#    Object file  =  D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\sout\stm32f #
#                    10x_tim.o                                                #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\lib_stm32\src\stm32f10x_tim.c
      1          /******************** (C) COPYRIGHT 2007 STMicroelectronics ********************
      2          * File Name          : stm32f10x_tim.c
      3          * Author             : MCD Application Team
      4          * Date First Issued  : 09/29/2006
      5          * Description        : This file provides all the TIM firmware functions.
      6          ********************************************************************************
      7          * History:
      8          * 05/21/2007: V0.3
      9          * 04/02/2007: V0.2
     10          * 02/05/2007: V0.1
     11          * 09/29/2006: V0.01
     12          ********************************************************************************
     13          * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     14          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     15          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     16          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     17          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     18          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     19          *******************************************************************************/
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "stm32f10x_conf.h"
     23          
     24          /* Private typedef -----------------------------------------------------------*/
     25          /* Private define ------------------------------------------------------------*/
     26          /* ---------------------- TIM registers bit mask ------------------------ */
     27          #define CR1_CEN_Set                 ((u16)0x0001)
     28          #define CR1_CEN_Reset               ((u16)0x03FE)
     29          #define CR1_UDIS_Set                ((u16)0x0002)
     30          #define CR1_UDIS_Reset              ((u16)0x03FD)
     31          #define CR1_URS_Set                 ((u16)0x0004)
     32          #define CR1_URS_Reset               ((u16)0x03FB)
     33          #define CR1_OPM_Mask                ((u16)0x03F7)
     34          #define CR1_CounterMode_Mask        ((u16)0x039F)
     35          #define CR1_ARPE_Set                ((u16)0x0080)
     36          #define CR1_ARPE_Reset              ((u16)0x037F)
     37          #define CR1_CKD_Mask                ((u16)0x00FF)
     38          
     39          #define CR2_CCDS_Set                ((u16)0x0008)
     40          #define CR2_CCDS_Reset              ((u16)0x0007)
     41          #define CR2_MMS_Mask                ((u16)0x0080)
     42          #define CR2_TI1S_Set                ((u16)0x0080)
     43          #define CR2_TI1S_Reset              ((u16)0xFF70)
     44          
     45          #define SMCR_SMS_Mask               ((u16)0xFFF0)
     46          #define SMCR_ETR_Mask               ((u16)0x00F7)
     47          #define SMCR_TS_Mask                ((u16)0xFF87)
     48          #define SMCR_MSM_Mask               ((u16)0xFF77)
     49          #define SMCR_ECE_Set                ((u16)0x4000)
     50          
     51          #define CCMR_CC13S_Mask             ((u16)0x7F7C)
     52          #define CCMR_CC24S_Mask             ((u16)0x7C7F)
     53          #define CCMR_TI13Direct_Set         ((u16)0x0001)
     54          #define CCMR_TI24Direct_Set         ((u16)0x0100)
     55          #define CCMR_OC13FE_Mask            ((u16)0x7F7B)
     56          #define CCMR_OC24FE_Mask            ((u16)0x7B7F)
     57          #define CCMR_OC13PE_Mask            ((u16)0x7F77)
     58          #define CCMR_OC24PE_Mask            ((u16)0x777F)
     59          #define CCMR_OCM13_Mask             ((u16)0x7F0F)
     60          #define CCMR_OCM24_Mask             ((u16)0x0F7F)
     61          
     62          #define CCMR_OC13CE_Mask            ((u16)0xFF7F)
     63          #define CCMR_OC24CE_Mask            ((u16)0x7FFF)
     64          
     65          #define CCMR_IC13PSC_Mask           ((u16)0xFFF3)
     66          #define CCMR_IC24PSC_Mask           ((u16)0xF3FF)
     67          #define CCMR_IC13F_Mask             ((u16)0xFF0F)
     68          #define CCMR_IC24F_Mask             ((u16)0x0FFF)
     69          
     70          #define CCER_CC1P_Mask              ((u16)0xFFFD)
     71          #define CCER_CC2P_Mask              ((u16)0xFFDF)
     72          #define CCER_CC3P_Mask              ((u16)0xFDFF)
     73          #define CCER_CC4P_Mask              ((u16)0xDFFF)
     74          
     75          #define CCER_CC1E_Set               ((u16)0x0001)
     76          #define CCER_CC1E_Reset             ((u16)0xFFFE)
     77          #define CCER_CC1E_Mask              ((u16)0xFFFE)
     78          
     79          #define CCER_CC2E_Set               ((u16)0x0010)
     80          #define CCER_CC2E_Reset             ((u16)0xFFEF)
     81          #define CCER_CC2E_Mask              ((u16)0xFFEF)
     82          
     83          #define CCER_CC3E_Set               ((u16)0x0100)
     84          #define CCER_CC3E_Reset             ((u16)0xFEFF)
     85          
     86          #define CCER_CC4E_Set               ((u16)0x1000)
     87          #define CCER_CC4E_Reset             ((u16)0xEFFF)
     88          #define CCER_CC4E_Mask              ((u16)0xEFFF)
     89          
     90          #define DCR_DMA_Mask                ((u16)0x0000)
     91          
     92          /* TIM private Masks */
     93          #define TIM_Period_Reset_Mask       ((u16)0x0000)
     94          #define TIM_Prescaler_Reset_Mask    ((u16)0x0000)
     95          #define TIM_Pulse_Reset_Mask        ((u16)0x0000)
     96          #define TIM_ICFilter_Mask           ((u8)0x00)
     97          
     98          /* Private macro -------------------------------------------------------------*/
     99          /* Private variables ---------------------------------------------------------*/
    100          static uc16 Tab_OCModeMask[4] = {0xFF00, 0x00FF, 0xFF00, 0x00FF};
    101          static uc16 Tab_PolarityMask[4] = {CCER_CC1P_Mask, CCER_CC2P_Mask, CCER_CC3P_Mask, CCER_CC4P_Mask};
    102          
    103          /* Private function prototypes -----------------------------------------------*/
    104          static void PWMI_Config(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct);
    105          static void TI1_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
    106                                 u8 TIM_ICFilter);
    107          static void TI2_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
    108                                 u8 TIM_ICFilter);
    109          static void TI3_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
    110                                 u8 TIM_ICFilter);
    111          static void TI4_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
    112                                 u8 TIM_ICFilter);
    113          /* Private functions ---------------------------------------------------------*/
    114          
    115          /*******************************************************************************
    116          * Function Name  : TIM_DeInit
    117          * Description    : Deinitializes the TIMx peripheral registers to their default
    118          *                  reset values.
    119          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    120          * Output         : None
    121          * Return         : None
    122          *******************************************************************************/
    123          void TIM_DeInit(TIM_TypeDef* TIMx)
    124          {  
    125            switch (*(u32*)&TIMx)
    126            {
    127              case TIM2_BASE:
    128          //      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
    129          //      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
    130                break;
    131           
    132              case TIM3_BASE:
    133          //      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
    134          //      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
    135                break;
    136           
    137              case TIM4_BASE:
    138          //      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
    139          //      RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
    140                break;
    141           
    142              default:
    143                break;
    144            }
    145          }
    146          
    147          /*******************************************************************************
    148          * Function Name  : TIM_TimeBaseInit
    149          * Description    : Initializes the TIMx Time Base Unit peripheral according to 
    150          *                  the specified parameters in the TIM_TimeBaseInitStruct.
    151          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    152          *                  - TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
    153          *                   structure that contains the configuration information for
    154          *                   the specified TIM peripheral.
    155          * Output         : None
    156          * Return         : None
    157          *******************************************************************************/
    158          void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    159          {
    160            /* Check the parameters */
    161            assert(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
    162            assert(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
    163            
    164            /* Set the Autoreload value */
    165            TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
    166          
    167            /* Set the Prescaler value */
    168            TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
    169          
    170            /* Select the Counter Mode and set the clock division */
    171            TIMx->CR1 &= CR1_CKD_Mask & CR1_CounterMode_Mask;
    172            TIMx->CR1 |= (u32)TIM_TimeBaseInitStruct->TIM_ClockDivision |
    173                         TIM_TimeBaseInitStruct->TIM_CounterMode;
    174          }
    175          /*******************************************************************************
    176          * Function Name  : TIM_OCInit
    177          * Description    : Initializes the TIMx peripheral according to the specified
    178          *                  parameters in the TIM_OCInitStruct.
    179          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    180          *                  - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    181          *                    that contains the configuration information for the specified
    182          *                    TIM peripheral.
    183          * Output         : None
    184          * Return         : None
    185          *******************************************************************************/
    186          void TIM_OCInit(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
    187          {
    188            u32 tmpccmrx = 0, tmpccer = 0;
    189            
    190            /* Check the parameters */
    191            assert(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
    192            assert(IS_TIM_CHANNEL(TIM_OCInitStruct->TIM_Channel));
    193            assert(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));
    194          
    195            tmpccer = TIMx->CCER;
    196          
    197            if ((TIM_OCInitStruct->TIM_Channel == (u16)TIM_Channel_1) ||
    198                (TIM_OCInitStruct->TIM_Channel == (u16)TIM_Channel_2))
    199            {
    200              tmpccmrx = TIMx->CCMR1;
    201              
    202              /* Reset the Output Compare Bits */
    203              tmpccmrx &= Tab_OCModeMask[TIM_OCInitStruct->TIM_Channel];
    204          
    205              /* Set the Output Polarity level */
    206              tmpccer &= Tab_PolarityMask[TIM_OCInitStruct->TIM_Channel];
    207          
    208              if (TIM_OCInitStruct->TIM_Channel == TIM_Channel_1)
    209              {
    210                /* Disable the Channel 1: Reset the CCE Bit */
    211                TIMx->CCER &= CCER_CC1E_Reset;
    212          
    213                /* Select the Output Compare Mode */
    214                tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
    215          
    216                /* Set the Capture Compare Register value */
    217                TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
    218          
    219                /* Set the Capture Compare Enable Bit */
    220                tmpccer |= CCER_CC1E_Set;
    221          
    222                /* Set the Capture Compare Polarity */
    223                tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
    224              }
    225              else /* TIM_Channel_2 */
    226              {
    227                /* Disable the Channel 2: Reset the CCE Bit */
    228                TIMx->CCER &= CCER_CC2E_Reset;
    229          
    230                /* Select the Output Compare Mode */
    231                tmpccmrx |= (u32)TIM_OCInitStruct->TIM_OCMode << 8;
    232          
    233                /* Set the Capture Compare Register value */
    234                TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
    235          
    236                /* Set the Capture Compare Enable Bit */
    237                tmpccer |= CCER_CC2E_Set;
    238          
    239                /* Set the Capture Compare Polarity */
    240                tmpccer |= (u32)TIM_OCInitStruct->TIM_OCPolarity << 4;
    241              }
    242          
    243              TIMx->CCMR1 = (u16)tmpccmrx;
    244            }
    245            else 
    246            {
    247              if ((TIM_OCInitStruct->TIM_Channel == TIM_Channel_3) ||
    248                  (TIM_OCInitStruct->TIM_Channel == TIM_Channel_4))
    249              { 
    250                tmpccmrx = TIMx->CCMR2;
    251          
    252                /* Reset the Output Compare Bits */
    253                tmpccmrx &= Tab_OCModeMask[TIM_OCInitStruct->TIM_Channel];
    254          
    255                /* Set the Output Polarity level */
    256                tmpccer &= Tab_PolarityMask[TIM_OCInitStruct->TIM_Channel];
    257          
    258                if (TIM_OCInitStruct->TIM_Channel == TIM_Channel_3)
    259                {
    260                  /* Disable the Channel 3: Reset the CCE Bit */
    261                  TIMx->CCER &= CCER_CC3E_Reset;
    262          
    263                  /* Select the Output Compare Mode */
    264                  tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
    265          
    266                  /* Set the Capture Compare Register value */
    267                  TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
    268          
    269                  /* Set the Capture Compare Enable Bit */
    270                  tmpccer |= CCER_CC3E_Set;
    271          
    272                  /* Set the Capture Compare Polarity */
    273                  tmpccer |= (u32)TIM_OCInitStruct->TIM_OCPolarity << 8;
    274                }
    275                else  /* TIM_Channel_4 */
    276                {
    277                  /* Disable the Channel 4: Reset the CCE Bit */
    278                  TIMx->CCER &= CCER_CC4E_Reset;
    279          
    280                 /* Select the Output Compare Mode */
    281                  tmpccmrx |= (u32)TIM_OCInitStruct->TIM_OCMode << 8;
    282          
    283                  /* Set the Capture Compare Register value */
    284                  TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
    285          
    286                  /* Set the Capture Compare Enable Bit */
    287                  tmpccer |= CCER_CC4E_Set;
    288          
    289                  /* Set the Capture Compare Polarity */
    290                  tmpccer |= (u32)TIM_OCInitStruct->TIM_OCPolarity << 12;
    291                }
    292          
    293                TIMx->CCMR2 = (u16)tmpccmrx;
    294              }
    295            }
    296            
    297            TIMx->CCER = (u16)tmpccer;
    298          }
    299          
    300          /*******************************************************************************
    301          * Function Name  : TIM_ICInit
    302          * Description    : Initializes the TIMx peripheral according to the specified
    303          *                  parameters in the TIM_ICInitStruct.
    304          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    305          *                  - TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
    306          *                    that contains the configuration information for the specified
    307          *                    TIM peripheral.
    308          * Output         : None
    309          * Return         : None
    310          *******************************************************************************/
    311          void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
    312          {
    313            /* Check the parameters */
    314            assert(IS_TIM_IC_MODE(TIM_ICInitStruct->TIM_ICMode));
    315            assert(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));
    316            assert(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
    317            assert(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
    318            assert(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
    319            assert(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
    320            
    321            if (TIM_ICInitStruct->TIM_ICMode == TIM_ICMode_ICAP)
    322            {
    323              if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
    324              {
    325                /* TI1 Configuration */
    326                TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    327                           TIM_ICInitStruct->TIM_ICSelection,
    328                           TIM_ICInitStruct->TIM_ICFilter);
    329          
    330                /* Set the Input Capture Prescaler value */
    331                TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    332              }
    333              else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
    334              {
    335                /* TI2 Configuration */
    336                TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    337                           TIM_ICInitStruct->TIM_ICSelection,
    338                           TIM_ICInitStruct->TIM_ICFilter);
    339          
    340                /* Set the Input Capture Prescaler value */
    341                TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    342              }
    343              else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
    344              {
    345                /* TI3 Configuration */
    346                TI3_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    347                           TIM_ICInitStruct->TIM_ICSelection,
    348                           TIM_ICInitStruct->TIM_ICFilter);
    349          
    350                /* Set the Input Capture Prescaler value */
    351                TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    352              }
    353              else /* TIM_Channel_4 */
    354              {
    355                /* TI4 Configuration */
    356                TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
    357                           TIM_ICInitStruct->TIM_ICSelection,
    358                           TIM_ICInitStruct->TIM_ICFilter);
    359          
    360                /* Set the Input Capture Prescaler value */
    361                TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
    362              }
    363            }
    364            else
    365            {
    366              PWMI_Config(TIMx, TIM_ICInitStruct);
    367            }
    368          }
    369          
    370          /*******************************************************************************
    371          * Function Name  : TIM_TimeBaseStructInit
    372          * Description    : Fills each TIM_TimeBaseInitStruct member with its default value.
    373          * Input          : - TIM_TimeBaseInitStruct: pointer to a TIM_TimeBaseInitTypeDef
    374          *                    structure which will be initialized.
    375          * Output         : None
    376          * Return         : None
    377          *******************************************************************************/
    378          void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
    379          {
    380            /* Set the default configuration */
    381            TIM_TimeBaseInitStruct->TIM_Period = TIM_Period_Reset_Mask;
    382            TIM_TimeBaseInitStruct->TIM_Prescaler = TIM_Prescaler_Reset_Mask;
    383            TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
    384            TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
    385          }
    386          
    387          /*******************************************************************************
    388          * Function Name  : TIM_OCStructInit
    389          * Description    : Fills each TIM_OCInitStruct member with its default value.
    390          * Input          : - TIM_OCInitStruct: pointer to a TIM_OCInitTypeDef structure
    391          *                    which will be initialized.
    392          * Output         : None
    393          * Return         : None
    394          *******************************************************************************/
    395          void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
    396          {
    397            /* Set the default configuration */
    398            TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
    399            TIM_OCInitStruct->TIM_Channel = TIM_Channel_1;
    400            TIM_OCInitStruct->TIM_Pulse = TIM_Pulse_Reset_Mask;
    401            TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
    402          }
    403          
    404          /*******************************************************************************
    405          * Function Name  : TIM_ICStructInit
    406          * Description    : Fills each TIM_InitStruct member with its default value.
    407          * Input          : - TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
    408          *                    which will be initialized.
    409          * Output         : None
    410          * Return         : None
    411          *******************************************************************************/
    412          void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
    413          {
    414            /* Set the default configuration */
    415            TIM_ICInitStruct->TIM_ICMode = TIM_ICMode_ICAP;
    416            TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
    417            TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
    418            TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
    419            TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
    420            TIM_ICInitStruct->TIM_ICFilter = TIM_ICFilter_Mask;
    421          }
    422          
    423          /*******************************************************************************
    424          * Function Name  : TIM_Cmd
    425          * Description    : Enables or disables the specified TIM peripheral.
    426          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIMx peripheral.
    427          *                  - Newstate: new state of the TIMx peripheral.
    428          *                    This parameter can be: ENABLE or DISABLE.
    429          * Output         : None
    430          * Return         : None
    431          *******************************************************************************/
    432          void TIM_Cmd(TIM_TypeDef* TIMx, u32 NewState)
    433          {
    434              if (NewState != DISABLE)
    435              {
    436                  // Enable the TIM Counter */
    437                  TIMx->CR1 |= CR1_CEN_Set;
    438              }
    439              else
    440              {
    441                  // Disable the TIM Counter
    442                  TIMx->CR1 &= CR1_CEN_Reset;
    443            }
    444          }
    445          
    446          /*******************************************************************************
    447          * Function Name  : TIM_ITConfig
    448          * Description    : Enables or disables the TIMx interrupts.
    449          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    450          *                  - TIM_IT: specifies the TIM interrupts sources to be enabled
    451          *                    or disabled.
    452          *                    This parameter can be any combination of the following values:
    453          *                       - TIM_IT_Update: Timer update Interrupt
    454          *                       - TIM_IT_CC1: Capture Compare 1 Interrupt
    455          *                       - TIM_IT_CC2: Capture Compare 2 Interrupt
    456          *                       - TIM_IT_CC3: Capture Compare 3 Interrupt
    457          *                       - TIM_IT_CC4: Capture Compare 4 Interrupt
    458          *                       - TIM_IT_Trigger: Trigger Interrupt
    459          *                  - Newstate: new state of the specified TIMx interrupts.
    460          *                    This parameter can be: ENABLE or DISABLE.
    461          * Output         : None
    462          * Return         : None
    463          *******************************************************************************/
    464          void TIM_ITConfig(TIM_TypeDef* TIMx, u16 TIM_IT, u32 NewState)
    465          {
    466              if (NewState != DISABLE)
    467              {
    468                  // Enable the Interrupt sources
    469                  TIMx->DIER |= TIM_IT;
    470              }
    471              else
    472              {
    473                  // Disable the Interrupt sources
    474                  TIMx->DIER &= (u16)(~TIM_IT);
    475              }
    476          }
    477          
    478          /*******************************************************************************
    479          * Function Name  : TIM_DMAConfig
    480          * Description    : Configures the TIMx’s DMA interface.
    481          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    482          *                  - TIM_DMABase: DMA Base address.
    483          *                    This parameter can be one of the following values:
    484          *                       - TIM_DMABase_CR1, TIM_DMABase_CR2, TIM_DMABase_SMCR,
    485          *                         TIM_DMABase_DIER, TIM_DMABase_SR, TIM_DMABase_EGR,
    486          *                         TIM_DMABase_CCMR1, TIM_DMABase_CCMR2, TIM_DMABase_CCER,
    487          *                         TIM_DMABase_CNT, TIM_DMABase_PSC, TIM_DMABase_ARR,
    488          *                         TIM_DMABase_CCR1, TIM_DMABase_CCR2, TIM_DMABase_CCR3,
    489          *                         TIM_DMABase_CCR4, TIM_DMABase_DCR.
    490          *                  - TIM_DMABurstLength: DMA Burst length.
    491          *                    This parameter can be one value between:
    492          *                    TIM_DMABurstLength_1Byte and TIM_DMABurstLength_18Bytes.
    493          * Output         : None
    494          * Return         : None
    495          *******************************************************************************/
    496          void TIM_DMAConfig(TIM_TypeDef* TIMx, u16 TIM_DMABase, u16 TIM_DMABurstLength)
    497          {
    498            u32 tmpdcr = 0;
    499          
    500            /* Check the parameters */
    501            assert(IS_TIM_DMA_BASE(TIM_DMABase));
    502            assert(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
    503            
    504            tmpdcr = TIMx->DCR;
    505          
    506            /* Reset the DBA and the DBL Bits */
    507            tmpdcr &= DCR_DMA_Mask;
    508          
    509            /* Set the DMA Base and the DMA Burst Length */
    510            tmpdcr |= TIM_DMABase | TIM_DMABurstLength;
    511          
    512            TIMx->DCR = (u16)tmpdcr;
    513          }
    514          
    515          /*******************************************************************************
    516          * Function Name  : TIM_DMACmd
    517          * Description    : Enables or disables the TIMx’s DMA Requests.
    518          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    519          *                  - TIM_DMASources: specifies the DMA Request sources.
    520          *                    This parameter can be any combination of the following values:
    521          *                       - TIM_DMA_CC1: Capture Compare 1 DMA source
    522          *                       - TIM_DMA_CC2: Capture Compare 2 DMA source
    523          *                       - TIM_DMA_CC3: Capture Compare 3 DMA source
    524          *                       - TIM_DMA_CC4: Capture Compare 4 DMA source
    525          *                       - TIM_DMA_Trigger: Trigger DMA source
    526          *                  - Newstate: new state of the DMA Request sources.
    527          *                    This parameter can be: ENABLE or DISABLE.
    528          * Output         : None
    529          * Return         : None
    530          *******************************************************************************/
    531          void TIM_DMACmd(TIM_TypeDef* TIMx, u16 TIM_DMASource, u32 Newstate)
    532          {
    533              u32 tmpdier = 0;
    534              tmpdier = TIMx->DIER;
    535          
    536              if (Newstate != DISABLE)
    537              {
    538                  // Enable the DMA sources
    539                  tmpdier |= TIM_DMASource;
    540              }
    541              else
    542              {
    543                  // Disable the DMA sources
    544                  tmpdier &= (u16)(~TIM_DMASource);
    545              }
    546              TIMx->DIER = (u16)tmpdier;
    547          }
    548          
    549          /*******************************************************************************
    550          * Function Name  : TIM_InternalClockConfig
    551          * Description    : Configures the TIMx interrnal Clock
    552          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    553          * Output         : None
    554          * Return         : None
    555          *******************************************************************************/
    556          void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
    557          {
    558            /* Disable slave mode to clock the prescaler directly with the internal clock */
    559            TIMx->SMCR &=  SMCR_SMS_Mask;
    560          }
    561          /*******************************************************************************
    562          * Function Name  : TIM_ITRxExternalClockConfig
    563          * Description    : Configures the TIMx Internal Trigger as External Clock
    564          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    565          *                  - TIM_ITRSource: Trigger source.
    566          *                    This parameter can be one of the following values:
    567          *                       - TIM_TS_ITR0: Internal Trigger 0
    568          *                       - TIM_TS_ITR1: Internal Trigger 1
    569          *                       - TIM_TS_ITR2: Internal Trigger 2
    570          *                       - TIM_TS_ITR3: Internal Trigger 3
    571          * Output         : None
    572          * Return         : None
    573          *******************************************************************************/
    574          void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
    575          {
    576            /* Check the parameters */
    577            assert(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
    578          
    579            /* Select the Internal Trigger */
    580            TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
    581          
    582            /* Select the External clock mode1 */
    583            TIMx->SMCR |= TIM_SlaveMode_External1;
    584          }
    585          /*******************************************************************************
    586          * Function Name  : TIM_TIxExternalClockConfig
    587          * Description    : Configures the TIMx Trigger as External Clock
    588          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    589          *                  - TIM_TIxExternalCLKSource: Trigger source.
    590          *                    This parameter can be one of the following values:
    591          *                       - TIM_TS_TI1F_ED: TI1 Edge Detector
    592          *                       - TIM_TS_TI1FP1: Filtered Timer Input 1
    593          *                       - TIM_TS_TI2FP2: Filtered Timer Input 2
    594          *                  - TIM_ICPolarity: specifies the TIx Polarity.
    595          *                    This parameter can be:
    596          *                       - TIM_ICPolarity_Rising
    597          *                       - TIM_ICPolarity_Falling
    598          *                   - ICFilter : specifies the filter value.
    599          *                     This parameter must be a value between 0x0 and 0xF.
    600          * Output         : None
    601          * Return         : None
    602          *******************************************************************************/
    603          void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, u16 TIM_TIxExternalCLKSource,
    604                                          u16 TIM_ICPolarity, u8 ICFilter)
    605          {
    606            /* Check the parameters */
    607            assert(IS_TIM_TIX_TRIGGER_SELECTION(TIM_TIxExternalCLKSource));
    608            assert(IS_TIM_IC_POLARITY(TIM_ICPolarity));
    609            assert(IS_TIM_IC_FILTER(ICFilter));
    610          
    611            /* Configure the Timer Input Clock Source */
    612            if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
    613            {
    614              TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
    615            }
    616            else
    617            {
    618              TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
    619            }
    620          
    621            /* Select the Trigger source */
    622            TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
    623          
    624            /* Select the External clock mode1 */
    625            TIMx->SMCR |= TIM_SlaveMode_External1;
    626          }
    627          
    628          /*******************************************************************************
    629          * Function Name  : TIM_ETRClockMode1Config
    630          * Description    : Configures the External clock Mode1
    631          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    632          *                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
    633          *                    It can be one of the following values:
    634          *                       - TIM_ExtTRGPSC_OFF
    635          *                       - TIM_ExtTRGPSC_DIV2
    636          *                       - TIM_ExtTRGPSC_DIV4
    637          *                       - TIM_ExtTRGPSC_DIV8.
    638          *                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
    639          *                    It can be one of the following values:
    640          *                       - TIM_ExtTRGPolarity_Inverted
    641          *                       - TIM_ExtTRGPolarity_NonInverted
    642          *                  - ExtTRGFilter: External Trigger Filter.
    643          *                    This parameter must be a value between 0x00 and 0x0F
    644          * Output         : None
    645          * Return         : None
    646          *******************************************************************************/
    647          void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
    648                                       u8 ExtTRGFilter)
    649          {
    650            /* Check the parameters */
    651            assert(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
    652            assert(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
    653          
    654            /* Configure the ETR Clock source */
    655            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
    656          
    657            /* Select the External clock mode1 */
    658            TIMx->SMCR &= SMCR_SMS_Mask;
    659            TIMx->SMCR |= TIM_SlaveMode_External1;
    660          
    661            /* Select the Trigger selection : ETRF */
    662            TIMx->SMCR &= SMCR_TS_Mask;
    663            TIMx->SMCR |= TIM_TS_ETRF;
    664          }
    665          
    666          /*******************************************************************************
    667          * Function Name  : TIM_ETRClockMode2Config
    668          * Description    : Configures the External clock Mode2
    669          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    670          *                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
    671          *                    It can be one of the following values:
    672          *                       - TIM_ExtTRGPSC_OFF
    673          *                       - TIM_ExtTRGPSC_DIV2
    674          *                       - TIM_ExtTRGPSC_DIV4
    675          *                       - TIM_ExtTRGPSC_DIV8
    676          *                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
    677          *                    It can be one of the following values:
    678          *                       - TIM_ExtTRGPolarity_Inverted
    679          *                       - TIM_ExtTRGPolarity_NonInverted
    680          *                  - ExtTRGFilter: External Trigger Filter.
    681          *                    This parameter must be a value between 0x00 and 0x0F
    682          * Output         : None
    683          * Return         : None
    684          *******************************************************************************/
    685          void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, 
    686                                       u16 TIM_ExtTRGPolarity, u8 ExtTRGFilter)
    687          {
    688            /* Check the parameters */
    689            assert(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
    690            assert(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
    691          
    692            /* Configure the ETR Clock source */
    693            TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
    694          
    695            /* Enable the External clock mode2 */
    696            TIMx->SMCR |= SMCR_ECE_Set;
    697          }
    698          
    699          /*******************************************************************************
    700          * Function Name  : TIM_ETRConfig
    701          * Description    : Configures the TIMx External Trigger (ETR).
    702          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    703          *                  - TIM_ExtTRGPrescaler: The external Trigger Prescaler.
    704          *                    This parameter can be one of the following values:
    705          *                       - TIM_ExtTRGPSC_OFF
    706          *                       - TIM_ExtTRGPSC_DIV2
    707          *                       - TIM_ExtTRGPSC_DIV4
    708          *                       - TIM_ExtTRGPSC_DIV8
    709          *                  - TIM_ExtTRGPolarity: The external Trigger Polarity.
    710          *                    This parameter can be one of the following values:
    711          *                       - TIM_ExtTRGPolarity_Inverted
    712          *                       - TIM_ExtTRGPolarity_NonInverted
    713          *                  - ExtTRGFilter: External Trigger Filter.
    714          *                    This parameter must be a value between 0x00 and 0x0F.
    715          * Output         : None
    716          * Return         : None
    717          *******************************************************************************/
    718           void TIM_ETRConfig(TIM_TypeDef* TIMx, u16 TIM_ExtTRGPrescaler, u16 TIM_ExtTRGPolarity,
    719                                 u8 ExtTRGFilter)
    720          {
    721            u32 tmpsmcr = 0;
    722          
    723            tmpsmcr = TIMx->SMCR;
    724          
    725            /* Set the Prescaler, the Filter value and the Polarity */
    726            tmpsmcr &= SMCR_ETR_Mask;
    727            tmpsmcr |= TIM_ExtTRGPrescaler | TIM_ExtTRGPolarity | (u16)((u16)ExtTRGFilter << 8);
    728          
    729            TIMx->SMCR = (u16)tmpsmcr;
    730          }
    731          
    732          /*******************************************************************************
    733          * Function Name  : TIM_SelectInputTrigger
    734          * Description    : Selects the Input Trigger source
    735          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    736          *                  - TIM_InputTriggerSource: The Input Trigger source.
    737          *                    This parameter can be one of the following values:
    738          *                       - TIM_TS_ITR0: Internal Trigger 0
    739          *                       - TIM_TS_ITR1: Internal Trigger 1
    740          *                       - TIM_TS_ITR2: Internal Trigger 2
    741          *                       - TIM_TS_ITR3: Internal Trigger 3
    742          *                       - TIM_TS_TI1F_ED: TI1 Edge Detector
    743          *                       - TIM_TS_TI1FP1: Filtered Timer Input 1
    744          *                       - TIM_TS_TI2FP2: Filtered Timer Input 2
    745          *                       - TIM_TS_ETRF: External Trigger input
    746          * Output         : None
    747          * Return         : None
    748          *******************************************************************************/
    749          void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, u16 TIM_InputTriggerSource)
    750          {
    751            u32 tmpsmcr = 0;
    752          
    753            /* Check the parameters */
    754            assert(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
    755          
    756            tmpsmcr = TIMx->SMCR;
    757          
    758            /* Select the Tgigger Source */
    759            tmpsmcr &= SMCR_TS_Mask;
    760            tmpsmcr |= TIM_InputTriggerSource;
    761          
    762            TIMx->SMCR = (u16)tmpsmcr;
    763          }
    764          
    765          /*******************************************************************************
    766          * Function Name  : TIM_PrescalerConfig
    767          * Description    : Configures the TIMx Prescaler.
    768          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    769          *                  - Prescaler: specifies the Prescaler Register value
    770          *                  - TIM_PSCReloadMode: specifies the TIM Prescaler Reload mode
    771          *                    This parameter can be one of the following values:
    772          *                       - TIM_PSCReloadMode_Update: The Prescaler is loaded at
    773          *                         the update event.
    774          *                       - TIM_PSCReloadMode_Immediate: The Prescaler is loaded
    775          *                         immediatly.
    776          * Output         : None
    777          * Return         : None
    778          *******************************************************************************/
    779          void TIM_PrescalerConfig(TIM_TypeDef* TIMx, u16 Prescaler, u16 TIM_PSCReloadMode)
    780          {
    781            /* Check the parameters */
    782            assert(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
    783          
    784            /* Set the Prescaler value */
    785            TIMx->PSC = Prescaler;
    786          
    787            /* Set or reset the UG Bit */
    788            if (TIM_PSCReloadMode == TIM_PSCReloadMode_Immediate)
    789            {
    790              TIMx->EGR |= TIM_EventSource_Update;
    791            }
    792            else
    793            {
    794              TIMx->EGR &= TIM_EventSource_Update;
    795            }
    796          }
    797          
    798          /*******************************************************************************
    799          * Function Name  : TIM_CounterModeConfig
    800          * Description    : Specifies the TIMx Counter Mode to be used.
    801          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    802          *                  - TIM_CounterMode: specifies the Counter Mode to be used
    803          *                    This parameter can be one of the following values:
    804          *                       - TIM_CounterMode_Up: TIM Up Counting Mode
    805          *                       - TIM_CounterMode_Down: TIM Down Counting Mode
    806          *                       - TIM_CounterMode_CenterAligned1: TIM Center Aligned Mode1
    807          *                       - TIM_CounterMode_CenterAligned2: TIM Center Aligned Mode2
    808          *                       - TIM_CounterMode_CenterAligned3: TIM Center Aligned Mode3
    809          * Output         : None
    810          * Return         : None
    811          *******************************************************************************/
    812          void TIM_CounterModeConfig(TIM_TypeDef* TIMx, u16 TIM_CounterMode)
    813          {
    814            u32 tmpcr1 = 0;
    815          
    816            /* Check the parameters */
    817            assert(IS_TIM_COUNTER_MODE(TIM_CounterMode));
    818          
    819            tmpcr1 = TIMx->CR1;
    820          
    821            /* Reset the CMS and DIR Bits */
    822            tmpcr1 &= CR1_CounterMode_Mask;
    823          
    824            /* Set the Counter Mode */
    825            tmpcr1 |= TIM_CounterMode;
    826          
    827            TIMx->CR1 = (u16)tmpcr1;
    828          }
    829          
    830          /*******************************************************************************
    831          * Function Name  : TIM_ForcedOC1Config
    832          * Description    : Forces the TIMx output 1 waveform to active or inactive level.
    833          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    834          *                  - TIM_ForcedAction: specifies the forced Action to be set to
    835          *                    the output waveform.
    836          *                    This parameter can be one of the following values:
    837          *                       - TIM_ForcedAction_Active: Force active level on OC1REF
    838          *                       - TIM_ForcedAction_InActive: Force inactive level on
    839          *                         OC1REF.
    840          * Output         : None
    841          * Return         : None
    842          *******************************************************************************/
    843          void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
    844          {
    845            u32 tmpccmr1 = 0;
    846          
    847            /* Check the parameters */
    848            assert(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
    849          
    850            tmpccmr1 = TIMx->CCMR1;
    851          
    852            /* Reset the OCM Bits */
    853            tmpccmr1 &= CCMR_OCM13_Mask;
    854          
    855            /* Configure The Forced output Mode */
    856            tmpccmr1 |= TIM_ForcedAction;
    857          
    858            TIMx->CCMR1 = (u16)tmpccmr1;
    859          }
    860          
    861          /*******************************************************************************
    862          * Function Name  : TIM_ForcedOC2Config
    863          * Description    : Forces the TIMx output 2 waveform to active or inactive level.
    864          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    865          *                  - TIM_ForcedAction: specifies the forced Action to be set to
    866          *                    the output waveform.
    867          *                    This parameter can be one of the following values:
    868          *                       - TIM_ForcedAction_Active: Force active level on OC2REF
    869          *                       - TIM_ForcedAction_InActive: Force inactive level on
    870          *                         OC2REF.
    871          * Output         : None
    872          * Return         : None
    873          *******************************************************************************/
    874          void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
    875          {
    876            u32 tmpccmr1 = 0;
    877          
    878            /* Check the parameters */
    879            assert(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
    880          
    881            tmpccmr1 = TIMx->CCMR1;
    882          
    883            /* Reset the OCM Bits */
    884            tmpccmr1 &= CCMR_OCM24_Mask;
    885          
    886            /* Configure The Forced output Mode */
    887            tmpccmr1 |= (u16)(TIM_ForcedAction << 8);
    888          
    889            TIMx->CCMR1 = (u16)tmpccmr1;
    890          }
    891          
    892          /*******************************************************************************
    893          * Function Name  : TIM_ForcedOC3Config
    894          * Description    : Forces the TIMx output 3 waveform to active or inactive level.
    895          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    896          *                  - TIM_ForcedAction: specifies the forced Action to be set to
    897          *                    the output waveform.
    898          *                    This parameter can be one of the following values:
    899          *                       - TIM_ForcedAction_Active: Force active level on OC3REF
    900          *                       - TIM_ForcedAction_InActive: Force inactive level on
    901          *                         OC3REF.
    902          * Output         : None
    903          * Return         : None
    904          *******************************************************************************/
    905          void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
    906          {
    907            u32 tmpccmr2 = 0;
    908          
    909            /* Check the parameters */
    910            assert(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
    911          
    912            tmpccmr2 = TIMx->CCMR2;
    913          
    914            /* Reset the OCM Bits */
    915            tmpccmr2 &= CCMR_OCM13_Mask;
    916          
    917            /* Configure The Forced output Mode */
    918            tmpccmr2 |= TIM_ForcedAction;
    919          
    920            TIMx->CCMR2 = (u16)tmpccmr2;
    921          }
    922          
    923          /*******************************************************************************
    924          * Function Name  : TIM_ForcedOC4Config
    925          * Description    : Forces the TIMx output 4 waveform to active or inactive level.
    926          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    927          *                  - TIM_ForcedAction: specifies the forced Action to be set to
    928          *                    the output waveform.
    929          *                    This parameter can be one of the following values:
    930          *                       - TIM_ForcedAction_Active: Force active level on OC4REF
    931          *                       - TIM_ForcedAction_InActive: Force inactive level on
    932          *                         OC4REF.
    933          * Output         : None
    934          * Return         : None
    935          *******************************************************************************/
    936          void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, u16 TIM_ForcedAction)
    937          {
    938            u32 tmpccmr2 = 0;
    939          
    940            /* Check the parameters */
    941            assert(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
    942          
    943            tmpccmr2 = TIMx->CCMR2;
    944          
    945            /* Reset the OCM Bits */
    946            tmpccmr2 &= CCMR_OCM24_Mask;
    947          
    948            /* Configure The Forced output Mode */
    949            tmpccmr2 |= (u16)(TIM_ForcedAction << 8);
    950          
    951            TIMx->CCMR2 = (u16)tmpccmr2;
    952          }
    953          
    954          /*******************************************************************************
    955          * Function Name  : TIM_ARRPreloadConfig
    956          * Description    : Enables or disables TIMx peripheral Preload register on ARR.
    957          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    958          *                  - Newstate: new state of the TIMx peripheral Preload register
    959          *                    This parameter can be: ENABLE or DISABLE.
    960          * Output         : None
    961          * Return         : None
    962          *******************************************************************************/
    963          void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, u32 Newstate)
    964          {
    965              u32 tmpcr1 = 0;
    966              
    967               tmpcr1 = TIMx->CR1;
    968            
    969              if (Newstate != DISABLE)
    970              {
    971                  // Set the ARR Preload Bit
    972                  tmpcr1 |= CR1_ARPE_Set;
    973              }
    974              else
    975              {
    976                  // Reset the ARR Preload Bit
    977                  tmpcr1 &= CR1_ARPE_Reset;
    978              }
    979            
    980              TIMx->CR1 = (u16)tmpcr1;
    981          }
    982          
    983          /*******************************************************************************
    984          * Function Name  : TIM_SelectCCDMA
    985          * Description    : Selects the TIMx peripheral Capture Compare DMA source.
    986          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
    987          *                  - Newstate: new state of the Capture Compare DMA source
    988          *                    This parameter can be: ENABLE or DISABLE.
    989          * Output         : None
    990          * Return         : None
    991          *******************************************************************************/
    992          void TIM_SelectCCDMA(TIM_TypeDef* TIMx, u32 Newstate)
    993          {
    994              u32 tmpcr2 = 0;
    995              tmpcr2 = TIMx->CR2;
    996          
    997              if (Newstate != DISABLE)
    998              {
    999                  // Set the CCDS Bit
   1000                  tmpcr2 |= CR2_CCDS_Set;
   1001              }
   1002              else
   1003              {
   1004                  // Reset the CCDS Bit
   1005                  tmpcr2 &= CR2_CCDS_Reset;
   1006              }
   1007            
   1008              TIMx->CR2 = (u16)tmpcr2;
   1009          }
   1010          
   1011          /*******************************************************************************
   1012          * Function Name  : TIM_OC1PreloadConfig
   1013          * Description    : Enables or disables the TIMx peripheral Preload register on CCR1.
   1014          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1015          *                  - TIM_OCPreload: new state of the TIMx peripheral Preload
   1016          *                    register
   1017          *                    This parameter can be one of the following values:
   1018          *                       - TIM_OCPreload_Enable
   1019          *                       - TIM_OCPreload_Disable
   1020          * Output         : None
   1021          * Return         : None
   1022          *******************************************************************************/
   1023          void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
   1024          {
   1025            u32 tmpccmr1 = 0;
   1026          
   1027            /* Check the parameters */
   1028            assert(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1029          
   1030            tmpccmr1 = TIMx->CCMR1;
   1031          
   1032            /* Reset the OCPE Bit */
   1033            tmpccmr1 &= CCMR_OC13PE_Mask;
   1034          
   1035            /* Enable or Disable the Output Compare Preload feature */
   1036            tmpccmr1 |= TIM_OCPreload;
   1037          
   1038            TIMx->CCMR1 = (u16)tmpccmr1;
   1039          }
   1040          
   1041          /*******************************************************************************
   1042          * Function Name  : TIM_OC2PreloadConfig
   1043          * Description    : Enables or disables the TIMx peripheral Preload register on CCR2.
   1044          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1045          *                  - TIM_OCPreload: new state of the TIMx peripheral Preload
   1046          *                    register
   1047          *                    This parameter can be one of the following values:
   1048          *                       - TIM_OCPreload_Enable
   1049          *                       - TIM_OCPreload_Disable
   1050          * Output         : None
   1051          * Return         : None
   1052          *******************************************************************************/
   1053          void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
   1054          {
   1055            u32 tmpccmr1 = 0;
   1056          
   1057            /* Check the parameters */
   1058            assert(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1059          
   1060            tmpccmr1 = TIMx->CCMR1;
   1061          
   1062            /* Reset the OCPE Bit */
   1063            tmpccmr1 &= CCMR_OC24PE_Mask;
   1064          
   1065            /* Enable or Disable the Output Compare Preload feature */
   1066            tmpccmr1 |= (u16)(TIM_OCPreload << 8);
   1067          
   1068            TIMx->CCMR1 = (u16)tmpccmr1;
   1069          }
   1070          
   1071          /*******************************************************************************
   1072          * Function Name  : TIM_OC3PreloadConfig
   1073          * Description    : Enables or disables the TIMx peripheral Preload register on CCR3.
   1074          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1075          *                  - TIM_OCPreload: new state of the TIMx peripheral Preload
   1076          *                    register
   1077          *                    This parameter can be one of the following values:
   1078          *                       - TIM_OCPreload_Enable
   1079          *                       - TIM_OCPreload_Disable
   1080          * Output         : None
   1081          * Return         : None
   1082          *******************************************************************************/
   1083          void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
   1084          {
   1085            u32 tmpccmr2 = 0;
   1086          
   1087            /* Check the parameters */
   1088            assert(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1089          
   1090            tmpccmr2 = TIMx->CCMR2;
   1091          
   1092            /* Reset the OCPE Bit */
   1093            tmpccmr2 &= CCMR_OC13PE_Mask;
   1094          
   1095            /* Enable or Disable the Output Compare Preload feature */
   1096            tmpccmr2 |= TIM_OCPreload;
   1097          
   1098            TIMx->CCMR2 = (u16)tmpccmr2;
   1099          }
   1100          
   1101          /*******************************************************************************
   1102          * Function Name  : TIM_OC4PreloadConfig
   1103          * Description    : Enables or disables the TIMx peripheral Preload register on CCR4.
   1104          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1105          *                  - TIM_OCPreload: new state of the TIMx peripheral Preload
   1106          *                    register
   1107          *                    This parameter can be one of the following values:
   1108          *                       - TIM_OCPreload_Enable
   1109          *                       - TIM_OCPreload_Disable
   1110          * Output         : None
   1111          * Return         : None
   1112          *******************************************************************************/
   1113          void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, u16 TIM_OCPreload)
   1114          {
   1115            u32 tmpccmr2 = 0;
   1116          
   1117            /* Check the parameters */
   1118            assert(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
   1119          
   1120            tmpccmr2 = TIMx->CCMR2;
   1121          
   1122            /* Reset the OCPE Bit */
   1123            tmpccmr2 &= CCMR_OC24PE_Mask;
   1124          
   1125            /* Enable or Disable the Output Compare Preload feature */
   1126            tmpccmr2 |= (u16)(TIM_OCPreload << 8);
   1127          
   1128            TIMx->CCMR2 = (u16)tmpccmr2;
   1129          }
   1130          
   1131          /*******************************************************************************
   1132          * Function Name  : TIM_OC1FastConfig
   1133          * Description    : Configures the TIMx Output Compare 1 Fast feature.
   1134          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1135          *                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1136          *                    This parameter can be one of the following values:
   1137          *                       - TIM_OCFast_Enable
   1138          *                       - TIM_OCFast_Disable
   1139          * Output         : None
   1140          * Return         : None
   1141          *******************************************************************************/
   1142          void TIM_OC1FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
   1143          {
   1144            u32 tmpccmr1 = 0;
   1145          
   1146            /* Check the parameters */
   1147            assert(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1148          
   1149            tmpccmr1 = TIMx->CCMR1;
   1150          
   1151            /* Reset the OCFE Bit */
   1152            tmpccmr1 &= CCMR_OC13FE_Mask;
   1153          
   1154            /* Enable or Disable the Output Compare Fast Bit */
   1155            tmpccmr1 |= TIM_OCFast;
   1156          
   1157            TIMx->CCMR1 = (u16)tmpccmr1;
   1158          }
   1159          
   1160          /*******************************************************************************
   1161          * Function Name  : TIM_OC2FastConfig
   1162          * Description    : Configures the TIMx Output Compare 2 Fast feature.
   1163          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1164          *                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1165          *                    This parameter can be one of the following values:
   1166          *                       - TIM_OCFast_Enable
   1167          *                       - TIM_OCFast_Disable
   1168          * Output         : None
   1169          * Return         : None
   1170          *******************************************************************************/
   1171          void TIM_OC2FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
   1172          {
   1173            u32 tmpccmr1 = 0;
   1174          
   1175            /* Check the parameters */
   1176            assert(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1177          
   1178            tmpccmr1 = TIMx->CCMR1;
   1179          
   1180            /* Reset the OCFE Bit */
   1181            tmpccmr1 &= CCMR_OC24FE_Mask;
   1182          
   1183            /* Enable or Disable the Output Compare Fast Bit */
   1184            tmpccmr1 |= (u16)(TIM_OCFast << 8);
   1185          
   1186            TIMx->CCMR1 = (u16)tmpccmr1;
   1187          }
   1188          
   1189          /*******************************************************************************
   1190          * Function Name  : TIM_OC3FastConfig
   1191          * Description    : Configures the TIMx Output Compare 3 Fast feature.
   1192          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1193          *                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1194          *                    This parameter can be one of the following values:
   1195          *                       - TIM_OCFast_Enable
   1196          *                       - TIM_OCFast_Disable
   1197          * Output         : None
   1198          * Return         : None
   1199          *******************************************************************************/
   1200          void TIM_OC3FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
   1201          {
   1202            u32 tmpccmr2 = 0;
   1203          
   1204            /* Check the parameters */
   1205            assert(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1206          
   1207            tmpccmr2 = TIMx->CCMR2;
   1208          
   1209            /* Reset the OCFE Bit */
   1210            tmpccmr2 &= CCMR_OC13FE_Mask;
   1211          
   1212            /* Enable or Disable the Output Compare Fast Bit */
   1213            tmpccmr2 |= TIM_OCFast;
   1214          
   1215            TIMx->CCMR2 = (u16)tmpccmr2;
   1216          }
   1217          
   1218          /*******************************************************************************
   1219          * Function Name  : TIM_OC4FastConfig
   1220          * Description    : Configures the TIMx Output Compare 4 Fast feature.
   1221          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1222          *                  - TIM_OCFast: new state of the Output Compare Fast Enable Bit.
   1223          *                    This parameter can be one of the following values:
   1224          *                       - TIM_OCFast_Enable
   1225          *                       - TIM_OCFast_Disable
   1226          * Output         : None
   1227          * Return         : None
   1228          *******************************************************************************/
   1229          void TIM_OC4FastConfig(TIM_TypeDef* TIMx, u16 TIM_OCFast)
   1230          {
   1231            u32 tmpccmr2 = 0;
   1232          
   1233            /* Check the parameters */
   1234            assert(IS_TIM_OCFAST_STATE(TIM_OCFast));
   1235          
   1236            tmpccmr2 = TIMx->CCMR2;
   1237          
   1238            /* Reset the OCFE Bit */
   1239            tmpccmr2 &= CCMR_OC24FE_Mask;
   1240          
   1241            /* Enable or Disable the Output Compare Fast Bit */
   1242            tmpccmr2 |= (u16)(TIM_OCFast << 8);
   1243          
   1244            TIMx->CCMR2 = (u16)tmpccmr2;
   1245          }
   1246          
   1247          /*******************************************************************************
   1248          * Function Name  : TIM_ClearOC1Ref
   1249          * Description    : Clears or safeguards the OCREF1 signal on an external event
   1250          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1251          *                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1252          *                    This parameter can be one of the following values:
   1253          *                       - TIM_OCClear_Enable
   1254          *                       - TIM_OCClear_Disable
   1255          * Output         : None
   1256          * Return         : None
   1257          *******************************************************************************/
   1258          void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
   1259          {
   1260            u32 tmpccmr1 = 0;
   1261          
   1262            /* Check the parameters */
   1263            assert(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1264          
   1265            tmpccmr1 = TIMx->CCMR1;
   1266          
   1267            /* Reset the OCFE Bit */
   1268            tmpccmr1 &= CCMR_OC13CE_Mask;
   1269          
   1270            /* Enable or Disable the Output Compare Clear Bit */
   1271            tmpccmr1 |= (u16)(TIM_OCClear);
   1272          
   1273            TIMx->CCMR1 = (u16)tmpccmr1;
   1274          }
   1275          
   1276          /*******************************************************************************
   1277          * Function Name  : TIM_ClearOC2Ref
   1278          * Description    : Clears or safeguards the OCREF2 signal on an external event
   1279          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1280          *                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1281          *                    This parameter can be one of the following values:
   1282          *                       - TIM_OCClear_Enable
   1283          *                       - TIM_OCClear_Disable
   1284          * Output         : None
   1285          * Return         : None
   1286          *******************************************************************************/
   1287          void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
   1288          {
   1289            u32 tmpccmr1 = 0;
   1290          
   1291            /* Check the parameters */
   1292            assert(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1293          
   1294            tmpccmr1 = TIMx->CCMR1;
   1295          
   1296            /* Reset the OCFE Bit */
   1297            tmpccmr1 &= CCMR_OC24CE_Mask;
   1298          
   1299            /* Enable or Disable the Output Compare Clear Bit */
   1300            tmpccmr1 |= (u16)(TIM_OCClear << 8);
   1301          
   1302            TIMx->CCMR1 = (u16)tmpccmr1;
   1303          }
   1304          
   1305          /*******************************************************************************
   1306          * Function Name  : TIM_ClearOC3Ref
   1307          * Description    : Clears or safeguards the OCREF3 signal on an external event
   1308          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1309          *                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1310          *                    This parameter can be one of the following values:
   1311          *                       - TIM_OCClear_Enable
   1312          *                       - TIM_OCClear_Disable
   1313          * Output         : None
   1314          * Return         : None
   1315          *******************************************************************************/
   1316          void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
   1317          {
   1318            u32 tmpccmr2 = 0;
   1319          
   1320            /* Check the parameters */
   1321            assert(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1322          
   1323            tmpccmr2 = TIMx->CCMR2;
   1324          
   1325            /* Reset the OCFE Bit */
   1326            tmpccmr2 &= CCMR_OC13CE_Mask;
   1327          
   1328            /* Enable or Disable the Output Compare Clear Bit */
   1329            tmpccmr2 |= (u16)(TIM_OCClear);
   1330          
   1331            TIMx->CCMR2 = (u16)tmpccmr2;
   1332          }
   1333          
   1334          /*******************************************************************************
   1335          * Function Name  : TIM_ClearOC4Ref
   1336          * Description    : Clears or safeguards the OCREF4 signal on an external event
   1337          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1338          *                  - TIM_OCClear: new state of the Output Compare Clear Enable Bit.
   1339          *                    This parameter can be one of the following values:
   1340          *                       - TIM_OCClear_Enable
   1341          *                       - TIM_OCClear_Disable
   1342          * Output         : None
   1343          * Return         : None
   1344          *******************************************************************************/
   1345          void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, u16 TIM_OCClear)
   1346          {
   1347            u32 tmpccmr2 = 0;
   1348          
   1349            /* Check the parameters */
   1350            assert(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
   1351          
   1352            tmpccmr2 = TIMx->CCMR2;
   1353          
   1354            /* Reset the OCFE Bit */
   1355            tmpccmr2 &= CCMR_OC24CE_Mask;
   1356          
   1357            /* Enable or Disable the Output Compare Clear Bit */
   1358            tmpccmr2 |= (u16)(TIM_OCClear << 8);
   1359          
   1360            TIMx->CCMR2 = (u16)tmpccmr2;
   1361          }
   1362          
   1363          /*******************************************************************************
   1364          * Function Name  : TIM_UpdateDisableConfig
   1365          * Description    : Enables or Disables the TIMx Update event.
   1366          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1367          *                  - Newstate: new state of the TIMx peripheral Preload register
   1368          *                    This parameter can be: ENABLE or DISABLE.
   1369          * Output         : None
   1370          * Return         : None
   1371          *******************************************************************************/
   1372          void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, u32 Newstate)
   1373          {
   1374              u32 tmpcr1 = 0;
   1375            
   1376              tmpcr1 = TIMx->CR1;
   1377            
   1378              if (Newstate != DISABLE)
   1379              {
   1380                  // Set the Update Disable Bit
   1381                  tmpcr1 |= CR1_UDIS_Set;
   1382              }
   1383              else
   1384              {
   1385                  // Reset the Update Disable Bit
   1386                  tmpcr1 &= CR1_UDIS_Reset;
   1387              }
   1388            
   1389              TIMx->CR1 = (u16)tmpcr1;
   1390          }
   1391          
   1392          /*******************************************************************************
   1393          * Function Name  : TIM_EncoderInterfaceConfig
   1394          * Description    : Configures the TIMx Encoder Interface.
   1395          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1396          *                  - TIM_EncoderMode: specifies the TIMx Encoder Mode.
   1397          *                    This parameter can be one of the following values:
   1398          *                       - TIM_EncoderMode_TI1: Counter counts on TI1FP1 edge
   1399          *                         depending on TI2FP2 level.
   1400          *                       - TIM_EncoderMode_TI2: Counter counts on TI2FP2 edge
   1401          *                         depending on TI1FP1 level.
   1402          *                       - TIM_EncoderMode_TI12: Counter counts on both TI1FP1 and
   1403          *                         TI2FP2 edges depending on the level of the other input.
   1404          *                  - TIM_IC1Polarity: specifies the IC1 Polarity
   1405          *                    This parmeter can be one of the following values:
   1406          *                        - TIM_ICPolarity_Falling
   1407          *                        - TIM_ICPolarity_Rising
   1408          *                  - TIM_IC2Polarity: specifies the IC2 Polarity
   1409          *                    This parmeter can be one of the following values:
   1410          *                       - TIM_ICPolarity_Falling
   1411          *                       - TIM_ICPolarity_Rising
   1412          * Output         : None
   1413          * Return         : None
   1414          *******************************************************************************/
   1415          void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, u16 TIM_EncoderMode,
   1416                                          u16 TIM_IC1Polarity, u16 TIM_IC2Polarity)
   1417          {
   1418            u32 tmpsmcr = 0;
   1419            u32 tmpccmr1 = 0;
   1420            u32 tmpccer = 0;
   1421              
   1422            /* Check the parameters */
   1423            assert(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
   1424            assert(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
   1425            assert(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
   1426          
   1427            tmpsmcr = TIMx->SMCR;
   1428            tmpccmr1 = TIMx->CCMR1;
   1429            tmpccer = TIMx->CCER;
   1430          
   1431            /* Set the encoder Mode */
   1432            tmpsmcr &= SMCR_SMS_Mask;
   1433            tmpsmcr |= TIM_EncoderMode;
   1434          
   1435            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   1436            tmpccmr1 &= CCMR_CC13S_Mask & CCMR_CC24S_Mask;
   1437            tmpccmr1 |= CCMR_TI13Direct_Set | CCMR_TI24Direct_Set;
   1438          
   1439            /* Set the TI1 and the TI2 Polarities */
   1440            tmpccer &= CCER_CC1P_Mask & CCER_CC2P_Mask;
   1441            tmpccer |= (TIM_IC1Polarity | (u16)((u16)TIM_IC2Polarity << 4));
   1442          
   1443            TIMx->SMCR = (u16)tmpsmcr;
   1444          
   1445            TIMx->CCMR1 = (u16)tmpccmr1;
   1446          
   1447            TIMx->CCER = (u16)tmpccer;
   1448          }
   1449          
   1450          /*******************************************************************************
   1451          * Function Name  : TIM_GenerateEvent
   1452          * Description    : Configures the TIMx event to be generate by software.
   1453          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1454          *                  - TIM_EventSource: specifies the event source.
   1455          *                    This parameter can be one or more of the following values:
   1456          *                       - TIM_EventSource_Update: Timer update Event source
   1457          *                       - TIM_EventSource_CC1: Timer Capture Compare 1 Event source
   1458          *                       - TIM_EventSource_CC2: Timer Capture Compare 2 Event source
   1459          *                       - TIM_EventSource_CC3: Timer Capture Compare 3 Event source
   1460          *                       - TIM_EventSource_CC4: Timer Capture Compare 4 Event source
   1461          *                       - TIM_EventSource_Trigger: Timer Trigger Event source
   1462          * Output         : None
   1463          * Return         : None
   1464          *******************************************************************************/
   1465          void TIM_GenerateEvent(TIM_TypeDef* TIMx, u16 TIM_EventSource)
   1466          {
   1467            /* Check the parameters */
   1468            assert(IS_TIM_EVENT_SOURCE(TIM_EventSource));
   1469          
   1470            /* Set the event sources */
   1471            TIMx->EGR |= TIM_EventSource;
   1472          }
   1473          
   1474          /*******************************************************************************
   1475          * Function Name  : TIM_OC1PolarityConfig
   1476          * Description    : Configures the TIMx channel 1 polarity.
   1477          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1478          *                  - TIM_OCPolarity: specifies the OC1 Polarity
   1479          *                    This parmeter can be one of the following values:
   1480          *                       - TIM_OCPolarity_High: Output Compare active high
   1481          *                       - TIM_OCPolarity_Low: Output Compare active low
   1482          * Output         : None
   1483          * Return         : None
   1484          *******************************************************************************/
   1485          void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
   1486          {
   1487            u32 tmpccer = 0;
   1488          
   1489            /* Check the parameters */
   1490            assert(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1491          
   1492            tmpccer = TIMx->CCER;
   1493          
   1494            /* Set or Reset the CC1P Bit */
   1495            tmpccer &= CCER_CC1P_Mask;
   1496            tmpccer |= TIM_OCPolarity;
   1497          
   1498            TIMx->CCER = (u16)tmpccer;
   1499          }
   1500          
   1501          /*******************************************************************************
   1502          * Function Name  : TIM_OC2PolarityConfig
   1503          * Description    : Configures the TIMx channel 2 polarity.
   1504          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1505          *                  - TIM_OCPolarity: specifies the OC2 Polarity
   1506          *                    This parmeter can be one of the following values:
   1507          *                       - TIM_OCPolarity_High: Output Compare active high
   1508          *                       - TIM_OCPolarity_Low: Output Compare active low
   1509          * Output         : None
   1510          * Return         : None
   1511          *******************************************************************************/
   1512          void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
   1513          {
   1514            u32 tmpccer = 0;
   1515          
   1516            /* Check the parameters */
   1517            assert(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1518          
   1519            tmpccer = TIMx->CCER;
   1520          
   1521            /* Set or Reset the CC2P Bit */
   1522            tmpccer &= CCER_CC2P_Mask;
   1523            tmpccer |= (u16)((u16)TIM_OCPolarity << 4);
   1524          
   1525            TIMx->CCER = (u16)tmpccer;
   1526          }
   1527          
   1528          /*******************************************************************************
   1529          * Function Name  : TIM_OC3PolarityConfig
   1530          * Description    : Configures the TIMx channel 3 polarity.
   1531          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1532          *                  - TIM_OCPolarity: specifies the OC3 Polarity
   1533          *                    This parmeter can be one of the following values:
   1534          *                       - TIM_OCPolarity_High: Output Compare active high
   1535          *                       - TIM_OCPolarity_Low: Output Compare active low
   1536          * Output         : None
   1537          * Return         : None
   1538          *******************************************************************************/
   1539          void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
   1540          {
   1541            u32 tmpccer = 0;
   1542          
   1543            /* Check the parameters */
   1544            assert(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1545          
   1546            tmpccer = TIMx->CCER;
   1547          
   1548            /* Set or Reset the CC3P Bit */
   1549            tmpccer &= CCER_CC3P_Mask;
   1550            tmpccer |= (u16)((u16)TIM_OCPolarity << 8);
   1551          
   1552            TIMx->CCER = (u16)tmpccer;
   1553          }
   1554          
   1555          /*******************************************************************************
   1556          * Function Name  : TIM_OC4PolarityConfig
   1557          * Description    : Configures the TIMx channel 4 polarity.
   1558          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1559          *                  - TIM_OCPolarity: specifies the OC4 Polarity
   1560          *                    This parmeter can be one of the following values:
   1561          *                       - TIM_OCPolarity_High: Output Compare active high
   1562          *                       - TIM_OCPolarity_Low: Output Compare active low
   1563          * Output         : None
   1564          * Return         : None
   1565          *******************************************************************************/
   1566          void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, u16 TIM_OCPolarity)
   1567          {
   1568            u32 tmpccer = 0;
   1569          
   1570            /* Check the parameters */
   1571            assert(IS_TIM_OC_POLARITY(TIM_OCPolarity));
   1572          
   1573            tmpccer = TIMx->CCER;
   1574          
   1575            /* Set or Reset the CC4P Bit */
   1576            tmpccer &= CCER_CC4P_Mask;
   1577            tmpccer |= (u16)((u16)TIM_OCPolarity << 12);
   1578          
   1579            TIMx->CCER = (u16)tmpccer;
   1580          }
   1581          
   1582          /*******************************************************************************
   1583          * Function Name  : TIM_UpdateRequestConfig
   1584          * Description    : Configures the TIMx Update Request Interrupt source.
   1585          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1586          *                  - TIM_UpdateSource: specifies the Update source.
   1587          *                    This parameter can be one of the following values:
   1588          *                       - TIM_UpdateSource_Regular
   1589          *                       - TIM_UpdateSource_Global
   1590          * Output         : None
   1591          * Return         : None
   1592          *******************************************************************************/
   1593          void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, u16 TIM_UpdateSource)
   1594          {
   1595            u32 tmpcr1 = 0;
   1596          
   1597            /* Check the parameters */
   1598            assert(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
   1599          
   1600            tmpcr1 = TIMx->CR1;
   1601          
   1602            if (TIM_UpdateSource == TIM_UpdateSource_Regular)
   1603            {
   1604              /* Set the URS Bit */
   1605              tmpcr1 |= CR1_URS_Set;
   1606            }
   1607            else
   1608            {
   1609              /* Reset the URS Bit */
   1610              tmpcr1 &= CR1_URS_Reset;
   1611            }
   1612            TIMx->CR1 = (u16)tmpcr1;
   1613          }
   1614          
   1615          /*******************************************************************************
   1616          * Function Name  : TIM_SelectHallSensor
   1617          * Description    : Enables or disables the TIMx’s Hall sensor interface.
   1618          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1619          *                  - Newstate: new state of the TIMx Hall sensor interface.
   1620          *                    This parameter can be: ENABLE or DISABLE.
   1621          * Output         : None
   1622          * Return         : None
   1623          *******************************************************************************/
   1624          void TIM_SelectHallSensor(TIM_TypeDef* TIMx, u32 Newstate)
   1625          {
   1626              if (Newstate != DISABLE)
   1627              {
   1628                  // Set the TI1S Bit
   1629                  TIMx->CR2 |= CR2_TI1S_Set;
   1630              }
   1631              else
   1632              {
   1633                  // Reset the TI1S Bit
   1634                  TIMx->CR2 &= CR2_TI1S_Reset;
   1635            }
   1636          }
   1637          
   1638          /*******************************************************************************
   1639          * Function Name  : TIM_SelectOnePulseMode
   1640          * Description    : Selects the TIMx’s One Pulse Mode.
   1641          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1642          *                  - TIM_OPMode: specifies the OPM Mode to be used.
   1643          *                    This parameter can be one of the following values:
   1644          *                       - TIM_OPMode_Single
   1645          *                       - TIM_OPMode_Repetitive
   1646          * Output         : None
   1647          * Return         : None
   1648          *******************************************************************************/
   1649          void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, u16 TIM_OPMode)
   1650          {
   1651            u32 tmpcr1 = 0;
   1652          
   1653            /* Check the parameters */
   1654            assert(IS_TIM_OPM_MODE(TIM_OPMode));
   1655          
   1656            tmpcr1 = TIMx->CR1;
   1657          
   1658            /* Reset the OPM Bit */
   1659            tmpcr1 &= CR1_OPM_Mask;
   1660          
   1661            /* Configure the OPM Mode */
   1662            tmpcr1 |= TIM_OPMode;
   1663          
   1664            TIMx->CR1 = (u16)tmpcr1;
   1665          }
   1666          
   1667          /*******************************************************************************
   1668          * Function Name  : TIM_SelectOutputTrigger
   1669          * Description    : Selects the TIMx Trigger Output Mode.
   1670          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1671          *                  - TIM_TRGOSource: specifies the Trigger Output source.
   1672          *                    This paramter can be one of the following values:
   1673          *                       - TIM_TRGOSource_Reset
   1674          *                       - TIM_TRGOSource_Enable
   1675          *                       - TIM_TRGOSource_Update
   1676          *                       - TIM_TRGOSource_OC1
   1677          *                       - TIM_TRGOSource_OC1Ref
   1678          *                       - TIM_TRGOSource_OC2Ref
   1679          *                       - TIM_TRGOSource_OC3Ref
   1680          *                       - TIM_TRGOSource_OC4Ref
   1681          * Output         : None
   1682          * Return         : None
   1683          *******************************************************************************/
   1684          void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, u16 TIM_TRGOSource)
   1685          {
   1686            u32 tmpcr2 = 0;
   1687          
   1688            /* Check the parameters */
   1689            assert(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
   1690          
   1691            tmpcr2 = TIMx->CR2;
   1692            /* Reset the MMS Bits */
   1693            tmpcr2 &= CR2_MMS_Mask;
   1694          
   1695            /* Select the TRGO source */
   1696            tmpcr2 |=  TIM_TRGOSource;
   1697          
   1698            TIMx->CR2 = (u16)tmpcr2;
   1699          }
   1700          
   1701          /*******************************************************************************
   1702          * Function Name  : TIM_SelectSlaveMode
   1703          * Description    : Selects the TIMx Slave Mode.
   1704          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1705          *                  - TIM_SlaveMode: specifies the Timer Slave Mode.
   1706          *                    This paramter can be one of the following values:
   1707          *                       - TIM_SlaveMode_Reset
   1708          *                       - TIM_SlaveMode_Gated
   1709          *                       - TIM_SlaveMode_Trigger
   1710          *                       - TIM_SlaveMode_External1
   1711          * Output         : None
   1712          * Return         : None
   1713          *******************************************************************************/
   1714          void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, u16 TIM_SlaveMode)
   1715          {
   1716            u32 tmpsmcr = 0;
   1717          
   1718            /* Check the parameters */
   1719            assert(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
   1720          
   1721            tmpsmcr = TIMx->SMCR;
   1722          
   1723            /* Reset the SMS Bits */
   1724            tmpsmcr &= SMCR_SMS_Mask;
   1725          
   1726            /* Select the Slave Mode */
   1727            tmpsmcr |= TIM_SlaveMode;
   1728          
   1729            TIMx->SMCR = (u16)tmpsmcr;
   1730          }
   1731          
   1732          /*******************************************************************************
   1733          * Function Name  : TIM_SelectMasterSlaveMode
   1734          * Description    : Sets or Resets the TIMx Master/Slave Mode.
   1735          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1736          *                  - TIM_MasterSlaveMode: specifies the Timer Master Slave Mode.
   1737          *                    This paramter can be one of the following values:
   1738          *                       - TIM_MasterSlaveMode_Enable: synchronization between the
   1739          *                         current timer and its slaves (through TRGO).
   1740          *                       - TIM_MasterSlaveMode_Disable: No action
   1741          * Output         : None
   1742          * Return         : None
   1743          *******************************************************************************/
   1744          void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, u16 TIM_MasterSlaveMode)
   1745          {
   1746            u32 tmpsmcr = 0;
   1747          
   1748            /* Check the parameters */
   1749            assert(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
   1750          
   1751            tmpsmcr = TIMx->SMCR;
   1752          
   1753            /* Set or Reset the MSM Bit */
   1754            tmpsmcr &= SMCR_MSM_Mask;
   1755            tmpsmcr |= TIM_MasterSlaveMode;
   1756          
   1757            TIMx->SMCR = (u16)tmpsmcr;
   1758          }
   1759          
   1760          /*******************************************************************************
   1761          * Function Name  : TIM_SetCounter
   1762          * Description    : Sets the TIMx Counter Register value
   1763          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1764          *                  - Counter: specifies the Counter register new value.
   1765          * Output         : None
   1766          * Return         : None
   1767          *******************************************************************************/
   1768          void TIM_SetCounter(TIM_TypeDef* TIMx, u16 Counter)
   1769          {
   1770            /* Set the Counter Register value */
   1771            TIMx->CNT = Counter;
   1772          }
   1773          
   1774          /*******************************************************************************
   1775          * Function Name  : TIM_SetAutoreload
   1776          * Description    : Sets the TIMx Autoreload Register value
   1777          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1778          *                  - Autoreload: specifies the Autoreload register new value.
   1779          * Output         : None
   1780          * Return         : None
   1781          *******************************************************************************/
   1782          void TIM_SetAutoreload(TIM_TypeDef* TIMx, u16 Autoreload)
   1783          {
   1784            /* Set the Autoreload Register value */
   1785            TIMx->ARR = Autoreload;
   1786          }
   1787          
   1788          /*******************************************************************************
   1789          * Function Name  : TIM_SetCompare1
   1790          * Description    : Sets the TIMx Capture Compare1 Register value
   1791          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1792          *                  - Compare1: specifies the Capture Compare1 register new value.
   1793          * Output         : None
   1794          * Return         : None
   1795          *******************************************************************************/
   1796          void TIM_SetCompare1(TIM_TypeDef* TIMx, u16 Compare1)
   1797          {
   1798            /* Set the Capture Compare1 Register value */
   1799            TIMx->CCR1 = Compare1;
   1800          }
   1801          
   1802          /*******************************************************************************
   1803          * Function Name  : TIM_SetCompare2
   1804          * Description    : Sets the TIMx Capture Compare2 Register value
   1805          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1806          *                  - Compare2: specifies the Capture Compare2 register new value.
   1807          * Output         : None
   1808          * Return         : None
   1809          *******************************************************************************/
   1810          void TIM_SetCompare2(TIM_TypeDef* TIMx, u16 Compare2)
   1811          {
   1812            /* Set the Capture Compare2 Register value */
   1813            TIMx->CCR2 = Compare2;
   1814          }
   1815          
   1816          /*******************************************************************************
   1817          * Function Name  : TIM_SetCompare3
   1818          * Description    : Sets the TIMx Capture Compare3 Register value
   1819          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1820          *                  - Compare3: specifies the Capture Compare3 register new value.
   1821          * Output         : None
   1822          * Return         : None
   1823          *******************************************************************************/
   1824          void TIM_SetCompare3(TIM_TypeDef* TIMx, u16 Compare3)
   1825          {
   1826            /* Set the Capture Compare3 Register value */
   1827            TIMx->CCR3 = Compare3;
   1828          }
   1829          
   1830          /*******************************************************************************
   1831          * Function Name  : TIM_SetCompare4
   1832          * Description    : Sets the TIMx Capture Compare4 Register value
   1833          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1834          *                  - Compare4: specifies the Capture Compare4 register new value.
   1835          * Output         : None
   1836          * Return         : None
   1837          *******************************************************************************/
   1838          void TIM_SetCompare4(TIM_TypeDef* TIMx, u16 Compare4)
   1839          {
   1840            /* Set the Capture Compare4 Register value */
   1841            TIMx->CCR4 = Compare4;
   1842          }
   1843          
   1844          /*******************************************************************************
   1845          * Function Name  : TIM_SetIC1Prescaler
   1846          * Description    : Sets the TIMx Input Capture 1 prescaler.
   1847          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1848          *                  - TIM_IC1Prescaler: specifies the Input Capture1 prescaler
   1849          *                    new value.
   1850          *                    This parameter can be one of the following values:
   1851          *                       - TIM_ICPSC_DIV1: no prescaler
   1852          *                       - TIM_ICPSC_DIV2: capture is done once every 2 events
   1853          *                       - TIM_ICPSC_DIV4: capture is done once every 4 events
   1854          *                       - TIM_ICPSC_DIV8: capture is done once every 8 events
   1855          * Output         : None
   1856          * Return         : None
   1857          *******************************************************************************/
   1858          void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, u16 TIM_IC1Prescaler)
   1859          {
   1860            u32 tmpccmr1 = 0;
   1861          
   1862            /* Check the parameters */
   1863            assert(IS_TIM_IC_PRESCALER(TIM_IC1Prescaler));
   1864          
   1865            tmpccmr1 = TIMx->CCMR1;
   1866          
   1867            /* Reset the IC1PSC Bits */
   1868            tmpccmr1 &= CCMR_IC13PSC_Mask;
   1869          
   1870            /* Set the IC1PSC value */
   1871            tmpccmr1 |= TIM_IC1Prescaler;
   1872          
   1873            TIMx->CCMR1 = (u16)tmpccmr1;
   1874          }
   1875          
   1876          /*******************************************************************************
   1877          * Function Name  : TIM_SetIC2Prescaler
   1878          * Description    : Sets the TIMx Input Capture 2 prescaler.
   1879          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1880          *                  - TIM_IC2Prescaler: specifies the Input Capture2 prescaler
   1881          *                    new value.
   1882          *                    This parameter can be one of the following values:
   1883          *                       - TIM_ICPSC_DIV1: no prescaler
   1884          *                       - TIM_ICPSC_DIV2: capture is done once every 2 events
   1885          *                       - TIM_ICPSC_DIV4: capture is done once every 4 events
   1886          *                       - TIM_ICPSC_DIV8: capture is done once every 8 events
   1887          * Output         : None
   1888          * Return         : None
   1889          *******************************************************************************/
   1890          void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, u16 TIM_IC2Prescaler)
   1891          {
   1892            u32 tmpccmr1 = 0;
   1893          
   1894            /* Check the parameters */
   1895            assert(IS_TIM_IC_PRESCALER(TIM_IC2Prescaler));
   1896          
   1897            tmpccmr1 = TIMx->CCMR1;
   1898          
   1899            /* Reset the IC2PSC Bits */
   1900            tmpccmr1 &= CCMR_IC24PSC_Mask;
   1901          
   1902            /* Set the IC2PSC value */
   1903            tmpccmr1 |= (u16)((u16)TIM_IC2Prescaler << 8);
   1904          
   1905            TIMx->CCMR1 = (u16)tmpccmr1;
   1906          }
   1907          
   1908          /*******************************************************************************
   1909          * Function Name  : TIM_SetIC3Prescaler
   1910          * Description    : Sets the TIMx Input Capture 3 prescaler.
   1911          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1912          *                  - TIM_IC3Prescaler: specifies the Input Capture3 prescaler
   1913          *                    new value.
   1914          *                    This parameter can be one of the following values:
   1915          *                       - TIM_ICPSC_DIV1: no prescaler
   1916          *                       - TIM_ICPSC_DIV2: capture is done once every 2 events
   1917          *                       - TIM_ICPSC_DIV4: capture is done once every 4 events
   1918          *                       - TIM_ICPSC_DIV8: capture is done once every 8 events
   1919          * Output         : None
   1920          * Return         : None
   1921          *******************************************************************************/
   1922          void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, u16 TIM_IC3Prescaler)
   1923          {
   1924            u32 tmpccmr2 = 0;
   1925          
   1926            /* Check the parameters */
   1927            assert(IS_TIM_IC_PRESCALER(TIM_IC3Prescaler));
   1928          
   1929            tmpccmr2 = TIMx->CCMR2;
   1930          
   1931            /* Reset the IC3PSC Bits */
   1932            tmpccmr2 &= CCMR_IC13PSC_Mask;
   1933          
   1934            /* Set the IC3PSC value */
   1935            tmpccmr2 |= TIM_IC3Prescaler;
   1936          
   1937            TIMx->CCMR2 = (u16)tmpccmr2;
   1938          }
   1939          
   1940          /*******************************************************************************
   1941          * Function Name  : TIM_SetIC4Prescaler
   1942          * Description    : Sets the TIMx Input Capture 4 prescaler.
   1943          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1944          *                  - TIM_IC4Prescaler: specifies the Input Capture4 prescaler
   1945          *                    new value.
   1946          *                    This parameter can be one of the following values:
   1947          *                      - TIM_ICPSC_DIV1: no prescaler
   1948          *                      - TIM_ICPSC_DIV2: capture is done once every 2 events
   1949          *                      - TIM_ICPSC_DIV4: capture is done once every 4 events
   1950          *                      - TIM_ICPSC_DIV8: capture is done once every 8 events
   1951          * Output         : None
   1952          * Return         : None
   1953          *******************************************************************************/
   1954          void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, u16 TIM_IC4Prescaler)
   1955          {
   1956            u32 tmpccmr2 = 0;
   1957             
   1958            /* Check the parameters */
   1959            assert(IS_TIM_IC_PRESCALER(TIM_IC4Prescaler));
   1960          
   1961            tmpccmr2 = TIMx->CCMR2;
   1962          
   1963            /* Reset the IC4PSC Bits */
   1964            tmpccmr2 &= CCMR_IC24PSC_Mask;
   1965          
   1966            /* Set the IC4PSC value */
   1967            tmpccmr2 |= (u16)((u16)TIM_IC4Prescaler << 8);
   1968          
   1969            TIMx->CCMR2 = (u16)tmpccmr2;
   1970          }
   1971          
   1972          /*******************************************************************************
   1973          * Function Name  : TIM_SetClockDivision
   1974          * Description    : Sets the TIMx Clock Division value.
   1975          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   1976          *                  - TIM_CKD: specifies the clock division value.
   1977          *                    This parameter can be one of the following value:
   1978          *                       - TIM_CKD_DIV1: TDTS = Tck_tim
   1979          *                       - TIM_CKD_DIV2: TDTS = 2*Tck_tim
   1980          *                       - TIM_CKD_DIV4: TDTS = 4*Tck_tim
   1981          * Output         : None
   1982          * Return         : None
   1983          *******************************************************************************/
   1984          void TIM_SetClockDivision(TIM_TypeDef* TIMx, u16 TIM_CKD)
   1985          {
   1986            u32 tmpcr1 = 0;
   1987          
   1988            /* Check the parameters */
   1989            assert(IS_TIM_CKD_DIV(TIM_CKD));
   1990          
   1991            tmpcr1 = TIMx->CR1;
   1992          
   1993            /* Reset the CKD Bits */
   1994            tmpcr1 &= CR1_CKD_Mask;
   1995          
   1996            /* Set the CKD value */
   1997            tmpcr1 |= TIM_CKD;
   1998          
   1999            TIMx->CR1 = (u16)tmpcr1;
   2000          }
   2001          
   2002          /*******************************************************************************
   2003          * Function Name  : TIM_GetCapture1
   2004          * Description    : Gets the TIMx Input Capture 1 value.
   2005          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2006          * Output         : None
   2007          * Return         : Capture Compare 1 Register value.
   2008          *******************************************************************************/
   2009          u16 TIM_GetCapture1(TIM_TypeDef* TIMx)
   2010          {
   2011            /* Get the Capture 1 Register value */
   2012            return TIMx->CCR1;
   2013          }
   2014          
   2015          /*******************************************************************************
   2016          * Function Name  : TIM_GetCapture2
   2017          * Description    : Gets the TIMx Input Capture 2 value.
   2018          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2019          * Output         : None
   2020          * Return         : Capture Compare 2 Register value.
   2021          *******************************************************************************/
   2022          u16 TIM_GetCapture2(TIM_TypeDef* TIMx)
   2023          {
   2024            /* Get the Capture 2 Register value */
   2025            return TIMx->CCR2;
   2026          }
   2027          
   2028          /*******************************************************************************
   2029          * Function Name  : TIM_GetCapture3
   2030          * Description    : Gets the TIMx Input Capture 3 value.
   2031          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2032          * Output         : None
   2033          * Return         : Capture Compare 3 Register value.
   2034          *******************************************************************************/
   2035          u16 TIM_GetCapture3(TIM_TypeDef* TIMx)
   2036          {
   2037            /* Get the Capture 3 Register value */
   2038            return TIMx->CCR3;
   2039          }
   2040          
   2041          /*******************************************************************************
   2042          * Function Name  : TIM_GetCapture4
   2043          * Description    : Gets the TIMx Input Capture 4 value.
   2044          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2045          * Output         : None
   2046          * Return         : Capture Compare 4 Register value.
   2047          *******************************************************************************/
   2048          u16 TIM_GetCapture4(TIM_TypeDef* TIMx)
   2049          {
   2050            /* Get the Capture 4 Register value */
   2051            return TIMx->CCR4;
   2052          }
   2053          
   2054          /*******************************************************************************
   2055          * Function Name  : TIM_GetCounter
   2056          * Description    : Gets the TIMx Counter value.
   2057          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2058          * Output         : None
   2059          * Return         : Counter Register value.
   2060          *******************************************************************************/
   2061          u16 TIM_GetCounter(TIM_TypeDef* TIMx)
   2062          {
   2063            /* Get the Counter Register value */
   2064            return TIMx->CNT;
   2065          }
   2066          
   2067          /*******************************************************************************
   2068          * Function Name  : TIM_GetPrescaler
   2069          * Description    : Gets the TIMx Prescaler value.
   2070          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2071          * Output         : None
   2072          * Return         : Prescaler Register value.
   2073          *******************************************************************************/
   2074          u16 TIM_GetPrescaler(TIM_TypeDef* TIMx)
   2075          {
   2076            /* Get the Prescaler Register value */
   2077            return TIMx->PSC;
   2078          }
   2079          
   2080          /*******************************************************************************
   2081          * Function Name  : TIM_GetFlagStatus
   2082          * Description    : Checks whether the specified TIMx flag is set or not.
   2083          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2084          *                  - TIM_FLAG: specifies the flag to check.
   2085          *                    This parameter can be one of the following values:
   2086          *                       - TIM_FLAG_Update: Timer update Flag
   2087          *                       - TIM_FLAG_CC1: Timer Capture Compare 1 Flag
   2088          *                       - TIM_FLAG_CC2: Timer Capture Compare 2 Flag
   2089          *                       - TIM_FLAG_CC3: Timer Capture Compare 3 Flag
   2090          *                       - TIM_FLAG_CC4: Timer Capture Compare 4 Flag
   2091          *                       - TIM_FLAG_Trigger: Timer Trigger Flag
   2092          *                       - TIM_FLAG_CC1OF: Timer Capture Compare 1 overcapture Flag
   2093          *                       - TIM_FLAG_CC2OF: Timer Capture Compare 2 overcapture Flag
   2094          *                       - TIM_FLAG_CC3OF: Timer Capture Compare 3 overcapture Flag
   2095          *                       - TIM_FLAG_CC4OF: Timer Capture Compare 4 overcapture Flag
   2096          * Output         : None
   2097          * Return         : The new state of TIM_FLAG (SET or RESET).
   2098          *******************************************************************************/
   2099          FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, u16 TIM_FLAG)
   2100          {
   2101            FlagStatus bitstatus = RESET;
   2102          
   2103            /* Check the parameters */
   2104            assert(IS_TIM_GET_FLAG(TIM_FLAG));
   2105          
   2106            if ((TIMx->SR & TIM_FLAG) != (u16)RESET )
   2107            {
   2108              bitstatus = SET;
   2109            }
   2110            else
   2111            {
   2112              bitstatus = RESET;
   2113            }
   2114            return bitstatus;
   2115          }
   2116          
   2117          /*******************************************************************************
   2118          * Function Name  : TIM_ClearFlag
   2119          * Description    : Clears the TIMx's pending flags.
   2120          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2121          *                  - TIM_FLAG: specifies the flag bit to clear.
   2122          *                    This parameter can be any combination of the following values:
   2123          *                       - TIM_FLAG_Update: Timer update Flag
   2124          *                       - TIM_FLAG_CC1: Timer Capture Compare 1 Flag
   2125          *                       - TIM_FLAG_CC2: Timer Capture Compare 2 Flag
   2126          *                       - TIM_FLAG_CC3: Timer Capture Compare 3 Flag
   2127          *                       - TIM_FLAG_CC4: Timer Capture Compare 4 Flag
   2128          *                       - TIM_FLAG_Trigger: Timer Trigger Flag
   2129          *                       - TIM_FLAG_CC1OF: Timer Capture Compare 1 overcapture Flag
   2130          *                       - TIM_FLAG_CC2OF: Timer Capture Compare 2 overcapture Flag
   2131          *                       - TIM_FLAG_CC3OF: Timer Capture Compare 3 overcapture Flag
   2132          *                       - TIM_FLAG_CC4OF: Timer Capture Compare 4 overcapture Flag
   2133          * Output         : None
   2134          * Return         : None
   2135          *******************************************************************************/
   2136          void TIM_ClearFlag(TIM_TypeDef* TIMx, u16 TIM_FLAG)
   2137          {
   2138            /* Check the parameters */
   2139            assert(IS_TIM_CLEAR_FLAG(TIM_FLAG));
   2140          
   2141            /* Clear the flags */
   2142            TIMx->SR &= (u16)~TIM_FLAG;
   2143          }
   2144          
   2145          /*******************************************************************************
   2146          * Function Name  : TIM_GetITStatus
   2147          * Description    : Checks whether the TIMx interrupt has occurred or not.
   2148          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2149          *                  - TIM_IT: specifies the TIM interrupt source to check.
   2150          *                    This parameter can be one of the following values:
   2151          *                         - TIM_IT_Update: Timer update Interrupt source
   2152          *                         - TIM_IT_CC1: Timer Capture Compare 1 Interrupt source
   2153          *                         - TIM_IT_CC2: Timer Capture Compare 2 Interrupt source
   2154          *                         - TIM_IT_CC3: Timer Capture Compare 3 Interrupt source
   2155          *                         - TIM_IT_CC4: Timer Capture Compare 4 Interrupt source
   2156          *                         - TIM_IT_Trigger: Timer Trigger Interrupt source
   2157          * Output         : None
   2158          * Return         : The new state of the TIM_IT(SET or RESET).
   2159          *******************************************************************************/
   2160          ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, u16 TIM_IT)
   2161          {
   2162            ITStatus bitstatus = RESET;
   2163            
   2164            u16 itstatus = 0x0, itenable = 0x0;
   2165          
   2166            /* Check the parameters */
   2167            assert(IS_TIM_GET_IT(TIM_IT));
   2168            
   2169            itstatus = TIMx->SR & TIM_IT;
   2170            
   2171            itenable = TIMx->DIER & TIM_IT;
   2172          
   2173            if ((itstatus != (u16)RESET)  && (itenable != (u16)RESET))
   2174            {
   2175              bitstatus = SET;
   2176            }
   2177            else
   2178            {
   2179              bitstatus = RESET;
   2180            }
   2181            return bitstatus;
   2182          }
   2183          
   2184          /*******************************************************************************
   2185          * Function Name  : TIM_ClearITPendingBit
   2186          * Description    : Clears the TIMx's interrupt pending bits.
   2187          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2188          *                  - TIM_IT: specifies the pending bit to clear.
   2189          *                    This parameter can be any combination of the following values:
   2190          *                       - TIM_IT_Update: Timer update Interrupt source
   2191          *                       - TIM_IT_CC1: Timer Capture Compare 1 Interrupt source
   2192          *                       - TIM_IT_CC2: Timer Capture Compare 2 Interrupt source
   2193          *                       - TIM_IT_CC3: Timer Capture Compare 3 Interrupt source
   2194          *                       - TIM_IT_CC4: Timer Capture Compare 4 Interrupt source
   2195          *                       - TIM_IT_Trigger: Timer Trigger Interrupt source
   2196          * Output         : None
   2197          * Return         : None
   2198          *******************************************************************************/
   2199          void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, u16 TIM_IT)
   2200          {
   2201            /* Check the parameters */
   2202            assert(IS_TIM_IT(TIM_IT));
   2203            
   2204            /* Clear the IT pending Bit */
   2205            TIMx->SR &= (u16)~TIM_IT;
   2206          }
   2207          
   2208          /*******************************************************************************
   2209          * Function Name  : PWMInput_Config
   2210          * Description    : Configures the TIM peripheral according to the specified
   2211          *                  parameters in the TIM_ICInitStruct to measure an external PWM
   2212          *                  signal.
   2213          * Input          : - TIM_ICInitStruct: pointer to a TIM_ICInitTypeDef structure
   2214          *                    that contains the configuration information for the specified
   2215          *                    TIM peripheral.
   2216          * Output         : None
   2217          * Return         : None
   2218          *******************************************************************************/
   2219          static void PWMI_Config(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
   2220          {
   2221            u8 ICPolarity = TIM_ICPolarity_Rising;
   2222            u8 ICSelection = TIM_ICSelection_DirectTI;
   2223          
   2224            /* Select the Opposite Input Polarity */
   2225            if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
   2226            {
   2227              ICPolarity = TIM_ICPolarity_Falling;
   2228            }
   2229            else
   2230            {
   2231              ICPolarity = TIM_ICPolarity_Rising;
   2232            }
   2233          
   2234            /* Select the Opposite Input */
   2235            if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
   2236            {
   2237              ICSelection = TIM_ICSelection_IndirectTI;
   2238            }
   2239            else
   2240            {
   2241              ICSelection = TIM_ICSelection_DirectTI;
   2242            }
   2243          
   2244            if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
   2245            {
   2246              /* TI1 Configuration */
   2247              TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
   2248                         TIM_ICInitStruct->TIM_ICFilter);
   2249          
   2250              /* Set the Input Capture Prescaler value */
   2251              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2252          
   2253              /* TI2 Configuration */
   2254              TI2_Config(TIMx, ICPolarity, ICSelection, TIM_ICInitStruct->TIM_ICFilter);
   2255          
   2256              /* Set the Input Capture Prescaler value */
   2257              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2258            }
   2259            else
   2260            {	 
   2261              /* TI1 Configuration */
   2262              TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
   2263                         TIM_ICInitStruct->TIM_ICFilter);
   2264          
   2265              /* Set the Input Capture Prescaler value */
   2266              TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2267          
   2268              /* TI2 Configuration */
   2269              TI1_Config(TIMx, ICPolarity, ICSelection, TIM_ICInitStruct->TIM_ICFilter);
   2270          
   2271              /* Set the Input Capture Prescaler value */
   2272              TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
   2273            }
   2274          }
   2275          
   2276          /*******************************************************************************
   2277          * Function Name  : TI1_Config
   2278          * Description    : Configure the TI1 as Input.
   2279          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2280          *                  - TIM_ICPolarity : The Input Polarity.
   2281          *                    This parameter can be one of the following values:
   2282          *                       - TIM_ICPolarity_Rising
   2283          *                       - TIM_ICPolarity_Falling
   2284          *                  - TIM_ICSelection: specifies the input to be used.
   2285          *                    This parameter can be one of the following values:
   2286          *                       - TIM_ICSelection_DirectTI: TIM Input 1 is selected to
   2287          *                         be connected to IC1.
   2288          *                       - TIM_ICSelection_IndirectTI: TIM Input 1 is selected to
   2289          *                         be connected to IC2.
   2290          *                       - TIM_ICSelection_TRGI: TIM Input 1 is selected to be
   2291          *                         connected to TRGI.
   2292          *                  - TIM_ICFilter: Specifies the Input Capture Filter.
   2293          *                    This parameter must be a value between 0x00 and 0x0F.
   2294          * Output         : None
   2295          * Return         : None
   2296          *******************************************************************************/
   2297          static void TI1_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
   2298                                 u8 TIM_ICFilter)
   2299          {
   2300            u32 tmpccmr1 = 0, tmpccer = 0;
   2301          
   2302            tmpccmr1 = TIMx->CCMR1;
   2303            tmpccer = TIMx->CCER;
   2304          
   2305            /* Disable the Channel 1: Reset the CCE Bit */
   2306            TIMx->CCER &= CCER_CC1E_Reset;
   2307          
   2308            /* Select the Input and set the filter */
   2309            tmpccmr1 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
   2310            tmpccmr1 |= TIM_ICSelection | (u16)((u16)TIM_ICFilter << 4);
   2311          
   2312            /* Select the Polarity  and set the CCE Bit */
   2313            tmpccer &= CCER_CC1P_Mask & CCER_CC1E_Mask;
   2314            tmpccer |= TIM_ICPolarity | CCER_CC1E_Set;
   2315          
   2316            TIMx->CCMR1 = 0x0000;
   2317            TIMx->CCMR1 = (u16)tmpccmr1;
   2318            TIMx->CCER = (u16)tmpccer;
   2319          }
   2320          
   2321          /*******************************************************************************
   2322          * Function Name  : TI2_Config
   2323          * Description    : Configure the TI2 as Input.
   2324          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2325          *                  - TIM_ICPolarity : The Input Polarity.
   2326          *                    This parameter can be one of the following values:
   2327          *                       - TIM_ICPolarity_Rising
   2328          *                       - TIM_ICPolarity_Falling
   2329          *                  - TIM_ICSelection: specifies the input to be used.
   2330          *                    This parameter can be one of the following values:
   2331          *                       - TIM_ICSelection_DirectTI: TIM Input 2 is selected to
   2332          *                         be connected to IC2.
   2333          *                       - TIM_ICSelection_IndirectTI: TIM Input 2 is selected to
   2334          *                         be connected to IC1.
   2335          *                       - TIM_ICSelection_TRGI: TIM Input 2 is selected to be
   2336          *                         connected to TRGI.
   2337          *                  - TIM_ICFilter: Specifies the Input Capture Filter.
   2338          *                    This parameter must be a value between 0x00 and 0x0F.
   2339          * Output         : None
   2340          * Return         : None
   2341          *******************************************************************************/
   2342          static void TI2_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
   2343                                 u8 TIM_ICFilter)
   2344          {
   2345            u32 tmpccmr1 = 0, tmpccer = 0, tmp = 0;
   2346          
   2347            tmpccmr1 = TIMx->CCMR1;
   2348            tmpccer = TIMx->CCER;
   2349            tmp = (u16)((u16)TIM_ICPolarity << 4);
   2350          
   2351            /* Disable the Channel 2: Reset the CCE Bit */
   2352            TIMx->CCER &= CCER_CC2E_Reset;
   2353          
   2354            /* Select the Input and set the filter */
   2355            tmpccmr1 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
   2356            tmpccmr1 |= (u16)((u16)TIM_ICFilter << 12);
   2357            tmpccmr1 |= (u16)((u16)TIM_ICSelection << 8);
   2358          
   2359            /* Select the Polarity  and set the CCE Bit */
   2360            tmpccer &= CCER_CC2P_Mask & CCER_CC2E_Mask;
   2361            tmpccer |=  tmp | CCER_CC2E_Set;
   2362          
   2363            TIMx->CCMR1 = (u16)tmpccmr1 ;
   2364            TIMx->CCER = (u16)tmpccer;
   2365          }
   2366          
   2367          /*******************************************************************************
   2368          * Function Name  : TI3_Config
   2369          * Description    : Configure the TI3 as Input.
   2370          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2371          *                  - TIM_ICPolarity : The Input Polarity.
   2372          *                    This parameter can be one of the following values:
   2373          *                       - TIM_ICPolarity_Rising
   2374          *                       - TIM_ICPolarity_Falling
   2375          *                  - TIM_ICSelection: specifies the input to be used.
   2376          *                    This parameter can be one of the following values:
   2377          *                       - TIM_ICSelection_DirectTI: TIM Input 3 is selected to
   2378          *                         be connected to IC3.
   2379          *                       - TIM_ICSelection_IndirectTI: TIM Input 3 is selected to
   2380          *                         be connected to IC4.
   2381          *                       - TIM_ICSelection_TRGI: TIM Input 3 is selected to be
   2382          *                         connected to TRGI.
   2383          *                  - TIM_ICFilter: Specifies the Input Capture Filter.
   2384          *                    This parameter must be a value between 0x00 and 0x0F.
   2385          * Output         : None
   2386          * Return         : None
   2387          *******************************************************************************/
   2388          static void TI3_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
   2389                                 u8 TIM_ICFilter)
   2390          {
   2391            u32 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   2392          
   2393            tmpccmr2 = TIMx->CCMR2;
   2394            tmpccer = TIMx->CCER;
   2395            tmp = (u16)((u16)TIM_ICPolarity << 8);
   2396          
   2397            /* Disable the Channel 3: Reset the CCE Bit */
   2398            TIMx->CCER &= CCER_CC3E_Reset;
   2399          
   2400            /* Select the Input and set the filter */
   2401            tmpccmr2 &= CCMR_CC13S_Mask & CCMR_IC13F_Mask;
   2402            tmpccmr2 |= TIM_ICSelection | (u16)((u16)TIM_ICFilter << 4);
   2403          
   2404            /* Select the Polarity  and set the CCE Bit */
   2405            tmpccer &= CCER_CC1P_Mask & CCER_CC1E_Mask;
   2406            tmpccer |= tmp | CCER_CC3E_Set;
   2407          
   2408            TIMx->CCMR2 = (u16)tmpccmr2;
   2409            TIMx->CCER = (u16)tmpccer;
   2410          }
   2411          
   2412          /*******************************************************************************
   2413          * Function Name  : TI4_Config
   2414          * Description    : Configure the TI1 as Input.
   2415          * Input          : - TIMx: where x can be 2, 3 or 4 to select the TIM peripheral.
   2416          *                  - TIM_ICPolarity : The Input Polarity.
   2417          *                    This parameter can be one of the following values:
   2418          *                       - TIM_ICPolarity_Rising
   2419          *                       - TIM_ICPolarity_Falling
   2420          *                  - TIM_ICSelection: specifies the input to be used.
   2421          *                    This parameter can be one of the following values:
   2422          *                       - TIM_ICSelection_DirectTI: TIM Input 4 is selected to
   2423          *                         be connected to IC4.
   2424          *                       - TIM_ICSelection_IndirectTI: TIM Input 4 is selected to
   2425          *                         be connected to IC3.
   2426          *                       - TIM_ICSelection_TRGI: TIM Input 4 is selected to be
   2427          *                         connected to TRGI.
   2428          *                  - TIM_ICFilter: Specifies the Input Capture Filter.
   2429          *                    This parameter must be a value between 0x00 and 0x0F.
   2430          * Output         : None
   2431          * Return         : None
   2432          *******************************************************************************/
   2433          static void TI4_Config(TIM_TypeDef* TIMx, u16 TIM_ICPolarity, u16 TIM_ICSelection,
   2434                                 u8 TIM_ICFilter)
   2435          {
   2436            u32 tmpccmr2 = 0, tmpccer = 0, tmp = 0;
   2437          
   2438            tmpccmr2 = TIMx->CCMR2;
   2439            tmpccer = TIMx->CCER;
   2440            tmp = (u16)((u16)TIM_ICPolarity << 12);
   2441          
   2442            /* Disable the Channel 4: Reset the CCE Bit */
   2443            TIMx->CCER &= CCER_CC4E_Reset;
   2444          
   2445            /* Select the Input and set the filter */
   2446            tmpccmr2 &= CCMR_CC24S_Mask & CCMR_IC24F_Mask;
   2447            tmpccmr2 |= (u16)((u16)TIM_ICSelection << 8) | (u16)((u16)TIM_ICFilter << 12);
   2448          
   2449            /* Select the Polarity  and set the CCE Bit */
   2450            tmpccer &= CCER_CC4P_Mask & CCER_CC4E_Mask;
   2451            tmpccer |= tmp | CCER_CC4E_Set;
   2452          
   2453            TIMx->CCMR2 = (u16)tmpccmr2;
   2454            TIMx->CCER = (u16)tmpccer ;
   2455          }
   2456          
   2457          /******************* (C) COPYRIGHT 2007 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                    .cstack
     --------                    -------
     PWMI_Config                     24
     TI1_Config                      16
     TI2_Config                      16
     TIM_ARRPreloadConfig             0
     TIM_ClearFlag                    0
     TIM_ClearITPendingBit            0
     TIM_ClearOC1Ref                  0
     TIM_ClearOC2Ref                  0
     TIM_ClearOC3Ref                  0
     TIM_ClearOC4Ref                  0
     TIM_Cmd                          0
     TIM_CounterModeConfig            0
     TIM_DMACmd                       0
     TIM_DMAConfig                    0
     TIM_DeInit                       0
     TIM_ETRClockMode1Config          8
     TIM_ETRClockMode2Config          8
     TIM_ETRConfig                    8
     TIM_EncoderInterfaceConfig      16
     TIM_ForcedOC1Config              0
     TIM_ForcedOC2Config              0
     TIM_ForcedOC3Config              0
     TIM_ForcedOC4Config              0
     TIM_GenerateEvent                0
     TIM_GetCapture1                  0
     TIM_GetCapture2                  0
     TIM_GetCapture3                  0
     TIM_GetCapture4                  0
     TIM_GetCounter                   0
     TIM_GetFlagStatus                0
     TIM_GetITStatus                  0
     TIM_GetPrescaler                 0
     TIM_ICInit                      24
     TIM_ICStructInit                 0
     TIM_ITConfig                     0
     TIM_ITRxExternalClockConfig      8
     TIM_InternalClockConfig          0
     TIM_OC1FastConfig                0
     TIM_OC1PolarityConfig            0
     TIM_OC1PreloadConfig             0
     TIM_OC2FastConfig                0
     TIM_OC2PolarityConfig            0
     TIM_OC2PreloadConfig             0
     TIM_OC3FastConfig                0
     TIM_OC3PolarityConfig            0
     TIM_OC3PreloadConfig             0
     TIM_OC4FastConfig                0
     TIM_OC4PolarityConfig            0
     TIM_OC4PreloadConfig             0
     TIM_OCInit                      16
     TIM_OCStructInit                 0
     TIM_PrescalerConfig              0
     TIM_SelectCCDMA                  0
     TIM_SelectHallSensor             0
     TIM_SelectInputTrigger           0
     TIM_SelectMasterSlaveMode        0
     TIM_SelectOnePulseMode           0
     TIM_SelectOutputTrigger          0
     TIM_SelectSlaveMode              0
     TIM_SetAutoreload                0
     TIM_SetClockDivision             0
     TIM_SetCompare1                  0
     TIM_SetCompare2                  0
     TIM_SetCompare3                  0
     TIM_SetCompare4                  0
     TIM_SetCounter                   0
     TIM_SetIC1Prescaler              0
     TIM_SetIC2Prescaler              0
     TIM_SetIC3Prescaler              0
     TIM_SetIC4Prescaler              0
     TIM_TIxExternalClockConfig      16
     TIM_TimeBaseInit                 0
     TIM_TimeBaseStructInit           0
     TIM_UpdateDisableConfig          0
     TIM_UpdateRequestConfig          0


   Section sizes:

     Function/Label              Bytes
     --------------              -----
     Tab_OCModeMask                16
     Tab_PolarityMask
     TIM_DeInit                     2
     TIM_TimeBaseInit              26
     ??Subroutine10_0               6
     TIM_OCInit                   184
     TIM_ICInit                   170
     TIM_TimeBaseStructInit         0
     ?Subroutine0                  12
     TIM_OCStructInit               2
     TIM_ICStructInit              22
     TIM_Cmd                       20
     TIM_ITConfig                  16
     TIM_DMAConfig                 12
     TIM_DMACmd                    16
     TIM_InternalClockConfig       10
     TIM_ITRxExternalClockConfig   18
     TIM_TIxExternalClockConfig    44
     TIM_ETRClockMode1Config       42
     TIM_ETRClockMode2Config       18
     TIM_ETRConfig                 22
     TIM_SelectInputTrigger         8
     ?Subroutine5                   8
     TIM_PrescalerConfig           20
     ?Subroutine6                   4
     TIM_CounterModeConfig          8
     TIM_ForcedOC1Config            8
     ?Subroutine7                   8
     TIM_ForcedOC2Config            8
     ?Subroutine3                   4
     ??Subroutine11_0               8
     TIM_ForcedOC3Config            8
     ?Subroutine8                   8
     TIM_ForcedOC4Config            8
     ?Subroutine4                   4
     ??Subroutine12_0               8
     TIM_ARRPreloadConfig          20
     TIM_SelectCCDMA               18
     TIM_OC1PreloadConfig           8
     TIM_OC2PreloadConfig           8
     TIM_OC3PreloadConfig           8
     TIM_OC4PreloadConfig           8
     TIM_OC1FastConfig              8
     TIM_OC2FastConfig              8
     TIM_OC3FastConfig              8
     TIM_OC4FastConfig              8
     TIM_ClearOC1Ref                8
     TIM_ClearOC2Ref                8
     TIM_ClearOC3Ref                8
     TIM_ClearOC4Ref                8
     TIM_UpdateDisableConfig       20
     TIM_EncoderInterfaceConfig    50
     TIM_GenerateEvent              8
     TIM_OC1PolarityConfig         14
     TIM_OC2PolarityConfig         16
     TIM_OC3PolarityConfig         16
     TIM_OC4PolarityConfig         16
     TIM_UpdateRequestConfig       20
     TIM_SelectHallSensor          18
     TIM_SelectOnePulseMode         8
     TIM_SelectOutputTrigger       12
     TIM_SelectSlaveMode            8
     TIM_SelectMasterSlaveMode      8
     TIM_SetCounter                 4
     TIM_SetAutoreload              4
     TIM_SetCompare1                4
     TIM_SetCompare2                4
     TIM_SetCompare3                4
     TIM_SetCompare4                6
     TIM_SetIC1Prescaler            8
     TIM_SetIC2Prescaler            8
     TIM_SetIC3Prescaler            8
     TIM_SetIC4Prescaler            8
     TIM_SetClockDivision           6
     TIM_GetCapture1                4
     TIM_GetCapture2                4
     TIM_GetCapture3                4
     TIM_GetCapture4                6
     TIM_GetCounter                 4
     TIM_GetPrescaler               4
     TIM_GetFlagStatus              4
     ?Subroutine1                  10
     TIM_ClearFlag                  0
     ?Subroutine2                  10
     TIM_GetITStatus               18
     TIM_ClearITPendingBit          2
     PWMI_Config                  104
     TI1_Config                    44
     ?Subroutine9                   6
     TI2_Config                    46

 
    16 bytes in section .rodata
 1 444 bytes in section .text
 
 1 444 bytes of CODE  memory
    16 bytes of CONST memory

Errors: none
Warnings: none

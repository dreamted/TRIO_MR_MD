###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V5.30.2.51295/W32 for ARM     02/Apr/2012  19:03:57 #
# Copyright 1999-2009 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\lib_stm32\s #
#                    rc\stm32f10x_flash.c                                     #
#    Command line =  D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\lib_stm32\s #
#                    rc\stm32f10x_flash.c -D NDEBUG -lcN                      #
#                    D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\sout\ -o    #
#                    D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\sout\       #
#                    --debug --endian=little --cpu=Cortex-M3 -e               #
#                    --warnings_are_errors --fpu=None --dlib_config           #
#                    "C:\Program Files\IAR Systems\Embedded Workbench         #
#                    5.4\arm\INC\DLib_Config_Normal.h" -I                     #
#                    D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\include\    #
#                    -I D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\lib_stm3 #
#                    2\inc\ -I D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\l #
#                    ib_stm32\src\ -I D:\Project\TRIO\3.F_W\TRIO_appl_src_201 #
#                    20401\uC-CPU\ -I D:\Project\TRIO\3.F_W\TRIO_appl_src_201 #
#                    20401\uC-LIB\ -I D:\Project\TRIO\3.F_W\TRIO_appl_src_201 #
#                    20401\uCOS-II\Ports\ -I D:\Project\TRIO\3.F_W\TRIO_appl_ #
#                    src_20120401\uCOS-II\Source\ -I                          #
#                    D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\uC-Probe\   #
#                    -I "C:\Program Files\IAR Systems\Embedded Workbench      #
#                    5.4\arm\INC\" -Oh                                        #
#    List file    =  D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\sout\stm32f #
#                    10x_flash.lst                                            #
#    Object file  =  D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\sout\stm32f #
#                    10x_flash.o                                              #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\TRIO\3.F_W\TRIO_appl_src_20120401\lib_stm32\src\stm32f10x_flash.c
      1          /******************** (C) COPYRIGHT 2007 STMicroelectronics ********************
      2          * File Name          : stm32f10x_flash.c
      3          * Author             : MCD Application Team
      4          * Date First Issued  : 05/21/2007
      5          * Description        : This file provides all the FLASH firmware functions.
      6          *******************************************************************************/
      7          
      8          /* Includes ------------------------------------------------------------------*/
      9          #include "stm32f10x_conf.h"
     10          /* Private typedef -----------------------------------------------------------*/
     11          /* Private define ------------------------------------------------------------*/
     12          /* Flash Control Register bits */
     13          #define CR_PG_Set                ((u32)0x00000001)
     14          #define CR_PG_Reset              ((u32)0x00001FFE) 
     15          
     16          #define CR_PER_Set               ((u32)0x00000002)
     17          #define CR_PER_Reset             ((u32)0x00001FFD)
     18          
     19          #define CR_MER_Set               ((u32)0x00000004)
     20          #define CR_MER_Reset             ((u32)0x00001FFB)
     21          
     22          #define CR_OPTPG_Set             ((u32)0x00000010)
     23          #define CR_OPTPG_Reset           ((u32)0x00001FEF)
     24          
     25          #define CR_OPTER_Set             ((u32)0x00000020)
     26          #define CR_OPTER_Reset           ((u32)0x00001FDF)
     27          
     28          #define CR_STRT_Set              ((u32)0x00000040)
     29          							 
     30          #define CR_LOCK_Set              ((u32)0x00000080)
     31          
     32          /* FLASH Mask */
     33          #define RDPRT_Mask               ((u32)0x00000002)
     34          #define WRP0_Mask                ((u32)0x000000FF)
     35          #define WRP1_Mask                ((u32)0x0000FF00)
     36          #define WRP2_Mask                ((u32)0x00FF0000)
     37          #define WRP3_Mask                ((u32)0xFF000000)
     38          
     39          /* FLASH Keys */
     40          #define RDP_Key                  ((u16)0x00A5)
     41          #define FLASH_KEY1               ((u32)0x45670123)
     42          #define FLASH_KEY2               ((u32)0xCDEF89AB)
     43          
     44          /* Delay definition */   
     45          #define EraseTimeout             ((u32)0x00000FFF)
     46          #define ProgramTimeout           ((u32)0x0000000F)
     47          
     48          /* Private macro -------------------------------------------------------------*/
     49          /* Private variables ---------------------------------------------------------*/
     50          /* Private function prototypes -----------------------------------------------*/
     51          static void delay(void);
     52          
     53          /*******************************************************************************
     54          * Function Name  : FLASH_HalfCycleAccessCmd
     55          * Description    : Enables or disables the Half cycle flash access.
     56          * Input          : - FLASH_HalfCycle: specifies the FLASH Half cycle Access mode.
     57          *                    This parameter can be one of the following values:
     58          *                       - FLASH_HalfCycleAccess_Enable: FLASH Half Cycle Enable
     59          *                       - FLASH_HalfCycleAccess_Disable: FLASH Half Cycle Disable
     60          * Output         : None
     61          * Return         : None
     62          *******************************************************************************/
     63          void FLASH_HalfCycleAccessCmd(u32 FLASH_HalfCycleAccess)
     64          {
     65          	/* Enable or disable the Half cycle access */
     66          	//  FLASH->ACR.Data &= ACR_HLFCYA_Mask;
     67          	//  FLASH->ACR.Data |= FLASH_HalfCycleAccess;
     68          }
     69          
     70          /*******************************************************************************
     71          * Function Name  : FLASH_Unlock
     72          * Description    : Unlocks the FLASH Program Erase Controller.
     73          * Input          : None
     74          * Output         : None
     75          * Return         : None
     76          *******************************************************************************/
     77          void FLASH_Unlock(void)
     78          {
     79          	// Authorize the FPEC Access
     80          	FLASH->KEYR.Data = FLASH_KEY1;
     81          	FLASH->KEYR.Data = FLASH_KEY2;
     82          }
     83          
     84          INT32U FLASH_pAPBK_Check(INT32U pAddr)	// page no
     85          {
     86          	INT32U i = 0;
     87          	vu32 *Addr = (vu32 *)(__pAPBKAddr + pAddr*1024);
     88          
     89          	for(i = 0; i < (1024/4); i++)
     90          	{
     91          		if(Addr[i] != 0xffffffff) return TRUE;
     92          	}
     93          	return FALSE;
     94          }
     95          
     96          extern void WatchdogClear(void);
     97          INT32U FLASHpAPBK_Check_Erase(void)
     98          {
     99          	INT32U i = 0;
    100          	INT32U FLASH_Sts = FLASH_COMPLETE;
    101          
    102          
    103          	FLASH_Unlock();
    104          	FLASH_ClearFlag(FLASH_FLAG_BSY | FLASH_FLAG_EOP | FLASH_FLAG_PGERR | FLASH_FLAG_WRPRTERR);	
    105          
    106          	for(i = 0; i < (APBKSIZE/1024); i++)
    107          	{
    108          		if(FLASH_pAPBK_Check(i))
    109          		{
    110          			WatchdogClear();
    111          			FLASH_Sts = FLASH_ErasePage(__pAPBKAddr + (i << 10));
    112          		}
    113          
    114          		if(FLASH_Sts != FLASH_COMPLETE)
    115          		{
    116          			FLASH_Sts = FALSE;
    117          			break;
    118          		}
    119          	}	
    120          	return FLASH_Sts;	
    121          }
    122          
    123          
    124          /*******************************************************************************
    125          * Function Name  : FLASH_Lock
    126          * Description    : Locks the FLASH Program Erase Controller.
    127          * Input          : None
    128          * Output         : None
    129          * Return         : None
    130          *******************************************************************************/
    131          void FLASH_Lock(void)
    132          {
    133          	/* Set the Lock Bit to lock the FPEC and the FCR */
    134          	FLASH->CR.Data |= CR_LOCK_Set;
    135          }
    136          
    137          /*******************************************************************************
    138          * Function Name  : FLASH_ErasePage
    139          * Description    : Erases a specified FLASH page.
    140          * Input          : - Page_Address: The page address to be erased.
    141          * Output         : None
    142          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    143          *                  FLASH_ERROR_PG or FLASH_ERROR_WRP or FLASH_COMPLETE or 
    144          *                  FLASH_TIMEOUT.
    145          *******************************************************************************/
    146          INT32U FLASH_ErasePage(u32 Page_Address)
    147          {
    148          	INT32U status = FLASH_COMPLETE;
    149          
    150          	// Wait for last operation to be completed
    151          	status = FLASH_WaitForLastOperation(EraseTimeout);
    152          
    153          	if(status == FLASH_COMPLETE)
    154          	{ 
    155          		// if the previous operation is completed, proceed to erase the page
    156          		FLASH->CR.Data |= CR_PER_Set;
    157          		FLASH->AR.Data = Page_Address; 
    158          		FLASH->CR.Data |= CR_STRT_Set;
    159          
    160          		// Wait for last operation to be completed
    161          		status = FLASH_WaitForLastOperation(EraseTimeout);
    162          
    163          		if(status != FLASH_BUSY)
    164          		{
    165          			// if the erase operation is completed, disable the PER Bit
    166          			FLASH->CR.Data &= CR_PER_Reset;
    167          		}
    168          	}
    169          	return status;
    170          }
    171          
    172          /*******************************************************************************
    173          * Function Name  : FLASH_EraseAllPages
    174          * Description    : Erases all FLASH pages.
    175          * Input          : None
    176          * Output         : None
    177          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    178          *                  FLASH_ERROR_PG or FLASH_ERROR_WRP or FLASH_COMPLETE or 
    179          *                  FLASH_TIMEOUT.
    180          *******************************************************************************/
    181          INT32U FLASH_EraseAllPages(void)
    182          {
    183            INT32U status = FLASH_COMPLETE;
    184          
    185            /* Wait for last operation to be completed */
    186            status = FLASH_WaitForLastOperation(EraseTimeout);
    187            
    188            if(status == FLASH_COMPLETE)
    189            {
    190              /* if the previous operation is completed, proceed to erase all pages */
    191               FLASH->CR.Data |= CR_MER_Set;
    192               FLASH->CR.Data |= CR_STRT_Set;
    193              
    194              /* Wait for last operation to be completed */
    195              status = FLASH_WaitForLastOperation(EraseTimeout);
    196          
    197              if(status != FLASH_BUSY)
    198              {
    199                /* if the erase operation is completed, disable the MER Bit */
    200                FLASH->CR.Data &= CR_MER_Reset;
    201              }
    202            }	   
    203            /* Return the Erase Status */
    204            return status;
    205          }
    206          
    207          /*******************************************************************************
    208          * Function Name  : FLASH_EraseOptionBytes
    209          * Description    : Erases the FLASH option bytes.
    210          * Input          : None
    211          * Output         : None
    212          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    213          *                  FLASH_ERROR_PG or FLASH_ERROR_WRP or FLASH_COMPLETE or 
    214          *                  FLASH_TIMEOUT.
    215          *******************************************************************************/
    216          INT32U FLASH_EraseOptionBytes(void)
    217          {
    218            INT32U status = FLASH_COMPLETE;
    219            
    220            /* Wait for last operation to be completed */
    221            status = FLASH_WaitForLastOperation(EraseTimeout);
    222          
    223            if(status == FLASH_COMPLETE)
    224            {
    225              /* Authorize the small information block programming */
    226              FLASH->OPTKEYR.Data = FLASH_KEY1;
    227              FLASH->OPTKEYR.Data = FLASH_KEY2;
    228              
    229              /* if the previous operation is completed, proceed to erase the option bytes */
    230              FLASH->CR.Data |= CR_OPTER_Set;
    231              FLASH->CR.Data |= CR_STRT_Set;
    232          
    233              /* Wait for last operation to be completed */
    234              status = FLASH_WaitForLastOperation(EraseTimeout);
    235              
    236              if(status == FLASH_COMPLETE)
    237              {
    238                /* if the erase operation is completed, disable the OPTER Bit */
    239                FLASH->CR.Data &= CR_OPTER_Reset;
    240                 
    241                /* Enable the Option Bytes Programming operation */
    242                FLASH->CR.Data |= CR_OPTPG_Set;
    243          
    244                /* Enable the readout access */
    245                OB->RDP= RDP_Key; 
    246          
    247                /* Wait for last operation to be completed */
    248                status = FLASH_WaitForLastOperation(ProgramTimeout);
    249           
    250                if(status != FLASH_BUSY)
    251                {
    252                  /* if the program operation is completed, disable the OPTPG Bit */
    253                  FLASH->CR.Data &= CR_OPTPG_Reset;
    254                }
    255              }
    256              else
    257              {
    258                if (status != FLASH_BUSY)
    259                {
    260                  /* Disable the OPTPG Bit */
    261                  FLASH->CR.Data &= CR_OPTPG_Reset;
    262                }
    263              }  
    264            }
    265            /* Return the erase status */
    266            return status;
    267          }
    268          
    269          /*******************************************************************************
    270          * Function Name  : FLASH_ProgramWord
    271          * Description    : Programs a word at a specified address.
    272          * Input          : - Address: specifies the address to be programmed.
    273          *                  - Data: specifies the data to be programmed.
    274          * Output         : None
    275          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    276          *                  FLASH_ERROR_PG or FLASH_ERROR_WRP or FLASH_COMPLETE or 
    277          *                  FLASH_TIMEOUT. 
    278          *******************************************************************************/
    279          INT32U FLASH_ProgramWord(u32 Address, u32 Data)
    280          {
    281          	INT32U status = FLASH_COMPLETE;
    282          	INT32U cpu_sr;
    283          	
    284          	OS_ENTER_CRITICAL();
    285          	// Wait for last operation to be completed
    286          	status = FLASH_WaitForLastOperation(ProgramTimeout);
    287            
    288          	if(status == FLASH_COMPLETE)
    289          	{
    290          		// if the previous operation is completed, proceed to program the new first half word */
    291          		FLASH->CR.Data |= CR_PG_Set;
    292            
    293              	*(vu16*)Address = (u16)Data;
    294          
    295              	// Wait for last operation to be completed
    296          	    status = FLASH_WaitForLastOperation(ProgramTimeout);
    297           
    298              	if(status == FLASH_COMPLETE)
    299          	    {
    300          		    // if the previous operation is completed, proceed to program the new second 
    301          		    //half word
    302          			*(vu16*)(Address + 2) = Data >> 16;
    303          		    
    304          		    // Wait for last operation to be completed
    305          		    status = FLASH_WaitForLastOperation(ProgramTimeout);
    306          		        
    307          		    if(status != FLASH_BUSY)
    308          		    {
    309          				// Disable the PG Bit
    310          				FLASH->CR.Data &= CR_PG_Reset;
    311          
    312          				// Check Data;
    313          				if(Data != *(vu32 *)Address) status = FLASH_ERRORWR;	// write check error
    314          		    }
    315          	    }
    316              	else
    317              	{
    318               	 	if (status != FLASH_BUSY)
    319                		{
    320                  		// Disable the PG Bit
    321                  		FLASH->CR.Data &= CR_PG_Reset;
    322                		}
    323              	}
    324            	}
    325            	// Return the Program Status
    326          	OS_EXIT_CRITICAL();
    327            	return status;
    328          }
    329          
    330          /*******************************************************************************
    331          * Function Name  : FLASH_ProgramHalfWord
    332          * Description    : Programs a half word at a specified address.
    333          * Input          : - Address: specifies the address to be programmed.
    334          *                  - Data: specifies the data to be programmed.
    335          * Output         : None
    336          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    337          *                  FLASH_ERROR_PG or FLASH_ERROR_WRP or FLASH_COMPLETE or 
    338          *                  FLASH_TIMEOUT. 
    339          *******************************************************************************/
    340          INT32U FLASH_ProgramHalfWord(u32 Address, u16 Data)
    341          {
    342            INT32U status = FLASH_COMPLETE;
    343            INT32U cpu_sr;
    344          
    345            OS_ENTER_CRITICAL();
    346          
    347            /* Wait for last operation to be completed */
    348            status = FLASH_WaitForLastOperation(ProgramTimeout);
    349            
    350            if(status == FLASH_COMPLETE)
    351            {
    352              /* if the previous operation is completed, proceed to program the new data */
    353              FLASH->CR.Data |= CR_PG_Set;
    354            
    355              *(vu16*)Address = Data;
    356              /* Wait for last operation to be completed */
    357              status = FLASH_WaitForLastOperation(ProgramTimeout);
    358          
    359              if(status != FLASH_BUSY)
    360              {
    361                /* if the program operation is completed, disable the PG Bit */
    362                FLASH->CR.Data &= CR_PG_Reset;
    363              }
    364            } 
    365            /* Return the Program Status */
    366            
    367            OS_EXIT_CRITICAL();
    368            return status;
    369          }
    370          
    371          /*******************************************************************************
    372          * Function Name  : FLASH_ProgramOptionByteData
    373          * Description    : Programs a half word at a specified Option Byte Data address.
    374          * Input          : - Address: specifies the address to be programmed.
    375          *                    This parameter can be 0x1FFFF804 or 0x1FFFF806. 
    376          *                  - Data: specifies the data to be programmed.
    377          * Output         : None
    378          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    379          *                  FLASH_ERROR_PG or FLASH_ERROR_WRP or FLASH_COMPLETE or 
    380          *                  FLASH_TIMEOUT. 
    381          *******************************************************************************/
    382          INT32U FLASH_ProgramOptionByteData(u32 Address, u8 Data)
    383          {
    384            INT32U status = FLASH_COMPLETE;
    385          
    386            /* Check the parameters */
    387            assert(IS_OB_DATA_ADDRESS(Address));
    388          
    389            status = FLASH_WaitForLastOperation(ProgramTimeout);
    390          
    391            if(status == FLASH_COMPLETE)
    392            {
    393              /* Authorize the small information block programming */
    394              FLASH->OPTKEYR.Data = FLASH_KEY1;
    395              FLASH->OPTKEYR.Data = FLASH_KEY2;
    396          
    397              /* Enables the Option Bytes Programming operation */
    398              FLASH->CR.Data |= CR_OPTPG_Set; 
    399              *(vu16*)Address = Data;
    400              
    401              /* Wait for last operation to be completed */
    402              status = FLASH_WaitForLastOperation(ProgramTimeout);
    403          
    404              if(status != FLASH_BUSY)
    405              {
    406                /* if the program operation is completed, disable the OPTPG Bit */
    407                FLASH->CR.Data &= CR_OPTPG_Reset;
    408              }
    409            }    
    410            /* Return the Option Byte Data Program Status */
    411            return status;      
    412          }
    413          
    414          /*******************************************************************************
    415          * Function Name  : FLASH_EnableWriteProtection
    416          * Description    : Write protects the desired pages
    417          * Input          : - FLASH_Pages: specifies the address of the pages to be 
    418          *                    write protected. This parameter can be:
    419          *                    - A value between FLASH_WRProt_Pages0to3 and 
    420          *                      FLASH_WRProt_Pages124to127 
    421          *                    - FLASH_WRProt_AllPages
    422          * Output         : None
    423          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    424          *                  FLASH_ERROR_PG or FLASH_ERROR_WRP or FLASH_COMPLETE or 
    425          *                  FLASH_TIMEOUT.
    426          *******************************************************************************/
    427          INT32U FLASH_EnableWriteProtection(u32 FLASH_Pages)
    428          {
    429            u16 WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
    430            
    431            INT32U status = FLASH_COMPLETE;
    432            
    433            /* Check the parameters */
    434            assert(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
    435            
    436            FLASH_Pages = (u32)(~FLASH_Pages);
    437            WRP0_Data = (vu16)(FLASH_Pages & WRP0_Mask);
    438            WRP1_Data = (vu16)((FLASH_Pages & WRP1_Mask) >> 8);
    439            WRP2_Data = (vu16)((FLASH_Pages & WRP2_Mask) >> 16);
    440            WRP3_Data = (vu16)((FLASH_Pages & WRP3_Mask) >> 24);
    441            
    442            /* Wait for last operation to be completed */
    443            status = FLASH_WaitForLastOperation(ProgramTimeout);
    444            
    445            if(status == FLASH_COMPLETE)
    446            {
    447              /* Authorizes the small information block programming */
    448              FLASH->OPTKEYR.Data = FLASH_KEY1;
    449              FLASH->OPTKEYR.Data = FLASH_KEY2;
    450              FLASH->CR.Data |= CR_OPTPG_Set;
    451          
    452              if(WRP0_Data != 0xFF)
    453              {
    454                OB->WRP0 = WRP0_Data;
    455                
    456                /* Wait for last operation to be completed */
    457                status = FLASH_WaitForLastOperation(ProgramTimeout);
    458              }
    459              if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
    460              {
    461                OB->WRP1 = WRP1_Data;
    462                
    463                /* Wait for last operation to be completed */
    464                status = FLASH_WaitForLastOperation(ProgramTimeout);
    465              }
    466          
    467              if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
    468              {
    469                OB->WRP2 = WRP2_Data;
    470                
    471                /* Wait for last operation to be completed */
    472                status = FLASH_WaitForLastOperation(ProgramTimeout);
    473              }
    474              
    475              if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
    476              {
    477                OB->WRP3 = WRP3_Data;
    478               
    479                /* Wait for last operation to be completed */
    480                status = FLASH_WaitForLastOperation(ProgramTimeout);
    481              }
    482                    
    483              if(status != FLASH_BUSY)
    484              {
    485                /* if the program operation is completed, disable the OPTPG Bit */
    486                FLASH->CR.Data &= CR_OPTPG_Reset;
    487              }
    488            } 
    489            /* Return the write protection operation Status */
    490            return status;       
    491          }
    492          
    493          /*******************************************************************************
    494          * Function Name  : FLASH_ReadOutProtection
    495          * Description    : Enables or disables the read out protection
    496          * Input          : - Newstate: new state of the ReadOut Protection.
    497          *                    This parameter can be: ENABLE or DISABLE.
    498          * Output         : None
    499          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    500          *                  FLASH_ERROR_PG or FLASH_ERROR_WRP or FLASH_COMPLETE or 
    501          *                  FLASH_TIMEOUT.
    502          *******************************************************************************/
    503          INT32U FLASH_ReadOutProtection(INT32U NewState)
    504          {
    505            INT32U status = FLASH_COMPLETE;
    506          
    507            /* Check the parameters */
    508            assert(IS_FUNCTIONAL_STATE(NewState));
    509          
    510            status = FLASH_WaitForLastOperation(EraseTimeout);
    511          
    512            if(status == FLASH_COMPLETE)
    513            {
    514              /* Authorizes the small information block programming */
    515              FLASH->OPTKEYR.Data = FLASH_KEY1;
    516              FLASH->OPTKEYR.Data = FLASH_KEY2;
    517          
    518              FLASH->CR.Data |= CR_OPTER_Set;
    519              FLASH->CR.Data |= CR_STRT_Set;
    520          
    521              /* Wait for last operation to be completed */
    522              status = FLASH_WaitForLastOperation(EraseTimeout);
    523          
    524              if(status == FLASH_COMPLETE)
    525              {
    526                /* if the erase operation is completed, disable the OPTER Bit */
    527                FLASH->CR.Data &= CR_OPTER_Reset;
    528          
    529                /* Enable the Option Bytes Programming operation */
    530                FLASH->CR.Data |= CR_OPTPG_Set; 
    531          
    532                if(NewState != DISABLE)
    533                {
    534                  OB->RDP = 0x00;
    535                }
    536                else
    537                {
    538                  OB->RDP = RDP_Key;  
    539                }
    540          
    541                /* Wait for last operation to be completed */
    542                status = FLASH_WaitForLastOperation(EraseTimeout); 
    543              
    544                if(status != FLASH_BUSY)
    545                {
    546                  /* if the program operation is completed, disable the OPTPG Bit */
    547                  FLASH->CR.Data &= CR_OPTPG_Reset;
    548                }
    549              }
    550              else 
    551              {
    552                if(status != FLASH_BUSY)
    553                {
    554                  /* Disable the OPTER Bit */
    555                  FLASH->CR.Data &= CR_OPTER_Reset;
    556                }
    557              }
    558            }
    559            /* Return the protection operation Status */
    560            return status;      
    561          }
    562            	
    563          /*******************************************************************************
    564          * Function Name  : FLASH_UserOptionByteConfig
    565          * Description    : Programs the FLASH User Option Byte: IWDG_SW / RST_STOP /
    566          *                  RST_STDBY.
    567          * Input          : - OB_IWDG: Selects the IWDG mode
    568          *                     This parameter can be one of the following values:
    569          *                     - OB_IWDG_SW: Software IWDG selected
    570          *                     - OB_IWDG_HW: Hardware IWDG selected
    571          *                  - OB_STOP: Reset event when entering STOP mode.
    572          *                     This parameter can be one of the following values:
    573          *                     - OB_STOP_NoRST: No reset generated when entering in STOP
    574          *                     - OB_STOP_RST: Reset generated when entering in STOP
    575          *                  - OB_STDBY: Reset event when entering Standby mode.
    576          *                    This parameter can be one of the following values:
    577          *                     - OB_STDBY_NoRST: No reset generated when entering in STANDBY
    578          *                     - OB_STDBY_RST: Reset generated when entering in STANDBY
    579          * Output         : None
    580          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    581          *                  FLASH_ERROR_PG or FLASH_ERROR_WRP or FLASH_COMPLETE or 
    582          *                  FLASH_TIMEOUT.
    583          *******************************************************************************/
    584          INT32U FLASH_UserOptionByteConfig(u16 OB_IWDG, u16 OB_STOP, u16 OB_STDBY)
    585          {
    586            INT32U status = FLASH_COMPLETE; 
    587          
    588            /* Check the parameters */
    589            assert(IS_OB_IWDG_SOURCE(OB_IWDG));
    590            assert(IS_OB_STOP_SOURCE(OB_STOP));
    591            assert(IS_OB_STDBY_SOURCE(OB_STDBY));
    592          
    593            /* Authorize the small information block programming */
    594            FLASH->OPTKEYR.Data = FLASH_KEY1;
    595            FLASH->OPTKEYR.Data = FLASH_KEY2;
    596            
    597            /* Wait for last operation to be completed */
    598            status = FLASH_WaitForLastOperation(ProgramTimeout);
    599            
    600            if(status == FLASH_COMPLETE)
    601            {  
    602              /* Enable the Option Bytes Programming operation */
    603              FLASH->CR.Data |= CR_OPTPG_Set; 
    604                     
    605              OB->USER = ( OB_IWDG | OB_STOP |OB_STDBY) | (u16)0xF8; 
    606            
    607              /* Wait for last operation to be completed */
    608              status = FLASH_WaitForLastOperation(ProgramTimeout);
    609          
    610              if(status != FLASH_BUSY)
    611              {
    612                /* if the program operation is completed, disable the OPTPG Bit */
    613                FLASH->CR.Data &= CR_OPTPG_Reset;
    614              }
    615            }    
    616            /* Return the Option Byte program Status */
    617            return status;
    618          }
    619          
    620          /*******************************************************************************
    621          * Function Name  : FLASH_GetUserOptionByte
    622          * Description    : Returns the FLASH User Option Bytes values.
    623          * Input          : None
    624          * Output         : None
    625          * Return         : The FLASH User Option Bytes values:IWDG_SW(Bit0), RST_STOP(Bit1)
    626          *                  and RST_STDBY(Bit2).
    627          *******************************************************************************/
    628          INT32U FLASH_GetUserOptionByte(void)
    629          {
    630            /* Return the User Option Byte */
    631            return (u32)(FLASH->OBR.Data >> 2);
    632          }
    633          
    634          /*******************************************************************************
    635          * Function Name  : FLASH_GetWriteProtectionOptionByte
    636          * Description    : Returns the FLASH Write Protection Option Bytes Register value.
    637          * Input          : None
    638          * Output         : None
    639          * Return         : The FLASH Write Protection  Option Bytes Register value
    640          *******************************************************************************/
    641          INT32U FLASH_GetWriteProtectionOptionByte(void)
    642          {
    643            /* Return the Falsh write protection Register value */
    644            return (u32)(FLASH->WRPR.Data);
    645          }
    646          
    647          /*******************************************************************************
    648          * Function Name  : FLASH_GetReadOutProtectionStatus
    649          * Description    : Checks whether the FLASH Read Out Protection Status is set 
    650          *                  or not.
    651          * Input          : None
    652          * Output         : None
    653          * Return         : FLASH ReadOut Protection Status(SET or RESET)
    654          *******************************************************************************/
    655          INT32U FLASH_GetReadOutProtectionStatus(void)
    656          {
    657            INT32U readoutstatus = RESET;
    658          
    659            if ((FLASH->OBR.Data & RDPRT_Mask) != (u32)RESET)
    660            {
    661              readoutstatus = SET;
    662            }
    663            else
    664            {
    665              readoutstatus = RESET;
    666            }
    667            return readoutstatus;
    668          }
    669          
    670          /*******************************************************************************
    671          * Function Name  : FLASH_GetPrefetchBufferStatus
    672          * Description    : Checks whether the FLASH Prefetch Buffer status is set or not.
    673          * Input          : None
    674          * Output         : None
    675          * Return         : FLASH Prefetch Buffer Status (SET or RESET).
    676          *******************************************************************************/
    677          INT32U FLASH_GetPrefetchBufferStatus(void)
    678          {
    679          
    680            INT32U bitstatus = RESET;
    681          /**  
    682            if ((FLASH->ACR.Data & ACR_PRFTBS_Mask) != (u32)RESET)
    683            {
    684              bitstatus = SET;
    685            }
    686            else
    687            {
    688              bitstatus = RESET;
    689            }
    690           */
    691            /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
    692            return bitstatus; 
    693          }
    694          
    695          /*******************************************************************************
    696          * Function Name  : FLASH_ITConfig
    697          * Description    : Enables or disables the specified FLASH interrupts.
    698          * Input          : - FLASH_IT: specifies the FLASH interrupt sources to be 
    699          *                    enabled or disabled.
    700          *                    This parameter can be any combination of the following values:
    701          *                       - FLASH_IT_ERROR: FLASH Error Interrupt
    702          *                       - FLASH_IT_EOP: FLASH end of operation Interrupt
    703          * Output         : None
    704          * Return         : None 
    705          *******************************************************************************/
    706          void FLASH_ITConfig(u16 FLASH_IT, INT32U NewState)
    707          {
    708            /* Check the parameters */
    709            assert(IS_FLASH_IT(FLASH_IT)); 
    710            assert(IS_FUNCTIONAL_STATE(NewState));
    711          
    712            if(NewState != DISABLE)
    713            {
    714              /* Enable the interrupt sources */
    715              FLASH->CR.Data |= FLASH_IT;
    716            }
    717            else
    718            {
    719              /* Disable the interrupt sources */
    720              FLASH->CR.Data &= ~(u32)FLASH_IT;
    721            }
    722          }
    723          
    724          /*******************************************************************************
    725          * Function Name  : FLASH_GetFlagStatus
    726          * Description    : Checks whether the specified FLASH flag is set or not.
    727          * Input          : - FLASH_FLAG: specifies the FLASH flag to check.
    728          *                     This parameter can be one of the following values:
    729          *                    - FLASH_FLAG_BSY: FLASH Busy flag           
    730          *                    - FLASH_FLAG_PGERR: FLASH Program error flag       
    731          *                    - FLASH_FLAG_WRPRTERR: FLASH Write protected error flag      
    732          *                    - FLASH_FLAG_EOP: FLASH End of Operation flag           
    733          *                    - FLASH_FLAG_OPTERR:  FLASH Option Byte error flag     
    734          * Output         : None
    735          * Return         : The new state of FLASH_FLAG (SET or RESET).
    736          *******************************************************************************/
    737          INT32U FLASH_GetFlagStatus(u16 FLASH_FLAG)
    738          {
    739          	INT32U bitstatus = RESET;
    740          
    741          	if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
    742          	{
    743          		if((FLASH->OBR.Data & FLASH_FLAG_OPTERR) != (u32)RESET)
    744          		{
    745          		  bitstatus = SET;
    746          		}
    747          		else
    748          		{
    749          		  bitstatus = RESET;
    750          		}
    751          	}
    752          	else
    753          	{
    754          		if((FLASH->SR.Data & FLASH_FLAG) != (u32)RESET)
    755          		{
    756          		  	bitstatus = SET;
    757          		}
    758          		else
    759          		{
    760          		  	bitstatus = RESET;
    761          		}
    762          	}
    763            	// Return the new state of FLASH_FLAG (SET or RESET)
    764          	return bitstatus;
    765          }
    766          
    767          /*******************************************************************************
    768          * Function Name  : FLASH_ClearFlag
    769          * Description    : Clears the FLASH’s pending flags.
    770          * Input          : - FLASH_FLAG: specifies the FLASH flags to clear.
    771          *                    This parameter can be any combination of the following values:
    772          *                    - FLASH_FLAG_BSY: FLASH Busy flag           
    773          *                    - FLASH_FLAG_PGERR: FLASH Program error flag       
    774          *                    - FLASH_FLAG_WRPRTERR: FLASH Write protected error flag      
    775          *                    - FLASH_FLAG_EOP: FLASH End of Operation flag           
    776          * Output         : None
    777          * Return         : None
    778          *******************************************************************************/
    779          void FLASH_ClearFlag(u16 FLASH_FLAG)
    780          {
    781          	// Clear the flags
    782          	FLASH->SR.Data = FLASH_FLAG;
    783          }
    784          
    785          /*******************************************************************************
    786          * Function Name  : FLASH_GetStatus
    787          * Description    : Returns the FLASH Status.
    788          * Input          : None
    789          * Output         : None
    790          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    791          *                  FLASH_ERROR_PG or FLASH_ERROR_WRP or FLASH_COMPLETE
    792          *******************************************************************************/
    793          INT32U FLASH_GetStatus(void)
    794          {
    795            INT32U flashstatus = FLASH_COMPLETE;
    796            
    797          	if((FLASH->SR.Data & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
    798          	{
    799          		flashstatus = FLASH_BUSY;
    800          	}
    801          	else 
    802          	{  
    803          		if(FLASH->SR.Data & FLASH_FLAG_PGERR)
    804          		{ 
    805          		  flashstatus = FLASH_ERROR_PG;
    806          		}
    807          		else 
    808          		{
    809          			if(FLASH->SR.Data & FLASH_FLAG_WRPRTERR)
    810          			{
    811          				flashstatus = FLASH_ERROR_WRP;
    812          			}
    813          			else
    814          			{
    815          				flashstatus = FLASH_COMPLETE;
    816          			}
    817          		}
    818          	}
    819            /* Return the Flash Status */
    820            return flashstatus;
    821          }
    822          
    823          /*******************************************************************************
    824          * Function Name  : FLASH_WaitForLastOperation
    825          * Description    : Waits for a Flash operation to complete or a TIMEOUT to occur.
    826          * Input          : - Timeout: FLASH progamming Timeout
    827          * Output         : None
    828          * Return         : FLASH Status: The returned value can be: FLASH_BUSY, 
    829          *                  FLASH_ERROR_PG or FLASH_ERROR_WRP or FLASH_COMPLETE or 
    830          *                  FLASH_TIMEOUT.
    831          *******************************************************************************/
    832          INT32U FLASH_WaitForLastOperation(u32 Timeout)
    833          { 
    834          	// Check for the Flash Status
    835          	INT32U status = FLASH_GetStatus();
    836          
    837          	// Wait for a Flash operation to complete or a TIMEOUT to occur
    838          	while((status == FLASH_BUSY) && (Timeout--))
    839          	{
    840          		delay();
    841          		status = FLASH_GetStatus();
    842          	}
    843          
    844          	if(Timeout == 0x00 )
    845          	{
    846          		status = FLASH_TIMEOUT;
    847          	}
    848          
    849          	// Return the operation status
    850          	return status;
    851          }
    852          
    853          /*******************************************************************************
    854          * Function Name  : delay
    855          * Description    : Inserts a time delay.
    856          * Input          : None
    857          * Output         : None
    858          * Return         : None
    859          *******************************************************************************/
    860          static void delay(void)
    861          {
    862          	vu32 i = 0xFF;
    863          	while(i--);
    864          }
    865          /******************* (C) COPYRIGHT 2007 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     FLASH_ClearFlag                     0
     FLASH_EnableWriteProtection        24
     FLASH_EraseAllPages                16
     FLASH_EraseOptionBytes             16
     FLASH_ErasePage                    16
     FLASH_GetFlagStatus                 0
     FLASH_GetPrefetchBufferStatus       0
     FLASH_GetReadOutProtectionStatus
                                         0
     FLASH_GetStatus                     0
     FLASH_GetUserOptionByte             0
     FLASH_GetWriteProtectionOptionByte
                                         0
     FLASH_HalfCycleAccessCmd            0
     FLASH_ITConfig                      0
     FLASH_Lock                          0
     FLASH_ProgramHalfWord              24
     FLASH_ProgramOptionByteData        16
     FLASH_ProgramWord                  32
     FLASH_ReadOutProtection            16
     FLASH_Unlock                        0
     FLASH_UserOptionByteConfig         24
     FLASH_WaitForLastOperation         16
     FLASH_pAPBK_Check                   0
     FLASHpAPBK_Check_Erase             24


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     FLASH_HalfCycleAccessCmd          2
     FLASH_Unlock                     16
     FLASH_pAPBK_Check                50
     FLASHpAPBK_Check_Erase          104
     FLASH_Lock                       14
     FLASH_ErasePage                  62
     FLASH_EraseAllPages              56
     FLASH_EraseOptionBytes           98
     FLASH_ProgramWord               112
     FLASH_ProgramHalfWord            72
     FLASH_ProgramOptionByteData      58
     FLASH_EnableWriteProtection     148
     FLASH_ReadOutProtection         118
     FLASH_UserOptionByteConfig       76
     FLASH_GetUserOptionByte           8
     FLASH_GetWriteProtectionOptionByte
                                      12
     FLASH_GetReadOutProtectionStatus
                                       8
     ?Subroutine0                     10
     FLASH_GetPrefetchBufferStatus     4
     FLASH_ITConfig                   18
     FLASH_GetFlagStatus              20
     FLASH_ClearFlag                   6
     FLASH_GetStatus                  42
     FLASH_WaitForLastOperation       46
     ??DataTable5                      4
     ??DataTable8                      4
     ??DataTable9                      4
     ??DataTable28                     4
     ??DataTable29                     4
     ??DataTable30                     4
     ??DataTable31                     4
     ??DataTable33                     4
     ??DataTable34                     4
     ??DataTable37                     4

 
 1 200 bytes in section .text
 
 1 200 bytes of CODE memory

Errors: none
Warnings: none

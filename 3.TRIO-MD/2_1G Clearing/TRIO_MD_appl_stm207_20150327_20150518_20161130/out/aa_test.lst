###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     19/May/2017  23:32:01 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Project\TRIO\3.TRIO-MD\2_1G                           #
#                    Clearing\TRIO_MD_appl_stm207_20150327_20150518_20161130\ #
#                    code\aa_test.c                                           #
#    Command line =  "D:\Project\TRIO\3.TRIO-MD\2_1G                          #
#                    Clearing\TRIO_MD_appl_stm207_20150327_20150518_20161130\ #
#                    code\aa_test.c" -lC "D:\Project\TRIO\3.TRIO-MD\2_1G      #
#                    Clearing\TRIO_MD_appl_stm207_20150327_20150518_20161130\ #
#                    out\" -o "D:\Project\TRIO\3.TRIO-MD\2_1G                 #
#                    Clearing\TRIO_MD_appl_stm207_20150327_20150518_20161130\ #
#                    out\" --endian=little --cpu=Cortex-M3 -e --fpu=None      #
#                    --dlib_config "D:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I "D:\Project\TRIO\3.TRIO-MD\2_1G                #
#                    Clearing\TRIO_MD_appl_stm207_20150327_20150518_20161130\ #
#                    include\" -I "D:\Project\TRIO\3.TRIO-MD\2_1G             #
#                    Clearing\TRIO_MD_appl_stm207_20150327_20150518_20161130\ #
#                    STM32F2xx_StdPeriph_Driver_v1212\" -I                    #
#                    "D:\Project\TRIO\3.TRIO-MD\2_1G                          #
#                    Clearing\TRIO_MD_appl_stm207_20150327_20150518_20161130\ #
#                    STM32F2xx_StdPeriph_Driver_v1212\inc\" -I                #
#                    "D:\Project\TRIO\3.TRIO-MD\2_1G                          #
#                    Clearing\TRIO_MD_appl_stm207_20150327_20150518_20161130\ #
#                    uC-CPU\" -I "D:\Project\TRIO\3.TRIO-MD\2_1G              #
#                    Clearing\TRIO_MD_appl_stm207_20150327_20150518_20161130\ #
#                    uC-LIB\" -I "D:\Project\TRIO\3.TRIO-MD\2_1G              #
#                    Clearing\TRIO_MD_appl_stm207_20150327_20150518_20161130\ #
#                    uCOS-II\Ports\" -I "D:\Project\TRIO\3.TRIO-MD\2_1G       #
#                    Clearing\TRIO_MD_appl_stm207_20150327_20150518_20161130\ #
#                    uCOS-II\Source\" -I "D:\Project\TRIO\3.TRIO-MD\2_1G      #
#                    Clearing\TRIO_MD_appl_stm207_20150327_20150518_20161130\ #
#                    uC-Probe\" -Oh --use_c++_inline                          #
#    List file    =  D:\Project\TRIO\3.TRIO-MD\2_1G                           #
#                    Clearing\TRIO_MD_appl_stm207_20150327_20150518_20161130\ #
#                    out\aa_test.lst                                          #
#    Object file  =  D:\Project\TRIO\3.TRIO-MD\2_1G                           #
#                    Clearing\TRIO_MD_appl_stm207_20150327_20150518_20161130\ #
#                    out\aa_test.o                                            #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\TRIO\3.TRIO-MD\2_1G Clearing\TRIO_MD_appl_stm207_20150327_20150518_20161130\code\aa_test.c
      1          
      2          /******************** (C) COPYRIGHT 2008 PILOG, NSINFO *************************
      3          * File Name          : exlib.c
      4          * Author             : Yoon Byong-Gyu(bgyoon@naver.com)
      5          * Date First Issued  : 02/01/2008
      6          * Description        : This file provides all the port/input/update firmware functions.
      7          * $Revision: 0.1 $
      8          * $Revision date: 2008.01.__
      9          ********************************************************************************/
     10          
     11          #define TEST_C
     12          
     13          #include <math.h>
     14          #include <stdlib.h>
     15          //#include <ctype.h>
     16          
     17          #include "../include/main.h"

   \                                 In section iram, align 4
   \   static __absolute OS_STK TestTaskStk[512]
   \                     TestTaskStk:
   \   00000000                      DS8 2048

   \                                 In section .bss, align 1
   \   __absolute INT8U tTestFlag
   \                     tTestFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute char tIndex
   \                     tIndex:
   \   00000000                      DS8 1
   \   __absolute INT8S PrevWRCnt
   \                     PrevWRCnt:
   \   00000001                      DS8 1
   \   __absolute INT8S PrevRDCnt
   \                     PrevRDCnt:
   \   00000002                      DS8 1
   \   00000003                      DS8 1
   \   __absolute char rRevData[30]
   \                     rRevData:
   \   00000004                      DS8 32
   \   __absolute INT8U PrevData[5][30]
   \                     PrevData:
   \   00000024                      DS8 152

   \                                 In section .bss, align 4
   \   __absolute INT8U tRevData[30]
   \                     tRevData:
   \   00000000                      DS8 32

   \                                 In section .bss, align 1
   \   __absolute INT8U gTestFlag
   \                     gTestFlag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute INT8U SysPath
   \                     SysPath:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute INT8U DTUTest
   \                     DTUTest:
   \   00000000                      DS8 1
   \   00000001                      DS8 1
   \   __absolute INT16U Argc
   \                     Argc:
   \   00000002                      DS8 2
   \   __absolute char *Argv[15]
   \                     Argv:
   \   00000004                      DS8 60

   \                                 In section .bss, align 4
   \   __absolute MON_STR MonStr
   \                     MonStr:
   \   00000000                      DS8 164

   \                                 In section .data, align 4
   \   __absolute unsigned char const *testResult[2]
   \                     testResult:
   \   00000000   0x........         DC32 `?<Constant "NON TESTED">`, `?<Constant "    TESTED">`
   \              0x........   

   \                                 In section .bss, align 4
   \   __absolute _inputStsStr tinputStsOld
   \                     tinputStsOld:
   \   00000000                      DS8 52

   \                                 In section .data, align 4
   \   __absolute _inputStsStr tinputSts
   \                     tinputSts:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000010   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000020   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   __absolute char const *tDisplay[9]
   \                     tDisplay:
   \   00000034   0x........         DC32 `?<Constant "AC(PSU)      :">`, `?<Constant "CL_PLL_LD    :">`
   \              0x........   
   \   0000003C   0x........         DC32 `?<Constant "LTEA_PLL_LD  :">`, `?<Constant "WCDMA_PLL_LD :">`
   \              0x........   
   \   00000044   0x........         DC32 `?<Constant "F_DONE       :">`, `?<Constant "DTU_Insert   :">`
   \              0x........   
   \   0000004C   0x........         DC32 `?<Constant "DTU_Insert1  :">`, `?<Constant "RF_Insert    :">`
   \              0x........   
   \   00000054   0x........         DC32 `?<Constant "EXT_Insert\\t  :">`

   \                                 In section .bss, align 1
   \   __absolute INT8U FNDi
   \                     FNDi:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute INT8U FNDj
   \                     FNDj:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute INT32U testFNDCnt
   \                     testFNDCnt:
   \   00000000                      DS8 4

   \                                 In section .data, align 1
   \   __absolute INT8U FNDSTOPFlag
   \                     FNDSTOPFlag:
   \   00000000   0x01               DC8 1
     18          
     19          #define Board_Test
     20          
     21          
     22          

   \                                 In section .text, align 2, keep-with-next
     23          void TestInit(void)
     24          {
     25          	OSTaskCreate(TestTask, (void *)NULL, (OS_STK *)&TestTaskStk[TEST_START_STK_SIZE - 1], TEST_START_PRIO);
   \                     TestInit:
   \   00000000   0x2307             MOVS     R3,#+7
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable112_3
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x.... 0x....      ADR.W    R0,TestTask
   \   0000000C   0x.... 0x....      B.W      OSTaskCreate
     26          }
     27          
     28          

   \                                 In section .text, align 4, keep-with-next
     29          void TestTask(void *p_arg)
     30          {
   \                     TestTask:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
     31          	INT16U nCnt = 0;
     32          //	INT32U nFlag = 0;
     33              nCnt = nCnt;
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xF8AD 0x0000      STRH     R0,[SP, #+0]
     34          	gTestFlag = FALSE;
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable112_4
   \   0000000C   0x7020             STRB     R0,[R4, #+0]
     35          	
     36          	OSTimeDly(TEST_START_PRIO*100L);
   \   0000000E   0xF44F 0x702F      MOV      R0,#+700
   \   00000012   0x.... 0x....      BL       OSTimeDly
     37          
     38          	memset((INT8U *)&MonStr,0,sizeof(MON_STR));
   \   00000016   0x21A2             MOVS     R1,#+162
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable112_5
   \   0000001C   0x.... 0x....      BL       __aeabi_memclr4
   \   00000020   0x.... 0x....      ADR.W    R5,`?<Constant "\\n\\r Unknown Command!!">`
   \   00000024   0x.... 0x....      LDR.W    R6,??DataTable112_6
   \   00000028   0x.... 0x....      LDR.W    R7,??DataTable112_7
     39          //	iUser_Value2 = __ChangeDebug;
     40          	while(1)
     41          	{
     42          		if(iUser_Value2 == __ChangeDebug)
   \                     ??TestTask_0:
   \   0000002C   0x7838             LDRB     R0,[R7, #+0]
   \   0000002E   0x280D             CMP      R0,#+13
   \   00000030   0xD128             BNE.N    ??TestTask_1
     43          		{
     44          			PrintLogo();
   \   00000032   0x.... 0x....      BL       PrintLogo
     45          			PromptOut();
   \   00000036   0x.... 0x....      BL       PromptOut
     46          			gTestFlag = TRUE;
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x7020             STRB     R0,[R4, #+0]
     47          	
     48          			while(iUser_Value2 == __ChangeDebug)
   \   0000003E   0x7838             LDRB     R0,[R7, #+0]
   \   00000040   0x280D             CMP      R0,#+13
   \   00000042   0xD11F             BNE.N    ??TestTask_1
     49          			{
     50          				if(SerPtr->CheckByte(1, &nCnt))
   \                     ??TestTask_2:
   \   00000044   0xA900             ADD      R1,SP,#+0
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x6832             LDR      R2,[R6, #+0]
   \   0000004A   0x6852             LDR      R2,[R2, #+4]
   \   0000004C   0x4790             BLX      R2
   \   0000004E   0xB168             CBZ.N    R0,??TestTask_3
     51          				{
     52          					if(GetCommand(0)){
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0x.... 0x....      BL       GetCommand
   \   00000056   0xB148             CBZ.N    R0,??TestTask_3
     53          						if(!CommandInterpret(0)) SerPtr->printf(NULL,"\n\r Unknown Command!!");
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x.... 0x....      BL       CommandInterpret
   \   0000005E   0xB918             CBNZ.N   R0,??TestTask_4
   \   00000060   0x4629             MOV      R1,R5
   \   00000062   0x6832             LDR      R2,[R6, #+0]
   \   00000064   0x6912             LDR      R2,[R2, #+16]
   \   00000066   0x4790             BLX      R2
     54          						PromptOut();
   \                     ??TestTask_4:
   \   00000068   0x.... 0x....      BL       PromptOut
     55          					}
     56          				}
     57          
     58          				if(TimeOverCheck(Timer_DebugCnt)) DownLoadBootingJump();
   \                     ??TestTask_3:
   \   0000006C   0x2006             MOVS     R0,#+6
   \   0000006E   0x.... 0x....      BL       TimeOverCheck
   \   00000072   0xB108             CBZ.N    R0,??TestTask_5
   \   00000074   0x.... 0x....      BL       DownLoadBootingJump
     59          				OSTimeDly(10u);
   \                     ??TestTask_5:
   \   00000078   0x200A             MOVS     R0,#+10
   \   0000007A   0x.... 0x....      BL       OSTimeDly
   \   0000007E   0x7838             LDRB     R0,[R7, #+0]
   \   00000080   0x280D             CMP      R0,#+13
   \   00000082   0xD0DF             BEQ.N    ??TestTask_2
     60          			}
     61          		}
     62          
     63          		OSTimeDly(500L);
   \                     ??TestTask_1:
   \   00000084   0xF44F 0x70FA      MOV      R0,#+500
   \   00000088   0x.... 0x....      BL       OSTimeDly
   \   0000008C   0xE7CE             B.N      ??TestTask_0
     64          	}
     65          }
     66          
     67          /*#########################################################*/
     68          /*  RS232로 부터 데이타를 받아서 COM_STR.BUFF에 저장한다.  */
     69          /*  RETURN(0x0D)코드가 오면 명령어의 끝으로 인식하고 널    */
     70          /* (0x00)을 저장하고 끝난다.                               */
     71          /*  입력값 : dest_sio --> SIO 포트.                        */
     72          /*  리턴값 : TRUE  --> CR Code가 입력됨.                   */
     73          /*           FALSE --> CR Code가 입력이 안됨.              */
     74          /*#########################################################*/

   \                                 In section .text, align 2, keep-with-next
     75          INT8U GetCommand(INT8U Sio)
     76          {
   \                     GetCommand:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
     77           	char Data;
     78          
     79          	Data = lower(SerPtr->RxGetByte());
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable112_6
   \   00000006   0x6820             LDR      R0,[R4, #+0]
   \   00000008   0x6880             LDR      R0,[R0, #+8]
   \   0000000A   0x4780             BLX      R0
   \   0000000C   0xB2C0             UXTB     R0,R0
   \   0000000E   0x.... 0x....      BL       lower
   \   00000012   0xB2C5             UXTB     R5,R0
     80          	SerPtr->PutToBuffer(Data);			// 입력 키 출력
   \   00000014   0x4628             MOV      R0,R5
   \   00000016   0x6821             LDR      R1,[R4, #+0]
   \   00000018   0x6989             LDR      R1,[R1, #+24]
   \   0000001A   0x4788             BLX      R1
     81          
     82              switch(MonStr.m_Mode){
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable112_5
   \   00000020   0x7801             LDRB     R1,[R0, #+0]
   \   00000022   0xB119             CBZ.N    R1,??GetCommand_0
   \   00000024   0x2901             CMP      R1,#+1
   \   00000026   0xD013             BEQ.N    ??GetCommand_1
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xBD32             POP      {R1,R4,R5,PC}
     83                 case 0:
     84                      if(Data==CR){ /* Carrige Return */
   \                     ??GetCommand_0:
   \   0000002C   0x2D0D             CMP      R5,#+13
   \   0000002E   0xBF08             IT       EQ 
   \   00000030   0x7081             STRBEQ   R1,[R0, #+2]
     85          				MonStr.m_Buff[0]='\0';            /* NULL CODE */
     86          				Parser(MonStr.m_Buff);
   \   00000032   0xD014             BEQ.N    ??GetCommand_2
     87          
     88          				SerPtr->PutToBuffer('\r');
     89          				SerPtr->PutToBuffer('\n');
     90          					
     91          				return(TRUE);
     92                      }
     93                      else if(Data!=' ' && Data!=BS){
   \   00000034   0x2D20             CMP      R5,#+32
   \   00000036   0xBF18             IT       NE 
   \   00000038   0x2D08             CMPNE    R5,#+8
   \   0000003A   0xD027             BEQ.N    ??GetCommand_3
     94                         MonStr.m_Buff[MonStr.m_Ptr++]=Data;
   \   0000003C   0x7841             LDRB     R1,[R0, #+1]
   \   0000003E   0x1809             ADDS     R1,R1,R0
   \   00000040   0x708D             STRB     R5,[R1, #+2]
   \   00000042   0x7841             LDRB     R1,[R0, #+1]
   \   00000044   0x1C49             ADDS     R1,R1,#+1
   \   00000046   0x7041             STRB     R1,[R0, #+1]
     95                         MonStr.m_Mode=1;
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0x7001             STRB     R1,[R0, #+0]
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xBD32             POP      {R1,R4,R5,PC}
     96                      }
     97                      break;
     98                 case 1:
     99                      if(Data==CR){
   \                     ??GetCommand_1:
   \   00000050   0x7841             LDRB     R1,[R0, #+1]
   \   00000052   0x2D0D             CMP      R5,#+13
   \   00000054   0xD110             BNE.N    ??GetCommand_4
    100                         MonStr.m_Buff[MonStr.m_Ptr]='\0';  /* NULL CODE */
   \   00000056   0x1809             ADDS     R1,R1,R0
   \   00000058   0x2200             MOVS     R2,#+0
   \   0000005A   0x708A             STRB     R2,[R1, #+2]
    101                         MonStr.m_Mode=0;
   \   0000005C   0x8002             STRH     R2,[R0, #+0]
    102                         MonStr.m_Ptr=0;
    103                         Parser(MonStr.m_Buff);
   \                     ??GetCommand_2:
   \   0000005E   0x1C80             ADDS     R0,R0,#+2
   \   00000060   0x.... 0x....      BL       Parser
    104          
    105          			   SerPtr->PutToBuffer('\r');
   \   00000064   0x200D             MOVS     R0,#+13
   \   00000066   0x6821             LDR      R1,[R4, #+0]
   \   00000068   0x6989             LDR      R1,[R1, #+24]
   \   0000006A   0x4788             BLX      R1
    106          			   SerPtr->PutToBuffer('\n');
   \   0000006C   0x200A             MOVS     R0,#+10
   \   0000006E   0x6821             LDR      R1,[R4, #+0]
   \   00000070   0x6989             LDR      R1,[R1, #+24]
   \   00000072   0x4788             BLX      R1
    107          
    108          			   return(TRUE);
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0xBD32             POP      {R1,R4,R5,PC}
    109                      }
    110                      else if(Data==BS){ /* Backspace */
   \                     ??GetCommand_4:
   \   00000078   0x2D08             CMP      R5,#+8
   \   0000007A   0xD102             BNE.N    ??GetCommand_5
    111                         if(MonStr.m_Ptr>0)
   \   0000007C   0xB131             CBZ.N    R1,??GetCommand_3
    112                            MonStr.m_Ptr--;
   \   0000007E   0x1E49             SUBS     R1,R1,#+1
   \   00000080   0xE003             B.N      ??GetCommand_6
    113                      }
    114                      else{
    115                         MonStr.m_Buff[MonStr.m_Ptr++]=Data;
   \                     ??GetCommand_5:
   \   00000082   0x1809             ADDS     R1,R1,R0
   \   00000084   0x708D             STRB     R5,[R1, #+2]
   \   00000086   0x7841             LDRB     R1,[R0, #+1]
   \   00000088   0x1C49             ADDS     R1,R1,#+1
   \                     ??GetCommand_6:
   \   0000008A   0x7041             STRB     R1,[R0, #+1]
    116          			   
    117                      }
    118                      break;
    119              }/* End of switch */
    120            return(FALSE);
   \                     ??GetCommand_3:
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    121          }
    122          

   \                                 In section .text, align 4, keep-with-next
    123          INT8U CommandInterpret(INT8U Sio)
    124          {
   \                     CommandInterpret:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x4606             MOV      R6,R0
    125          	INT16U addr;
    126          	INT8U data;
    127          	INT32U Data32;
    128          	INT32U faddr;
    129          
    130          
    131          
    132          	if(!Argc)
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable113
   \   0000000C   0x8860             LDRH     R0,[R4, #+2]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xF000 0x852D      BEQ.W    ??CommandInterpret_0
    133          		return(1);  /* Enter키가 입력됨. */
    134          
    135          //	SerPtr->printf("Argv[%s][%s]\n",Argv[0],Argv[1]);
    136          
    137          #if 1
    138          	if(!strcmp((char *)Argv[0], "HELP"))
   \   00000014   0x6865             LDR      R5,[R4, #+4]
   \   00000016   0x.... 0x....      ADR.W    R1,`?<Constant "HELP">`
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0x.... 0x....      BL       strcmp
   \   00000020   0xB958             CBNZ.N   R0,??CommandInterpret_1
    139          	{
    140          		SerPtr->printf("[%s]\n",Argv[0]);
   \   00000022   0x4629             MOV      R1,R5
   \   00000024   0x.... 0x....      ADR.W    R0,`?<Constant "[%s]\\n">`
   \   00000028   0x.... 0x....      LDR.W    R2,??DataTable112_6
   \   0000002C   0x6812             LDR      R2,[R2, #+0]
   \   0000002E   0x6912             LDR      R2,[R2, #+16]
   \   00000030   0x4790             BLX      R2
    141          
    142          		PrintLogo();
   \   00000032   0x.... 0x....      BL       PrintLogo
   \   00000036   0xF000 0xBD1A      B.W      ??CommandInterpret_0
    143          	}
    144          	else if(!strcmp((char *)Argv[0], "FPGA"))
   \                     ??CommandInterpret_1:
   \   0000003A   0x.... 0x....      ADR.W    R1,`?<Constant "FPGA">`
   \   0000003E   0x4628             MOV      R0,R5
   \   00000040   0x.... 0x....      BL       strcmp
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xF040 0x8148      BNE.W    ??CommandInterpret_2
    145          	{
    146          		DTUTest = SET;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x7020             STRB     R0,[R4, #+0]
    147          		
    148          		if(!strcmp((char *)Argv[1], "DET"))
   \   0000004E   0x68A5             LDR      R5,[R4, #+8]
   \   00000050   0xA1BF             ADR.N    R1,??CommandInterpret_3  ;; "DET"
   \   00000052   0x4628             MOV      R0,R5
   \   00000054   0x.... 0x....      BL       strcmp
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xF040 0x8092      BNE.W    ??CommandInterpret_4
    149          		{
    150          			#if 1
    151          			type32 tmp;
    152          			
    153          			addr = strtol(Argv[2], NULL, 16);
   \   0000005E   0x2300             MOVS     R3,#+0
   \   00000060   0x2210             MOVS     R2,#+16
   \   00000062   0x2100             MOVS     R1,#+0
   \   00000064   0x68E0             LDR      R0,[R4, #+12]
   \   00000066   0x.... 0x....      BL       __iar_Stolx
    154          			DTU_WriteData(CS0SEL, DTU_ReadSelect, addr);
   \   0000006A   0xB2C2             UXTB     R2,R0
   \   0000006C   0x2110             MOVS     R1,#+16
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x.... 0x....      BL       DTU_WriteData
    155          			{
    156          
    157          				INT8U tmpAddr = DTU_PeakPower_B0;
    158          				tmp.sD8[3] = DTU_ReadData(CS0SEL, tmpAddr + 0);
   \   00000074   0x2111             MOVS     R1,#+17
   \   00000076   0x2000             MOVS     R0,#+0
   \   00000078   0x.... 0x....      BL       DTU_ReadData
   \   0000007C   0xF88D 0x000F      STRB     R0,[SP, #+15]
    159          				tmp.sD8[2] = DTU_ReadData(CS0SEL, tmpAddr + 1);
   \   00000080   0x2112             MOVS     R1,#+18
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x.... 0x....      BL       DTU_ReadData
   \   00000088   0xF88D 0x000E      STRB     R0,[SP, #+14]
    160          				tmp.sD8[1] = DTU_ReadData(CS0SEL, tmpAddr + 2);
   \   0000008C   0x2113             MOVS     R1,#+19
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x.... 0x....      BL       DTU_ReadData
   \   00000094   0xF88D 0x000D      STRB     R0,[SP, #+13]
    161          				tmp.sD8[0] = DTU_ReadData(CS0SEL, tmpAddr + 3);
   \   00000098   0x2114             MOVS     R1,#+20
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x.... 0x....      BL       DTU_ReadData
   \   000000A0   0xF88D 0x000C      STRB     R0,[SP, #+12]
    162          
    163          				Data32 = logx(tmp.uD32);
   \   000000A4   0x2400             MOVS     R4,#+0
   \   000000A6   0x.... 0x....      LDR.W    R5,??DataTable114  ;; 0x40240000
   \   000000AA   0x9803             LDR      R0,[SP, #+12]
   \   000000AC   0x.... 0x....      BL       __aeabi_ui2d
   \   000000B0   0x2201             MOVS     R2,#+1
   \   000000B2   0x.... 0x....      BL       __iar_Log
   \   000000B6   0x4622             MOV      R2,R4
   \   000000B8   0x462B             MOV      R3,R5
   \   000000BA   0x.... 0x....      BL       __aeabi_dmul
   \   000000BE   0x4622             MOV      R2,R4
   \   000000C0   0x462B             MOV      R3,R5
   \   000000C2   0x.... 0x....      BL       __aeabi_dmul
   \   000000C6   0x.... 0x....      BL       __aeabi_d2iz
   \   000000CA   0xB200             SXTH     R0,R0
    164          
    165          //				Data = logx(100);
    166          
    167          				if( Sio == 0)	SerPtr->printf("DTUPeakPower[%x][%x][%x][%x]:%d.%d \n",tmp.sD8[3],tmp.sD8[2],tmp.sD8[1],tmp.sD8[0],Data32/10, Data32%10);
   \   000000CC   0xB9C6             CBNZ.N   R6,??CommandInterpret_5
   \   000000CE   0x210A             MOVS     R1,#+10
   \   000000D0   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   000000D4   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   000000D8   0xEBA0 0x0042      SUB      R0,R0,R2, LSL #+1
   \   000000DC   0x9002             STR      R0,[SP, #+8]
   \   000000DE   0x9101             STR      R1,[SP, #+4]
   \   000000E0   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   000000E4   0x9000             STR      R0,[SP, #+0]
   \   000000E6   0xF89D 0x300D      LDRB     R3,[SP, #+13]
   \   000000EA   0xF89D 0x200E      LDRB     R2,[SP, #+14]
   \   000000EE   0xF89D 0x100F      LDRB     R1,[SP, #+15]
   \   000000F2   0x.... 0x....      ADR.W    R0,`?<Constant "DTUPeakPower[%x][%x][...">`
   \   000000F6   0x.... 0x....      LDR.W    R7,??DataTable112_6
   \   000000FA   0x683F             LDR      R7,[R7, #+0]
   \   000000FC   0x693F             LDR      R7,[R7, #+16]
   \   000000FE   0x47B8             BLX      R7
    168          			}
    169          			{
    170          				INT8U tmpAddr = DTU_AverPower_B0;
    171          
    172          				tmp.sD8[3] = DTU_ReadData(CS0SEL, tmpAddr + 0);
   \                     ??CommandInterpret_5:
   \   00000100   0x2115             MOVS     R1,#+21
   \   00000102   0x2000             MOVS     R0,#+0
   \   00000104   0x.... 0x....      BL       DTU_ReadData
   \   00000108   0xF88D 0x000F      STRB     R0,[SP, #+15]
    173          				tmp.sD8[2] = DTU_ReadData(CS0SEL, tmpAddr + 1);
   \   0000010C   0x2116             MOVS     R1,#+22
   \   0000010E   0x4620             MOV      R0,R4
   \   00000110   0x.... 0x....      BL       DTU_ReadData
   \   00000114   0xF88D 0x000E      STRB     R0,[SP, #+14]
    174          				tmp.sD8[1] = DTU_ReadData(CS0SEL, tmpAddr + 2);
   \   00000118   0x2117             MOVS     R1,#+23
   \   0000011A   0x4620             MOV      R0,R4
   \   0000011C   0x.... 0x....      BL       DTU_ReadData
   \   00000120   0xF88D 0x000D      STRB     R0,[SP, #+13]
    175          				tmp.sD8[0] = DTU_ReadData(CS0SEL, tmpAddr + 3);
   \   00000124   0x2118             MOVS     R1,#+24
   \   00000126   0x4620             MOV      R0,R4
   \   00000128   0x.... 0x....      BL       DTU_ReadData
   \   0000012C   0xF88D 0x000C      STRB     R0,[SP, #+12]
    176          
    177          				Data32 = logx(tmp.uD32);
   \   00000130   0x9803             LDR      R0,[SP, #+12]
   \   00000132   0x.... 0x....      BL       __aeabi_ui2d
   \   00000136   0x2201             MOVS     R2,#+1
   \   00000138   0x.... 0x....      BL       __iar_Log
   \   0000013C   0x4622             MOV      R2,R4
   \   0000013E   0x462B             MOV      R3,R5
   \   00000140   0x.... 0x....      BL       __aeabi_dmul
   \   00000144   0x4622             MOV      R2,R4
   \   00000146   0x462B             MOV      R3,R5
   \   00000148   0x.... 0x....      BL       __aeabi_dmul
   \   0000014C   0x.... 0x....      BL       __aeabi_d2iz
   \   00000150   0xB200             SXTH     R0,R0
    178          				if( Sio == 0)	SerPtr->printf("DTUAverPower[%x][%x][%x][%x]:%d.%d \n",tmp.sD8[3],tmp.sD8[2],tmp.sD8[1],tmp.sD8[0],Data32/10, Data32%10);
   \   00000152   0x2E00             CMP      R6,#+0
   \   00000154   0xF040 0x848B      BNE.W    ??CommandInterpret_0
   \   00000158   0x210A             MOVS     R1,#+10
   \   0000015A   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   0000015E   0xEB01 0x0281      ADD      R2,R1,R1, LSL #+2
   \   00000162   0xEBA0 0x0042      SUB      R0,R0,R2, LSL #+1
   \   00000166   0x9002             STR      R0,[SP, #+8]
   \   00000168   0x9101             STR      R1,[SP, #+4]
   \   0000016A   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   0000016E   0x9000             STR      R0,[SP, #+0]
   \   00000170   0xF89D 0x300D      LDRB     R3,[SP, #+13]
   \   00000174   0xF89D 0x200E      LDRB     R2,[SP, #+14]
   \   00000178   0xF89D 0x100F      LDRB     R1,[SP, #+15]
   \   0000017C   0x.... 0x....      ADR.W    R0,`?<Constant "DTUAverPower[%x][%x][...">`
   \   00000180   0xE068             B.N      ??CommandInterpret_6
    179          
    180          			}
    181          			#endif
    182          
    183          		}
    184          		else if(!strcmp((char *)Argv[1], "ISO"))
   \                     ??CommandInterpret_4:
   \   00000182   0xA174             ADR.N    R1,??CommandInterpret_3+0x4  ;; "ISO"
   \   00000184   0x4628             MOV      R0,R5
   \   00000186   0x.... 0x....      BL       strcmp
   \   0000018A   0x2800             CMP      R0,#+0
   \   0000018C   0xD169             BNE.N    ??CommandInterpret_7
    185          		{
    186          			type32 tmp;
    187          			
    188          			INT32U ecs_x, ecs_0;
    189          			INT16S Temp;
    190          
    191          			addr = strtol(Argv[2], NULL, 16);
   \   0000018E   0x2300             MOVS     R3,#+0
   \   00000190   0x2210             MOVS     R2,#+16
   \   00000192   0x2100             MOVS     R1,#+0
   \   00000194   0x68E0             LDR      R0,[R4, #+12]
   \   00000196   0x.... 0x....      BL       __iar_Stolx
   \   0000019A   0xB286             UXTH     R6,R0
    192          			{
    193          				DTU_WriteData(CS0SEL, DTU_ISOPathSel, addr);
   \   0000019C   0xB2F2             UXTB     R2,R6
   \   0000019E   0x2160             MOVS     R1,#+96
   \   000001A0   0x2000             MOVS     R0,#+0
   \   000001A2   0x.... 0x....      BL       DTU_WriteData
    194          
    195          				tmp.sD8[3] = DTU_ReadData(CS0SEL, DTU_ISO_O_Power + 0);
   \   000001A6   0x2161             MOVS     R1,#+97
   \   000001A8   0x2000             MOVS     R0,#+0
   \   000001AA   0x.... 0x....      BL       DTU_ReadData
   \   000001AE   0xF88D 0x000B      STRB     R0,[SP, #+11]
    196          				tmp.sD8[2] = DTU_ReadData(CS0SEL, DTU_ISO_O_Power + 1);
   \   000001B2   0x2162             MOVS     R1,#+98
   \   000001B4   0x2000             MOVS     R0,#+0
   \   000001B6   0x.... 0x....      BL       DTU_ReadData
   \   000001BA   0xF88D 0x000A      STRB     R0,[SP, #+10]
    197          				tmp.sD8[1] = DTU_ReadData(CS0SEL, DTU_ISO_O_Power + 2);
   \   000001BE   0x2163             MOVS     R1,#+99
   \   000001C0   0x2000             MOVS     R0,#+0
   \   000001C2   0x.... 0x....      BL       DTU_ReadData
   \   000001C6   0xF88D 0x0009      STRB     R0,[SP, #+9]
    198          				tmp.sD8[0] = DTU_ReadData(CS0SEL, DTU_ISO_O_Power + 3);
   \   000001CA   0x2164             MOVS     R1,#+100
   \   000001CC   0x2000             MOVS     R0,#+0
   \   000001CE   0x.... 0x....      BL       DTU_ReadData
   \   000001D2   0xF88D 0x0008      STRB     R0,[SP, #+8]
    199          				ecs_0 = tmp.uD32;
   \   000001D6   0x9F02             LDR      R7,[SP, #+8]
    200          
    201          				tmp.sD8[3] = DTU_ReadData(CS0SEL, DTU_ISO_x_Power + 0);
   \   000001D8   0x2165             MOVS     R1,#+101
   \   000001DA   0x2000             MOVS     R0,#+0
   \   000001DC   0x.... 0x....      BL       DTU_ReadData
   \   000001E0   0xF88D 0x000B      STRB     R0,[SP, #+11]
    202          				tmp.sD8[2] = DTU_ReadData(CS0SEL, DTU_ISO_x_Power + 1);
   \   000001E4   0x2166             MOVS     R1,#+102
   \   000001E6   0x2000             MOVS     R0,#+0
   \   000001E8   0x.... 0x....      BL       DTU_ReadData
   \   000001EC   0xF88D 0x000A      STRB     R0,[SP, #+10]
    203          				tmp.sD8[1] = DTU_ReadData(CS0SEL, DTU_ISO_x_Power + 2);
   \   000001F0   0x2167             MOVS     R1,#+103
   \   000001F2   0x2000             MOVS     R0,#+0
   \   000001F4   0x.... 0x....      BL       DTU_ReadData
   \   000001F8   0xF88D 0x0009      STRB     R0,[SP, #+9]
    204          				tmp.sD8[0] = DTU_ReadData(CS0SEL, DTU_ISO_x_Power + 3);
   \   000001FC   0x2168             MOVS     R1,#+104
   \   000001FE   0x2000             MOVS     R0,#+0
   \   00000200   0x.... 0x....      BL       DTU_ReadData
   \   00000204   0xF88D 0x0008      STRB     R0,[SP, #+8]
    205          				ecs_x = tmp.uD32;
    206          				Temp = -log2x((double)ecs_x/(double)ecs_0);
   \   00000208   0x9802             LDR      R0,[SP, #+8]
   \   0000020A   0x.... 0x....      BL       __aeabi_ui2d
   \   0000020E   0x4604             MOV      R4,R0
   \   00000210   0x460D             MOV      R5,R1
   \   00000212   0x4638             MOV      R0,R7
   \   00000214   0x.... 0x....      BL       __aeabi_ui2d
   \   00000218   0x4602             MOV      R2,R0
   \   0000021A   0x460B             MOV      R3,R1
   \   0000021C   0x4620             MOV      R0,R4
   \   0000021E   0x4629             MOV      R1,R5
   \   00000220   0x.... 0x....      BL       __aeabi_ddiv
   \   00000224   0x2201             MOVS     R2,#+1
   \   00000226   0x.... 0x....      BL       __iar_Log
   \   0000022A   0x2200             MOVS     R2,#+0
   \   0000022C   0x.... 0x....      LDR.W    R3,??DataTable114_1  ;; 0x40340000
   \   00000230   0x.... 0x....      BL       __aeabi_dmul
   \   00000234   0x2200             MOVS     R2,#+0
   \   00000236   0x.... 0x....      LDR.W    R3,??DataTable114  ;; 0x40240000
   \   0000023A   0x.... 0x....      BL       __aeabi_dmul
   \   0000023E   0x.... 0x....      BL       __aeabi_d2iz
   \   00000242   0x4240             RSBS     R0,R0,#+0
   \   00000244   0xB200             SXTH     R0,R0
    207          				SerPtr->printf("ISOPower[%x]:[%x][%x]>[%x][%d] \n",addr,ecs_0,ecs_x,Temp,Temp);
   \   00000246   0x9001             STR      R0,[SP, #+4]
   \   00000248   0x9000             STR      R0,[SP, #+0]
   \   0000024A   0x9B02             LDR      R3,[SP, #+8]
   \   0000024C   0x463A             MOV      R2,R7
   \   0000024E   0x4631             MOV      R1,R6
   \   00000250   0x.... 0x....      ADR.W    R0,`?<Constant "ISOPower[%x]:[%x][%x]...">`
   \                     ??CommandInterpret_6:
   \   00000254   0x.... 0x....      LDR.W    R4,??DataTable112_6
   \   00000258   0x6824             LDR      R4,[R4, #+0]
   \   0000025A   0x6924             LDR      R4,[R4, #+16]
   \   0000025C   0x47A0             BLX      R4
   \   0000025E   0xF000 0xBC06      B.W      ??CommandInterpret_0
    208          			}
    209          		}
    210          		else if(!strcmp((char *)Argv[1], "W"))
   \                     ??CommandInterpret_7:
   \   00000262   0xA13D             ADR.N    R1,??CommandInterpret_3+0x8  ;; "W"
   \   00000264   0x4628             MOV      R0,R5
   \   00000266   0x.... 0x....      BL       strcmp
   \   0000026A   0xB9D0             CBNZ.N   R0,??CommandInterpret_8
    211          		{
    212          
    213          			addr = strtol(Argv[2], NULL, 16);
   \   0000026C   0x2300             MOVS     R3,#+0
   \   0000026E   0x2210             MOVS     R2,#+16
   \   00000270   0x2100             MOVS     R1,#+0
   \   00000272   0x68E0             LDR      R0,[R4, #+12]
   \   00000274   0x.... 0x....      BL       __iar_Stolx
   \   00000278   0xB286             UXTH     R6,R0
    214          			data = strtol(Argv[3], NULL, 16);
   \   0000027A   0x2300             MOVS     R3,#+0
   \   0000027C   0x2210             MOVS     R2,#+16
   \   0000027E   0x4619             MOV      R1,R3
   \   00000280   0x6920             LDR      R0,[R4, #+16]
   \   00000282   0x.... 0x....      BL       __iar_Stolx
    215          
    216          			DTU_WriteData(CS0SEL, addr, data);
   \   00000286   0xB2C2             UXTB     R2,R0
   \   00000288   0xB2F1             UXTB     R1,R6
   \   0000028A   0x2000             MOVS     R0,#+0
   \   0000028C   0x.... 0x....      BL       DTU_WriteData
    217          			
    218          			data = DTU_ReadData(CS0SEL, addr);
   \   00000290   0xB2F1             UXTB     R1,R6
   \   00000292   0x2000             MOVS     R0,#+0
   \   00000294   0x.... 0x....      BL       DTU_ReadData
    219          
    220          			SerPtr->printf ("FPGA Write[%x]: data[%x]\n",addr,data);
   \   00000298   0xB2C2             UXTB     R2,R0
   \   0000029A   0x4631             MOV      R1,R6
   \   0000029C   0x.... 0x....      ADR.W    R0,`?<Constant "FPGA Write[%x]: data[...">`
   \   000002A0   0xE015             B.N      ??CommandInterpret_9
    221          		}
    222          		else if(!strcmp((char *)Argv[1], "R"))
   \                     ??CommandInterpret_8:
   \   000002A2   0xA1E4             ADR.N    R1,??CommandInterpret_10  ;; "R"
   \   000002A4   0x4628             MOV      R0,R5
   \   000002A6   0x.... 0x....      BL       strcmp
   \   000002AA   0x2800             CMP      R0,#+0
   \   000002AC   0xF040 0x83DF      BNE.W    ??CommandInterpret_0
    223          		{
    224          			addr = strtol(Argv[2], NULL, 16);
   \   000002B0   0x2300             MOVS     R3,#+0
   \   000002B2   0x2210             MOVS     R2,#+16
   \   000002B4   0x2100             MOVS     R1,#+0
   \   000002B6   0x68E0             LDR      R0,[R4, #+12]
   \   000002B8   0x.... 0x....      BL       __iar_Stolx
   \   000002BC   0xB286             UXTH     R6,R0
    225          			data = DTU_ReadData(CS0SEL, addr);
   \   000002BE   0xB2F1             UXTB     R1,R6
   \   000002C0   0x2000             MOVS     R0,#+0
   \   000002C2   0x.... 0x....      BL       DTU_ReadData
    226          
    227          			SerPtr->printf ("FPGA Read[%x]: data[%x]\n",addr,data);
   \   000002C6   0xB2C2             UXTB     R2,R0
   \   000002C8   0x4631             MOV      R1,R6
   \   000002CA   0x.... 0x....      ADR.W    R0,`?<Constant "FPGA Read[%x]: data[%x]\\n">`
   \                     ??CommandInterpret_9:
   \   000002CE   0x.... 0x....      LDR.W    R3,??DataTable112_6
   \   000002D2   0x681B             LDR      R3,[R3, #+0]
   \   000002D4   0x691B             LDR      R3,[R3, #+16]
   \   000002D6   0x4798             BLX      R3
   \   000002D8   0xE3C9             B.N      ??CommandInterpret_0
    228          		}
    229          	}
    230          	else if(!strcmp((char *)Argv[0], "RESET"))
   \                     ??CommandInterpret_2:
   \   000002DA   0x.... 0x....      ADR.W    R1,`?<Constant "RESET">`
   \   000002DE   0x4628             MOV      R0,R5
   \   000002E0   0x.... 0x....      BL       strcmp
   \   000002E4   0xB978             CBNZ.N   R0,??CommandInterpret_11
    231          	{
    232          		SerPtr->printf("[%s]\n",Argv[0]);
   \   000002E6   0x4629             MOV      R1,R5
   \   000002E8   0x.... 0x....      ADR.W    R0,`?<Constant "[%s]\\n">`
   \   000002EC   0x.... 0x....      LDR.W    R2,??DataTable112_6
   \   000002F0   0x6812             LDR      R2,[R2, #+0]
   \   000002F2   0x6912             LDR      R2,[R2, #+16]
   \   000002F4   0x4790             BLX      R2
    233          		
    234          		DownloadFlagClr();
   \   000002F6   0x.... 0x....      BL       DownloadFlagClr
    235          		ForDelay(20L);
   \   000002FA   0x2014             MOVS     R0,#+20
   \   000002FC   0x.... 0x....      BL       ForDelay
    236          		DownLoadBootingJump();
   \   00000300   0x.... 0x....      BL       DownLoadBootingJump
   \   00000304   0xE3B3             B.N      ??CommandInterpret_0
    237          	}
    238          	else if(!strcmp((char *)Argv[0], "SPI"))
   \                     ??CommandInterpret_11:
   \   00000306   0xA115             ADR.N    R1,??CommandInterpret_3+0xC  ;; "SPI"
   \   00000308   0x4628             MOV      R0,R5
   \   0000030A   0x.... 0x....      BL       strcmp
   \   0000030E   0xBB38             CBNZ.N   R0,??CommandInterpret_12
    239          	{
    240          		INT8U OPCODE;
    241          		INT8U tmp = 0;
   \   00000310   0xF88D 0x0008      STRB     R0,[SP, #+8]
    242          
    243          		OPCODE = strtol(Argv[1], NULL, 16);
   \   00000314   0x2300             MOVS     R3,#+0
   \   00000316   0x2210             MOVS     R2,#+16
   \   00000318   0x2100             MOVS     R1,#+0
   \   0000031A   0x68A0             LDR      R0,[R4, #+8]
   \   0000031C   0x.... 0x....      BL       __iar_Stolx
   \   00000320   0x4605             MOV      R5,R0
    244          		faddr = strtol(Argv[2], NULL, 16);
   \   00000322   0x2300             MOVS     R3,#+0
   \   00000324   0x2210             MOVS     R2,#+16
   \   00000326   0x4619             MOV      R1,R3
   \   00000328   0x68E0             LDR      R0,[R4, #+12]
   \   0000032A   0x.... 0x....      BL       __iar_Stolx
   \   0000032E   0x4603             MOV      R3,R0
    245          
    246          		sSPI_DataRead(&AT25DFSpi,SPI_FLASH_CH0,OPCODE,faddr,&tmp, 1);
   \   00000330   0x2001             MOVS     R0,#+1
   \   00000332   0x9001             STR      R0,[SP, #+4]
   \   00000334   0xA802             ADD      R0,SP,#+8
   \   00000336   0x9000             STR      R0,[SP, #+0]
   \   00000338   0xB2EA             UXTB     R2,R5
   \   0000033A   0x2100             MOVS     R1,#+0
   \   0000033C   0x.... 0x....      LDR.W    R0,??DataTable114_3
   \   00000340   0x.... 0x....      BL       sSPI_DataRead
    247          
    248          		SerPtr->printf("[%02x]\n",tmp);		
   \   00000344   0xF89D 0x1008      LDRB     R1,[SP, #+8]
   \   00000348   0x.... 0x....      ADR.W    R0,`?<Constant "[%02x]\\n">`
   \   0000034C   0xE38B             B.N      ??CommandInterpret_13
   \   0000034E   0xBF00             Nop      
   \                     ??CommandInterpret_3:
   \   00000350   0x44 0x45          DC8      "DET"
   \              0x54 0x00    
   \   00000354   0x49 0x53          DC8      "ISO"
   \              0x4F 0x00    
   \   00000358   0x57 0x00          DC8      "W",0x0,0x0
   \              0x00 0x00    
   \   0000035C   0x53 0x50          DC8      "SPI"
   \              0x49 0x00    
    249          	}	
    250          	else if(!strcmp((char *)Argv[0], "FLASH"))
   \                     ??CommandInterpret_12:
   \   00000360   0x.... 0x....      ADR.W    R1,`?<Constant "FLASH">`
   \   00000364   0x4628             MOV      R0,R5
   \   00000366   0x.... 0x....      BL       strcmp
   \   0000036A   0x2800             CMP      R0,#+0
   \   0000036C   0xF040 0x81F6      BNE.W    ??CommandInterpret_14
    251          	{
    252          		INT16U i;
    253          		INT8U tmp;
    254          
    255          		if(!strcmp((char *)Argv[1], "0"))
   \   00000370   0x68A5             LDR      R5,[R4, #+8]
   \   00000372   0xA1E6             ADR.N    R1,??CommandInterpret_15  ;; "0"
   \   00000374   0x4628             MOV      R0,R5
   \   00000376   0x.... 0x....      BL       strcmp
   \   0000037A   0x2800             CMP      R0,#+0
   \   0000037C   0xF040 0x817B      BNE.W    ??CommandInterpret_16
    256          		{
    257          			if(!strcmp((char *)Argv[2], "W"))
   \   00000380   0xA1E3             ADR.N    R1,??CommandInterpret_15+0x4  ;; "W"
   \   00000382   0x68E0             LDR      R0,[R4, #+12]
   \   00000384   0x.... 0x....      BL       strcmp
   \   00000388   0x2800             CMP      R0,#+0
   \   0000038A   0xD170             BNE.N    ??CommandInterpret_17
    258          			{
    259          #define DUMPSIZE	16			
    260          
    261          				INT8U tmpData[DUMPSIZE];
    262          				INT8U data1[4] = {0,};
   \   0000038C   0xA800             ADD      R0,SP,#+0
   \   0000038E   0x2100             MOVS     R1,#+0
   \   00000390   0x6001             STR      R1,[R0, #+0]
    263          
    264          				faddr = strtol(Argv[3], NULL, 16);
   \   00000392   0x2300             MOVS     R3,#+0
   \   00000394   0x2210             MOVS     R2,#+16
   \   00000396   0x6920             LDR      R0,[R4, #+16]
   \   00000398   0x.... 0x....      BL       __iar_Stolx
   \   0000039C   0x4606             MOV      R6,R0
    265          				data1[0] = strtol(Argv[4], NULL, 16);
   \   0000039E   0x2300             MOVS     R3,#+0
   \   000003A0   0x2210             MOVS     R2,#+16
   \   000003A2   0x4619             MOV      R1,R3
   \   000003A4   0x6960             LDR      R0,[R4, #+20]
   \   000003A6   0x.... 0x....      BL       __iar_Stolx
   \   000003AA   0xF88D 0x0000      STRB     R0,[SP, #+0]
    266          				data1[1] = strtol(Argv[5], NULL, 16);
   \   000003AE   0xAD00             ADD      R5,SP,#+0
   \   000003B0   0x2300             MOVS     R3,#+0
   \   000003B2   0x2210             MOVS     R2,#+16
   \   000003B4   0x4619             MOV      R1,R3
   \   000003B6   0x69A0             LDR      R0,[R4, #+24]
   \   000003B8   0x.... 0x....      BL       __iar_Stolx
   \   000003BC   0x7068             STRB     R0,[R5, #+1]
    267          				data1[2] = strtol(Argv[6], NULL, 16);
   \   000003BE   0x2300             MOVS     R3,#+0
   \   000003C0   0x2210             MOVS     R2,#+16
   \   000003C2   0x4619             MOV      R1,R3
   \   000003C4   0x69E0             LDR      R0,[R4, #+28]
   \   000003C6   0x.... 0x....      BL       __iar_Stolx
   \   000003CA   0x70A8             STRB     R0,[R5, #+2]
    268          				data1[3] = strtol(Argv[7], NULL, 16);
   \   000003CC   0x2300             MOVS     R3,#+0
   \   000003CE   0x2210             MOVS     R2,#+16
   \   000003D0   0x4619             MOV      R1,R3
   \   000003D2   0x6A20             LDR      R0,[R4, #+32]
   \   000003D4   0x.... 0x....      BL       __iar_Stolx
   \   000003D8   0x70E8             STRB     R0,[R5, #+3]
    269          
    270          				tmpData[0] = data1[0];
   \   000003DA   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000003DE   0xF88D 0x0004      STRB     R0,[SP, #+4]
    271          				tmpData[1] = data1[1];
   \   000003E2   0x786A             LDRB     R2,[R5, #+1]
   \   000003E4   0xAB01             ADD      R3,SP,#+4
   \   000003E6   0x705A             STRB     R2,[R3, #+1]
    272          				tmpData[2] = data1[2];
   \   000003E8   0x78A8             LDRB     R0,[R5, #+2]
   \   000003EA   0x7098             STRB     R0,[R3, #+2]
    273          				tmpData[3] = data1[3];
   \   000003EC   0x78E9             LDRB     R1,[R5, #+3]
   \   000003EE   0x70D9             STRB     R1,[R3, #+3]
    274          				tmpData[4] = data1[0];
   \   000003F0   0xF89D 0x5000      LDRB     R5,[SP, #+0]
   \   000003F4   0x711D             STRB     R5,[R3, #+4]
    275          				tmpData[5] = data1[1];
   \   000003F6   0xF88D 0x2009      STRB     R2,[SP, #+9]
    276          				tmpData[6] = data1[2];
   \   000003FA   0xF88D 0x000A      STRB     R0,[SP, #+10]
    277          				tmpData[7] = data1[3];
   \   000003FE   0xF88D 0x100B      STRB     R1,[SP, #+11]
    278          				
    279          				tmpData[8] = data1[0];
   \   00000402   0xF89D 0x5000      LDRB     R5,[SP, #+0]
   \   00000406   0x721D             STRB     R5,[R3, #+8]
    280          				tmpData[9] = data1[1];
   \   00000408   0xF88D 0x200D      STRB     R2,[SP, #+13]
    281          				tmpData[10] = data1[2];
   \   0000040C   0x7298             STRB     R0,[R3, #+10]
    282          				tmpData[11] = data1[3];
   \   0000040E   0xF88D 0x100F      STRB     R1,[SP, #+15]
    283          				tmpData[12] = data1[0];
   \   00000412   0xF89D 0x5000      LDRB     R5,[SP, #+0]
   \   00000416   0x731D             STRB     R5,[R3, #+12]
    284          				tmpData[13] = data1[1];
   \   00000418   0xF88D 0x2011      STRB     R2,[SP, #+17]
    285          				tmpData[14] = data1[2];
   \   0000041C   0xF88D 0x0012      STRB     R0,[SP, #+18]
    286          				tmpData[15] = data1[3];
   \   00000420   0xF88D 0x1013      STRB     R1,[SP, #+19]
    287          
    288          				for(i = 0; i < DUMPSIZE; i++)
    289          				{
    290          //					tmpData[i] = data;
    291          				}
    292           				
    293          //				sFLASH_CS0_DataWriteExt(0);
    294          //				sFLASH_CS0_BL4kCheckErase(sFLASH_APPLAddr + faddr, DUMPSIZE);
    295          //				sFLASH_CS0_DataWrite(sFLASH_APPLAddr + faddr, tmpData, DUMPSIZE);
    296          #if 0
    297          				if(faddr > SPI_FLASH_16MB_BOUN)
    298          				{
    299          					INT8U tmp1[4];
    300          
    301          					tmp = sFLASH_CS0_SetRegister(CMD_EXTNADDR_WREAR,NULL,tmp1,0);
    302          				}
    303          #endif
    304          				sFLASH_CS0_BL4kCheckErase(faddr, DUMPSIZE);
   \   00000424   0x.... 0x....      LDR.W    R7,??DataTable114_3
   \   00000428   0x2210             MOVS     R2,#+16
   \   0000042A   0x4631             MOV      R1,R6
   \   0000042C   0x4638             MOV      R0,R7
   \   0000042E   0x.... 0x....      BL       sFLASH_BL4kCheckErase
    305          				sFLASH_CS0_DataWrite(faddr, tmpData, DUMPSIZE);
   \   00000432   0x2310             MOVS     R3,#+16
   \   00000434   0xAA01             ADD      R2,SP,#+4
   \   00000436   0x4631             MOV      R1,R6
   \   00000438   0x4638             MOV      R0,R7
   \   0000043A   0x.... 0x....      BL       sFLASH_DataWrite
    306          
    307          				for(i = 0; i < DUMPSIZE; i++)
   \   0000043E   0xF04F 0x0A10      MOV      R10,#+16
   \   00000442   0x.... 0x....      ADR.W    R9,`?<Constant "[%x]">`
   \   00000446   0x.... 0x....      LDR.W    R5,??DataTable112_6
    308          				{
    309          					tmp = sFLASH_CS0_DataRead(faddr + i);
   \                     ??CommandInterpret_18:
   \   0000044A   0x4631             MOV      R1,R6
   \   0000044C   0x4638             MOV      R0,R7
   \   0000044E   0x.... 0x....      BL       sFLASH_DataRead
   \   00000452   0x4680             MOV      R8,R0
    310          					SerPtr->printf("[%x]",tmp);
   \   00000454   0x4641             MOV      R1,R8
   \   00000456   0x4648             MOV      R0,R9
   \   00000458   0x682A             LDR      R2,[R5, #+0]
   \   0000045A   0x6912             LDR      R2,[R2, #+16]
   \   0000045C   0x4790             BLX      R2
    311          				}
   \   0000045E   0x1C76             ADDS     R6,R6,#+1
   \   00000460   0xF1BA 0x0A01      SUBS     R10,R10,#+1
   \   00000464   0xD1F1             BNE.N    ??CommandInterpret_18
    312          				
    313          				SerPtr->printf("\n");
   \   00000466   0xA0C3             ADR.N    R0,??CommandInterpret_19  ;; "\n"
   \   00000468   0x6829             LDR      R1,[R5, #+0]
   \   0000046A   0x6909             LDR      R1,[R1, #+16]
   \   0000046C   0x4788             BLX      R1
    314           
    315          			}
    316          			if(!strcmp((char *)Argv[2], "R"))
   \                     ??CommandInterpret_17:
   \   0000046E   0xA171             ADR.N    R1,??CommandInterpret_10  ;; "R"
   \   00000470   0x68E0             LDR      R0,[R4, #+12]
   \   00000472   0x.... 0x....      BL       strcmp
   \   00000476   0xB9F8             CBNZ.N   R0,??CommandInterpret_20
    317          			{
    318          				INT32U i = 0;
    319          				INT8U tmp;
    320          #define DUMPSIZE	16			
    321          				faddr = strtol(Argv[3], NULL, 16);
    322          
    323          //				sFLASH_CS0_DataWriteExt(0);
    324          
    325          #if 0
    326          				if(faddr > SPI_FLASH_16MB_BOUN)
    327          				{
    328          					INT8U tmp1[4];
    329          
    330          					tmp = sFLASH_CS0_SetRegister(CMD_EXTNADDR_WREAR,NULL,tmp1,0);
    331          				}
    332          #endif
    333          
    334          				for(i = 0; i < DUMPSIZE; i++)
   \   00000478   0x2300             MOVS     R3,#+0
   \   0000047A   0x2210             MOVS     R2,#+16
   \   0000047C   0x2100             MOVS     R1,#+0
   \   0000047E   0x6920             LDR      R0,[R4, #+16]
   \   00000480   0x.... 0x....      BL       __iar_Stolx
   \   00000484   0x4606             MOV      R6,R0
   \   00000486   0xF04F 0x0910      MOV      R9,#+16
   \   0000048A   0x.... 0x....      ADR.W    R10,`?<Constant "[%02x]">`
   \   0000048E   0x.... 0x....      LDR.W    R7,??DataTable114_3
   \   00000492   0x.... 0x....      LDR.W    R5,??DataTable112_6
    335          				{
    336          //					tmp = sFLASH_CS0_DataRead(sFLASH_APPLAddr + faddr + i);
    337          					tmp = sFLASH_CS0_DataRead(faddr + i);
   \                     ??CommandInterpret_21:
   \   00000496   0x4631             MOV      R1,R6
   \   00000498   0x4638             MOV      R0,R7
   \   0000049A   0x.... 0x....      BL       sFLASH_DataRead
    338          
    339          					SerPtr->printf("[%02x]",tmp);
   \   0000049E   0x4601             MOV      R1,R0
   \   000004A0   0x4650             MOV      R0,R10
   \   000004A2   0x682A             LDR      R2,[R5, #+0]
   \   000004A4   0x6912             LDR      R2,[R2, #+16]
   \   000004A6   0x4790             BLX      R2
    340          				}
   \   000004A8   0x1C76             ADDS     R6,R6,#+1
   \   000004AA   0xF1B9 0x0901      SUBS     R9,R9,#+1
   \   000004AE   0xD1F2             BNE.N    ??CommandInterpret_21
    341          				SerPtr->printf("\n");
   \   000004B0   0xA0B0             ADR.N    R0,??CommandInterpret_19  ;; "\n"
   \   000004B2   0x6829             LDR      R1,[R5, #+0]
   \   000004B4   0x6909             LDR      R1,[R1, #+16]
   \   000004B6   0x4788             BLX      R1
    342           			}
    343          			if(!strcmp((char *)Argv[2], "P"))
   \                     ??CommandInterpret_20:
   \   000004B8   0xA1D1             ADR.N    R1,??CommandInterpret_22  ;; "P"
   \   000004BA   0x68E0             LDR      R0,[R4, #+12]
   \   000004BC   0x.... 0x....      BL       strcmp
   \   000004C0   0xB968             CBNZ.N   R0,??CommandInterpret_23
    344          			{
    345          
    346          				faddr = strtol(Argv[3], NULL, 16);
   \   000004C2   0x2300             MOVS     R3,#+0
   \   000004C4   0x2210             MOVS     R2,#+16
   \   000004C6   0x2100             MOVS     R1,#+0
   \   000004C8   0x6920             LDR      R0,[R4, #+16]
   \   000004CA   0x.... 0x....      BL       __iar_Stolx
    347          //				tmp = sFLASH_CS0_DataReadExt(faddr);
    348          				SerPtr->printf("[%x]\n",tmp);
   \   000004CE   0x4641             MOV      R1,R8
   \   000004D0   0x.... 0x....      ADR.W    R0,`?<Constant "[%x]\\n">`
   \   000004D4   0x.... 0x....      LDR.W    R2,??DataTable112_6
   \   000004D8   0x6812             LDR      R2,[R2, #+0]
   \   000004DA   0x6912             LDR      R2,[R2, #+16]
   \   000004DC   0x4790             BLX      R2
    349          			}
    350          			if(!strcmp((char *)Argv[2], "E9"))
   \                     ??CommandInterpret_23:
   \   000004DE   0xA1C9             ADR.N    R1,??CommandInterpret_22+0x4  ;; 0x45, 0x39, 0x00, 0x00
   \   000004E0   0x68E0             LDR      R0,[R4, #+12]
   \   000004E2   0x.... 0x....      BL       strcmp
   \   000004E6   0xB988             CBNZ.N   R0,??CommandInterpret_24
    351          			{
    352          				tmp = sFLASH_CS0_SetRegister(0xE9,NULL,NULL,0);
   \   000004E8   0x9000             STR      R0,[SP, #+0]
   \   000004EA   0x2300             MOVS     R3,#+0
   \   000004EC   0x2200             MOVS     R2,#+0
   \   000004EE   0x21E9             MOVS     R1,#+233
   \   000004F0   0x.... 0x....      LDR.W    R0,??DataTable114_3
   \   000004F4   0x.... 0x....      BL       sFLASH_SetRegister
   \   000004F8   0xFA5F 0xF880      UXTB     R8,R0
    353          				
    354          				SerPtr->printf("0xE9 tmp[%d]\n",tmp);
   \   000004FC   0x4641             MOV      R1,R8
   \   000004FE   0x.... 0x....      ADR.W    R0,`?<Constant "0xE9 tmp[%d]\\n">`
   \   00000502   0x.... 0x....      LDR.W    R2,??DataTable112_6
   \   00000506   0x6812             LDR      R2,[R2, #+0]
   \   00000508   0x6912             LDR      R2,[R2, #+16]
   \   0000050A   0x4790             BLX      R2
    355          			}
    356          			if(!strcmp((char *)Argv[2], "B7"))
   \                     ??CommandInterpret_24:
   \   0000050C   0xA1E0             ADR.N    R1,??CommandInterpret_25  ;; 0x42, 0x37, 0x00, 0x00
   \   0000050E   0x68E0             LDR      R0,[R4, #+12]
   \   00000510   0x.... 0x....      BL       strcmp
   \   00000514   0xB988             CBNZ.N   R0,??CommandInterpret_26
    357          			{
    358          				tmp = sFLASH_CS0_SetRegister(0xB7,NULL,NULL,0);
   \   00000516   0x9000             STR      R0,[SP, #+0]
   \   00000518   0x2300             MOVS     R3,#+0
   \   0000051A   0x2200             MOVS     R2,#+0
   \   0000051C   0x21B7             MOVS     R1,#+183
   \   0000051E   0x.... 0x....      LDR.W    R0,??DataTable114_3
   \   00000522   0x.... 0x....      BL       sFLASH_SetRegister
   \   00000526   0xFA5F 0xF880      UXTB     R8,R0
    359          				
    360          				SerPtr->printf("0xB7 tmp[%d]\n",tmp);
   \   0000052A   0x4641             MOV      R1,R8
   \   0000052C   0x.... 0x....      ADR.W    R0,`?<Constant "0xB7 tmp[%d]\\n">`
   \   00000530   0x.... 0x....      LDR.W    R2,??DataTable112_6
   \   00000534   0x6812             LDR      R2,[R2, #+0]
   \   00000536   0x6912             LDR      R2,[R2, #+16]
   \   00000538   0x4790             BLX      R2
    361          			}
    362          
    363          
    364          
    365          			if(!strcmp((char *)Argv[2], "E"))
   \                     ??CommandInterpret_26:
   \   0000053A   0xA1D6             ADR.N    R1,??CommandInterpret_25+0x4  ;; "E"
   \   0000053C   0x68E0             LDR      R0,[R4, #+12]
   \   0000053E   0x.... 0x....      BL       strcmp
   \   00000542   0xB968             CBNZ.N   R0,??CommandInterpret_27
    366          			{
    367          
    368          				faddr = strtol(Argv[3], NULL, 16);
   \   00000544   0x2300             MOVS     R3,#+0
   \   00000546   0x2210             MOVS     R2,#+16
   \   00000548   0x2100             MOVS     R1,#+0
   \   0000054A   0x6920             LDR      R0,[R4, #+16]
   \   0000054C   0x.... 0x....      BL       __iar_Stolx
    369          //				tmp = sFLASH_CS0_DataWriteExt(faddr);
    370          				SerPtr->printf("[%x]\n",tmp);
   \   00000550   0x4641             MOV      R1,R8
   \   00000552   0x.... 0x....      ADR.W    R0,`?<Constant "[%x]\\n">`
   \   00000556   0x.... 0x....      LDR.W    R2,??DataTable112_6
   \   0000055A   0x6812             LDR      R2,[R2, #+0]
   \   0000055C   0x6912             LDR      R2,[R2, #+16]
   \   0000055E   0x4790             BLX      R2
    371          			}
    372          			if(!strcmp((char *)Argv[2], "S"))
   \                     ??CommandInterpret_27:
   \   00000560   0xA1DC             ADR.N    R1,??CommandInterpret_28  ;; "S"
   \   00000562   0x68E0             LDR      R0,[R4, #+12]
   \   00000564   0x.... 0x....      BL       strcmp
   \   00000568   0xB978             CBNZ.N   R0,??CommandInterpret_29
    373          			{
    374          				INT8U tmp1[20];
    375          				tmp = sFLASH_CS0_SetRegister(READ_EXT,NULL,tmp1,0);
   \   0000056A   0x9000             STR      R0,[SP, #+0]
   \   0000056C   0xAB01             ADD      R3,SP,#+4
   \   0000056E   0x2200             MOVS     R2,#+0
   \   00000570   0x21C8             MOVS     R1,#+200
   \   00000572   0x.... 0x....      LDR.W    R0,??DataTable114_3
   \   00000576   0x.... 0x....      BL       sFLASH_SetRegister
    376          				SerPtr->printf("tmp[%d]\n",tmp);
   \   0000057A   0xB2C1             UXTB     R1,R0
   \   0000057C   0x.... 0x....      ADR.W    R0,`?<Constant "tmp[%d]\\n">`
   \   00000580   0x.... 0x....      LDR.W    R2,??DataTable112_6
   \   00000584   0x6812             LDR      R2,[R2, #+0]
   \   00000586   0x6912             LDR      R2,[R2, #+16]
   \   00000588   0x4790             BLX      R2
    377          			}
    378          			if(!strcmp((char *)Argv[2], "D"))
   \                     ??CommandInterpret_29:
   \   0000058A   0xA1D3             ADR.N    R1,??CommandInterpret_28+0x4  ;; "D"
   \   0000058C   0x68E0             LDR      R0,[R4, #+12]
   \   0000058E   0x.... 0x....      BL       strcmp
   \   00000592   0xBB00             CBNZ.N   R0,??CommandInterpret_30
    379          			{
    380          				INT8U tmp1[20];
    381          
    382          //				tmp = sFLASH_CS0_SetRegister(RDID,NULL,tmp1,20);
    383          
    384          //				tmp = sFLASH_CS0_SetRegister(WRITE_EXT,NULL,tmp1,0);
    385          //				tmp = sFLASH_CS0_SetRegister(READFlagSTS,NULL,tmp1,1);
    386          				tmp = sFLASH_CS0_SetRegister(READNVCR,NULL,tmp1,2);
   \   00000594   0x2002             MOVS     R0,#+2
   \   00000596   0x9000             STR      R0,[SP, #+0]
   \   00000598   0xAB01             ADD      R3,SP,#+4
   \   0000059A   0x2200             MOVS     R2,#+0
   \   0000059C   0x21B5             MOVS     R1,#+181
   \   0000059E   0x.... 0x....      LDR.W    R0,??DataTable114_3
   \   000005A2   0x.... 0x....      BL       sFLASH_SetRegister
    387          
    388          //				SerPtr->printf("tmp[%d]\n",tmp);
    389          
    390          				#if 1
    391          				SerPtr->printf("tmp[%d]>>",tmp);
   \   000005A6   0x.... 0x....      LDR.W    R5,??DataTable112_6
   \   000005AA   0xB2C1             UXTB     R1,R0
   \   000005AC   0x.... 0x....      ADR.W    R0,`?<Constant "tmp[%d]>>">`
   \   000005B0   0x682A             LDR      R2,[R5, #+0]
   \   000005B2   0x6912             LDR      R2,[R2, #+16]
   \   000005B4   0x4790             BLX      R2
    392          				for(i = 0; i < 2; i++)
   \   000005B6   0xAE01             ADD      R6,SP,#+4
   \   000005B8   0x2702             MOVS     R7,#+2
   \   000005BA   0x.... 0x....      ADR.W    R9,`?<Constant "[%x]">`
    393          				{
    394          					SerPtr->printf("[%x]",tmp1[i]);
   \                     ??CommandInterpret_31:
   \   000005BE   0xF816 0x1B01      LDRB     R1,[R6], #+1
   \   000005C2   0x4648             MOV      R0,R9
   \   000005C4   0x682A             LDR      R2,[R5, #+0]
   \   000005C6   0x6912             LDR      R2,[R2, #+16]
   \   000005C8   0x4790             BLX      R2
    395          
    396          				}
   \   000005CA   0x1E7F             SUBS     R7,R7,#+1
   \   000005CC   0xD1F7             BNE.N    ??CommandInterpret_31
    397          
    398          				SerPtr->printf("\n");
   \   000005CE   0xA069             ADR.N    R0,??CommandInterpret_19  ;; "\n"
   \   000005D0   0x6829             LDR      R1,[R5, #+0]
   \   000005D2   0x6909             LDR      R1,[R1, #+16]
   \   000005D4   0x4788             BLX      R1
    399          				#endif
    400          			}
    401          
    402          			if(!strcmp((char *)Argv[2], "F"))
   \                     ??CommandInterpret_30:
   \   000005D6   0xA1C1             ADR.N    R1,??CommandInterpret_28+0x8  ;; "F"
   \   000005D8   0x68E0             LDR      R0,[R4, #+12]
   \   000005DA   0x.... 0x....      BL       strcmp
   \   000005DE   0xBB30             CBNZ.N   R0,??CommandInterpret_32
    403          			{
    404          				INT8U tmp1[20];
    405          
    406          //				tmp = sFLASH_CS0_SetRegister(RDID,NULL,tmp1,20);
    407          
    408          //				tmp = sFLASH_CS0_SetRegister(WRITE_EXT,NULL,tmp1,0);
    409          //				tmp = sFLASH_CS0_SetRegister(READFlagSTS,NULL,tmp1,1);
    410          				tmp1[0] = 0xff;
   \   000005E0   0x20FF             MOVS     R0,#+255
   \   000005E2   0xF88D 0x0004      STRB     R0,[SP, #+4]
    411          				tmp1[1] = 0xfD;
   \   000005E6   0x20FD             MOVS     R0,#+253
   \   000005E8   0xF88D 0x0005      STRB     R0,[SP, #+5]
    412          
    413          				tmp = sFLASH_CS0_SetRegister(WRITENVCR,NULL,tmp1,2);
   \   000005EC   0x2002             MOVS     R0,#+2
   \   000005EE   0x9000             STR      R0,[SP, #+0]
   \   000005F0   0xAB01             ADD      R3,SP,#+4
   \   000005F2   0x2200             MOVS     R2,#+0
   \   000005F4   0x21B1             MOVS     R1,#+177
   \   000005F6   0x.... 0x....      LDR.W    R0,??DataTable114_3
   \   000005FA   0x.... 0x....      BL       sFLASH_SetRegister
    414          
    415          //				SerPtr->printf("tmp[%d]\n",tmp);
    416          
    417          				#if 1
    418          				SerPtr->printf("tmp[%d]>>",tmp);
   \   000005FE   0x.... 0x....      LDR.W    R5,??DataTable112_6
   \   00000602   0xB2C1             UXTB     R1,R0
   \   00000604   0x.... 0x....      ADR.W    R0,`?<Constant "tmp[%d]>>">`
   \   00000608   0x682A             LDR      R2,[R5, #+0]
   \   0000060A   0x6912             LDR      R2,[R2, #+16]
   \   0000060C   0x4790             BLX      R2
    419          				for(i = 0; i < 2; i++)
   \   0000060E   0xAE01             ADD      R6,SP,#+4
   \   00000610   0x2702             MOVS     R7,#+2
   \   00000612   0x.... 0x....      ADR.W    R9,`?<Constant "[%x]">`
    420          				{
    421          					SerPtr->printf("[%x]",tmp1[i]);
   \                     ??CommandInterpret_33:
   \   00000616   0xF816 0x1B01      LDRB     R1,[R6], #+1
   \   0000061A   0x4648             MOV      R0,R9
   \   0000061C   0x682A             LDR      R2,[R5, #+0]
   \   0000061E   0x6912             LDR      R2,[R2, #+16]
   \   00000620   0x4790             BLX      R2
    422          
    423          				}
   \   00000622   0x1E7F             SUBS     R7,R7,#+1
   \   00000624   0xD1F7             BNE.N    ??CommandInterpret_33
    424          
    425          				SerPtr->printf("\n");
   \   00000626   0xA053             ADR.N    R0,??CommandInterpret_19  ;; "\n"
   \   00000628   0x6829             LDR      R1,[R5, #+0]
   \   0000062A   0x6909             LDR      R1,[R1, #+16]
   \   0000062C   0x4788             BLX      R1
    426          				#endif
    427          			}
    428          
    429          		
    430          			if(!strcmp((char *)Argv[2], "70"))
   \                     ??CommandInterpret_32:
   \   0000062E   0xA1CD             ADR.N    R1,??CommandInterpret_34  ;; 0x37, 0x30, 0x00, 0x00
   \   00000630   0xE002             B.N      ??CommandInterpret_35
   \   00000632   0xBF00             Nop      
   \                     ??CommandInterpret_10:
   \   00000634   0x52 0x00          DC8      "R",0x0,0x0
   \              0x00 0x00    
   \                     ??CommandInterpret_35:
   \   00000638   0x68E0             LDR      R0,[R4, #+12]
   \   0000063A   0x.... 0x....      BL       strcmp
   \   0000063E   0x2800             CMP      R0,#+0
   \   00000640   0xF040 0x8215      BNE.W    ??CommandInterpret_0
    431          			{
    432          				INT8U tmp1[20];
    433          
    434          				tmp = sFLASH_CS0_SetRegister(0x70,NULL,tmp1,1);
   \   00000644   0x2001             MOVS     R0,#+1
   \   00000646   0x9000             STR      R0,[SP, #+0]
   \   00000648   0xAB01             ADD      R3,SP,#+4
   \   0000064A   0x2200             MOVS     R2,#+0
   \   0000064C   0x2170             MOVS     R1,#+112
   \   0000064E   0x.... 0x....      LDR.W    R0,??DataTable114_3
   \   00000652   0x.... 0x....      BL       sFLASH_SetRegister
    435          
    436          				SerPtr->printf("70 tmp[%d]>>",tmp);
   \   00000656   0x.... 0x....      LDR.W    R5,??DataTable112_6
   \   0000065A   0xB2C1             UXTB     R1,R0
   \   0000065C   0x.... 0x....      ADR.W    R0,`?<Constant "70 tmp[%d]>>">`
   \   00000660   0x682A             LDR      R2,[R5, #+0]
   \   00000662   0x6912             LDR      R2,[R2, #+16]
   \   00000664   0x4790             BLX      R2
    437          				for(i = 0; i < 1; i++)
    438          				{
    439          					SerPtr->printf("[%x]",tmp1[i]);
   \   00000666   0xF89D 0x1004      LDRB     R1,[SP, #+4]
   \   0000066A   0x.... 0x....      ADR.W    R0,`?<Constant "[%x]">`
   \   0000066E   0x682A             LDR      R2,[R5, #+0]
   \   00000670   0x6912             LDR      R2,[R2, #+16]
   \   00000672   0x4790             BLX      R2
    440          				}
   \   00000674   0xE1EF             B.N      ??CommandInterpret_36
    441          
    442          				SerPtr->printf("\n");
    443          			}	
    444          		}
    445          		else if(!strcmp((char *)Argv[1], "1"))
   \                     ??CommandInterpret_16:
   \   00000676   0xA1BC             ADR.N    R1,??CommandInterpret_34+0x4  ;; "1"
   \   00000678   0x4628             MOV      R0,R5
   \   0000067A   0x.... 0x....      BL       strcmp
   \   0000067E   0x2800             CMP      R0,#+0
   \   00000680   0xF040 0x81F5      BNE.W    ??CommandInterpret_0
    446          		{
    447          			if(!strcmp((char *)Argv[2], "W"))
   \   00000684   0xA122             ADR.N    R1,??CommandInterpret_15+0x4  ;; "W"
   \   00000686   0x68E0             LDR      R0,[R4, #+12]
   \   00000688   0x.... 0x....      BL       strcmp
   \   0000068C   0xBB98             CBNZ.N   R0,??CommandInterpret_37
    448          			{
    449          #define DUMPSIZE1	16			
    450          				INT8U tmpData[DUMPSIZE1];
    451          
    452          				faddr = strtol(Argv[3], NULL, 16);
   \   0000068E   0x2300             MOVS     R3,#+0
   \   00000690   0x2210             MOVS     R2,#+16
   \   00000692   0x2100             MOVS     R1,#+0
   \   00000694   0x6920             LDR      R0,[R4, #+16]
   \   00000696   0x.... 0x....      BL       __iar_Stolx
   \   0000069A   0x4605             MOV      R5,R0
    453          				data = strtol(Argv[4], NULL, 16);
   \   0000069C   0x2300             MOVS     R3,#+0
   \   0000069E   0x2210             MOVS     R2,#+16
   \   000006A0   0x4619             MOV      R1,R3
   \   000006A2   0x6960             LDR      R0,[R4, #+20]
   \   000006A4   0x.... 0x....      BL       __iar_Stolx
    454          
    455          				for(i = 0; i < DUMPSIZE1; i++)
    456          				{
    457          					tmpData[i] = data;
   \   000006A8   0x4602             MOV      R2,R0
   \   000006AA   0x2110             MOVS     R1,#+16
   \   000006AC   0xA800             ADD      R0,SP,#+0
   \   000006AE   0x.... 0x....      BL       __aeabi_memset4
    458          				}
    459          				
    460          				sFLASH_CS1_BL4kCheckErase(sFLASH_APPLAddr+faddr, DUMPSIZE1);
   \   000006B2   0x.... 0x....      LDR.W    R6,??DataTable118_2
   \   000006B6   0x2210             MOVS     R2,#+16
   \   000006B8   0x4629             MOV      R1,R5
   \   000006BA   0x4630             MOV      R0,R6
   \   000006BC   0x.... 0x....      BL       sFLASH_BL4kCheckErase
    461          				sFLASH_CS1_DataWrite(sFLASH_APPLAddr, tmpData, DUMPSIZE1);
   \   000006C0   0x2310             MOVS     R3,#+16
   \   000006C2   0xAA00             ADD      R2,SP,#+0
   \   000006C4   0x2100             MOVS     R1,#+0
   \   000006C6   0x4630             MOV      R0,R6
   \   000006C8   0x.... 0x....      BL       sFLASH_DataWrite
    462          				for(i = 0; i < DUMPSIZE1; i++)
   \   000006CC   0x2700             MOVS     R7,#+0
   \   000006CE   0x.... 0x....      ADR.W    R9,`?<Constant "[%x]">`
   \   000006D2   0x.... 0x....      LDR.W    R5,??DataTable112_6
    463          				{
    464          					tmp = sFLASH_CS1_DataRead(sFLASH_APPLAddr + i);
   \                     ??CommandInterpret_38:
   \   000006D6   0x4639             MOV      R1,R7
   \   000006D8   0x4630             MOV      R0,R6
   \   000006DA   0x.... 0x....      BL       sFLASH_DataRead
   \   000006DE   0x4601             MOV      R1,R0
    465          					SerPtr->printf("[%x]",tmp);
   \   000006E0   0x4648             MOV      R0,R9
   \   000006E2   0x682A             LDR      R2,[R5, #+0]
   \   000006E4   0x6912             LDR      R2,[R2, #+16]
   \   000006E6   0x4790             BLX      R2
    466          				}
   \   000006E8   0x1C7F             ADDS     R7,R7,#+1
   \   000006EA   0x2F10             CMP      R7,#+16
   \   000006EC   0xD3F3             BCC.N    ??CommandInterpret_38
    467          				
    468          				SerPtr->printf("\n");
   \   000006EE   0xA021             ADR.N    R0,??CommandInterpret_19  ;; "\n"
   \   000006F0   0x6829             LDR      R1,[R5, #+0]
   \   000006F2   0x6909             LDR      R1,[R1, #+16]
   \   000006F4   0x4788             BLX      R1
    469           
    470          			}
    471          			if(!strcmp((char *)Argv[2], "R"))
   \                     ??CommandInterpret_37:
   \   000006F6   0xA19D             ADR.N    R1,??CommandInterpret_34+0x8  ;; "R"
   \   000006F8   0x68E0             LDR      R0,[R4, #+12]
   \   000006FA   0x.... 0x....      BL       strcmp
   \   000006FE   0x2800             CMP      R0,#+0
   \   00000700   0xF040 0x81B5      BNE.W    ??CommandInterpret_0
    472          			{
    473          				INT32U i = 0;
    474          				INT8U tmp;
    475          				_DTU_SEL0 = SET;
   \   00000704   0x.... 0x....      LDR.W    R0,??DataTable118_3  ;; 0x40020414
   \   00000708   0xE004             B.N      ??CommandInterpret_39
   \   0000070A   0xBF00             Nop      
   \                     ??CommandInterpret_15:
   \   0000070C   0x30 0x00          DC8      "0",0x0,0x0
   \              0x00 0x00    
   \   00000710   0x57 0x00          DC8      "W",0x0,0x0
   \              0x00 0x00    
   \                     ??CommandInterpret_39:
   \   00000714   0x6801             LDR      R1,[R0, #+0]
   \   00000716   0xF041 0x0110      ORR      R1,R1,#0x10
   \   0000071A   0x6001             STR      R1,[R0, #+0]
    476          #define DUMPSIZE	16			
    477          				faddr = strtol(Argv[3], NULL, 16);
   \   0000071C   0x2300             MOVS     R3,#+0
   \   0000071E   0x2210             MOVS     R2,#+16
   \   00000720   0x2100             MOVS     R1,#+0
   \   00000722   0x6920             LDR      R0,[R4, #+16]
   \   00000724   0x.... 0x....      BL       __iar_Stolx
   \   00000728   0x4607             MOV      R7,R0
    478          				data = strtol(Argv[4], NULL, 16);
   \   0000072A   0x2300             MOVS     R3,#+0
   \   0000072C   0x2210             MOVS     R2,#+16
   \   0000072E   0x4619             MOV      R1,R3
   \   00000730   0x6960             LDR      R0,[R4, #+20]
   \   00000732   0x.... 0x....      BL       __iar_Stolx
    479          
    480          				for(i = 0; i < DUMPSIZE; i++)
   \   00000736   0x2410             MOVS     R4,#+16
   \   00000738   0x.... 0x....      LDR.W    R6,??DataTable118_2
   \   0000073C   0x.... 0x....      ADR.W    R9,`?<Constant "[%x]">`
   \   00000740   0x....             LDR.N    R5,??DataTable112_6
    481          				{
    482          					tmp = sFLASH_CS1_DataRead(sFLASH_APPLAddr + faddr +i);
   \                     ??CommandInterpret_40:
   \   00000742   0x4639             MOV      R1,R7
   \   00000744   0x4630             MOV      R0,R6
   \   00000746   0x.... 0x....      BL       sFLASH_DataRead
    483          					SerPtr->printf("[%x]",tmp);
   \   0000074A   0x4601             MOV      R1,R0
   \   0000074C   0x4648             MOV      R0,R9
   \   0000074E   0x682A             LDR      R2,[R5, #+0]
   \   00000750   0x6912             LDR      R2,[R2, #+16]
   \   00000752   0x4790             BLX      R2
    484          				}
   \   00000754   0x1C7F             ADDS     R7,R7,#+1
   \   00000756   0x1E64             SUBS     R4,R4,#+1
   \   00000758   0xD1F3             BNE.N    ??CommandInterpret_40
   \   0000075A   0xE17C             B.N      ??CommandInterpret_36
    485          				SerPtr->printf("\n");
    486          			}
    487          		}
    488          
    489          
    490          	}
    491          	
    492          	else if(!strcmp((char *)Argv[0], "TEST"))
   \                     ??CommandInterpret_14:
   \   0000075C   0x.... 0x....      ADR.W    R1,`?<Constant "TEST">`
   \   00000760   0x4628             MOV      R0,R5
   \   00000762   0x.... 0x....      BL       strcmp
   \   00000766   0x2800             CMP      R0,#+0
   \   00000768   0xF040 0x817A      BNE.W    ??CommandInterpret_41
    493          	{
    494          //		SerPtr->printf("0 TEST[%s]\n",Argv[0]);
    495          //////////////////
    496          		INT8U tdata = TRUE;
    497          //0x1FFF 7A22
    498          //		SerPtr->printf("Flash Size[%x][%x]\n", READ_REG(0x1FFF7A22),READ_REG(0x1FFF7A22));
    499          
    500          #ifdef	Board_Test
    501          
    502          		if(!strcmp((char *)Argv[1], "A"))
   \   0000076C   0x68A5             LDR      R5,[R4, #+8]
   \   0000076E   0x....             ADR.N    R1,??DataTable112  ;; "A"
   \   00000770   0xE002             B.N      ??CommandInterpret_42
   \   00000772   0xBF00             Nop      
   \                     ??CommandInterpret_19:
   \   00000774   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    
   \                     ??CommandInterpret_42:
   \   00000778   0x4628             MOV      R0,R5
   \   0000077A   0x.... 0x....      BL       strcmp
   \   0000077E   0x2800             CMP      R0,#+0
   \   00000780   0xD13B             BNE.N    ??CommandInterpret_43
    503          		{
    504          			char *tstmsg = "ADC Input";
    505          
    506          			if(SavetoTestBackup(ADCTest, SET, NULL) == SET)
    507          			{
    508          				tdata = returnmsgTest(tstmsg);
    509          			}
    510          			if(tdata)
    511          			{
    512          				INT16U nCnt;
    513          
    514          				SerPtr->printf("\n* [%s] TEST START TimeOut 5 Min]\n", tstmsg);
   \   00000782   0x.... 0x....      ADR.W    R6,`?<Constant "ADC Input">`
   \   00000786   0x....             LDR.N    R5,??DataTable112_6
   \   00000788   0x4631             MOV      R1,R6
   \   0000078A   0x.... 0x....      ADR.W    R0,`?<Constant "\\n* [%s] TEST START Ti...">`
   \   0000078E   0x682A             LDR      R2,[R5, #+0]
   \   00000790   0x6912             LDR      R2,[R2, #+16]
   \   00000792   0x4790             BLX      R2
    515          
    516          				TimerRegist(TimerTest, Time1Sec*60L*5L);
   \   00000794   0x.... 0x....      LDR.W    R1,??DataTable118_4  ;; 0x493e0
   \   00000798   0x2003             MOVS     R0,#+3
   \   0000079A   0x.... 0x....      BL       TimerRegist
   \   0000079E   0xE003             B.N      ??CommandInterpret_44
    517          
    518          				while(1)
    519          				{
    520          					AdInputStatus();
    521          
    522          
    523          					if(TimeOverCheck(TimerTest))
    524          					{
    525          						SerPtr->printf("%s Test TimeOut\n", tstmsg);
    526          
    527          						TimerRegist(TimerTest, Time1Sec);
    528          						break;
    529          					}
    530          					if(SerPtr->CheckByte(1, &nCnt))
    531          					{
    532          						nCnt = SerPtr->RxGetByte();
    533          						if(nCnt == 'c' || nCnt == 'C')
    534          						{
    535          							SerPtr->printf("%s Test Canceled\n", tstmsg);
    536          							break;
    537          						}
    538          						else if(nCnt == 'f' || nCnt == 'F')
    539          						{
    540          //							gOK:
    541          							SerPtr->printf("%s Test Finished\n", tstmsg);
    542          							SavetoTestBackup(ADCTest, SET, SET);
    543          							break;
    544          						}
    545          					}
    546          					OSTimeDly(2000L);
   \                     ??CommandInterpret_45:
   \   000007A0   0xF44F 0x60FA      MOV      R0,#+2000
   \   000007A4   0x.... 0x....      BL       OSTimeDly
   \                     ??CommandInterpret_44:
   \   000007A8   0x.... 0x....      BL       AdInputStatus
   \   000007AC   0x2003             MOVS     R0,#+3
   \   000007AE   0x.... 0x....      BL       TimeOverCheck
   \   000007B2   0xB118             CBZ.N    R0,??CommandInterpret_46
   \   000007B4   0x4631             MOV      R1,R6
   \   000007B6   0x.... 0x....      ADR.W    R0,`?<Constant "%s Test TimeOut\\n">`
   \   000007BA   0xE0E6             B.N      ??CommandInterpret_47
   \                     ??CommandInterpret_46:
   \   000007BC   0xA900             ADD      R1,SP,#+0
   \   000007BE   0x2001             MOVS     R0,#+1
   \   000007C0   0x682A             LDR      R2,[R5, #+0]
   \   000007C2   0x6852             LDR      R2,[R2, #+4]
   \   000007C4   0x4790             BLX      R2
   \   000007C6   0x2800             CMP      R0,#+0
   \   000007C8   0xD0EA             BEQ.N    ??CommandInterpret_45
   \   000007CA   0x6828             LDR      R0,[R5, #+0]
   \   000007CC   0x6880             LDR      R0,[R0, #+8]
   \   000007CE   0x4780             BLX      R0
   \   000007D0   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   000007D4   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000007D8   0x2863             CMP      R0,#+99
   \   000007DA   0xBF18             IT       NE 
   \   000007DC   0x2843             CMPNE    R0,#+67
   \   000007DE   0xBF04             ITT      EQ 
   \   000007E0   0x4631             MOVEQ    R1,R6
   \   000007E2   0x.... 0x....      ADREQ.W  R0,`?<Constant "%s Test Canceled\\n">`
   \   000007E6   0xF000 0x80F6      BEQ.W    ??CommandInterpret_48
   \   000007EA   0x2866             CMP      R0,#+102
   \   000007EC   0xBF18             IT       NE 
   \   000007EE   0x2846             CMPNE    R0,#+70
   \   000007F0   0xD1D6             BNE.N    ??CommandInterpret_45
   \   000007F2   0x4631             MOV      R1,R6
   \   000007F4   0x.... 0x....      ADR.W    R0,`?<Constant "%s Test Finished\\n">`
   \   000007F8   0xE0ED             B.N      ??CommandInterpret_48
    547          					/////////////////////////////////////////////////////////////
    548          				}
    549          			}
    550          		}
    551          		else if(!strcmp((char *)Argv[1], "O"))
   \                     ??CommandInterpret_43:
   \   000007FA   0x....             ADR.N    R1,??DataTable112_1  ;; "O"
   \   000007FC   0xE004             B.N      ??CommandInterpret_49
   \   000007FE   0xBF00             Nop      
   \                     ??CommandInterpret_22:
   \   00000800   0x50 0x00          DC8      "P",0x0,0x0
   \              0x00 0x00    
   \   00000804   0x45 0x39          DC8      0x45, 0x39, 0x00, 0x00
   \              0x00 0x00    
   \                     ??CommandInterpret_49:
   \   00000808   0x4628             MOV      R0,R5
   \   0000080A   0x.... 0x....      BL       strcmp
   \   0000080E   0x2800             CMP      R0,#+0
   \   00000810   0xD13C             BNE.N    ??CommandInterpret_50
    552          		{
    553          			char *tstmsg = "Dig Output";
    554          			
    555          			if(SavetoTestBackup(OutputTest, SET, NULL) == SET)
    556          			{
    557          				tdata = returnmsgTest(tstmsg);
    558          			}
    559          			
    560          			if(tdata)
    561          			{
    562          				INT32U nFlag = 0;
   \   00000812   0x9001             STR      R0,[SP, #+4]
    563          				INT16U nCnt;
    564          
    565          				SerPtr->printf("\n* [%s TEST START TimeOut 5Min]\n", tstmsg);
   \   00000814   0x.... 0x....      ADR.W    R6,`?<Constant "Dig Output">`
   \   00000818   0x....             LDR.N    R5,??DataTable112_6
   \   0000081A   0x4631             MOV      R1,R6
   \   0000081C   0x.... 0x....      ADR.W    R0,`?<Constant "\\n* [%s TEST START Tim...">`
   \   00000820   0x682A             LDR      R2,[R5, #+0]
   \   00000822   0x6912             LDR      R2,[R2, #+16]
   \   00000824   0x4790             BLX      R2
    566          
    567          				TimerRegist(TimerTest, Time1Sec*60L*5L);
   \   00000826   0x.... 0x....      LDR.W    R1,??DataTable118_4  ;; 0x493e0
   \   0000082A   0x2003             MOVS     R0,#+3
   \   0000082C   0x.... 0x....      BL       TimerRegist
   \   00000830   0xE002             B.N      ??CommandInterpret_51
    568          
    569          				while(1)
    570          				{
    571          					HwTestOutFunc(&nFlag);
    572          
    573          					if(TimeOverCheck(TimerTest))
    574          					{
    575          						SerPtr->printf("%s test TimeOut\n", tstmsg);
    576          						TimerRegist(TimerTest, Time1Sec);
    577          						break;
    578          					}
    579          					if(SerPtr->CheckByte(1, &nCnt))
    580          					{
    581          						nCnt = SerPtr->RxGetByte();
    582          						if(nCnt == 'C' || nCnt == 'c')
    583          						{
    584          							SerPtr->printf("%s test Canceled\n", tstmsg);
    585          							break;
    586          						}
    587          						else if(nCnt == 'F' || nCnt == 'f')
    588          						{
    589          							SerPtr->printf("%s test Finished\n", tstmsg);
    590          							SavetoTestBackup(OutputTest, SET, SET);
    591          							break;
    592          						}
    593          					}
    594          					OSTimeDly(250L*1L);
   \                     ??CommandInterpret_52:
   \   00000832   0x20FA             MOVS     R0,#+250
   \   00000834   0x.... 0x....      BL       OSTimeDly
   \                     ??CommandInterpret_51:
   \   00000838   0xA801             ADD      R0,SP,#+4
   \   0000083A   0x.... 0x....      BL       HwTestOutFunc
   \   0000083E   0x2003             MOVS     R0,#+3
   \   00000840   0x.... 0x....      BL       TimeOverCheck
   \   00000844   0xB118             CBZ.N    R0,??CommandInterpret_53
   \   00000846   0x4631             MOV      R1,R6
   \   00000848   0x.... 0x....      ADR.W    R0,`?<Constant "%s test TimeOut\\n">`
   \   0000084C   0xE09D             B.N      ??CommandInterpret_47
   \                     ??CommandInterpret_53:
   \   0000084E   0xA900             ADD      R1,SP,#+0
   \   00000850   0x2001             MOVS     R0,#+1
   \   00000852   0x682A             LDR      R2,[R5, #+0]
   \   00000854   0x6852             LDR      R2,[R2, #+4]
   \   00000856   0x4790             BLX      R2
   \   00000858   0x2800             CMP      R0,#+0
   \   0000085A   0xD0EA             BEQ.N    ??CommandInterpret_52
   \   0000085C   0x6828             LDR      R0,[R5, #+0]
   \   0000085E   0x6880             LDR      R0,[R0, #+8]
   \   00000860   0x4780             BLX      R0
   \   00000862   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000866   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000086A   0x2843             CMP      R0,#+67
   \   0000086C   0xBF18             IT       NE 
   \   0000086E   0x2863             CMPNE    R0,#+99
   \   00000870   0xBF04             ITT      EQ 
   \   00000872   0x4631             MOVEQ    R1,R6
   \   00000874   0x.... 0x....      ADREQ.W  R0,`?<Constant "%s test Canceled\\n">`
   \   00000878   0xF000 0x80AD      BEQ.W    ??CommandInterpret_48
   \   0000087C   0x2846             CMP      R0,#+70
   \   0000087E   0xBF18             IT       NE 
   \   00000880   0x2866             CMPNE    R0,#+102
   \   00000882   0xD1D6             BNE.N    ??CommandInterpret_52
   \   00000884   0x4631             MOV      R1,R6
   \   00000886   0x.... 0x....      ADR.W    R0,`?<Constant "%s test Finished\\n">`
   \   0000088A   0xE0A4             B.N      ??CommandInterpret_48
    595          				}
    596          			}
    597          		}
    598          		else if(!strcmp((char *)Argv[1], "I"))
   \                     ??CommandInterpret_50:
   \   0000088C   0x....             ADR.N    R1,??DataTable112_2  ;; "I"
   \   0000088E   0xE003             B.N      ??CommandInterpret_54
   \                     ??CommandInterpret_25:
   \   00000890   0x42 0x37          DC8      0x42, 0x37, 0x00, 0x00
   \              0x00 0x00    
   \   00000894   0x45 0x00          DC8      "E",0x0,0x0
   \              0x00 0x00    
   \                     ??CommandInterpret_54:
   \   00000898   0x4628             MOV      R0,R5
   \   0000089A   0x.... 0x....      BL       strcmp
   \   0000089E   0x2800             CMP      R0,#+0
   \   000008A0   0xD14B             BNE.N    ??CommandInterpret_55
    599          		{
    600          			char *tstmsg = "Dig Input";
    601          
    602          			if(SavetoTestBackup(InputTest, SET, NULL) == SET)
    603          			{
    604          				tdata = returnmsgTest(tstmsg);
    605          			}
    606          			if(tdata)
    607          			{
    608          				INT16U nCnt;
    609          
    610          				SerPtr->printf("\n* [%s TEST START TimeOut 5 Min]\n", tstmsg);
   \   000008A2   0x.... 0x....      ADR.W    R6,`?<Constant "Dig Input">`
   \   000008A6   0x....             LDR.N    R5,??DataTable112_6
   \   000008A8   0x4631             MOV      R1,R6
   \   000008AA   0x.... 0x....      ADR.W    R0,`?<Constant "\\n* [%s TEST START Tim...">_1`
   \   000008AE   0x682A             LDR      R2,[R5, #+0]
   \   000008B0   0x6912             LDR      R2,[R2, #+16]
   \   000008B2   0x4790             BLX      R2
    611          				TimerRegist(TimerTest, Time1Sec*60L*1L);
   \   000008B4   0xF64E 0x2160      MOVW     R1,#+60000
   \   000008B8   0x2003             MOVS     R0,#+3
   \   000008BA   0x.... 0x....      BL       TimerRegist
    612          
    613          				CurrentInputStatus(0);
   \   000008BE   0x2000             MOVS     R0,#+0
   \   000008C0   0x.... 0x....      BL       CurrentInputStatus
    614          				tinputStsOld = tinputSts;
   \   000008C4   0x.... 0x....      LDR.W    R0,??DataTable119_2
   \   000008C8   0x.... 0x....      LDR.W    R1,??DataTable119_3
   \   000008CC   0x2234             MOVS     R2,#+52
   \   000008CE   0x.... 0x....      BL       __aeabi_memcpy4
   \   000008D2   0xE009             B.N      ??CommandInterpret_56
   \                     ??CommandInterpret_28:
   \   000008D4   0x53 0x00          DC8      "S",0x0,0x0
   \              0x00 0x00    
   \   000008D8   0x44 0x00          DC8      "D",0x0,0x0
   \              0x00 0x00    
   \   000008DC   0x46 0x00          DC8      "F",0x0,0x0
   \              0x00 0x00    
    615          
    616          				while(1)
    617          				{
    618          					CurrentInputStatus(1);
    619          
    620          					if(TimeOverCheck(TimerTest))
    621          					{
    622          						SerPtr->printf("%s Test TimeOut\n", tstmsg);
    623          						TimerRegist(TimerTest, Time1Sec);
    624          						break;
    625          					}
    626          					if(SerPtr->CheckByte(1, &nCnt))
    627          					{
    628          						nCnt = SerPtr->RxGetByte();
    629          						if(nCnt == 'c' || nCnt == 'C')
    630          						{
    631          							SerPtr->printf("%s Test Canceled\n", tstmsg);
    632          							break;
    633          						}
    634          						else if(nCnt == 'f' || nCnt == 'F')
    635          						{
    636          							SerPtr->printf("%s Test Finished\n", tstmsg);
    637          							SavetoTestBackup(InputTest, SET, SET);
    638          							break;
    639          						}
    640          					}
    641          					OSTimeDly(300L);
   \                     ??CommandInterpret_57:
   \   000008E0   0xF44F 0x7096      MOV      R0,#+300
   \   000008E4   0x.... 0x....      BL       OSTimeDly
   \                     ??CommandInterpret_56:
   \   000008E8   0x2001             MOVS     R0,#+1
   \   000008EA   0x.... 0x....      BL       CurrentInputStatus
   \   000008EE   0x2003             MOVS     R0,#+3
   \   000008F0   0x.... 0x....      BL       TimeOverCheck
   \   000008F4   0xB118             CBZ.N    R0,??CommandInterpret_58
   \   000008F6   0x4631             MOV      R1,R6
   \   000008F8   0x.... 0x....      ADR.W    R0,`?<Constant "%s Test TimeOut\\n">`
   \   000008FC   0xE045             B.N      ??CommandInterpret_47
   \                     ??CommandInterpret_58:
   \   000008FE   0xA900             ADD      R1,SP,#+0
   \   00000900   0x2001             MOVS     R0,#+1
   \   00000902   0x682A             LDR      R2,[R5, #+0]
   \   00000904   0x6852             LDR      R2,[R2, #+4]
   \   00000906   0x4790             BLX      R2
   \   00000908   0x2800             CMP      R0,#+0
   \   0000090A   0xD0E9             BEQ.N    ??CommandInterpret_57
   \   0000090C   0x6828             LDR      R0,[R5, #+0]
   \   0000090E   0x6880             LDR      R0,[R0, #+8]
   \   00000910   0x4780             BLX      R0
   \   00000912   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000916   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000091A   0x2863             CMP      R0,#+99
   \   0000091C   0xBF18             IT       NE 
   \   0000091E   0x2843             CMPNE    R0,#+67
   \   00000920   0xBF04             ITT      EQ 
   \   00000922   0x4631             MOVEQ    R1,R6
   \   00000924   0x.... 0x....      ADREQ.W  R0,`?<Constant "%s Test Canceled\\n">`
   \   00000928   0xD055             BEQ.N    ??CommandInterpret_48
   \   0000092A   0x2866             CMP      R0,#+102
   \   0000092C   0xBF18             IT       NE 
   \   0000092E   0x2846             CMPNE    R0,#+70
   \   00000930   0xD1D6             BNE.N    ??CommandInterpret_57
   \   00000932   0x4631             MOV      R1,R6
   \   00000934   0x.... 0x....      ADR.W    R0,`?<Constant "%s Test Finished\\n">`
   \   00000938   0xE04D             B.N      ??CommandInterpret_48
    642          				}
    643          			}
    644          		}
    645          		else if(!strcmp((char *)Argv[1], "C"))
   \                     ??CommandInterpret_55:
   \   0000093A   0x....             ADR.N    R1,??DataTable112_8  ;; "C"
   \   0000093C   0x4628             MOV      R0,R5
   \   0000093E   0x.... 0x....      BL       strcmp
   \   00000942   0x2800             CMP      R0,#+0
   \   00000944   0xD14B             BNE.N    ??CommandInterpret_59
    646          		{
    647          			char *tstmsg = "COM 시험";
    648          			
    649          			if(SavetoTestBackup(CommTest, SET, NULL) == SET)
    650          			{
    651          				tdata = returnmsgTest(tstmsg);
    652          			}
    653          
    654          			if(tdata)
    655          			{
    656          				INT16U nCnt;
    657          
    658          				SerPtr->printf("\n* [%s TEST START TimeOut 5Min]\n", tstmsg);
   \   00000946   0x.... 0x....      ADR.W    R6,`?<Constant "COM \\275\\303\\307\\350">`
   \   0000094A   0x....             LDR.N    R5,??DataTable112_6
   \   0000094C   0x4631             MOV      R1,R6
   \   0000094E   0x.... 0x....      ADR.W    R0,`?<Constant "\\n* [%s TEST START Tim...">`
   \   00000952   0x682A             LDR      R2,[R5, #+0]
   \   00000954   0x6912             LDR      R2,[R2, #+16]
   \   00000956   0x4790             BLX      R2
    659          
    660          				TimerRegist(TimerTest, Time1Sec*60L*5L);
   \   00000958   0x.... 0x....      LDR.W    R1,??DataTable118_4  ;; 0x493e0
   \   0000095C   0x2003             MOVS     R0,#+3
   \   0000095E   0x.... 0x....      BL       TimerRegist
   \   00000962   0xE009             B.N      ??CommandInterpret_60
   \                     ??CommandInterpret_34:
   \   00000964   0x37 0x30          DC8      0x37, 0x30, 0x00, 0x00
   \              0x00 0x00    
   \   00000968   0x31 0x00          DC8      "1",0x0,0x0
   \              0x00 0x00    
   \   0000096C   0x52 0x00          DC8      "R",0x0,0x0
   \              0x00 0x00    
    661          
    662          				while(1)
    663          				{
    664          					COMTestFunc();
    665          					if(TimeOverCheck(TimerTest))
    666          					{
    667          						SerPtr->printf("%s test Test TimeOut\n", tstmsg);
    668          						TimerRegist(TimerTest, Time1Sec);
    669          						break;
    670          					}
    671          
    672          					if(SerPtr->CheckByte(1, &nCnt))
    673          					{
    674          						nCnt = SerPtr->RxGetByte();
    675          						if(nCnt == 'C' || nCnt == 'c')
    676          						{
    677          							SerPtr->printf("%s test Test Canceled\n", tstmsg);
    678          							break;
    679          						}
    680          						else if(nCnt == 'F' || nCnt == 'f')
    681          						{
    682          							
    683          							SerPtr->printf("%s Test Test Finished\n", tstmsg);
    684          							SavetoTestBackup(CommTest, SET, SET);
    685          							break;
    686          						}
    687          					}
    688          					OSTimeDly(2000L);
   \                     ??CommandInterpret_61:
   \   00000970   0xF44F 0x60FA      MOV      R0,#+2000
   \   00000974   0x.... 0x....      BL       OSTimeDly
   \                     ??CommandInterpret_60:
   \   00000978   0x.... 0x....      BL       COMTestFunc
   \   0000097C   0x2003             MOVS     R0,#+3
   \   0000097E   0x.... 0x....      BL       TimeOverCheck
   \   00000982   0xB158             CBZ.N    R0,??CommandInterpret_62
   \   00000984   0x4631             MOV      R1,R6
   \   00000986   0x.... 0x....      ADR.W    R0,`?<Constant "%s test Test TimeOut\\n">`
   \                     ??CommandInterpret_47:
   \   0000098A   0x682A             LDR      R2,[R5, #+0]
   \   0000098C   0x6912             LDR      R2,[R2, #+16]
   \   0000098E   0x4790             BLX      R2
   \   00000990   0xF44F 0x717A      MOV      R1,#+1000
   \   00000994   0x2003             MOVS     R0,#+3
   \   00000996   0x.... 0x....      BL       TimerRegist
   \   0000099A   0xE03E             B.N      ??CommandInterpret_63
   \                     ??CommandInterpret_62:
   \   0000099C   0xA900             ADD      R1,SP,#+0
   \   0000099E   0x2001             MOVS     R0,#+1
   \   000009A0   0x682A             LDR      R2,[R5, #+0]
   \   000009A2   0x6852             LDR      R2,[R2, #+4]
   \   000009A4   0x4790             BLX      R2
   \   000009A6   0x2800             CMP      R0,#+0
   \   000009A8   0xD0E2             BEQ.N    ??CommandInterpret_61
   \   000009AA   0x6828             LDR      R0,[R5, #+0]
   \   000009AC   0x6880             LDR      R0,[R0, #+8]
   \   000009AE   0x4780             BLX      R0
   \   000009B0   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   000009B4   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000009B8   0x2843             CMP      R0,#+67
   \   000009BA   0xBF18             IT       NE 
   \   000009BC   0x2863             CMPNE    R0,#+99
   \   000009BE   0xBF04             ITT      EQ 
   \   000009C0   0x4631             MOVEQ    R1,R6
   \   000009C2   0x.... 0x....      ADREQ.W  R0,`?<Constant "%s test Test Canceled\\n">`
   \   000009C6   0xD006             BEQ.N    ??CommandInterpret_48
   \   000009C8   0x2846             CMP      R0,#+70
   \   000009CA   0xBF18             IT       NE 
   \   000009CC   0x2866             CMPNE    R0,#+102
   \   000009CE   0xD1CF             BNE.N    ??CommandInterpret_61
   \   000009D0   0x4631             MOV      R1,R6
   \   000009D2   0x.... 0x....      ADR.W    R0,`?<Constant "%s Test Test Finished\\n">`
   \                     ??CommandInterpret_48:
   \   000009D6   0x682A             LDR      R2,[R5, #+0]
   \   000009D8   0x6912             LDR      R2,[R2, #+16]
   \   000009DA   0x4790             BLX      R2
   \   000009DC   0xE01D             B.N      ??CommandInterpret_63
    689          				}
    690          			}
    691          		}
    692          		else if(!strcmp((char *)Argv[1], "S"))
   \                     ??CommandInterpret_59:
   \   000009DE   0x....             ADR.N    R1,??DataTable112_9  ;; "S"
   \   000009E0   0x4628             MOV      R0,R5
   \   000009E2   0x.... 0x....      BL       strcmp
   \   000009E6   0xB9C0             CBNZ.N   R0,??CommandInterpret_63
    693          		{
    694          			
    695          			SerPtr->printf("\n Default Back-up End -> Reboot...  \n\n");
   \   000009E8   0x.... 0x....      ADR.W    R0,`?<Constant "\\n Default Back-up End...">`
   \   000009EC   0x....             LDR.N    R1,??DataTable112_6
   \   000009EE   0x6809             LDR      R1,[R1, #+0]
   \   000009F0   0x6909             LDR      R1,[R1, #+16]
   \   000009F2   0x4788             BLX      R1
    696          
    697          			DefaultTable();
   \   000009F4   0x.... 0x....      BL       DefaultTable
    698          			ForDelay(20L);
   \   000009F8   0x2014             MOVS     R0,#+20
   \   000009FA   0x.... 0x....      BL       ForDelay
    699          
    700          			WriteEEprom(At24cDevID, DownLoadFlag1,	(INT8U)(0x5A5A >> 8), 0);
   \   000009FE   0x2300             MOVS     R3,#+0
   \   00000A00   0x225A             MOVS     R2,#+90
   \   00000A02   0x2101             MOVS     R1,#+1
   \   00000A04   0x20A0             MOVS     R0,#+160
   \   00000A06   0x.... 0x....      BL       WriteEEprom
    701          			WriteEEprom(At24cDevID, DownLoadFlag2,	(INT8U)(0x5A5A	 ), 0);
   \   00000A0A   0x2300             MOVS     R3,#+0
   \   00000A0C   0x225A             MOVS     R2,#+90
   \   00000A0E   0x2102             MOVS     R1,#+2
   \   00000A10   0x20A0             MOVS     R0,#+160
   \   00000A12   0x.... 0x....      BL       WriteEEprom
    702          			
    703          			DownLoadBootingJump();
   \   00000A16   0x.... 0x....      BL       DownLoadBootingJump
    704          
    705          		}		
    706          #endif		
    707          
    708          		if(!strcmp((char *)Argv[1], "SRAM"))
   \                     ??CommandInterpret_63:
   \   00000A1A   0x.... 0x....      ADR.W    R1,`?<Constant "SRAM">`
   \   00000A1E   0x68A0             LDR      R0,[R4, #+8]
   \   00000A20   0x.... 0x....      BL       strcmp
   \   00000A24   0xBB18             CBNZ.N   R0,??CommandInterpret_0
    709          		{
    710          			u8 *tptr = (u8 *)(Bank1_SRAM1_ADDR + (256*1024));
    711          			INT32U i = 0;
   \   00000A26   0x2400             MOVS     R4,#+0
    712          			SerPtr->printf("\n");
   \   00000A28   0x....             LDR.N    R5,??DataTable112_6
   \   00000A2A   0x....             ADR.N    R0,??DataTable113_1  ;; "\n"
   \   00000A2C   0x6829             LDR      R1,[R5, #+0]
   \   00000A2E   0x6909             LDR      R1,[R1, #+16]
   \   00000A30   0x4788             BLX      R1
    713          			
    714          			for(i = 0; i < (256*1024); i++)
   \   00000A32   0x.... 0x....      LDR.W    R6,??DataTable119_6  ;; 0x60040000
   \   00000A36   0x....             ADR.N    R7,??DataTable113_2  ;; "."
    715          			{
    716          				tptr[i] = (INT8U)i;
   \                     ??CommandInterpret_64:
   \   00000A38   0x7034             STRB     R4,[R6, #+0]
    717          				
    718          				if((INT8U)i != tptr[i])
    719          				{
    720          					SerPtr->printf("\nRAM TEST ERROR \n");
    721          					break;
    722          				}
    723          				if((i%1024) == 0)
   \   00000A3A   0x05A0             LSLS     R0,R4,#+22
   \   00000A3C   0xD106             BNE.N    ??CommandInterpret_65
    724          				{
    725          					OSTimeDly(10);
   \   00000A3E   0x200A             MOVS     R0,#+10
   \   00000A40   0x.... 0x....      BL       OSTimeDly
    726          					SerPtr->printf(".");
   \   00000A44   0x4638             MOV      R0,R7
   \   00000A46   0x6829             LDR      R1,[R5, #+0]
   \   00000A48   0x6909             LDR      R1,[R1, #+16]
   \   00000A4A   0x4788             BLX      R1
    727          
    728          				}
    729          			}
   \                     ??CommandInterpret_65:
   \   00000A4C   0x1C64             ADDS     R4,R4,#+1
   \   00000A4E   0x1C76             ADDS     R6,R6,#+1
   \   00000A50   0xF5B4 0x2F80      CMP      R4,#+262144
   \   00000A54   0xD3F0             BCC.N    ??CommandInterpret_64
    730          			if(i == (256*1024)){
    731          			}
    732          			
    733          			SerPtr->printf("\n");
   \                     ??CommandInterpret_36:
   \   00000A56   0x....             ADR.N    R0,??DataTable113_1  ;; "\n"
   \   00000A58   0x6829             LDR      R1,[R5, #+0]
   \   00000A5A   0x6909             LDR      R1,[R1, #+16]
   \   00000A5C   0x4788             BLX      R1
   \   00000A5E   0xE006             B.N      ??CommandInterpret_0
    734          		}
    735          	}
    736          	else 											SerPtr->printf("ETC[%s]\n",Argv[0]);
   \                     ??CommandInterpret_41:
   \   00000A60   0x4629             MOV      R1,R5
   \   00000A62   0x.... 0x....      ADR.W    R0,`?<Constant "ETC[%s]\\n">`
   \                     ??CommandInterpret_13:
   \   00000A66   0x....             LDR.N    R2,??DataTable112_6
   \   00000A68   0x6812             LDR      R2,[R2, #+0]
   \   00000A6A   0x6912             LDR      R2,[R2, #+16]
   \   00000A6C   0x4790             BLX      R2
    737          #endif
    738          	return(1);
   \                     ??CommandInterpret_0:
   \   00000A6E   0x2001             MOVS     R0,#+1
   \   00000A70   0xB006             ADD      SP,SP,#+24
   \   00000A72   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    739          }
    740          
    741          

   \                                 In section .text, align 2, keep-with-next
    742          void KeyProc( char sbuf, void (*func)(void))
    743          {
   \                     KeyProc:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x460C             MOV      R4,R1
    744          	INT16U nSize = sizeof(tRevData);
    745          
    746          	tRevData[tIndex%nSize] = sbuf;
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable119_7
   \   0000000A   0x7829             LDRB     R1,[R5, #+0]
   \   0000000C   0xF04F 0x081E      MOV      R8,#+30
   \   00000010   0xFB91 0xF2F8      SDIV     R2,R1,R8
   \   00000014   0xEBC2 0x1302      RSB      R3,R2,R2, LSL #+4
   \   00000018   0xEBA1 0x0243      SUB      R2,R1,R3, LSL #+1
   \   0000001C   0x.... 0x....      LDR.W    R7,??DataTable119_8
   \   00000020   0x55D0             STRB     R0,[R2, R7]
    747          //	
    748          	if( tRevData[tIndex%nSize] == 0x0D )			// Enter 입력
   \   00000022   0x280D             CMP      R0,#+13
   \   00000024   0xD131             BNE.N    ??KeyProc_0
    749          	{
    750          		SerPtr->PutToBuffer('\r');
   \   00000026   0x.... 0x....      LDR.W    R6,??DataTable121
   \   0000002A   0x6831             LDR      R1,[R6, #+0]
   \   0000002C   0x6989             LDR      R1,[R1, #+24]
   \   0000002E   0x4788             BLX      R1
    751          		SerPtr->PutToBuffer('\n');
   \   00000030   0x200A             MOVS     R0,#+10
   \   00000032   0x6831             LDR      R1,[R6, #+0]
   \   00000034   0x6989             LDR      R1,[R1, #+24]
   \   00000036   0x4788             BLX      R1
    752          		tRevData[tIndex%nSize] = '\0';
   \   00000038   0x7828             LDRB     R0,[R5, #+0]
   \   0000003A   0xFB90 0xF1F8      SDIV     R1,R0,R8
   \   0000003E   0xEBC1 0x1201      RSB      R2,R1,R1, LSL #+4
   \   00000042   0xEBA0 0x0142      SUB      R1,R0,R2, LSL #+1
   \   00000046   0x2200             MOVS     R2,#+0
   \   00000048   0x55CA             STRB     R2,[R1, R7]
    753          
    754          		if(tIndex != 0)
   \   0000004A   0xB1A0             CBZ.N    R0,??KeyProc_1
    755          		{
    756          			strcpy((char *)PrevData[PrevWRCnt++], (const char *)tRevData);
   \   0000004C   0xF995 0x0001      LDRSB    R0,[R5, #+1]
   \   00000050   0x1C41             ADDS     R1,R0,#+1
   \   00000052   0x7069             STRB     R1,[R5, #+1]
   \   00000054   0x4639             MOV      R1,R7
   \   00000056   0xEBC0 0x1200      RSB      R2,R0,R0, LSL #+4
   \   0000005A   0xEB05 0x0042      ADD      R0,R5,R2, LSL #+1
   \   0000005E   0x3024             ADDS     R0,R0,#+36
   \   00000060   0x.... 0x....      BL       strcpy
    757          			PrevWRCnt %= 5;
   \   00000064   0xF995 0x0001      LDRSB    R0,[R5, #+1]
   \   00000068   0x2105             MOVS     R1,#+5
   \   0000006A   0xFB90 0xF1F1      SDIV     R1,R0,R1
   \   0000006E   0xEB01 0x0181      ADD      R1,R1,R1, LSL #+2
   \   00000072   0x1A40             SUBS     R0,R0,R1
   \   00000074   0x7068             STRB     R0,[R5, #+1]
    758          		}
    759          		PrevRDCnt = PrevWRCnt;
   \                     ??KeyProc_1:
   \   00000076   0x7868             LDRB     R0,[R5, #+1]
   \   00000078   0x70A8             STRB     R0,[R5, #+2]
    760          		func();
   \   0000007A   0x47A0             BLX      R4
    761          		tIndex = 0;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x7028             STRB     R0,[R5, #+0]
    762          		Parser(rRevData);
   \   00000080   0x1D28             ADDS     R0,R5,#+4
   \   00000082   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000086   0x.... 0x....      B.W      Parser
    763          
    764          		return;
    765          	}
    766          	else if(tRevData[tIndex%nSize] == 0x08) // Back Space
   \                     ??KeyProc_0:
   \   0000008A   0x2808             CMP      R0,#+8
   \   0000008C   0xD111             BNE.N    ??KeyProc_2
    767          	{
    768          		if (tIndex == 0)
   \   0000008E   0x2900             CMP      R1,#+0
   \   00000090   0xD05F             BEQ.N    ??KeyProc_3
    769          			return;
    770          
    771          		SerPtr->PutToBuffer(0x08);
   \   00000092   0x.... 0x....      LDR.W    R4,??DataTable121
   \   00000096   0x6821             LDR      R1,[R4, #+0]
   \   00000098   0x6989             LDR      R1,[R1, #+24]
   \   0000009A   0x4788             BLX      R1
    772          		SerPtr->PutToBuffer(' ');
   \   0000009C   0x2020             MOVS     R0,#+32
   \   0000009E   0x6821             LDR      R1,[R4, #+0]
   \   000000A0   0x6989             LDR      R1,[R1, #+24]
   \   000000A2   0x4788             BLX      R1
    773          		SerPtr->PutToBuffer(0x08);
   \   000000A4   0x2008             MOVS     R0,#+8
   \   000000A6   0x6821             LDR      R1,[R4, #+0]
   \   000000A8   0x6989             LDR      R1,[R1, #+24]
   \   000000AA   0x4788             BLX      R1
    774          		tIndex--;
   \   000000AC   0x7828             LDRB     R0,[R5, #+0]
   \   000000AE   0x1E40             SUBS     R0,R0,#+1
   \   000000B0   0xE04E             B.N      ??KeyProc_4
    775          
    776          		return;
    777          	}
    778          	else if( tRevData[tIndex%nSize] == 0x09 )	// tab
   \                     ??KeyProc_2:
   \   000000B2   0x2809             CMP      R0,#+9
   \   000000B4   0xD13E             BNE.N    ??KeyProc_5
    779          	{
    780          		while(tIndex)
   \   000000B6   0x2900             CMP      R1,#+0
   \   000000B8   0x.... 0x....      LDR.W    R4,??DataTable121
   \   000000BC   0xD011             BEQ.N    ??KeyProc_6
    781          		{
    782          			SerPtr->PutToBuffer(0x08);
   \                     ??KeyProc_7:
   \   000000BE   0x2008             MOVS     R0,#+8
   \   000000C0   0x6821             LDR      R1,[R4, #+0]
   \   000000C2   0x6989             LDR      R1,[R1, #+24]
   \   000000C4   0x4788             BLX      R1
    783          			SerPtr->PutToBuffer(' ');
   \   000000C6   0x2020             MOVS     R0,#+32
   \   000000C8   0x6821             LDR      R1,[R4, #+0]
   \   000000CA   0x6989             LDR      R1,[R1, #+24]
   \   000000CC   0x4788             BLX      R1
    784          			SerPtr->PutToBuffer(0x08);
   \   000000CE   0x2008             MOVS     R0,#+8
   \   000000D0   0x6821             LDR      R1,[R4, #+0]
   \   000000D2   0x6989             LDR      R1,[R1, #+24]
   \   000000D4   0x4788             BLX      R1
    785          			tIndex--;
   \   000000D6   0x7828             LDRB     R0,[R5, #+0]
   \   000000D8   0x1E40             SUBS     R0,R0,#+1
   \   000000DA   0x7028             STRB     R0,[R5, #+0]
   \   000000DC   0xB2C0             UXTB     R0,R0
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD1ED             BNE.N    ??KeyProc_7
    786          		}
    787          
    788          		PrevRDCnt--;
   \                     ??KeyProc_6:
   \   000000E2   0x78A8             LDRB     R0,[R5, #+2]
   \   000000E4   0x1E40             SUBS     R0,R0,#+1
   \   000000E6   0x70A8             STRB     R0,[R5, #+2]
    789          		if(PrevRDCnt < 0) PrevRDCnt = 4;
   \   000000E8   0xB240             SXTB     R0,R0
   \   000000EA   0x2800             CMP      R0,#+0
   \   000000EC   0xBF44             ITT      MI 
   \   000000EE   0x2004             MOVMI    R0,#+4
   \   000000F0   0x70A8             STRBMI   R0,[R5, #+2]
    790          		strcpy((char *)tRevData, (const char *)PrevData[PrevRDCnt]);
   \   000000F2   0xF995 0x0002      LDRSB    R0,[R5, #+2]
   \   000000F6   0xEBC0 0x1100      RSB      R1,R0,R0, LSL #+4
   \   000000FA   0xEB05 0x0041      ADD      R0,R5,R1, LSL #+1
   \   000000FE   0xF100 0x0124      ADD      R1,R0,#+36
   \   00000102   0x4638             MOV      R0,R7
   \   00000104   0x.... 0x....      BL       strcpy
    791          
    792          		SerPtr->printf("%s", PrevData[PrevRDCnt]);
   \   00000108   0xF995 0x0002      LDRSB    R0,[R5, #+2]
   \   0000010C   0xEBC0 0x1100      RSB      R1,R0,R0, LSL #+4
   \   00000110   0xEB05 0x0041      ADD      R0,R5,R1, LSL #+1
   \   00000114   0xF100 0x0124      ADD      R1,R0,#+36
   \   00000118   0x....             ADR.N    R0,??DataTable114_2  ;; 0x25, 0x73, 0x00, 0x00
   \   0000011A   0x6822             LDR      R2,[R4, #+0]
   \   0000011C   0x6912             LDR      R2,[R2, #+16]
   \   0000011E   0x4790             BLX      R2
    793          		tIndex = strlen((const char *)PrevData[PrevRDCnt]);
   \   00000120   0xF995 0x0002      LDRSB    R0,[R5, #+2]
   \   00000124   0xEBC0 0x1100      RSB      R1,R0,R0, LSL #+4
   \   00000128   0xEB05 0x0041      ADD      R0,R5,R1, LSL #+1
   \   0000012C   0x3024             ADDS     R0,R0,#+36
   \   0000012E   0x.... 0x....      BL       strlen
   \   00000132   0xE00D             B.N      ??KeyProc_4
    794          
    795          		return;
    796          	}
    797          	rRevData[tIndex%nSize] = tRevData[tIndex%nSize];
   \                     ??KeyProc_5:
   \   00000134   0x1951             ADDS     R1,R2,R5
   \   00000136   0x7108             STRB     R0,[R1, #+4]
    798          	SerPtr->PutToBuffer(tRevData[tIndex%nSize]);			// 입력 키 출력
   \   00000138   0x.... 0x....      LDR.W    R1,??DataTable121
   \   0000013C   0x6809             LDR      R1,[R1, #+0]
   \   0000013E   0x6989             LDR      R1,[R1, #+24]
   \   00000140   0x4788             BLX      R1
    799          
    800          	if(++tIndex >= nSize) tIndex = 0;
   \   00000142   0x7828             LDRB     R0,[R5, #+0]
   \   00000144   0x1C40             ADDS     R0,R0,#+1
   \   00000146   0x7028             STRB     R0,[R5, #+0]
   \   00000148   0xB2C0             UXTB     R0,R0
   \   0000014A   0x281E             CMP      R0,#+30
   \   0000014C   0xD301             BCC.N    ??KeyProc_3
   \   0000014E   0x2000             MOVS     R0,#+0
   \                     ??KeyProc_4:
   \   00000150   0x7028             STRB     R0,[R5, #+0]
   \                     ??KeyProc_3:
   \   00000152   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    801          }
    802          

   \                                 In section .text, align 2, keep-with-next
    803          INT8U htob(INT8U hex)
    804          {
    805          	INT8U i;
    806          	
    807          	if (hex >= '0' && hex <= '9') i=hex-'0';
   \                     htob:
   \   00000000   0xF1A0 0x0130      SUB      R1,R0,#+48
   \   00000004   0xB2C9             UXTB     R1,R1
   \   00000006   0x290A             CMP      R1,#+10
   \   00000008   0xD307             BCC.N    ??htob_0
    808          	else if ( hex >= 'A' && hex <= 'F' )i=hex-'A'+10;
   \   0000000A   0xF1A0 0x0141      SUB      R1,R0,#+65
   \   0000000E   0x2906             CMP      R1,#+6
   \   00000010   0xBF34             ITE      CC 
   \   00000012   0xF1A0 0x0137      SUBCC    R1,R0,#+55
   \   00000016   0xF1A0 0x0157      SUBCS    R1,R0,#+87
    809          	else i=hex-'a'+10;
    810          	
    811          	return i;
   \                     ??htob_0:
   \   0000001A   0xB2C8             UXTB     R0,R1
   \   0000001C   0x4770             BX       LR               ;; return
    812          }
    813          

   \                                 In section .text, align 2, keep-with-next
    814          INT8U dGetHex (INT8U Data_H, INT8U Data_L)
    815          {
   \                     dGetHex:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    816          	INT8U i;
    817          	
    818          	i=htob( Data_H );
   \   00000004   0x.... 0x....      BL       htob
   \   00000008   0x4605             MOV      R5,R0
    819          	i=htob( Data_L )+(i<<4);
    820          	return i;
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       htob
   \   00000010   0xEB00 0x1005      ADD      R0,R0,R5, LSL #+4
   \   00000014   0xB2C0             UXTB     R0,R0
   \   00000016   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    821          }
    822          

   \                                 In section .text, align 2, keep-with-next
    823          void TestCommand(void)
    824          {
   \                     TestCommand:
   \   00000000   0xB580             PUSH     {R7,LR}
    825          
    826          	INT8U tdata = FALSE;
    827          	
    828          	if(tRevData[0] == 't' && tRevData[1] == 'e' && tRevData[2] == 's' && tRevData[3] == 't') tdata = TRUE;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable119_8
   \   00000006   0x7801             LDRB     R1,[R0, #+0]
   \   00000008   0x2974             CMP      R1,#+116
   \   0000000A   0xD108             BNE.N    ??TestCommand_0
   \   0000000C   0x7841             LDRB     R1,[R0, #+1]
   \   0000000E   0x2965             CMP      R1,#+101
   \   00000010   0xBF01             ITTTT    EQ 
   \   00000012   0x7881             LDRBEQ   R1,[R0, #+2]
   \   00000014   0x2973             CMPEQ    R1,#+115
   \   00000016   0x78C0             LDRBEQ   R0,[R0, #+3]
   \   00000018   0x2874             CMPEQ    R0,#+116
   \   0000001A   0xD11C             BNE.N    ??TestCommand_1
   \   0000001C   0xE00A             B.N      ??TestCommand_2
    829          	if(tRevData[0] == 'T' && tRevData[1] == 'E' && tRevData[2] == 'S' && tRevData[3] == 'T') tdata = TRUE;
   \                     ??TestCommand_0:
   \   0000001E   0x2954             CMP      R1,#+84
   \   00000020   0xBF04             ITT      EQ 
   \   00000022   0x7841             LDRBEQ   R1,[R0, #+1]
   \   00000024   0x2945             CMPEQ    R1,#+69
   \   00000026   0xD116             BNE.N    ??TestCommand_1
   \   00000028   0x7881             LDRB     R1,[R0, #+2]
   \   0000002A   0x2953             CMP      R1,#+83
   \   0000002C   0xBF04             ITT      EQ 
   \   0000002E   0x78C0             LDRBEQ   R0,[R0, #+3]
   \   00000030   0x2854             CMPEQ    R0,#+84
   \   00000032   0xD110             BNE.N    ??TestCommand_1
    830          
    831          	if(tdata){
    832          		iUser_Value2 = __ChangeDebug;
   \                     ??TestCommand_2:
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable122
   \   00000038   0x210D             MOVS     R1,#+13
   \   0000003A   0x7001             STRB     R1,[R0, #+0]
    833          		iDebugCnt = 0; 
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable122_1
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x7001             STRB     R1,[R0, #+0]
    834          		TimerRegist(Timer_DebugCnt, Time1Min*30L);
   \   00000044   0x.... 0x....      LDR.W    R1,??DataTable123  ;; 0x1b7740
   \   00000048   0x2006             MOVS     R0,#+6
   \   0000004A   0x.... 0x....      BL       TimerRegist
    835          		TimerRegist(TimerSioRx, Time100mSec);
   \   0000004E   0x2164             MOVS     R1,#+100
   \   00000050   0x2002             MOVS     R0,#+2
   \   00000052   0x.... 0x....      BL       TimerRegist
    836          	}
    837          	PromptOut();
   \                     ??TestCommand_1:
   \   00000056   0xE8BD 0x4001      POP      {R0,LR}
   \   0000005A   0x.... 0x....      B.W      PromptOut
    838          }
    839          
    840          //void OnCommand2nd(INT8U *pdata)
    841          
    842          

   \                                 In section .text, align 2, keep-with-next
    843          void OnCommand ( void )
    844          {
   \                     OnCommand:
   \   00000000   0xE92D 0x41FC      PUSH     {R2-R8,LR}
    845          	INT8U tdata = TRUE;
    846          //	if( memcmp( rxd_buff, "$$GMM_REJ:", cmdLen ) == 0 )
    847          #if 0
    848          	if(memcmp(Argv[0],"TEST",4) && Argc==1)
    849          	{
    850          		SerPtr->printf("Test OK\n");
    851          	}
    852          	else
    853          	{
    854          		SerPtr->printf("Test NOK\n");
    855          	}
    856          #endif
    857          //	else if(Ustrcmp(Argv[0],"HELP") && Argc==1)  DisplayHelpMenu(Sio);
    858          	switch(tRevData[0])
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable119_8
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x283F             CMP      R0,#+63
   \   0000000C   0xD020             BEQ.N    ??OnCommand_0
   \   0000000E   0x2841             CMP      R0,#+65
   \   00000010   0xD021             BEQ.N    ??OnCommand_1
   \   00000012   0x2843             CMP      R0,#+67
   \   00000014   0xF000 0x80E2      BEQ.W    ??OnCommand_2
   \   00000018   0x2847             CMP      R0,#+71
   \   0000001A   0xF000 0x8126      BEQ.W    ??OnCommand_3
   \   0000001E   0x2849             CMP      R0,#+73
   \   00000020   0xF000 0x8095      BEQ.W    ??OnCommand_4
   \   00000024   0x284F             CMP      R0,#+79
   \   00000026   0xD053             BEQ.N    ??OnCommand_5
   \   00000028   0x2853             CMP      R0,#+83
   \   0000002A   0xF000 0x8126      BEQ.W    ??OnCommand_6
   \   0000002E   0x2861             CMP      R0,#+97
   \   00000030   0xD011             BEQ.N    ??OnCommand_1
   \   00000032   0x2863             CMP      R0,#+99
   \   00000034   0xF000 0x80D2      BEQ.W    ??OnCommand_2
   \   00000038   0x2867             CMP      R0,#+103
   \   0000003A   0xF000 0x8116      BEQ.W    ??OnCommand_3
   \   0000003E   0x2869             CMP      R0,#+105
   \   00000040   0xF000 0x8085      BEQ.W    ??OnCommand_4
   \   00000044   0x286F             CMP      R0,#+111
   \   00000046   0xD043             BEQ.N    ??OnCommand_5
   \   00000048   0x2873             CMP      R0,#+115
   \   0000004A   0xF000 0x8116      BEQ.W    ??OnCommand_6
   \   0000004E   0xE139             B.N      ??OnCommand_7
    859          	{
    860          		case '?':
    861          			PrintLogo();
   \                     ??OnCommand_0:
   \   00000050   0x.... 0x....      BL       PrintLogo
    862          		break;
   \   00000054   0xE136             B.N      ??OnCommand_7
    863          		
    864          		case 'A':
    865          		case 'a':
    866          		{
    867          			char *tstmsg = "ADC Input";
    868          
    869          			
    870          			if(SavetoTestBackup(ADCTest, SET, NULL) == SET)
    871          			{
    872          				tdata = returnmsgTest(tstmsg);
    873          			}
    874          			
    875          
    876          			if(tdata)
    877          			{
    878          				INT16U nCnt;
    879          
    880          				SerPtr->printf("\n* [%s] TEST START TimeOut 5 Min]\n", tstmsg);
   \                     ??OnCommand_1:
   \   00000056   0x.... 0x....      ADR.W    R5,`?<Constant "ADC Input">`
   \   0000005A   0x.... 0x....      LDR.W    R4,??DataTable121
   \   0000005E   0x4629             MOV      R1,R5
   \   00000060   0x.... 0x....      ADR.W    R0,`?<Constant "\\n* [%s] TEST START Ti...">`
   \   00000064   0x6822             LDR      R2,[R4, #+0]
   \   00000066   0x6912             LDR      R2,[R2, #+16]
   \   00000068   0x4790             BLX      R2
    881          
    882          				TimerRegist(TimerTest, Time1Sec*60L*5L);
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable118_4  ;; 0x493e0
   \   0000006E   0x2003             MOVS     R0,#+3
   \   00000070   0x.... 0x....      BL       TimerRegist
   \   00000074   0xE003             B.N      ??OnCommand_8
    883          
    884          				while(1)
    885          				{
    886          					AdInputStatus();
    887          
    888          
    889          					if(TimeOverCheck(TimerTest))
    890          					{
    891          						SerPtr->printf("%s Test TimeOut\n", tstmsg);
    892          
    893          						TimerRegist(TimerTest, Time1Sec);
    894          						break;
    895          					}
    896          					if(SerPtr->CheckByte(1, &nCnt))
    897          					{
    898          						nCnt = SerPtr->RxGetByte();
    899          						if(nCnt == 'c' || nCnt == 'C')
    900          						{
    901          							SerPtr->printf("%s Test Canceled\n", tstmsg);
    902          							break;
    903          						}
    904          						else if(nCnt == 'f' || nCnt == 'F')
    905          						{
    906          //							gOK:
    907          							SerPtr->printf("%s Test Finished\n", tstmsg);
    908          							SavetoTestBackup(ADCTest, SET, SET);
    909          							break;
    910          						}
    911          					}
    912          					OSTimeDly(2000L);
   \                     ??OnCommand_9:
   \   00000076   0xF44F 0x60FA      MOV      R0,#+2000
   \   0000007A   0x.... 0x....      BL       OSTimeDly
   \                     ??OnCommand_8:
   \   0000007E   0x.... 0x....      BL       AdInputStatus
   \   00000082   0x2003             MOVS     R0,#+3
   \   00000084   0x.... 0x....      BL       TimeOverCheck
   \   00000088   0xB118             CBZ.N    R0,??OnCommand_10
   \   0000008A   0x4629             MOV      R1,R5
   \   0000008C   0x.... 0x....      ADR.W    R0,`?<Constant "%s Test TimeOut\\n">`
   \   00000090   0xE0C1             B.N      ??OnCommand_11
   \                     ??OnCommand_10:
   \   00000092   0xA900             ADD      R1,SP,#+0
   \   00000094   0x2001             MOVS     R0,#+1
   \   00000096   0x6822             LDR      R2,[R4, #+0]
   \   00000098   0x6852             LDR      R2,[R2, #+4]
   \   0000009A   0x4790             BLX      R2
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD0EA             BEQ.N    ??OnCommand_9
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x6880             LDR      R0,[R0, #+8]
   \   000000A4   0x4780             BLX      R0
   \   000000A6   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   000000AA   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000000AE   0x2863             CMP      R0,#+99
   \   000000B0   0xBF18             IT       NE 
   \   000000B2   0x2843             CMPNE    R0,#+67
   \   000000B4   0xBF04             ITT      EQ 
   \   000000B6   0x4629             MOVEQ    R1,R5
   \   000000B8   0x.... 0x....      ADREQ.W  R0,`?<Constant "%s Test Canceled\\n">`
   \   000000BC   0xF000 0x80D1      BEQ.W    ??OnCommand_12
   \   000000C0   0x2866             CMP      R0,#+102
   \   000000C2   0xBF18             IT       NE 
   \   000000C4   0x2846             CMPNE    R0,#+70
   \   000000C6   0xD1D6             BNE.N    ??OnCommand_9
   \   000000C8   0x4629             MOV      R1,R5
   \   000000CA   0x.... 0x....      ADR.W    R0,`?<Constant "%s Test Finished\\n">`
   \   000000CE   0xE0C8             B.N      ??OnCommand_12
    913          					/////////////////////////////////////////////////////////////
    914          				}
    915          			}
    916          		}
    917          		break;
    918          
    919          		case 'O':
    920          		case 'o':
    921          			{
    922          				char *tstmsg = "Dig Output";
    923          				
    924          				if(SavetoTestBackup(OutputTest, SET, NULL) == SET)
    925          				{
    926          					tdata = returnmsgTest(tstmsg);
    927          				}
    928          				
    929          				if(tdata)
    930          				{
    931          					INT32U nFlag = 0;
   \                     ??OnCommand_5:
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x9001             STR      R0,[SP, #+4]
    932          					INT16U nCnt;
    933          	
    934          					SerPtr->printf("\n* [%s TEST START TimeOut 5Min]\n", tstmsg);
   \   000000D4   0x.... 0x....      ADR.W    R5,`?<Constant "Dig Output">`
   \   000000D8   0x.... 0x....      LDR.W    R4,??DataTable121
   \   000000DC   0x4629             MOV      R1,R5
   \   000000DE   0x.... 0x....      ADR.W    R0,`?<Constant "\\n* [%s TEST START Tim...">`
   \   000000E2   0x6822             LDR      R2,[R4, #+0]
   \   000000E4   0x6912             LDR      R2,[R2, #+16]
   \   000000E6   0x4790             BLX      R2
    935          	
    936          					TimerRegist(TimerTest, Time1Sec*60L*5L);
   \   000000E8   0x.... 0x....      LDR.W    R1,??DataTable118_4  ;; 0x493e0
   \   000000EC   0x2003             MOVS     R0,#+3
   \   000000EE   0x.... 0x....      BL       TimerRegist
   \   000000F2   0xE002             B.N      ??OnCommand_13
    937          	
    938          					while(1)
    939          					{
    940          						HwTestOutFunc(&nFlag);
    941          	
    942          						if(TimeOverCheck(TimerTest))
    943          						{
    944          							SerPtr->printf("%s test TimeOut\n", tstmsg);
    945          							TimerRegist(TimerTest, Time1Sec);
    946          							break;
    947          						}
    948          						if(SerPtr->CheckByte(1, &nCnt))
    949          						{
    950          							nCnt = SerPtr->RxGetByte();
    951          							if(nCnt == 'C' || nCnt == 'c')
    952          							{
    953          								SerPtr->printf("%s test Canceled\n", tstmsg);
    954          								break;
    955          							}
    956          							else if(nCnt == 'F' || nCnt == 'f')
    957          							{
    958          								SerPtr->printf("%s test Finished\n", tstmsg);
    959          								SavetoTestBackup(OutputTest, SET, SET);
    960          								break;
    961          							}
    962          						}
    963          						OSTimeDly(250L*1L);
   \                     ??OnCommand_14:
   \   000000F4   0x20FA             MOVS     R0,#+250
   \   000000F6   0x.... 0x....      BL       OSTimeDly
   \                     ??OnCommand_13:
   \   000000FA   0xA801             ADD      R0,SP,#+4
   \   000000FC   0x.... 0x....      BL       HwTestOutFunc
   \   00000100   0x2003             MOVS     R0,#+3
   \   00000102   0x.... 0x....      BL       TimeOverCheck
   \   00000106   0xB118             CBZ.N    R0,??OnCommand_15
   \   00000108   0x4629             MOV      R1,R5
   \   0000010A   0x.... 0x....      ADR.W    R0,`?<Constant "%s test TimeOut\\n">`
   \   0000010E   0xE082             B.N      ??OnCommand_11
   \                     ??OnCommand_15:
   \   00000110   0xA900             ADD      R1,SP,#+0
   \   00000112   0x2001             MOVS     R0,#+1
   \   00000114   0x6822             LDR      R2,[R4, #+0]
   \   00000116   0x6852             LDR      R2,[R2, #+4]
   \   00000118   0x4790             BLX      R2
   \   0000011A   0x2800             CMP      R0,#+0
   \   0000011C   0xD0EA             BEQ.N    ??OnCommand_14
   \   0000011E   0x6820             LDR      R0,[R4, #+0]
   \   00000120   0x6880             LDR      R0,[R0, #+8]
   \   00000122   0x4780             BLX      R0
   \   00000124   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000128   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   0000012C   0x2843             CMP      R0,#+67
   \   0000012E   0xBF18             IT       NE 
   \   00000130   0x2863             CMPNE    R0,#+99
   \   00000132   0xBF04             ITT      EQ 
   \   00000134   0x4629             MOVEQ    R1,R5
   \   00000136   0x.... 0x....      ADREQ.W  R0,`?<Constant "%s test Canceled\\n">`
   \   0000013A   0xF000 0x8092      BEQ.W    ??OnCommand_12
   \   0000013E   0x2846             CMP      R0,#+70
   \   00000140   0xBF18             IT       NE 
   \   00000142   0x2866             CMPNE    R0,#+102
   \   00000144   0xD1D6             BNE.N    ??OnCommand_14
   \   00000146   0x4629             MOV      R1,R5
   \   00000148   0x.... 0x....      ADR.W    R0,`?<Constant "%s test Finished\\n">`
   \   0000014C   0xE089             B.N      ??OnCommand_12
    964          						/////////////////////////////////////////////////////////////						
    965          					}
    966          				}
    967          			}
    968          		break;
    969          
    970          		case 'I':
    971          		case 'i':
    972          			{
    973          				char *tstmsg = "Dig Input";
    974          
    975          				if(SavetoTestBackup(InputTest, SET, NULL) == SET)
    976          				{
    977          					tdata = returnmsgTest(tstmsg);
    978          				}
    979          				if(tdata)
    980          				{
    981          					INT16U nCnt;
    982          	
    983          					SerPtr->printf("\n* [%s TEST START TimeOut 5 Min]\n", tstmsg);
   \                     ??OnCommand_4:
   \   0000014E   0x.... 0x....      ADR.W    R5,`?<Constant "Dig Input">`
   \   00000152   0x.... 0x....      LDR.W    R4,??DataTable121
   \   00000156   0x4629             MOV      R1,R5
   \   00000158   0x.... 0x....      ADR.W    R0,`?<Constant "\\n* [%s TEST START Tim...">_1`
   \   0000015C   0x6822             LDR      R2,[R4, #+0]
   \   0000015E   0x6912             LDR      R2,[R2, #+16]
   \   00000160   0x4790             BLX      R2
    984          					TimerRegist(TimerTest, Time1Sec*60L*1L);
   \   00000162   0xF64E 0x2160      MOVW     R1,#+60000
   \   00000166   0x2003             MOVS     R0,#+3
   \   00000168   0x.... 0x....      BL       TimerRegist
    985          	
    986          					CurrentInputStatus(0);
   \   0000016C   0x2000             MOVS     R0,#+0
   \   0000016E   0x.... 0x....      BL       CurrentInputStatus
    987          					tinputStsOld = tinputSts;
   \   00000172   0x.... 0x....      LDR.W    R0,??DataTable119_2
   \   00000176   0x.... 0x....      LDR.W    R1,??DataTable119_3
   \   0000017A   0x2234             MOVS     R2,#+52
   \   0000017C   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000180   0xE003             B.N      ??OnCommand_16
    988          
    989          					while(1)
    990          					{
    991          						CurrentInputStatus(1);
    992          	
    993          						if(TimeOverCheck(TimerTest))
    994          						{
    995          							SerPtr->printf("%s Test TimeOut\n", tstmsg);
    996          							TimerRegist(TimerTest, Time1Sec);
    997          							break;
    998          						}
    999          						if(SerPtr->CheckByte(1, &nCnt))
   1000          						{
   1001          							nCnt = SerPtr->RxGetByte();
   1002          							if(nCnt == 'c' || nCnt == 'C')
   1003          							{
   1004          								SerPtr->printf("%s Test Canceled\n", tstmsg);
   1005          								break;
   1006          							}
   1007          							else if(nCnt == 'f' || nCnt == 'F')
   1008          							{
   1009          								SerPtr->printf("%s Test Finished\n", tstmsg);
   1010          								SavetoTestBackup(InputTest, SET, SET);
   1011          								break;
   1012          							}
   1013          						}
   1014          						OSTimeDly(300L);
   \                     ??OnCommand_17:
   \   00000182   0xF44F 0x7096      MOV      R0,#+300
   \   00000186   0x.... 0x....      BL       OSTimeDly
   \                     ??OnCommand_16:
   \   0000018A   0x2001             MOVS     R0,#+1
   \   0000018C   0x.... 0x....      BL       CurrentInputStatus
   \   00000190   0x2003             MOVS     R0,#+3
   \   00000192   0x.... 0x....      BL       TimeOverCheck
   \   00000196   0xB118             CBZ.N    R0,??OnCommand_18
   \   00000198   0x4629             MOV      R1,R5
   \   0000019A   0x.... 0x....      ADR.W    R0,`?<Constant "%s Test TimeOut\\n">`
   \   0000019E   0xE03A             B.N      ??OnCommand_11
   \                     ??OnCommand_18:
   \   000001A0   0xA900             ADD      R1,SP,#+0
   \   000001A2   0x2001             MOVS     R0,#+1
   \   000001A4   0x6822             LDR      R2,[R4, #+0]
   \   000001A6   0x6852             LDR      R2,[R2, #+4]
   \   000001A8   0x4790             BLX      R2
   \   000001AA   0x2800             CMP      R0,#+0
   \   000001AC   0xD0E9             BEQ.N    ??OnCommand_17
   \   000001AE   0x6820             LDR      R0,[R4, #+0]
   \   000001B0   0x6880             LDR      R0,[R0, #+8]
   \   000001B2   0x4780             BLX      R0
   \   000001B4   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   000001B8   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   000001BC   0x2863             CMP      R0,#+99
   \   000001BE   0xBF18             IT       NE 
   \   000001C0   0x2843             CMPNE    R0,#+67
   \   000001C2   0xBF04             ITT      EQ 
   \   000001C4   0x4629             MOVEQ    R1,R5
   \   000001C6   0x.... 0x....      ADREQ.W  R0,`?<Constant "%s Test Canceled\\n">`
   \   000001CA   0xD04A             BEQ.N    ??OnCommand_12
   \   000001CC   0x2866             CMP      R0,#+102
   \   000001CE   0xBF18             IT       NE 
   \   000001D0   0x2846             CMPNE    R0,#+70
   \   000001D2   0xD1D6             BNE.N    ??OnCommand_17
   \   000001D4   0x4629             MOV      R1,R5
   \   000001D6   0x.... 0x....      ADR.W    R0,`?<Constant "%s Test Finished\\n">`
   \   000001DA   0xE042             B.N      ??OnCommand_12
   1015          						/////////////////////////////////////////////////////////////
   1016          					}
   1017          				}
   1018          			}
   1019          		break;
   1020          		
   1021          		case 'C':
   1022          		case 'c':
   1023          			{
   1024          				char *tstmsg = "COM 시험";
   1025          				
   1026          				if(SavetoTestBackup(CommTest, SET, NULL) == SET)
   1027          				{
   1028          					tdata = returnmsgTest(tstmsg);
   1029          				}
   1030          
   1031          				if(tdata)
   1032          				{
   1033          					INT16U nCnt;
   1034          	
   1035          					SerPtr->printf("\n* [%s TEST START TimeOut 5Min]\n", tstmsg);
   \                     ??OnCommand_2:
   \   000001DC   0x.... 0x....      ADR.W    R5,`?<Constant "COM \\275\\303\\307\\350">`
   \   000001E0   0x.... 0x....      LDR.W    R4,??DataTable121
   \   000001E4   0x4629             MOV      R1,R5
   \   000001E6   0x.... 0x....      ADR.W    R0,`?<Constant "\\n* [%s TEST START Tim...">`
   \   000001EA   0x6822             LDR      R2,[R4, #+0]
   \   000001EC   0x6912             LDR      R2,[R2, #+16]
   \   000001EE   0x4790             BLX      R2
   1036          	
   1037          					TimerRegist(TimerTest, Time1Sec*60L*5L);
   \   000001F0   0x.... 0x....      LDR.W    R1,??DataTable118_4  ;; 0x493e0
   \   000001F4   0x2003             MOVS     R0,#+3
   \   000001F6   0x.... 0x....      BL       TimerRegist
   \   000001FA   0xE003             B.N      ??OnCommand_19
   1038          	
   1039          					while(1)
   1040          					{
   1041          						COMTestFunc();
   1042          						if(TimeOverCheck(TimerTest))
   1043          						{
   1044          							SerPtr->printf("%s test Test TimeOut\n", tstmsg);
   1045          							TimerRegist(TimerTest, Time1Sec);
   1046          							break;
   1047          						}
   1048          	
   1049          						if(SerPtr->CheckByte(1, &nCnt))
   1050          						{
   1051          							nCnt = SerPtr->RxGetByte();
   1052          							if(nCnt == 'C' || nCnt == 'c')
   1053          							{
   1054          								SerPtr->printf("%s test Test Canceled\n", tstmsg);
   1055          								break;
   1056          							}
   1057          							else if(nCnt == 'F' || nCnt == 'f')
   1058          							{
   1059          								
   1060          								SerPtr->printf("%s Test Test Finished\n", tstmsg);
   1061          								SavetoTestBackup(CommTest, SET, SET);
   1062          								break;
   1063          							}
   1064          						}
   1065          						OSTimeDly(2000L);
   \                     ??OnCommand_20:
   \   000001FC   0xF44F 0x60FA      MOV      R0,#+2000
   \   00000200   0x.... 0x....      BL       OSTimeDly
   \                     ??OnCommand_19:
   \   00000204   0x.... 0x....      BL       COMTestFunc
   \   00000208   0x2003             MOVS     R0,#+3
   \   0000020A   0x.... 0x....      BL       TimeOverCheck
   \   0000020E   0xB158             CBZ.N    R0,??OnCommand_21
   \   00000210   0x4629             MOV      R1,R5
   \   00000212   0x.... 0x....      ADR.W    R0,`?<Constant "%s test Test TimeOut\\n">`
   \                     ??OnCommand_11:
   \   00000216   0x6822             LDR      R2,[R4, #+0]
   \   00000218   0x6912             LDR      R2,[R2, #+16]
   \   0000021A   0x4790             BLX      R2
   \   0000021C   0xF44F 0x717A      MOV      R1,#+1000
   \   00000220   0x2003             MOVS     R0,#+3
   \   00000222   0x.... 0x....      BL       TimerRegist
   \   00000226   0xE04D             B.N      ??OnCommand_7
   \                     ??OnCommand_21:
   \   00000228   0xA900             ADD      R1,SP,#+0
   \   0000022A   0x2001             MOVS     R0,#+1
   \   0000022C   0x6822             LDR      R2,[R4, #+0]
   \   0000022E   0x6852             LDR      R2,[R2, #+4]
   \   00000230   0x4790             BLX      R2
   \   00000232   0x2800             CMP      R0,#+0
   \   00000234   0xD0E2             BEQ.N    ??OnCommand_20
   \   00000236   0x6820             LDR      R0,[R4, #+0]
   \   00000238   0x6880             LDR      R0,[R0, #+8]
   \   0000023A   0x4780             BLX      R0
   \   0000023C   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000240   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000244   0x2843             CMP      R0,#+67
   \   00000246   0xBF18             IT       NE 
   \   00000248   0x2863             CMPNE    R0,#+99
   \   0000024A   0xBF04             ITT      EQ 
   \   0000024C   0x4629             MOVEQ    R1,R5
   \   0000024E   0x.... 0x....      ADREQ.W  R0,`?<Constant "%s test Test Canceled\\n">`
   \   00000252   0xD006             BEQ.N    ??OnCommand_12
   \   00000254   0x2846             CMP      R0,#+70
   \   00000256   0xBF18             IT       NE 
   \   00000258   0x2866             CMPNE    R0,#+102
   \   0000025A   0xD1CF             BNE.N    ??OnCommand_20
   \   0000025C   0x4629             MOV      R1,R5
   \   0000025E   0x.... 0x....      ADR.W    R0,`?<Constant "%s Test Test Finished\\n">`
   \                     ??OnCommand_12:
   \   00000262   0x6822             LDR      R2,[R4, #+0]
   \   00000264   0x6912             LDR      R2,[R2, #+16]
   \   00000266   0x4790             BLX      R2
   \   00000268   0xE02C             B.N      ??OnCommand_7
   1066          					}
   1067          				}
   1068          			}
   1069          		break;
   1070          
   1071          		case 'G':
   1072          		case 'g':
   1073          			DownloadFlagClr();
   \                     ??OnCommand_3:
   \   0000026A   0x.... 0x....      BL       DownloadFlagClr
   1074          			ForDelay(20L);
   \   0000026E   0x2014             MOVS     R0,#+20
   \   00000270   0x.... 0x....      BL       ForDelay
   1075          			DownLoadBootingJump();
   \   00000274   0x.... 0x....      BL       DownLoadBootingJump
   1076          		break;
   \   00000278   0xE024             B.N      ??OnCommand_7
   1077          
   1078          		case 'E':
   1079          		case 'e':
   1080          #if 0      
   1081          		{
   1082          			EE_TABLE1 *ptr = &gEE_TABLE1;
   1083          			INT32U AddrOffset = vEE_TABLE1Addr + (INT32U)&(ptr->BdTestBp) - (INT32U )&gEE_TABLE1;
   1084          
   1085          			if(SavetoTestBackup(EepromTest, SET, NULL) == SET)
   1086          			{
   1087          				char *tstmsg = "EEPROM(AT24C64) 시험";
   1088          				tdata = returnmsgTest(tstmsg);
   1089          			}
   1090          
   1091          			if(tdata)
   1092          			{
   1093          				WriteEEprom(At24cDevID, AddrOffset + EepromResult, 'e', 0);
   1094          				tdata = ReadEEprom(At24cDevID, AddrOffset + EepromResult, 0);
   1095          
   1096          				SerPtr->printf("\n\nWriting 24C64_Addr[%d] = 'e' -> ", AddrOffset);
   1097          				if(tdata == 'e'){
   1098          					SerPtr->printf("success read_data = [%c][0x%02x]\n\n", tdata, tdata);
   1099          					SavetoTestBackup(EepromTest, SET, SET);
   1100          				}
   1101          				else{
   1102          					SerPtr->printf("failed  read_data = [%d][0x%02x]\n\n", tdata, tdata);
   1103          					SavetoTestBackup(EepromTest, RESET, SET);
   1104          				}
   1105          			}
   1106          		}
   1107          #endif       
   1108          		break;		
   1109          		case 'S':
   1110          		case 's':
   1111          		#if 1	
   1112          			{
   1113          				u8 *tptr = (u8 *)(Bank1_SRAM1_ADDR + (256*1024));
   1114          				INT32U i = 0;
   \                     ??OnCommand_6:
   \   0000027A   0x2500             MOVS     R5,#+0
   1115          				SerPtr->printf("\n");
   \   0000027C   0x.... 0x....      LDR.W    R4,??DataTable121
   \   00000280   0x....             ADR.N    R6,??DataTable118  ;; "\n"
   \   00000282   0x4630             MOV      R0,R6
   \   00000284   0x6821             LDR      R1,[R4, #+0]
   \   00000286   0x6909             LDR      R1,[R1, #+16]
   \   00000288   0x4788             BLX      R1
   1116          				
   1117          				for(i = 0; i < (256*1024); i++)
   \   0000028A   0x.... 0x....      LDR.W    R7,??DataTable119_6  ;; 0x60040000
   \   0000028E   0x.... 0x....      ADR.W    R8,??DataTable118_1  ;; "."
   1118          				{
   1119          					tptr[i] = (INT8U)i;
   \                     ??OnCommand_22:
   \   00000292   0x703D             STRB     R5,[R7, #+0]
   1120          					
   1121          					if((INT8U)i != tptr[i])
   1122          					{
   1123          						SerPtr->printf("\n      RAM TEST ERROR \n");
   1124          //						SavetoTestBackup(SramTest,  NULL, SET);
   1125          						break;
   1126          					}
   1127          					if((i%1024) == 0)
   \   00000294   0x05A8             LSLS     R0,R5,#+22
   \   00000296   0xD106             BNE.N    ??OnCommand_23
   1128          					{
   1129          						OSTimeDly(10);
   \   00000298   0x200A             MOVS     R0,#+10
   \   0000029A   0x.... 0x....      BL       OSTimeDly
   1130          						SerPtr->printf(".");
   \   0000029E   0x4640             MOV      R0,R8
   \   000002A0   0x6821             LDR      R1,[R4, #+0]
   \   000002A2   0x6909             LDR      R1,[R1, #+16]
   \   000002A4   0x4788             BLX      R1
   1131          //						SerPtr->printf("[%x][%x]:[%x][%d]\n",(u32)&nCS15,__pAPBK_SRAMAddr,i,*(vu8 *)(&nCS10 + i + (256*1024)));
   1132          
   1133          					}
   1134          				}
   \                     ??OnCommand_23:
   \   000002A6   0x1C6D             ADDS     R5,R5,#+1
   \   000002A8   0x1C7F             ADDS     R7,R7,#+1
   \   000002AA   0xF5B5 0x2F80      CMP      R5,#+262144
   \   000002AE   0xD3F0             BCC.N    ??OnCommand_22
   1135          				if(i == (256*1024)){
   \   000002B0   0xD104             BNE.N    ??OnCommand_24
   1136          					SerPtr->printf("\n      RAM TEST OK!!\n");
   \   000002B2   0x.... 0x....      ADR.W    R0,`?<Constant "\\n      RAM TEST OK!!\\n">`
   \   000002B6   0x6821             LDR      R1,[R4, #+0]
   \   000002B8   0x6909             LDR      R1,[R1, #+16]
   \   000002BA   0x4788             BLX      R1
   1137          //					SavetoTestBackup(SramTest,  SET, SET);
   1138          				}
   1139          				SerPtr->printf("\n");
   \                     ??OnCommand_24:
   \   000002BC   0x4630             MOV      R0,R6
   \   000002BE   0x6821             LDR      R1,[R4, #+0]
   \   000002C0   0x6909             LDR      R1,[R1, #+16]
   \   000002C2   0x4788             BLX      R1
   1140          			}
   1141          		#endif
   1142          		
   1143          		break;
   1144          
   1145          
   1146          		
   1147          		break;
   1148          
   1149          
   1150          		
   1151          #if 0
   1152          		case 'T':
   1153          		case 't':
   1154          		#if 1
   1155          			{
   1156          				INT32U i = 0;
   1157          			//	DevSPIxStr *Devptr = &FPGASpi;
   1158          				INT8U tmp;
   1159          			
   1160          #define DUMPSIZE	200			
   1161          						INT8U tmpData[DUMPSIZE];
   1162          //						INT8U tmpData1[DUMPSIZE]= {0,};
   1163          						
   1164          				for(i = 0; i < DUMPSIZE; i++)
   1165          				{
   1166          	//				tmpData[i] = 2;
   1167          				}
   1168          		#if 1
   1169          				tmpData[0] =0x19;
   1170           				tmpData[1] =0x38;
   1171            				tmpData[2] =0x57;
   1172           				tmpData[3] =0x76;
   1173          		#endif
   1174          //				sFLASH_CS0_BL4kCheckErase(sFLASH_APPLAddr + DUMPSIZE, DUMPSIZE);
   1175          
   1176          				sFLASH_CS0_BL4kCheckErase(sFLASH_APPLAddr, DUMPSIZE);
   1177          //				sFLASH_CS0_4kErase(0);
   1178          				OSTimeDly(1);
   1179          
   1180          				sFLASH_CS0_DataWrite(sFLASH_APPLAddr, tmpData, DUMPSIZE);
   1181          			
   1182          				OSTimeDly(1);
   1183          
   1184          //				sFLASH_CS0_BufferRead(sFLASH_APPLAddr, tmpData1, DUMPSIZE);
   1185          				for(i = 0; i < DUMPSIZE; i++)
   1186          				{
   1187          					tmp = sFLASH_CS0_DataRead(sFLASH_APPLAddr + i);
   1188          					SerPtr->printf("[%x]",tmp);
   1189          				}
   1190          			}
   1191          			SerPtr->printf("\n");
   1192          		#endif
   1193          
   1194          		
   1195          		break;
   1196          
   1197          		case 'P':
   1198          		case 'p':
   1199          			{
   1200          				INT32U i = 0;
   1201          				INT8U tmp;
   1202          
   1203          				for(i = 0; i < DUMPSIZE; i++)
   1204          				{
   1205          					tmp = sFLASH_CS0_DataRead(sFLASH_APPLAddr + i);
   1206          					SerPtr->printf("[%x]",tmp);
   1207          				}
   1208          			
   1209          			}
   1210          			SerPtr->printf("\n");
   1211          
   1212          		break;
   1213          
   1214          		
   1215          		case 'F':
   1216          		case 'f':
   1217          			if(tRevData[1] == ' ') AdditionalOnCommand((INT8U *)&tRevData[2]);
   1218          		break;
   1219          
   1220          
   1221          		case 'D':
   1222          		case 'd':
   1223          			if(tRevData[1] == ' ') DtuAdditionalOnCommand((INT8U *)&tRevData[2]);
   1224          		break;
   1225          #endif		
   1226          
   1227          		default:
   1228          		break;
   1229          
   1230          	}
   1231          	PromptOut();
   \                     ??OnCommand_7:
   \   000002C4   0x.... 0x....      BL       PromptOut
   1232          }
   \   000002C8   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
   1233           
   1234          

   \                                 In section .text, align 2, keep-with-next
   1235          void AdInputStatus(void)
   1236          {
   \                     AdInputStatus:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   1237          ////////////////////////////////////////////////////////////////////////////////
   1238          	if(ADC_CheckFinish(ADC_Channel_0))		ADC_ChannelEnable(ADC_Channel_0);
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x.... 0x....      BL       ADC_CheckFinish
   \   0000000A   0xB110             CBZ.N    R0,??AdInputStatus_0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x.... 0x....      BL       ADC_ChannelEnable
   1239          	if(ADC_CheckFinish(ADC_Channel_1))		ADC_ChannelEnable(ADC_Channel_1);
   \                     ??AdInputStatus_0:
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x.... 0x....      BL       ADC_CheckFinish
   \   00000018   0xB110             CBZ.N    R0,??AdInputStatus_1
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0x.... 0x....      BL       ADC_ChannelEnable
   1240          
   1241          //	SerPtr->printf("ADC_Channel_0[%04d]\n", 	ADC_DATA1[FwdOutAvgVolt_2G],	ADC_DATA1[RvsOutVolt_2G],ADC_DATA1[FwdOutAvgVolt_LTE],ADC_DATA1[RvsOutVolt_LTE]);	
   1242          
   1243          //	Data = AdctoVolt5opamp(ADC_AVR[adcFWDPWRdect_3G][0]);
   1244          
   1245          	PrintStar();
   \                     ??AdInputStatus_1:
   \   00000020   0x.... 0x....      BL       PrintStar
   1246          	
   1247          	ADC_Select(0);
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      BL       ADC_Select
   1248          
   1249          #if 1
   1250          	{
   1251          
   1252          //		INT16S Data, tmpx;
   1253                  INT16S Data;
   1254                  
   1255          //		Data = AdctoVolt33V(ADC_SUM[ADC_Channel_14]);
   1256          		Data = AdctoVolt33V(ADC_AVR[ADC_Channel_0][0]);
   \   0000002A   0x.... 0x....      LDR.W    R5,??DataTable123_5
   \   0000002E   0x6828             LDR      R0,[R5, #+0]
   \   00000030   0x8800             LDRH     R0,[R0, #+0]
   \   00000032   0x.... 0x....      BL       AdctoVolt33V
   \   00000036   0xB207             SXTH     R7,R0
   1257          		SerPtr->printf(STARMSG);
   \   00000038   0x.... 0x....      LDR.W    R4,??DataTable121
   \   0000003C   0x....             ADR.N    R6,??DataTable119  ;; 0x2A, 0x20, 0x00, 0x00
   \   0000003E   0x4630             MOV      R0,R6
   \   00000040   0x6821             LDR      R1,[R4, #+0]
   \   00000042   0x6909             LDR      R1,[R1, #+16]
   \   00000044   0x4788             BLX      R1
   1258          		SerPtr->printf("[AIN0] : %d.%03d[V]\n", Data/1000, Data%1000);
   \   00000046   0xF44F 0x787A      MOV      R8,#+1000
   \   0000004A   0xFB97 0xF1F8      SDIV     R1,R7,R8
   \   0000004E   0xFB08 0x7211      MLS      R2,R8,R1,R7
   \   00000052   0x.... 0x....      ADR.W    R0,`?<Constant "[AIN0] : %d.%03d[V]\\n">`
   \   00000056   0x6823             LDR      R3,[R4, #+0]
   \   00000058   0x691B             LDR      R3,[R3, #+16]
   \   0000005A   0x4798             BLX      R3
   1259          
   1260          		Data = AdctoVolt33V(ADC_AVR[ADC_Channel_1][0]);
   \   0000005C   0x6868             LDR      R0,[R5, #+4]
   \   0000005E   0x8800             LDRH     R0,[R0, #+0]
   \   00000060   0x.... 0x....      BL       AdctoVolt33V
   \   00000064   0xB205             SXTH     R5,R0
   1261          		SerPtr->printf(STARMSG);
   \   00000066   0x4630             MOV      R0,R6
   \   00000068   0x6821             LDR      R1,[R4, #+0]
   \   0000006A   0x6909             LDR      R1,[R1, #+16]
   \   0000006C   0x4788             BLX      R1
   1262          		SerPtr->printf("[AIN1] : %d.%03d[V]\n", Data/1000, Data%1000);
   \   0000006E   0xFB95 0xF1F8      SDIV     R1,R5,R8
   \   00000072   0xFB08 0x5211      MLS      R2,R8,R1,R5
   \   00000076   0x.... 0x....      ADR.W    R0,`?<Constant "[AIN1] : %d.%03d[V]\\n">`
   \   0000007A   0x6823             LDR      R3,[R4, #+0]
   \   0000007C   0x691B             LDR      R3,[R3, #+16]
   \   0000007E   0x4798             BLX      R3
   1263          
   1264          #if 0 
   1265          		Data = (ADC_AVR[ADC_Channel_15][0]);
   1266          		tmpx = ReadEnvTempTable(Data);
   1267          		SerPtr->printf(STARMSG);
   1268          		SerPtr->printf("TEMP                   : %d.%03d[V], %d['C]\n", Data/1000, Data%1000, tmpx/10);
   1269          #endif
   1270          		
   1271          		OSTimeDly(30L);
   \   00000080   0x201E             MOVS     R0,#+30
   \   00000082   0x.... 0x....      BL       OSTimeDly
   1272          
   1273          	}
   1274          #endif
   1275          
   1276          	SerPtr->printf("\n\n");
   \   00000086   0x....             ADR.N    R0,??DataTable119_1  ;; 0x0A, 0x0A, 0x00, 0x00
   \   00000088   0x6821             LDR      R1,[R4, #+0]
   \   0000008A   0x6909             LDR      R1,[R1, #+16]
   \   0000008C   0x4788             BLX      R1
   1277          	
   1278          	PrintStar();
   \   0000008E   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000092   0x.... 0x....      B.W      PrintStar
   1279          }
   1280          
   1281          
   1282          
   1283          

   \                                 In section .text, align 2, keep-with-next
   1284          void AdcPrintf(char *sptr, INT16U rawData, INT8U is_5V)
   1285          {
   \                     AdcPrintf:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460F             MOV      R7,R1
   1286          	INT16U Data=0;
   1287          	if(is_5V) 	Data = AdctoVolt5opamp(rawData);
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0x4638             MOV      R0,R7
   \   0000000A   0xD002             BEQ.N    ??AdcPrintf_0
   \   0000000C   0x.... 0x....      BL       AdctoVolt5opamp
   \   00000010   0xE001             B.N      ??AdcPrintf_1
   1288          	else		Data = AdctoVolt33V(rawData);
   \                     ??AdcPrintf_0:
   \   00000012   0x.... 0x....      BL       AdctoVolt33V
   \                     ??AdcPrintf_1:
   \   00000016   0x4606             MOV      R6,R0
   1289          	
   1290          	SerPtr->printf(STARMSG);
   \   00000018   0x.... 0x....      LDR.W    R5,??DataTable121
   \   0000001C   0x....             ADR.N    R0,??DataTable119  ;; 0x2A, 0x20, 0x00, 0x00
   \   0000001E   0x6829             LDR      R1,[R5, #+0]
   \   00000020   0x6909             LDR      R1,[R1, #+16]
   \   00000022   0x4788             BLX      R1
   1291          	SerPtr->printf("%s: %d.%d[V], [raw:%04d]", sptr, Data/10, Data%10, rawData);
   \   00000024   0x200A             MOVS     R0,#+10
   \   00000026   0xFB96 0xF2F0      SDIV     R2,R6,R0
   \   0000002A   0x9700             STR      R7,[SP, #+0]
   \   0000002C   0xEB02 0x0082      ADD      R0,R2,R2, LSL #+2
   \   00000030   0xEBA6 0x0340      SUB      R3,R6,R0, LSL #+1
   \   00000034   0x4621             MOV      R1,R4
   \   00000036   0x.... 0x....      ADR.W    R0,`?<Constant "%s: %d.%d[V], [raw:%04d]">`
   \   0000003A   0x682C             LDR      R4,[R5, #+0]
   \   0000003C   0x6924             LDR      R4,[R4, #+16]
   \   0000003E   0x47A0             BLX      R4
   1292          	SerPtr->printf(ENTMSG);
   \   00000040   0x....             ADR.N    R0,??DataTable118  ;; "\n"
   \   00000042   0x6829             LDR      R1,[R5, #+0]
   \   00000044   0x6909             LDR      R1,[R1, #+16]
   \   00000046   0xE8BD 0x40F4      POP      {R2,R4-R7,LR}
   \   0000004A   0x4708             BX       R1
   1293          }
   1294          
   1295          
   1296          
   1297          

   \                                 In section .bss, align 4
   1298          INT32U comtstcnt = 0;
   \                     comtstcnt:
   \   00000000                      DS8 4
   1299          

   \                                 In section .text, align 2, keep-with-next
   1300          void COMTestFunc(void)
   1301          {
   \                     COMTestFunc:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   1302          	INT16U Recv;
   1303          
   1304          	{
   1305          		pUSART1.printf(STARMSG);
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable123_6
   \   00000008   0x....             ADR.N    R0,??DataTable119  ;; 0x2A, 0x20, 0x00, 0x00
   \   0000000A   0x6921             LDR      R1,[R4, #+16]
   \   0000000C   0x4788             BLX      R1
   1306          		pUSART1.printf("통신시험 Ser4[MODEM] 시험을 체크하여 주세요     ");
   \   0000000E   0x.... 0x....      ADR.W    R0,`?<Constant "\\305\\353\\275\\305\\275\\303\\307\\350 S`
   \   00000012   0x6921             LDR      R1,[R4, #+16]
   \   00000014   0x4788             BLX      R1
   1307          		pUSART4.BuffClear();
   \   00000016   0x.... 0x....      LDR.W    R6,??DataTable123_7
   \   0000001A   0x6A30             LDR      R0,[R6, #+32]
   \   0000001C   0x4780             BLX      R0
   1308          		pUSART4.PutToBuffer(comtstcnt & 0x0f);		
   \   0000001E   0x.... 0x....      LDR.W    R5,??DataTable123_8
   \   00000022   0x7828             LDRB     R0,[R5, #+0]
   \   00000024   0xF000 0x000F      AND      R0,R0,#0xF
   \   00000028   0x69B1             LDR      R1,[R6, #+24]
   \   0000002A   0x4788             BLX      R1
   1309          
   1310          		OSTimeDly(100L);
   \   0000002C   0x2064             MOVS     R0,#+100
   \   0000002E   0x.... 0x....      BL       OSTimeDly
   1311          
   1312          		if(pUSART4.CheckByte(1, &Recv))
   \   00000032   0xA900             ADD      R1,SP,#+0
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x6872             LDR      R2,[R6, #+4]
   \   00000038   0x4790             BLX      R2
   \   0000003A   0xB168             CBZ.N    R0,??COMTestFunc_0
   1313          		{
   1314          			if( pUSART4.RxGetByte() == (comtstcnt & 0x0f)// &&
   1315          				//pUSART3.RxGetByte() == 'b' &&
   1316          				//pUSART3.RxGetByte() == 'i' &&
   1317          				//pUSART3.RxGetByte() == 'z' &&
   1318          				//pUSART3.RxGetByte() == 'i'
   1319          				)
   \   0000003C   0x68B0             LDR      R0,[R6, #+8]
   \   0000003E   0x4780             BLX      R0
   \   00000040   0x6921             LDR      R1,[R4, #+16]
   \   00000042   0x782A             LDRB     R2,[R5, #+0]
   \   00000044   0xF002 0x020F      AND      R2,R2,#0xF
   \   00000048   0x4290             CMP      R0,R2
   \   0000004A   0xBF0C             ITE      EQ 
   \   0000004C   0x.... 0x....      ADREQ.W  R0,`?<Constant "[OK]">`
   \   00000050   0x.... 0x....      ADRNE.W  R0,`?<Constant "[FAIL 1]">`
   1320          						pUSART1.printf("[OK]");
   1321          			else		pUSART1.printf("[FAIL 1]");
   \   00000054   0x4788             BLX      R1
   \   00000056   0xE005             B.N      ??COMTestFunc_1
   1322          		}
   1323          		else pUSART1.printf("[FAIL 2]: %d", Recv);
   \                     ??COMTestFunc_0:
   \   00000058   0xF8BD 0x1000      LDRH     R1,[SP, #+0]
   \   0000005C   0x.... 0x....      ADR.W    R0,`?<Constant "[FAIL 2]: %d">`
   \   00000060   0x6922             LDR      R2,[R4, #+16]
   \   00000062   0x4790             BLX      R2
   1324          		pUSART1.printf(ENTMSG);
   \                     ??COMTestFunc_1:
   \   00000064   0x....             ADR.N    R6,??DataTable118  ;; "\n"
   \   00000066   0x4630             MOV      R0,R6
   \   00000068   0x6921             LDR      R1,[R4, #+16]
   \   0000006A   0x4788             BLX      R1
   1325          	}
   1326          		
   1327          
   1328          	pUSART1.printf(ENTMSG);
   \   0000006C   0x4630             MOV      R0,R6
   \   0000006E   0x6921             LDR      R1,[R4, #+16]
   \   00000070   0x4788             BLX      R1
   1329          	pUSART1.printf(ENTMSG);
   \   00000072   0x4630             MOV      R0,R6
   \   00000074   0x6921             LDR      R1,[R4, #+16]
   \   00000076   0x4788             BLX      R1
   1330          	comtstcnt++;
   \   00000078   0x6828             LDR      R0,[R5, #+0]
   \   0000007A   0x1C40             ADDS     R0,R0,#+1
   \   0000007C   0x6028             STR      R0,[R5, #+0]
   1331          }
   \   0000007E   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   1332          

   \                                 In section .text, align 2, keep-with-next
   1333          void CurrentInputStatus(INT8U vcheck)
   1334          {
   \                     CurrentInputStatus:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4604             MOV      R4,R0
   1335          	INT8U tcnt = 0;
   1336          	INT8U tval = FALSE;
   1337          	
   1338          //	INT8U tmpData;
   1339          
   1340              tcnt = tcnt;
   1341          
   1342          	__PC15_IN_PU();				// F_DONE
   \   00000008   0x.... 0x....      LDR.W    R6,??DataTable123_9  ;; 0x40020800
   \   0000000C   0x230F             MOVS     R3,#+15
   \   0000000E   0x4632             MOV      R2,R6
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x2040             MOVS     R0,#+64
   \   00000014   0x.... 0x....      BL       GPIOPortInit
   1343          
   1344          //	tmpData = F_DONE;
   1345          //	SerPtr->printf("F_DONE[%d]\n",tmpData);
   1346          
   1347          	if(!vcheck)PrintStar();
   \   00000018   0xB90C             CBNZ.N   R4,??CurrentInputStatus_0
   \   0000001A   0x.... 0x....      BL       PrintStar
   1348          	{
   1349          #if 0
   1350          		tval += DigitalInputDiplay(tcnt++, _4G_PLL_LD, STARMSG, NULL, vcheck);
   1351          		tval += DigitalInputDiplay(tcnt++, _3G_PLL_LD, PHAMSG, ENTMSG, vcheck);
   1352          #endif
   1353          		tval += DigitalInputDiplay(tcnt++, AC_Alarm, STARMSG, NULL, vcheck);
   \                     ??CurrentInputStatus_0:
   \   0000001E   0x....             ADR.N    R5,??DataTable119  ;; 0x2A, 0x20, 0x00, 0x00
   \   00000020   0x9400             STR      R4,[SP, #+0]
   \   00000022   0x2300             MOVS     R3,#+0
   \   00000024   0x462A             MOV      R2,R5
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable123_10  ;; 0x40021810
   \   0000002A   0x6800             LDR      R0,[R0, #+0]
   \   0000002C   0xF3C0 0x1180      UBFX     R1,R0,#+6,#+1
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      BL       DigitalInputDiplay
   \   00000036   0x4682             MOV      R10,R0
   1354          		tval += DigitalInputDiplay(tcnt++, PLLAlarm_CDMALTE, PHAMSG, NULL, vcheck);
   \   00000038   0x....             ADR.N    R7,??DataTable119_4  ;; 0x2C, 0x20, 0x00, 0x00
   \   0000003A   0x9400             STR      R4,[SP, #+0]
   \   0000003C   0x2300             MOVS     R3,#+0
   \   0000003E   0x463A             MOV      R2,R7
   \   00000040   0x6930             LDR      R0,[R6, #+16]
   \   00000042   0xF3C0 0x1180      UBFX     R1,R0,#+6,#+1
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x.... 0x....      BL       DigitalInputDiplay
   \   0000004C   0x9001             STR      R0,[SP, #+4]
   \   0000004E   0x9400             STR      R4,[SP, #+0]
   \   00000050   0x....             ADR.N    R3,??DataTable119_5  ;; "\n"
   \   00000052   0x463A             MOV      R2,R7
   \   00000054   0x6930             LDR      R0,[R6, #+16]
   \   00000056   0x0A00             LSRS     R0,R0,#+8
   \   00000058   0xF000 0x0101      AND      R1,R0,#0x1
   \   0000005C   0x2002             MOVS     R0,#+2
   1355          		tval += DigitalInputDiplay(tcnt++, PLLAlarm_LTE_A2, PHAMSG, ENTMSG, vcheck);
   \   0000005E   0x.... 0x....      BL       DigitalInputDiplay
   \   00000062   0x4680             MOV      R8,R0
   1356          
   1357          
   1358          		tval += DigitalInputDiplay(tcnt++, PLLAlarm_WCDMA, STARMSG, NULL, vcheck);
   \   00000064   0x9400             STR      R4,[SP, #+0]
   \   00000066   0x2300             MOVS     R3,#+0
   \   00000068   0x462A             MOV      R2,R5
   \   0000006A   0x6930             LDR      R0,[R6, #+16]
   \   0000006C   0xF3C0 0x11C0      UBFX     R1,R0,#+7,#+1
   \   00000070   0x2003             MOVS     R0,#+3
   \   00000072   0x.... 0x....      BL       DigitalInputDiplay
   \   00000076   0x4681             MOV      R9,R0
   1359          		tval += DigitalInputDiplay(tcnt++, F_DONE, PHAMSG, ENTMSG, vcheck);
   \   00000078   0x9400             STR      R4,[SP, #+0]
   \   0000007A   0x....             ADR.N    R3,??DataTable119_5  ;; "\n"
   \   0000007C   0x463A             MOV      R2,R7
   \   0000007E   0x6930             LDR      R0,[R6, #+16]
   \   00000080   0x0BC0             LSRS     R0,R0,#+15
   \   00000082   0xF000 0x0101      AND      R1,R0,#0x1
   \   00000086   0x2004             MOVS     R0,#+4
   \   00000088   0x.... 0x....      BL       DigitalInputDiplay
   \   0000008C   0x4606             MOV      R6,R0
   1360          
   1361          		tval += DigitalInputDiplay(tcnt++, _DTU_Insert, STARMSG, NULL, vcheck);
   \   0000008E   0x9400             STR      R4,[SP, #+0]
   \   00000090   0x2300             MOVS     R3,#+0
   \   00000092   0x462A             MOV      R2,R5
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable123_11  ;; 0x40020010
   \   00000098   0x6800             LDR      R0,[R0, #+0]
   \   0000009A   0x0B00             LSRS     R0,R0,#+12
   \   0000009C   0xF000 0x0101      AND      R1,R0,#0x1
   \   000000A0   0x2005             MOVS     R0,#+5
   \   000000A2   0x.... 0x....      BL       DigitalInputDiplay
   \   000000A6   0x4605             MOV      R5,R0
   1362          		tval += DigitalInputDiplay(tcnt++, _DTU_Insert1, PHAMSG, NULL, vcheck);
   \   000000A8   0x9400             STR      R4,[SP, #+0]
   \   000000AA   0x2300             MOVS     R3,#+0
   \   000000AC   0x463A             MOV      R2,R7
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable123_12  ;; 0x40020410
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0x0A00             LSRS     R0,R0,#+8
   \   000000B6   0xF000 0x0101      AND      R1,R0,#0x1
   \   000000BA   0x2006             MOVS     R0,#+6
   \   000000BC   0x.... 0x....      BL       DigitalInputDiplay
   \   000000C0   0x4683             MOV      R11,R0
   1363          		tval += DigitalInputDiplay(tcnt++, _RF_Module_Insert, PHAMSG, NULL, vcheck);
   \   000000C2   0x9400             STR      R4,[SP, #+0]
   \   000000C4   0x2300             MOVS     R3,#+0
   \   000000C6   0x463A             MOV      R2,R7
   \   000000C8   0x.... 0x....      LDR.W    R0,??DataTable123_10  ;; 0x40021810
   \   000000CC   0x6840             LDR      R0,[R0, #+4]
   \   000000CE   0x0B00             LSRS     R0,R0,#+12
   \   000000D0   0xF000 0x0101      AND      R1,R0,#0x1
   \   000000D4   0x2007             MOVS     R0,#+7
   \   000000D6   0x.... 0x....      BL       DigitalInputDiplay
   1364          		tval += DigitalInputDiplay(tcnt++, _Ext_Module_Insert, PHAMSG, ENTMSG, vcheck);
   \   000000DA   0x9901             LDR      R1,[SP, #+4]
   \   000000DC   0x4451             ADD      R1,R1,R10
   \   000000DE   0x4441             ADD      R1,R8,R1
   \   000000E0   0x4449             ADD      R1,R9,R1
   \   000000E2   0x1871             ADDS     R1,R6,R1
   \   000000E4   0x1869             ADDS     R1,R5,R1
   \   000000E6   0x4459             ADD      R1,R11,R1
   \   000000E8   0x1845             ADDS     R5,R0,R1
   \   000000EA   0x9400             STR      R4,[SP, #+0]
   \   000000EC   0x....             ADR.N    R3,??DataTable119_5  ;; "\n"
   \   000000EE   0x463A             MOV      R2,R7
   \   000000F0   0x.... 0x....      LDR.W    R0,??DataTable123_10  ;; 0x40021810
   \   000000F4   0x6840             LDR      R0,[R0, #+4]
   \   000000F6   0x0BC0             LSRS     R0,R0,#+15
   \   000000F8   0xF000 0x0101      AND      R1,R0,#0x1
   \   000000FC   0x2008             MOVS     R0,#+8
   \   000000FE   0x.... 0x....      BL       DigitalInputDiplay
   \   00000102   0x1940             ADDS     R0,R0,R5
   1365          
   1366           	}
   1367          	
   1368          	if(!vcheck)PrintStar();
   \   00000104   0xB91C             CBNZ.N   R4,??CurrentInputStatus_1
   \   00000106   0xB003             ADD      SP,SP,#+12
   \   00000108   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   0000010C   0x....             B.N      PrintStar
   1369          	if(vcheck)
   1370          	{
   1371          		if(tval) SerPtr->printf("\n");
   \                     ??CurrentInputStatus_1:
   \   0000010E   0xB2C0             UXTB     R0,R0
   \   00000110   0xB140             CBZ.N    R0,??CurrentInputStatus_2
   \   00000112   0x....             ADR.N    R0,??DataTable119_5  ;; "\n"
   \   00000114   0x.... 0x....      LDR.W    R1,??DataTable121
   \   00000118   0x6809             LDR      R1,[R1, #+0]
   \   0000011A   0x6909             LDR      R1,[R1, #+16]
   \   0000011C   0xB003             ADD      SP,SP,#+12
   \   0000011E   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   00000122   0x4708             BX       R1
   1372          	}
   1373          }
   \                     ??CurrentInputStatus_2:
   \   00000124   0x....             B.N      ?Subroutine1

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0xB003             ADD      SP,SP,#+12
   \   00000002   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   1374          
   1375          
   1376          

   \                                 In section .text, align 4, keep-with-next
   1377          void HwTestOutFunc(INT32U *nFlag)
   1378          {
   \                     HwTestOutFunc:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   \   00000006   0x4604             MOV      R4,R0
   1379          #if 1
   1380          	INT32U MaxValue = 0xFFFF;
   \   00000008   0xF64F 0x70FF      MOVW     R0,#+65535
   \   0000000C   0x9000             STR      R0,[SP, #+0]
   1381          	INT8U Data = *nFlag;
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x9001             STR      R0,[SP, #+4]
   1382          
   1383          	INT8U i = 0;
   \   00000012   0x2500             MOVS     R5,#+0
   1384          
   1385          	PCA9555BitRst(GreenLED_CDMA, &AttnCS1Val);
   \   00000014   0x.... 0x....      LDR.W    R11,??DataTable123_13
   \   00000018   0x.... 0x....      LDR.W    R6,??DataTable123_14
   \   0000001C   0x2300             MOVS     R3,#+0
   \   0000001E   0x6832             LDR      R2,[R6, #+0]
   \   00000020   0x4659             MOV      R1,R11
   \   00000022   0x2049             MOVS     R0,#+73
   \   00000024   0x.... 0x....      BL       pPCA9555BitRst
   1386          	PCA9555BitRst(RedLED_CDMA,	&AttnCS1Val);
   \   00000028   0x462B             MOV      R3,R5
   \   0000002A   0x6832             LDR      R2,[R6, #+0]
   \   0000002C   0x4659             MOV      R1,R11
   \   0000002E   0x2041             MOVS     R0,#+65
   \   00000030   0x.... 0x....      BL       pPCA9555BitRst
   1387          	PCA9555BitRst(GreenLED_WCDMA, &AttnCS1Val);
   \   00000034   0x462B             MOV      R3,R5
   \   00000036   0x6832             LDR      R2,[R6, #+0]
   \   00000038   0x4659             MOV      R1,R11
   \   0000003A   0x2031             MOVS     R0,#+49
   \   0000003C   0x.... 0x....      BL       pPCA9555BitRst
   1388          	PCA9555BitRst(RedLED_WCDMA,	&AttnCS1Val);
   \   00000040   0x462B             MOV      R3,R5
   \   00000042   0x6832             LDR      R2,[R6, #+0]
   \   00000044   0x4659             MOV      R1,R11
   \   00000046   0x2029             MOVS     R0,#+41
   \   00000048   0x.... 0x....      BL       pPCA9555BitRst
   1389          	PCA9555BitRst(GreenLED_LTE, &AttnCS1Val);
   \   0000004C   0x462B             MOV      R3,R5
   \   0000004E   0x6832             LDR      R2,[R6, #+0]
   \   00000050   0x4659             MOV      R1,R11
   \   00000052   0x2059             MOVS     R0,#+89
   \   00000054   0x.... 0x....      BL       pPCA9555BitRst
   1390          	PCA9555BitRst(RedLED_LTE,	&AttnCS1Val);
   \   00000058   0x462B             MOV      R3,R5
   \   0000005A   0x6832             LDR      R2,[R6, #+0]
   \   0000005C   0x4659             MOV      R1,R11
   \   0000005E   0x2051             MOVS     R0,#+81
   \   00000060   0x.... 0x....      BL       pPCA9555BitRst
   1391          	PCA9555BitRst(GreenLED_LTE_A2, &AttnCS1Val);
   \   00000064   0x462B             MOV      R3,R5
   \   00000066   0x6832             LDR      R2,[R6, #+0]
   \   00000068   0x4659             MOV      R1,R11
   \   0000006A   0x2079             MOVS     R0,#+121
   \   0000006C   0x.... 0x....      BL       pPCA9555BitRst
   1392          	PCA9555BitRst(RedLED_LTE_A2,	&AttnCS1Val);
   \   00000070   0x462B             MOV      R3,R5
   \   00000072   0x6832             LDR      R2,[R6, #+0]
   \   00000074   0x4659             MOV      R1,R11
   \   00000076   0x2071             MOVS     R0,#+113
   \   00000078   0x.... 0x....      BL       pPCA9555BitRst
   1393          
   1394          	PCA9555BitRst(GreenLED_LTE_21, &AttnCS1Val);
   \   0000007C   0x462B             MOV      R3,R5
   \   0000007E   0x6832             LDR      R2,[R6, #+0]
   \   00000080   0x4659             MOV      R1,R11
   \   00000082   0x2069             MOVS     R0,#+105
   \   00000084   0x.... 0x....      BL       pPCA9555BitRst
   1395          	PCA9555BitRst(RedLED_LTE_21,   &AttnCS1Val);
   \   00000088   0x462B             MOV      R3,R5
   \   0000008A   0x6832             LDR      R2,[R6, #+0]
   \   0000008C   0x4659             MOV      R1,R11
   \   0000008E   0x2061             MOVS     R0,#+97
   \   00000090   0x.... 0x....      BL       pPCA9555BitRst
   1396          
   1397          
   1398          	DL_AmpOnOff_CDMALTE		= 0;
   \   00000094   0x.... 0x....      LDR.W    R7,??DataTable123_15  ;; 0x40021414
   \   00000098   0x6838             LDR      R0,[R7, #+0]
   \   0000009A   0xF020 0x0040      BIC      R0,R0,#0x40
   \   0000009E   0x6038             STR      R0,[R7, #+0]
   1399          	UL_AmpOnOff_CDMALTE		= 0;
   \   000000A0   0x6838             LDR      R0,[R7, #+0]
   \   000000A2   0xF020 0x0080      BIC      R0,R0,#0x80
   \   000000A6   0x6038             STR      R0,[R7, #+0]
   1400          	DL_AmpOnOff_LTEA		= 0;
   \   000000A8   0x6838             LDR      R0,[R7, #+0]
   \   000000AA   0xF420 0x7080      BIC      R0,R0,#0x100
   \   000000AE   0x6038             STR      R0,[R7, #+0]
   1401          	UL_AmpOnOff_LTEA		= 0;
   \   000000B0   0x6838             LDR      R0,[R7, #+0]
   \   000000B2   0xF420 0x7000      BIC      R0,R0,#0x200
   \   000000B6   0x6038             STR      R0,[R7, #+0]
   1402          	DL_AmpOnOff_WCDMA		= 0;
   \   000000B8   0x6838             LDR      R0,[R7, #+0]
   \   000000BA   0xF420 0x6080      BIC      R0,R0,#0x400
   \   000000BE   0x6038             STR      R0,[R7, #+0]
   1403          	UL_AmpOnOff_WCDMA		= 0;
   \   000000C0   0x6838             LDR      R0,[R7, #+0]
   \   000000C2   0xF420 0x6000      BIC      R0,R0,#0x800
   \   000000C6   0x6038             STR      R0,[R7, #+0]
   1404          
   1405          	PCA9555BitRst(Fwd_PLLEN_LTE,  &AttnCS1Val);
   \   000000C8   0x462B             MOV      R3,R5
   \   000000CA   0x6832             LDR      R2,[R6, #+0]
   \   000000CC   0x4659             MOV      R1,R11
   \   000000CE   0x2001             MOVS     R0,#+1
   \   000000D0   0x.... 0x....      BL       pPCA9555BitRst
   1406          	PCA9555BitRst(Rvs_PLLEN_LTE,  &AttnCS1Val);
   \   000000D4   0x462B             MOV      R3,R5
   \   000000D6   0x6832             LDR      R2,[R6, #+0]
   \   000000D8   0x4659             MOV      R1,R11
   \   000000DA   0x2009             MOVS     R0,#+9
   \   000000DC   0x.... 0x....      BL       pPCA9555BitRst
   1407          	PCA9555BitRst(PLLEN_LTE_A,	  &AttnCS1Val);
   \   000000E0   0x462B             MOV      R3,R5
   \   000000E2   0x6832             LDR      R2,[R6, #+0]
   \   000000E4   0x4659             MOV      R1,R11
   \   000000E6   0x2011             MOVS     R0,#+17
   \   000000E8   0x.... 0x....      BL       pPCA9555BitRst
   1408          	PCA9555BitRst(Fwd_PLLEN_WCDMA,&AttnCS1Val);
   \   000000EC   0x462B             MOV      R3,R5
   \   000000EE   0x6832             LDR      R2,[R6, #+0]
   \   000000F0   0x4659             MOV      R1,R11
   \   000000F2   0x2019             MOVS     R0,#+25
   \   000000F4   0x.... 0x....      BL       pPCA9555BitRst
   1409          	PLL_CLK					= 0;
   \   000000F8   0x.... 0x....      LDR.W    R8,??DataTable123_16  ;; 0x40020014
   \   000000FC   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000100   0xF420 0x4000      BIC      R0,R0,#0x8000
   \   00000104   0xF8C8 0x0000      STR      R0,[R8, #+0]
   1410          	PLL_DATA				= 0;
   \   00000108   0x.... 0x....      LDR.W    R9,??DataTable123_17  ;; 0x40020414
   \   0000010C   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   00000110   0xF020 0x0008      BIC      R0,R0,#0x8
   \   00000114   0xF8C9 0x0000      STR      R0,[R9, #+0]
   1411          	PCA9555BitRst(RVS_PLLEN_WCDMA,&AttnCS1Val);
   \   00000118   0x462B             MOV      R3,R5
   \   0000011A   0x6832             LDR      R2,[R6, #+0]
   \   0000011C   0x4659             MOV      R1,R11
   \   0000011E   0x2021             MOVS     R0,#+33
   \   00000120   0x.... 0x....      BL       pPCA9555BitRst
   1412          	
   1413          	SMS_PWR 			= 0;
   \   00000124   0x.... 0x....      LDR.W    R10,??DataTable123_18  ;; 0x40021814
   \   00000128   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   0000012C   0xF020 0x0080      BIC      R0,R0,#0x80
   \   00000130   0xF8CA 0x0000      STR      R0,[R10, #+0]
   \   00000134   0x462B             MOV      R3,R5
   \   00000136   0x6832             LDR      R2,[R6, #+0]
   \   00000138   0x.... 0x....      LDR.W    R1,??DataTable123_19
   \   0000013C   0x2038             MOVS     R0,#+56
   1414          
   1415          
   1416          	PCA9555BitRst(SP_EN1,&AttnCS0Val); 
   \   0000013E   0x.... 0x....      BL       pPCA9555BitRst
   1417          	PCA9555BitRst(SP_EN2,&AttnCS1Val); 
   \   00000142   0x462B             MOV      R3,R5
   \   00000144   0x6832             LDR      R2,[R6, #+0]
   \   00000146   0x4659             MOV      R1,R11
   \   00000148   0x2039             MOVS     R0,#+57
   \   0000014A   0x.... 0x....      BL       pPCA9555BitRst
   1418          
   1419          
   1420          //	DTU_WriteData(CS0, 0, 0);
   1421          
   1422          	for(i = 0;i < Att_SelMax ; i++)
   1423          	{
   1424          		AttnDataOutput(i, ~0);
   \                     ??HwTestOutFunc_1:
   \   0000014E   0x21FF             MOVS     R1,#+255
   \   00000150   0x4628             MOV      R0,R5
   \   00000152   0x.... 0x....      BL       AttnDataOutput
   1425          	}
   \   00000156   0x1C6D             ADDS     R5,R5,#+1
   \   00000158   0x2D0C             CMP      R5,#+12
   \   0000015A   0xD3F8             BCC.N    ??HwTestOutFunc_1
   1426          	OSTimeDly(50);
   \   0000015C   0x2032             MOVS     R0,#+50
   \   0000015E   0x.... 0x....      BL       OSTimeDly
   1427          	switch(Data)
   \   00000162   0x9801             LDR      R0,[SP, #+4]
   \   00000164   0x2821             CMP      R0,#+33
   \   00000166   0xF200 0x8109      BHI.W    ??HwTestOutFunc_2
   \   0000016A   0xE8DF 0xF010      TBH      [PC, R0, LSL #+1]
   \                     ??HwTestOutFunc_0:
   \   0000016E   0x0022 0x0029      DC16     0x22,0x29,0x30,0x37
   \              0x0030 0x0037
   \   00000176   0x003E 0x0045      DC16     0x3E,0x45,0x4C,0x53
   \              0x004C 0x0053
   \   0000017E   0x005A 0x0061      DC16     0x5A,0x61,0x68,0x6D
   \              0x0068 0x006D
   \   00000186   0x0072 0x0078      DC16     0x72,0x78,0x7E,0x83
   \              0x007E 0x0083
   \   0000018E   0x0088 0x008F      DC16     0x88,0x8F,0x96,0x9D
   \              0x0096 0x009D
   \   00000196   0x00A4 0x00AB      DC16     0xA4,0xAB,0xB2,0xB9
   \              0x00B2 0x00B9
   \   0000019E   0x00C0 0x00C8      DC16     0xC0,0xC8,0xCF,0xD8
   \              0x00CF 0x00D8
   \   000001A6   0x00E1 0x00EA      DC16     0xE1,0xEA,0xF3,0xFC
   \              0x00F3 0x00FC
   \   000001AE   0x0107 0x0105      DC16     0x107,0x105
   1428          	{
   1429          		case 0:
   1430          			PCA9555BitSet(GreenLED_CDMA, &AttnCS1Val);
   \                     ??HwTestOutFunc_3:
   \   000001B2   0x2300             MOVS     R3,#+0
   \   000001B4   0x6832             LDR      R2,[R6, #+0]
   \   000001B6   0x4659             MOV      R1,R11
   \   000001B8   0x2049             MOVS     R0,#+73
   \   000001BA   0x.... 0x....      BL       pPCA9555BitSet
   \   000001BE   0xE0DD             B.N      ??HwTestOutFunc_2
   1431          		break;
   1432          		
   1433          		case 1:
   1434          			PCA9555BitSet(RedLED_CDMA, &AttnCS1Val);
   \                     ??HwTestOutFunc_4:
   \   000001C0   0x2300             MOVS     R3,#+0
   \   000001C2   0x6832             LDR      R2,[R6, #+0]
   \   000001C4   0x4659             MOV      R1,R11
   \   000001C6   0x2041             MOVS     R0,#+65
   \   000001C8   0x.... 0x....      BL       pPCA9555BitSet
   \   000001CC   0xE0D6             B.N      ??HwTestOutFunc_2
   1435          		break;
   1436          
   1437          		case 2:
   1438          			PCA9555BitSet(GreenLED_LTE, &AttnCS1Val);
   \                     ??HwTestOutFunc_5:
   \   000001CE   0x2300             MOVS     R3,#+0
   \   000001D0   0x6832             LDR      R2,[R6, #+0]
   \   000001D2   0x4659             MOV      R1,R11
   \   000001D4   0x2059             MOVS     R0,#+89
   \   000001D6   0x.... 0x....      BL       pPCA9555BitSet
   \   000001DA   0xE0CF             B.N      ??HwTestOutFunc_2
   1439          		break;
   1440          		
   1441          		case 3:
   1442          			PCA9555BitSet(RedLED_LTE, &AttnCS1Val);
   \                     ??HwTestOutFunc_6:
   \   000001DC   0x2300             MOVS     R3,#+0
   \   000001DE   0x6832             LDR      R2,[R6, #+0]
   \   000001E0   0x4659             MOV      R1,R11
   \   000001E2   0x2051             MOVS     R0,#+81
   \   000001E4   0x.... 0x....      BL       pPCA9555BitSet
   \   000001E8   0xE0C8             B.N      ??HwTestOutFunc_2
   1443          		break;			
   1444          		
   1445          		case 4:
   1446          			PCA9555BitSet(GreenLED_LTE_A2, &AttnCS1Val);
   \                     ??HwTestOutFunc_7:
   \   000001EA   0x2300             MOVS     R3,#+0
   \   000001EC   0x6832             LDR      R2,[R6, #+0]
   \   000001EE   0x4659             MOV      R1,R11
   \   000001F0   0x2079             MOVS     R0,#+121
   \   000001F2   0x.... 0x....      BL       pPCA9555BitSet
   \   000001F6   0xE0C1             B.N      ??HwTestOutFunc_2
   1447          		break;
   1448          		
   1449          		case 5:
   1450          			PCA9555BitSet(RedLED_LTE_A2, &AttnCS1Val);
   \                     ??HwTestOutFunc_8:
   \   000001F8   0x2300             MOVS     R3,#+0
   \   000001FA   0x6832             LDR      R2,[R6, #+0]
   \   000001FC   0x4659             MOV      R1,R11
   \   000001FE   0x2071             MOVS     R0,#+113
   \   00000200   0x.... 0x....      BL       pPCA9555BitSet
   \   00000204   0xE0BA             B.N      ??HwTestOutFunc_2
   1451          		break;	
   1452          
   1453          		case 6:
   1454          			PCA9555BitSet(GreenLED_WCDMA, &AttnCS1Val);
   \                     ??HwTestOutFunc_9:
   \   00000206   0x2300             MOVS     R3,#+0
   \   00000208   0x6832             LDR      R2,[R6, #+0]
   \   0000020A   0x4659             MOV      R1,R11
   \   0000020C   0x2031             MOVS     R0,#+49
   \   0000020E   0x.... 0x....      BL       pPCA9555BitSet
   \   00000212   0xE0B3             B.N      ??HwTestOutFunc_2
   1455          		break;
   1456          		
   1457          		case 7:
   1458          			PCA9555BitSet(RedLED_WCDMA, &AttnCS1Val);
   \                     ??HwTestOutFunc_10:
   \   00000214   0x2300             MOVS     R3,#+0
   \   00000216   0x6832             LDR      R2,[R6, #+0]
   \   00000218   0x4659             MOV      R1,R11
   \   0000021A   0x2029             MOVS     R0,#+41
   \   0000021C   0x.... 0x....      BL       pPCA9555BitSet
   \   00000220   0xE0AC             B.N      ??HwTestOutFunc_2
   1459          		break;			
   1460          
   1461          		case 8:
   1462          			PCA9555BitSet(GreenLED_LTE_21, &AttnCS1Val);
   \                     ??HwTestOutFunc_11:
   \   00000222   0x2300             MOVS     R3,#+0
   \   00000224   0x6832             LDR      R2,[R6, #+0]
   \   00000226   0x4659             MOV      R1,R11
   \   00000228   0x2069             MOVS     R0,#+105
   \   0000022A   0x.... 0x....      BL       pPCA9555BitSet
   \   0000022E   0xE0A5             B.N      ??HwTestOutFunc_2
   1463          		break;
   1464          		
   1465          		case 9:
   1466          			PCA9555BitSet(RedLED_LTE_21, &AttnCS1Val);
   \                     ??HwTestOutFunc_12:
   \   00000230   0x2300             MOVS     R3,#+0
   \   00000232   0x6832             LDR      R2,[R6, #+0]
   \   00000234   0x4659             MOV      R1,R11
   \   00000236   0x2061             MOVS     R0,#+97
   \   00000238   0x.... 0x....      BL       pPCA9555BitSet
   \   0000023C   0xE09E             B.N      ??HwTestOutFunc_2
   1467          		break;
   1468          
   1469          
   1470          		
   1471          		case 10:
   1472          			DL_AmpOnOff_CDMALTE 	= 1;
   \                     ??HwTestOutFunc_13:
   \   0000023E   0x6838             LDR      R0,[R7, #+0]
   \   00000240   0xF040 0x0040      ORR      R0,R0,#0x40
   \   00000244   0x6038             STR      R0,[R7, #+0]
   \   00000246   0xE099             B.N      ??HwTestOutFunc_2
   1473          		break;
   1474          		
   1475          		case 11:
   1476          			UL_AmpOnOff_CDMALTE 	= 1;
   \                     ??HwTestOutFunc_14:
   \   00000248   0x6838             LDR      R0,[R7, #+0]
   \   0000024A   0xF040 0x0080      ORR      R0,R0,#0x80
   \   0000024E   0x6038             STR      R0,[R7, #+0]
   \   00000250   0xE094             B.N      ??HwTestOutFunc_2
   1477          		break;
   1478          		
   1479          		case 12:
   1480          			DL_AmpOnOff_LTEA		= 1;
   \                     ??HwTestOutFunc_15:
   \   00000252   0x6838             LDR      R0,[R7, #+0]
   \   00000254   0xF44F 0x7180      MOV      R1,#+256
   \   00000258   0x4308             ORRS     R0,R1,R0
   \   0000025A   0x6038             STR      R0,[R7, #+0]
   \   0000025C   0xE08E             B.N      ??HwTestOutFunc_2
   1481          		break;
   1482          		
   1483          		case 13:
   1484          			UL_AmpOnOff_LTEA		= 1;
   \                     ??HwTestOutFunc_16:
   \   0000025E   0x6838             LDR      R0,[R7, #+0]
   \   00000260   0xF44F 0x7100      MOV      R1,#+512
   \   00000264   0x4308             ORRS     R0,R1,R0
   \   00000266   0x6038             STR      R0,[R7, #+0]
   \   00000268   0xE088             B.N      ??HwTestOutFunc_2
   1485          		break;
   1486          
   1487                  case 14:
   1488          			DL_AmpOnOff_WCDMA		= 1;
   \                     ??HwTestOutFunc_17:
   \   0000026A   0x6838             LDR      R0,[R7, #+0]
   \   0000026C   0xF440 0x6080      ORR      R0,R0,#0x400
   \   00000270   0x6038             STR      R0,[R7, #+0]
   \   00000272   0xE083             B.N      ??HwTestOutFunc_2
   1489          		break;
   1490          
   1491                  case 15:
   1492          			UL_AmpOnOff_WCDMA		= 1;
   \                     ??HwTestOutFunc_18:
   \   00000274   0x6838             LDR      R0,[R7, #+0]
   \   00000276   0xF440 0x6000      ORR      R0,R0,#0x800
   \   0000027A   0x6038             STR      R0,[R7, #+0]
   1493          		break;
   \   0000027C   0xE07E             B.N      ??HwTestOutFunc_2
   1494          
   1495             		case 16:
   1496          			PCA9555BitSet(Fwd_PLLEN_LTE,  &AttnCS1Val);
   \                     ??HwTestOutFunc_19:
   \   0000027E   0x2300             MOVS     R3,#+0
   \   00000280   0x6832             LDR      R2,[R6, #+0]
   \   00000282   0x4659             MOV      R1,R11
   \   00000284   0x2001             MOVS     R0,#+1
   \   00000286   0x.... 0x....      BL       pPCA9555BitSet
   \   0000028A   0xE077             B.N      ??HwTestOutFunc_2
   1497          		break;
   1498          
   1499             		case 17:
   1500          			PCA9555BitSet(Rvs_PLLEN_LTE,  &AttnCS1Val);
   \                     ??HwTestOutFunc_20:
   \   0000028C   0x2300             MOVS     R3,#+0
   \   0000028E   0x6832             LDR      R2,[R6, #+0]
   \   00000290   0x4659             MOV      R1,R11
   \   00000292   0x2009             MOVS     R0,#+9
   \   00000294   0x.... 0x....      BL       pPCA9555BitSet
   \   00000298   0xE070             B.N      ??HwTestOutFunc_2
   1501          		break;
   1502          
   1503             		case 18:
   1504          			PCA9555BitSet(PLLEN_LTE_A,	  &AttnCS1Val);
   \                     ??HwTestOutFunc_21:
   \   0000029A   0x2300             MOVS     R3,#+0
   \   0000029C   0x6832             LDR      R2,[R6, #+0]
   \   0000029E   0x4659             MOV      R1,R11
   \   000002A0   0x2011             MOVS     R0,#+17
   \   000002A2   0x.... 0x....      BL       pPCA9555BitSet
   \   000002A6   0xE069             B.N      ??HwTestOutFunc_2
   1505          		break;
   1506          
   1507             		case 19:
   1508          			PCA9555BitSet(Fwd_PLLEN_WCDMA,&AttnCS1Val);
   \                     ??HwTestOutFunc_22:
   \   000002A8   0x2300             MOVS     R3,#+0
   \   000002AA   0x6832             LDR      R2,[R6, #+0]
   \   000002AC   0x4659             MOV      R1,R11
   \   000002AE   0x2019             MOVS     R0,#+25
   \   000002B0   0x.... 0x....      BL       pPCA9555BitSet
   \   000002B4   0xE062             B.N      ??HwTestOutFunc_2
   1509          		break;
   1510          
   1511             		case 20:
   1512          			PLL_CLK 				= 1;
   \                     ??HwTestOutFunc_23:
   \   000002B6   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000002BA   0xF440 0x4000      ORR      R0,R0,#0x8000
   \   000002BE   0xF8C8 0x0000      STR      R0,[R8, #+0]
   1513          		break;
   \   000002C2   0xE05B             B.N      ??HwTestOutFunc_2
   1514          
   1515             		case 21:
   1516          			PLL_DATA				= 1;
   \                     ??HwTestOutFunc_24:
   \   000002C4   0xF8D9 0x0000      LDR      R0,[R9, #+0]
   \   000002C8   0xF040 0x0008      ORR      R0,R0,#0x8
   \   000002CC   0xF8C9 0x0000      STR      R0,[R9, #+0]
   1517          		break;
   \   000002D0   0xE054             B.N      ??HwTestOutFunc_2
   1518          
   1519             		case 22:
   1520          			PCA9555BitSet(RVS_PLLEN_WCDMA,&AttnCS1Val);
   \                     ??HwTestOutFunc_25:
   \   000002D2   0x2300             MOVS     R3,#+0
   \   000002D4   0x6832             LDR      R2,[R6, #+0]
   \   000002D6   0x4659             MOV      R1,R11
   \   000002D8   0x2021             MOVS     R0,#+33
   \   000002DA   0x.... 0x....      BL       pPCA9555BitSet
   \   000002DE   0xE04D             B.N      ??HwTestOutFunc_2
   1521          		break;
   1522          
   1523             		case 23:
   1524          			SMS_PWR				= 1;
   \                     ??HwTestOutFunc_26:
   \   000002E0   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   000002E4   0xF040 0x0080      ORR      R0,R0,#0x80
   \   000002E8   0xF8CA 0x0000      STR      R0,[R10, #+0]
   1525          		break;
   \   000002EC   0xE046             B.N      ??HwTestOutFunc_2
   1526          
   1527             		case 24:
   1528          			PCA9555BitSet(SP_EN1,&AttnCS0Val); 
   \                     ??HwTestOutFunc_27:
   \   000002EE   0x2300             MOVS     R3,#+0
   \   000002F0   0x6832             LDR      R2,[R6, #+0]
   \   000002F2   0x.... 0x....      LDR.W    R1,??DataTable123_19
   \   000002F6   0x2038             MOVS     R0,#+56
   \   000002F8   0x.... 0x....      BL       pPCA9555BitSet
   \   000002FC   0xE03E             B.N      ??HwTestOutFunc_2
   1529          		break;
   1530          
   1531             		case 25:
   1532          			PCA9555BitSet(SP_EN2,&AttnCS1Val); 
   \                     ??HwTestOutFunc_28:
   \   000002FE   0x2300             MOVS     R3,#+0
   \   00000300   0x6832             LDR      R2,[R6, #+0]
   \   00000302   0x4659             MOV      R1,R11
   \   00000304   0x2039             MOVS     R0,#+57
   \   00000306   0x.... 0x....      BL       pPCA9555BitSet
   1533          		break;
   \   0000030A   0xE037             B.N      ??HwTestOutFunc_2
   1534          #if 1
   1535          		case 26:
   1536          			for(i = 0;i < Att_SelMax ; i++)
   \                     ??HwTestOutFunc_29:
   \   0000030C   0x2500             MOVS     R5,#+0
   1537          			{
   1538          				AttnDataOutput(i, ~1);
   \                     ??HwTestOutFunc_30:
   \   0000030E   0x21FE             MOVS     R1,#+254
   \   00000310   0x4628             MOV      R0,R5
   \   00000312   0x.... 0x....      BL       AttnDataOutput
   1539          			}
   \   00000316   0x1C6D             ADDS     R5,R5,#+1
   \   00000318   0x2D0C             CMP      R5,#+12
   \   0000031A   0xD3F8             BCC.N    ??HwTestOutFunc_30
   \   0000031C   0xE02E             B.N      ??HwTestOutFunc_2
   1540          		break;
   1541          
   1542          		case 27:
   1543          			for(i = 0;i < Att_SelMax ; i++)
   \                     ??HwTestOutFunc_31:
   \   0000031E   0x2500             MOVS     R5,#+0
   1544          			{
   1545          				AttnDataOutput(i, ~2);
   \                     ??HwTestOutFunc_32:
   \   00000320   0x21FD             MOVS     R1,#+253
   \   00000322   0x4628             MOV      R0,R5
   \   00000324   0x.... 0x....      BL       AttnDataOutput
   1546          			}
   \   00000328   0x1C6D             ADDS     R5,R5,#+1
   \   0000032A   0x2D0C             CMP      R5,#+12
   \   0000032C   0xD3F8             BCC.N    ??HwTestOutFunc_32
   \   0000032E   0xE025             B.N      ??HwTestOutFunc_2
   1547          		break;
   1548          
   1549          		case 28:
   1550          			for(i = 0;i < Att_SelMax ; i++)
   \                     ??HwTestOutFunc_33:
   \   00000330   0x2500             MOVS     R5,#+0
   1551          			{
   1552          				AttnDataOutput(i, ~4);
   \                     ??HwTestOutFunc_34:
   \   00000332   0x21FB             MOVS     R1,#+251
   \   00000334   0x4628             MOV      R0,R5
   \   00000336   0x.... 0x....      BL       AttnDataOutput
   1553          			}
   \   0000033A   0x1C6D             ADDS     R5,R5,#+1
   \   0000033C   0x2D0C             CMP      R5,#+12
   \   0000033E   0xD3F8             BCC.N    ??HwTestOutFunc_34
   \   00000340   0xE01C             B.N      ??HwTestOutFunc_2
   1554          		break;
   1555          
   1556          		case 29:
   1557          			for(i = 0;i < Att_SelMax ; i++)
   \                     ??HwTestOutFunc_35:
   \   00000342   0x2500             MOVS     R5,#+0
   1558          			{
   1559          				AttnDataOutput(i, ~8);
   \                     ??HwTestOutFunc_36:
   \   00000344   0x21F7             MOVS     R1,#+247
   \   00000346   0x4628             MOV      R0,R5
   \   00000348   0x.... 0x....      BL       AttnDataOutput
   1560          			}
   \   0000034C   0x1C6D             ADDS     R5,R5,#+1
   \   0000034E   0x2D0C             CMP      R5,#+12
   \   00000350   0xD3F8             BCC.N    ??HwTestOutFunc_36
   \   00000352   0xE013             B.N      ??HwTestOutFunc_2
   1561          		break;
   1562          
   1563          		case 30:
   1564          			for(i = 0;i < Att_SelMax ; i++)
   \                     ??HwTestOutFunc_37:
   \   00000354   0x2500             MOVS     R5,#+0
   1565          			{
   1566          				AttnDataOutput(i, ~16);
   \                     ??HwTestOutFunc_38:
   \   00000356   0x21EF             MOVS     R1,#+239
   \   00000358   0x4628             MOV      R0,R5
   \   0000035A   0x.... 0x....      BL       AttnDataOutput
   1567          			}
   \   0000035E   0x1C6D             ADDS     R5,R5,#+1
   \   00000360   0x2D0C             CMP      R5,#+12
   \   00000362   0xD3F8             BCC.N    ??HwTestOutFunc_38
   \   00000364   0xE00A             B.N      ??HwTestOutFunc_2
   1568          		break;
   1569          
   1570          		case 31:
   1571          			for(i = 0;i < Att_SelMax ; i++)
   \                     ??HwTestOutFunc_39:
   \   00000366   0x2500             MOVS     R5,#+0
   1572          			{
   1573          				AttnDataOutput(i, ~32);
   \                     ??HwTestOutFunc_40:
   \   00000368   0x21DF             MOVS     R1,#+223
   \   0000036A   0x4628             MOV      R0,R5
   \   0000036C   0x.... 0x....      BL       AttnDataOutput
   1574          			}
   \   00000370   0x1C6D             ADDS     R5,R5,#+1
   \   00000372   0x2D0C             CMP      R5,#+12
   \   00000374   0xD3F8             BCC.N    ??HwTestOutFunc_40
   \   00000376   0xE001             B.N      ??HwTestOutFunc_2
   1575          		break;
   1576          		case 32:
   1577          //			DTU_WriteData(CS0, 0, 0xff);
   1578          		break;
   1579          
   1580          
   1581          
   1582          #endif
   1583           		case 33:
   1584          			MaxValue = Data;
   \                     ??HwTestOutFunc_41:
   \   00000378   0x2021             MOVS     R0,#+33
   \   0000037A   0x9000             STR      R0,[SP, #+0]
   1585          			//BuzzShort();
   1586          		break;
   1587          	}
   1588          
   1589          	*nFlag = *nFlag + 1;
   \                     ??HwTestOutFunc_2:
   \   0000037C   0x6820             LDR      R0,[R4, #+0]
   \   0000037E   0x1C40             ADDS     R0,R0,#+1
   \   00000380   0x6020             STR      R0,[R4, #+0]
   1590          
   1591          	if(*nFlag >= MaxValue) *nFlag = 0;
   \   00000382   0x9900             LDR      R1,[SP, #+0]
   \   00000384   0x4288             CMP      R0,R1
   \   00000386   0xBF24             ITT      CS 
   \   00000388   0x2000             MOVCS    R0,#+0
   \   0000038A   0x6020             STRCS    R0,[R4, #+0]
   1592          #endif
   1593          }
   \   0000038C                      REQUIRE ?Subroutine1
   \   0000038C                      ;; // Fall through to label ?Subroutine1
   1594          

   \                                 In section .text, align 2, keep-with-next
   1595          INT32U DigitalInputDiplay(INT8U num, INT8U ival,
   1596          							INT8U *fmsg, INT8U *emsg,
   1597          							INT8U vcheck)
   1598          {
   \                     DigitalInputDiplay:
   \   00000000   0xE92D 0x45F8      PUSH     {R3-R8,R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4611             MOV      R1,R2
   \   0000000A   0x461E             MOV      R6,R3
   \   0000000C   0x9808             LDR      R0,[SP, #+32]
   1599          	INT32U temp = FALSE;
   \   0000000E   0x2700             MOVS     R7,#+0
   1600          	INT8U *currentptr = (INT8U *)&tinputSts;
   1601          	INT8U *beforeptr = (INT8U *)&tinputStsOld;
   1602          
   1603          	// first
   1604          	if(!vcheck)
   \   00000010   0xB9E0             CBNZ.N   R0,??DigitalInputDiplay_0
   1605          	{
   1606          		if(fmsg != NULL) SerPtr->printf("%s", fmsg);	// start // phase mssage
   \   00000012   0xB1D9             CBZ.N    R1,??DigitalInputDiplay_0
   \   00000014   0x....             ADR.N    R0,??DataTable123_1  ;; 0x25, 0x73, 0x00, 0x00
   \   00000016   0x....             LDR.N    R2,??DataTable121
   \   00000018   0x6812             LDR      R2,[R2, #+0]
   \   0000001A   0x6912             LDR      R2,[R2, #+16]
   \   0000001C   0x4790             BLX      R2
   \   0000001E   0x....             LDR.N    R0,??DataTable123_20
   \   00000020   0x5425             STRB     R5,[R4, R0]
   1607          	}
   1608          
   1609          	currentptr[num] = ival;
   1610          
   1611          	{
   1612          
   1613          		if( (vcheck && (beforeptr[num] != currentptr[num]) ) )
   1614          		{
   1615          			SerPtr->printf("%02d. ", num);
   1616          			SerPtr->printf("%s", tDisplay[num]);
   1617          			{
   1618          				if(ival) SerPtr->printf(OFFMSG);
   1619          				else	 SerPtr->printf(ONMSG);
   1620          			}
   1621          			temp = TRUE;
   1622          		}
   1623          		else if(!vcheck)
   1624          		{
   1625          			SerPtr->printf("%s", tDisplay[num]);
   \                     ??DigitalInputDiplay_1:
   \   00000022   0x.... 0x....      LDR.W    R8,??DataTable121
   \   00000026   0x....             LDR.N    R0,??DataTable123_20
   \   00000028   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \   0000002C   0x6B41             LDR      R1,[R0, #+52]
   \   0000002E   0x....             ADR.N    R0,??DataTable123_1  ;; 0x25, 0x73, 0x00, 0x00
   \   00000030   0xF8D8 0x2000      LDR      R2,[R8, #+0]
   \   00000034   0x6912             LDR      R2,[R2, #+16]
   \   00000036   0x4790             BLX      R2
   \   00000038   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000003C   0x6901             LDR      R1,[R0, #+16]
   \   0000003E   0x2D00             CMP      R5,#+0
   \   00000040   0xBF14             ITE      NE 
   \   00000042   0x.... 0x....      ADRNE.W  R0,`?<Constant "[OFF]">`
   \   00000046   0x.... 0x....      ADREQ.W  R0,`?<Constant "[ON ]">`
   1626          			{
   1627          				if(ival) SerPtr->printf(OFFMSG);
   \   0000004A   0xE022             B.N      ??DigitalInputDiplay_2
   1628          				else	 SerPtr->printf(ONMSG);
   1629          			}
   1630          		}
   \                     ??DigitalInputDiplay_0:
   \   0000004C   0x.... 0x....      LDR.W    R10,??DataTable123_20
   \   00000050   0xF804 0x500A      STRB     R5,[R4, R10]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD0E4             BEQ.N    ??DigitalInputDiplay_1
   \   00000058   0x....             LDR.N    R0,??DataTable123_21
   \   0000005A   0x5C20             LDRB     R0,[R4, R0]
   \   0000005C   0x42A8             CMP      R0,R5
   \   0000005E   0xD022             BEQ.N    ??DigitalInputDiplay_3
   \   00000060   0x....             LDR.N    R6,??DataTable121
   \   00000062   0x4621             MOV      R1,R4
   \   00000064   0x.... 0x....      ADR.W    R0,`?<Constant "%02d. ">`
   \   00000068   0x6832             LDR      R2,[R6, #+0]
   \   0000006A   0x6912             LDR      R2,[R2, #+16]
   \   0000006C   0x4790             BLX      R2
   \   0000006E   0xEB0A 0x0084      ADD      R0,R10,R4, LSL #+2
   \   00000072   0x6B41             LDR      R1,[R0, #+52]
   \   00000074   0x....             ADR.N    R0,??DataTable123_1  ;; 0x25, 0x73, 0x00, 0x00
   \   00000076   0x6832             LDR      R2,[R6, #+0]
   \   00000078   0x6912             LDR      R2,[R2, #+16]
   \   0000007A   0x4790             BLX      R2
   \   0000007C   0x6830             LDR      R0,[R6, #+0]
   \   0000007E   0x6901             LDR      R1,[R0, #+16]
   \   00000080   0x2D00             CMP      R5,#+0
   \   00000082   0xBF14             ITE      NE 
   \   00000084   0x.... 0x....      ADRNE.W  R0,`?<Constant "[OFF]">`
   \   00000088   0x.... 0x....      ADREQ.W  R0,`?<Constant "[ON ]">`
   \   0000008C   0x4788             BLX      R1
   \   0000008E   0x2701             MOVS     R7,#+1
   \   00000090   0xE001             B.N      ??DigitalInputDiplay_4
   1631          	}
   \                     ??DigitalInputDiplay_2:
   \   00000092   0x4788             BLX      R1
   1632          
   1633          ////////////////////////////////////////////////////////////////////////////////
   1634          	if(vcheck)
   1635          	{
   1636          		if(temp)
   1637          		{
   1638          			OSTimeDly(1L);
   1639          			SerPtr->printf(ENTMSG);
   1640          		}
   1641          	}
   1642          	else
   1643          	{
   1644          		if(emsg)
   \   00000094   0xB13E             CBZ.N    R6,??DigitalInputDiplay_3
   1645          		{
   1646          			OSTimeDly(1L);
   \                     ??DigitalInputDiplay_4:
   \   00000096   0x2001             MOVS     R0,#+1
   \   00000098   0x.... 0x....      BL       OSTimeDly
   1647          			SerPtr->printf(ENTMSG);
   \   0000009C   0x....             ADR.N    R0,??DataTable123_2  ;; "\n"
   \   0000009E   0x....             LDR.N    R1,??DataTable121
   \   000000A0   0x6809             LDR      R1,[R1, #+0]
   \   000000A2   0x6909             LDR      R1,[R1, #+16]
   \   000000A4   0x4788             BLX      R1
   1648          		}
   1649          	}
   1650          
   1651          	beforeptr[num] = currentptr[num];
   \                     ??DigitalInputDiplay_3:
   \   000000A6   0x....             LDR.N    R0,??DataTable123_21
   \   000000A8   0x....             LDR.N    R1,??DataTable123_20
   \   000000AA   0x5C61             LDRB     R1,[R4, R1]
   \   000000AC   0x5421             STRB     R1,[R4, R0]
   1652          	return (INT32U)temp;
   \   000000AE   0x4638             MOV      R0,R7
   \   000000B0   0xE8BD 0x85F2      POP      {R1,R4-R8,R10,PC}  ;; return
   1653          }
   1654          
   1655          

   \                                 In section .text, align 2, keep-with-next
   1656          INT8U returnmsgTest(char *str)
   1657          {
   \                     returnmsgTest:
   \   00000000   0xB580             PUSH     {R7,LR}
   1658          	SerPtr->printf("%s이 수행되어 있습니다. 계속 진행하시겠습니까?[Y]es, [C]ancel\n", str);
   \   00000002   0x4601             MOV      R1,R0
   \   00000004   0x.... 0x....      ADR.W    R0,`?<Constant "%s\\300\\314 \\274\\366\\307\\340\\265\\30`
   \   00000008   0x....             LDR.N    R2,??DataTable123_22
   \   0000000A   0x6812             LDR      R2,[R2, #+0]
   \   0000000C   0x6912             LDR      R2,[R2, #+16]
   \   0000000E   0x4790             BLX      R2
   1659          	return WaringMssageReturn();
   \   00000010   0xE8BD 0x4001      POP      {R0,LR}
   \   00000014                      REQUIRE WaringMssageReturn
   \   00000014                      ;; // Fall through to label WaringMssageReturn
   1660          }
   1661          

   \                                 In section .text, align 2, keep-with-next
   1662          INT8U WaringMssageReturn(void)
   1663          {
   \                     WaringMssageReturn:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1664          	INT16U nCnt;
   1665          
   1666          	TimerRegist(TimerTest, Time1Sec*5L);
   \   00000002   0xF241 0x3588      MOVW     R5,#+5000
   \   00000006   0x4629             MOV      R1,R5
   \   00000008   0x2003             MOVS     R0,#+3
   \   0000000A   0x.... 0x....      BL       TimerRegist
   \   0000000E   0x....             LDR.N    R4,??DataTable123_22
   \   00000010   0xE002             B.N      ??WaringMssageReturn_0
   1667          
   1668          	while(1)
   1669          	{
   1670          		if(TimeOverCheck(TimerTest))
   1671          		{
   1672          			TimerRegist(TimerTest, Time1Sec*5L);
   1673          			return TRUE;
   1674          		}
   1675          		if(SerPtr->CheckByte(1, &nCnt))
   1676          		{
   1677          			nCnt = SerPtr->RxGetByte();
   1678          			if(nCnt == 'C' || nCnt == 'c')
   1679          			{
   1680          				SerPtr->printf("CANCEL TEST \n");
   1681          				return FALSE;
   1682          			}
   1683          			else return TRUE;
   1684          		}
   1685          		OSTimeDly(10L);
   \                     ??WaringMssageReturn_1:
   \   00000012   0x200A             MOVS     R0,#+10
   \   00000014   0x.... 0x....      BL       OSTimeDly
   \                     ??WaringMssageReturn_0:
   \   00000018   0x2003             MOVS     R0,#+3
   \   0000001A   0x.... 0x....      BL       TimeOverCheck
   \   0000001E   0xB128             CBZ.N    R0,??WaringMssageReturn_2
   \   00000020   0x4629             MOV      R1,R5
   \   00000022   0x2003             MOVS     R0,#+3
   \   00000024   0x.... 0x....      BL       TimerRegist
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??WaringMssageReturn_2:
   \   0000002C   0xA900             ADD      R1,SP,#+0
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x6822             LDR      R2,[R4, #+0]
   \   00000032   0x6852             LDR      R2,[R2, #+4]
   \   00000034   0x4790             BLX      R2
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD0EB             BEQ.N    ??WaringMssageReturn_1
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x6880             LDR      R0,[R0, #+8]
   \   0000003E   0x4780             BLX      R0
   \   00000040   0xF8AD 0x0000      STRH     R0,[SP, #+0]
   \   00000044   0xF8BD 0x0000      LDRH     R0,[SP, #+0]
   \   00000048   0x2843             CMP      R0,#+67
   \   0000004A   0xBF18             IT       NE 
   \   0000004C   0x2863             CMPNE    R0,#+99
   \   0000004E   0xD106             BNE.N    ??WaringMssageReturn_3
   \   00000050   0x.... 0x....      ADR.W    R0,`?<Constant "CANCEL TEST \\n">`
   \   00000054   0x6821             LDR      R1,[R4, #+0]
   \   00000056   0x6909             LDR      R1,[R1, #+16]
   \   00000058   0x4788             BLX      R1
   \   0000005A   0x2000             MOVS     R0,#+0
   \   0000005C   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??WaringMssageReturn_3:
   \   0000005E   0x2001             MOVS     R0,#+1
   \   00000060   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1686          	}
   1687          }
   1688          #if 1

   \                                 In section .text, align 2, keep-with-next
   1689          INT8U SavetoTestBackup(INT8U tmpIndex, INT8U tSet, INT8U IsItLoad)
   1690          {
   1691          #if 0
   1692          	EE_TABLE1 *ptr = &gEE_TABLE1;
   1693          	INT32U AddrOffset = vEE_TABLE1Addr + (INT32U)&(ptr->BdTestBp) - (INT32U )&gEE_TABLE1;
   1694          
   1695          	AddrOffset += tmpIndex;
   1696          
   1697          	if(IsItLoad)
   1698          	{
   1699          		ptr->BdTestBp[tmpIndex] = tSet;
   1700          		WriteEEprom(At24cDevID, AddrOffset, tSet, 0);
   1701          	}
   1702          	return (ptr->BdTestBp[tmpIndex]);
   1703          #endif
   1704          
   1705          return 0;
   \                     SavetoTestBackup:
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
   1706          
   1707          }
   1708          #endif
   1709          

   \                                 In section .text, align 2, keep-with-next
   1710          void PrintLogo(void)
   1711          {
   \                     PrintLogo:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1712          
   1713          	SerPtr->printf("\n\n");
   \   00000002   0x....             LDR.N    R4,??DataTable123_22
   \   00000004   0x....             ADR.N    R0,??DataTable123_3  ;; 0x0A, 0x0A, 0x00, 0x00
   \   00000006   0x6821             LDR      R1,[R4, #+0]
   \   00000008   0x6909             LDR      R1,[R1, #+16]
   \   0000000A   0x4788             BLX      R1
   1714          	PrintStar();
   \   0000000C   0x.... 0x....      BL       PrintStar
   1715          	SerPtr->printf("*\n");
   \   00000010   0x....             ADR.N    R0,??DataTable123_4  ;; 0x2A, 0x0A, 0x00, 0x00
   \   00000012   0x6821             LDR      R1,[R4, #+0]
   \   00000014   0x6909             LDR      R1,[R1, #+16]
   \   00000016   0x4788             BLX      R1
   1716          	SerPtr->printf("* %s [VER:%d.%d]\n", BoardTestMode, (SystemVer >> 4 & 0x0f), (SystemVer >> 0 & 0x0f));
   \   00000018   0x2301             MOVS     R3,#+1
   \   0000001A   0x2203             MOVS     R2,#+3
   \   0000001C   0x.... 0x....      ADR.W    R1,`?<Constant "TRIO-MD RCU CTRL TEST...">`
   \   00000020   0x.... 0x....      ADR.W    R0,`?<Constant "* %s [VER:%d.%d]\\n">`
   \   00000024   0x6825             LDR      R5,[R4, #+0]
   \   00000026   0x692D             LDR      R5,[R5, #+16]
   \   00000028   0x47A8             BLX      R5
   1717          	SerPtr->printf("*    -COMMAND 1st-\n");
   \   0000002A   0x.... 0x....      ADR.W    R0,`?<Constant "*    -COMMAND 1st-\\n">`
   \   0000002E   0x6821             LDR      R1,[R4, #+0]
   \   00000030   0x6909             LDR      R1,[R1, #+16]
   \   00000032   0x4788             BLX      R1
   1718          	SerPtr->printf("*  ?        : help(this message)\n");
   \   00000034   0x.... 0x....      ADR.W    R0,`?<Constant "*  ?        : help(th...">`
   \   00000038   0x6821             LDR      R1,[R4, #+0]
   \   0000003A   0x6909             LDR      R1,[R1, #+16]
   \   0000003C   0x4788             BLX      R1
   1719          	SerPtr->printf("*  TEST I        : INPUT Test          [%s]\n", testResult[0x03 & SavetoTestBackup(InputTest, NULL, NULL)]);
   \   0000003E   0x....             LDR.N    R5,??DataTable123_23
   \   00000040   0x6829             LDR      R1,[R5, #+0]
   \   00000042   0x.... 0x....      ADR.W    R0,`?<Constant "*  TEST I        : IN...">`
   \   00000046   0x6822             LDR      R2,[R4, #+0]
   \   00000048   0x6912             LDR      R2,[R2, #+16]
   \   0000004A   0x4790             BLX      R2
   1720          	SerPtr->printf("*  TEST O        : OUTPUT Test         [%s]\n", testResult[0x03 & SavetoTestBackup(OutputTest,  NULL, NULL)]);
   \   0000004C   0x6829             LDR      R1,[R5, #+0]
   \   0000004E   0x.... 0x....      ADR.W    R0,`?<Constant "*  TEST O        : OU...">`
   \   00000052   0x6822             LDR      R2,[R4, #+0]
   \   00000054   0x6912             LDR      R2,[R2, #+16]
   \   00000056   0x4790             BLX      R2
   1721          	SerPtr->printf("*  TEST C        : SERIAL[UART]        [%s]\n", testResult[0x03 & SavetoTestBackup(CommTest, NULL, NULL)]);
   \   00000058   0x6829             LDR      R1,[R5, #+0]
   \   0000005A   0x.... 0x....      ADR.W    R0,`?<Constant "*  TEST C        : SE...">`
   \   0000005E   0x6822             LDR      R2,[R4, #+0]
   \   00000060   0x6912             LDR      R2,[R2, #+16]
   \   00000062   0x4790             BLX      R2
   1722          	SerPtr->printf("*  TEST A        : ANALOG DECT         [%s]\n", testResult[0x03 & SavetoTestBackup(ADCTest, 	NULL, NULL)]);
   \   00000064   0x6829             LDR      R1,[R5, #+0]
   \   00000066   0x.... 0x....      ADR.W    R0,`?<Constant "*  TEST A        : AN...">`
   \   0000006A   0x6822             LDR      R2,[R4, #+0]
   \   0000006C   0x6912             LDR      R2,[R2, #+16]
   \   0000006E   0x4790             BLX      R2
   1723          //	SerPtr->printf("*  TEST E        : EEPROM TEST         [%s]\n", testResult[0x03 & SavetoTestBackup(EepromTest, NULL, NULL)]);
   1724          //	SerPtr->printf("*  TEST S        : Factory SET\n");
   1725          	SerPtr->printf("*  RESET         : RESET\n");
   \   00000070   0x.... 0x....      ADR.W    R0,`?<Constant "*  RESET         : RE...">`
   \   00000074   0x6821             LDR      R1,[R4, #+0]
   \   00000076   0x6909             LDR      R1,[R1, #+16]
   \   00000078   0x4788             BLX      R1
   1726          	SerPtr->printf("*  TEST SRAM	 : SRAM TEST\n");
   \   0000007A   0x.... 0x....      ADR.W    R0,`?<Constant "*  TEST SRAM\\t : SRAM ...">`
   \   0000007E   0x6821             LDR      R1,[R4, #+0]
   \   00000080   0x6909             LDR      R1,[R1, #+16]
   \   00000082   0x4788             BLX      R1
   1727          	SerPtr->printf("*  FPGA DET 0(ADDR) : DTU DET TEST\n");
   \   00000084   0x.... 0x....      ADR.W    R0,`?<Constant "*  FPGA DET 0(ADDR) :...">`
   \   00000088   0x6821             LDR      R1,[R4, #+0]
   \   0000008A   0x6909             LDR      R1,[R1, #+16]
   \   0000008C   0x4788             BLX      R1
   1728          	SerPtr->printf("*  FPGA ISO 0(ADDR) : DTU ISO TEST\n");
   \   0000008E   0x.... 0x....      ADR.W    R0,`?<Constant "*  FPGA ISO 0(ADDR) :...">`
   \   00000092   0x6821             LDR      R1,[R4, #+0]
   \   00000094   0x6909             LDR      R1,[R1, #+16]
   \   00000096   0x4788             BLX      R1
   1729          	SerPtr->printf("*  FPGA W 0(ADDR) 1(Data)    : DTU REG Write TEST\n");
   \   00000098   0x.... 0x....      ADR.W    R0,`?<Constant "*  FPGA W 0(ADDR) 1(D...">`
   \   0000009C   0x6821             LDR      R1,[R4, #+0]
   \   0000009E   0x6909             LDR      R1,[R1, #+16]
   \   000000A0   0x4788             BLX      R1
   1730          	SerPtr->printf("*  FPGA R 0(ADDR)            : DTU REG Read TEST\n");
   \   000000A2   0x.... 0x....      ADR.W    R0,`?<Constant "*  FPGA R 0(ADDR)    ...">`
   \   000000A6   0x6821             LDR      R1,[R4, #+0]
   \   000000A8   0x6909             LDR      R1,[R1, #+16]
   \   000000AA   0x4788             BLX      R1
   1731          	SerPtr->printf("*  FLASH 0 W 0(ADDR) 1(Data) : DTU Flash REG Write TEST\n");
   \   000000AC   0x.... 0x....      ADR.W    R0,`?<Constant "*  FLASH 0 W 0(ADDR) ...">`
   \   000000B0   0x6821             LDR      R1,[R4, #+0]
   \   000000B2   0x6909             LDR      R1,[R1, #+16]
   \   000000B4   0x4788             BLX      R1
   1732          	SerPtr->printf("*  FLASH 0 R 0(ADDR)         : DTU Flash REG Read TEST\n");
   \   000000B6   0x.... 0x....      ADR.W    R0,`?<Constant "*  FLASH 0 R 0(ADDR) ...">`
   \   000000BA   0x6821             LDR      R1,[R4, #+0]
   \   000000BC   0x6909             LDR      R1,[R1, #+16]
   \   000000BE   0x4788             BLX      R1
   1733          
   1734          
   1735          //	SerPtr->printf("*  G        : compulsory boot/#,\n");
   1736          	
   1737          	PrintStar();
   \   000000C0   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   000000C4                      REQUIRE PrintStar
   \   000000C4                      ;; // Fall through to label PrintStar
   1738          }
   1739          
   1740          
   1741          
   1742          

   \                                 In section .text, align 2, keep-with-next
   1743          void PrintStar(void)
   1744          {
   1745          	SerPtr->printf("*******************************************************************************\n");
   \                     PrintStar:
   \   00000000   0x.... 0x....      ADR.W    R0,`?<Constant "*********************...">`
   \   00000004   0x....             B.N      ?Subroutine0
   1746          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0x....             LDR.N    R1,??DataTable123_22
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x6909             LDR      R1,[R1, #+16]
   \   00000006   0x4708             BX       R1
   1747          

   \                                 In section .text, align 2, keep-with-next
   1748          void PromptOut(void)
   1749          {
   1750          	SerPtr->printf("TRIO-MD >>");
   \                     PromptOut:
   \   00000000   0x.... 0x....      ADR.W    R0,`?<Constant "TRIO-MD >>">`
   \   00000004                      REQUIRE ?Subroutine0
   \   00000004                      ;; // Fall through to label ?Subroutine0
   1751          }
   1752          
   1753          

   \                                 In section .text, align 2, keep-with-next
   1754          INT8U RAMAccesscheck(void)
   1755          {
   \                     RAMAccesscheck:
   \   00000000   0xB410             PUSH     {R4}
   1756          	int i = 0;
   \   00000002   0x2100             MOVS     R1,#+0
   1757          	INT8U rval = FALSE;
   1758          	
   1759          	volatile INT8U	*upLdAddr = (INT8U * )(Bank1_SRAM1_ADDR);
   1760          
   1761          //	if(msRAMIns == SRAM_INSERT){
   1762          	{
   1763          		rval = TRUE;
   \   00000004   0x2001             MOVS     R0,#+1
   1764          		
   1765          		for(i = 0; i < (1*(1024)); i++)
   \   00000006   0xF04F 0x42C0      MOV      R2,#+1610612736
   1766          		{
   1767          			*(upLdAddr + i) = (INT8U)i;
   \                     ??RAMAccesscheck_0:
   \   0000000A   0x5489             STRB     R1,[R1, R2]
   1768          			if(*(upLdAddr + i) != (INT8U)i)
   \   0000000C   0x5C8B             LDRB     R3,[R1, R2]
   \   0000000E   0xB2CC             UXTB     R4,R1
   \   00000010   0x42A3             CMP      R3,R4
   \   00000012   0xD001             BEQ.N    ??RAMAccesscheck_1
   1769          			{
   1770          				rval = FALSE;
   \                     ??RAMAccesscheck_2:
   \   00000014   0x2000             MOVS     R0,#+0
   1771          				break;			
   \   00000016   0xE015             B.N      ??RAMAccesscheck_3
   1772          			}
   \                     ??RAMAccesscheck_1:
   \   00000018   0x1C49             ADDS     R1,R1,#+1
   \   0000001A   0x5489             STRB     R1,[R1, R2]
   \   0000001C   0x5C8B             LDRB     R3,[R1, R2]
   \   0000001E   0xB2CC             UXTB     R4,R1
   \   00000020   0x42A3             CMP      R3,R4
   \   00000022   0xD1F7             BNE.N    ??RAMAccesscheck_2
   \   00000024   0x1C49             ADDS     R1,R1,#+1
   \   00000026   0x5489             STRB     R1,[R1, R2]
   \   00000028   0x5C8B             LDRB     R3,[R1, R2]
   \   0000002A   0xB2CC             UXTB     R4,R1
   \   0000002C   0x42A3             CMP      R3,R4
   \   0000002E   0xD1F1             BNE.N    ??RAMAccesscheck_2
   \   00000030   0x1C49             ADDS     R1,R1,#+1
   \   00000032   0x5489             STRB     R1,[R1, R2]
   \   00000034   0x5C8B             LDRB     R3,[R1, R2]
   \   00000036   0xB2CC             UXTB     R4,R1
   \   00000038   0x42A3             CMP      R3,R4
   \   0000003A   0xD1EB             BNE.N    ??RAMAccesscheck_2
   1773          		}
   \   0000003C   0x1C49             ADDS     R1,R1,#+1
   \   0000003E   0xF5B1 0x6F80      CMP      R1,#+1024
   \   00000042   0xDBE2             BLT.N    ??RAMAccesscheck_0
   1774          		
   1775          	}
   1776          ////
   1777          #if 0
   1778          	{
   1779          		INT32U i = 0, j = 0, ret = 0;
   1780          
   1781          		INT8U *rptr = (INT8U *)__pAPBK_SRAMAddr;				
   1782          
   1783          		tptr->printf("SRAM START --> \n");
   1784          
   1785          		for(i = 0; i < (512*1024) && !ret; i++)
   1786          		{
   1787          			for(j = 0; j < 8 && !ret; j++)
   1788          			{
   1789          				*(rptr + i) = 1 << j;
   1790          
   1791          				if( *(rptr + i) != (1 << j))
   1792          				{
   1793          					tptr->printf("SRAM WRITE ERROR: ADDR: %02x, %02x \n", i, j, *(rptr + i));
   1794          					ret = TRUE;
   1795          					break;
   1796          				}
   1797          			}
   1798          			WatchdogClear();
   1799          			if(!(i%32)) tptr->printf(".");
   1800          		}
   1801          		tptr->printf("\nEND\n");
   1802          	}
   1803          
   1804          #endif
   1805          
   1806          
   1807          
   1808          ///
   1809          
   1810          
   1811          	return rval;
   \                     ??RAMAccesscheck_3:
   \   00000044   0xBC10             POP      {R4}
   \   00000046   0x4770             BX       LR               ;; return
   1812          }
   1813          /*#################################################*/
   1814          /*###  입력된 문자열에서 Space로 분리된 단어를  ###*/
   1815          /*###  분리한다.                                ###*/
   1816          /*###  입력 : buff    --> 문자열 포인터.        ###*/
   1817          /*###  출력 : argc    --> Argument Number.      ###*/
   1818          /*###         *argv[] --> Argument Buff.        ###*/
   1819          /*#################################################*/

   \                                 In section .text, align 2, keep-with-next
   1820          void Parser(char *buff)
   1821          {
   1822              Argc=0;
   \                     Parser:
   \   00000000   0x....             LDR.N    R1,??DataTable123_24
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x804A             STRH     R2,[R1, #+2]
   1823              while(*buff){
   \                     ??Parser_0:
   \   00000006   0x7802             LDRB     R2,[R0, #+0]
   \   00000008   0xB1E2             CBZ.N    R2,??Parser_1
   1824                  while(*buff==' ')
   \   0000000A   0x2A20             CMP      R2,#+32
   \   0000000C   0xD103             BNE.N    ??Parser_2
   1825                      buff++;
   \                     ??Parser_3:
   \   0000000E   0xF810 0x2F01      LDRB     R2,[R0, #+1]!
   \   00000012   0x2A20             CMP      R2,#+32
   \   00000014   0xD0FB             BEQ.N    ??Parser_3
   1826                  if(!*buff)
   \                     ??Parser_2:
   \   00000016   0x7802             LDRB     R2,[R0, #+0]
   \   00000018   0xB1A2             CBZ.N    R2,??Parser_1
   1827                      break;
   1828                  Argv[Argc++]=buff++;
   \   0000001A   0x884A             LDRH     R2,[R1, #+2]
   \   0000001C   0xEB01 0x0382      ADD      R3,R1,R2, LSL #+2
   \   00000020   0x6058             STR      R0,[R3, #+4]
   \   00000022   0x1C40             ADDS     R0,R0,#+1
   \   00000024   0x1C52             ADDS     R2,R2,#+1
   \   00000026   0x804A             STRH     R2,[R1, #+2]
   \   00000028   0xE000             B.N      ??Parser_4
   1829                  while(*buff!=' ' && *buff)
   1830                      buff++;
   \                     ??Parser_5:
   \   0000002A   0x1C40             ADDS     R0,R0,#+1
   \                     ??Parser_4:
   \   0000002C   0x7802             LDRB     R2,[R0, #+0]
   \   0000002E   0x2A20             CMP      R2,#+32
   \   00000030   0xBF18             IT       NE 
   \   00000032   0x2A00             CMPNE    R2,#+0
   \   00000034   0xD1F9             BNE.N    ??Parser_5
   1831                  if(*buff)
   \   00000036   0xB112             CBZ.N    R2,??Parser_6
   1832                      *buff++='\0';
   \   00000038   0x2200             MOVS     R2,#+0
   \   0000003A   0xF800 0x2B01      STRB     R2,[R0], #+1
   1833                  if(Argc>=MAX_SARGC)
   \                     ??Parser_6:
   \   0000003E   0x884A             LDRH     R2,[R1, #+2]
   \   00000040   0x2A0F             CMP      R2,#+15
   \   00000042   0xD3E0             BCC.N    ??Parser_0
   1834                      break;
   1835              }
   1836          }
   \                     ??Parser_1:
   \   00000044   0x4770             BX       LR               ;; return
   1837          
   1838          /*#################################################*/
   1839          /*## 입력된 ASCII문자를 32Bit HEX로 변환.        ##*/
   1840          /*#################################################*/

   \                                 In section .text, align 2, keep-with-next
   1841          int Atox(char *Buff)
   1842          {
   \                     Atox:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   1843          	int Hex;
   1844          	INT8U Len;
   1845          	INT8U i;
   1846          
   1847          	Len=strlen(Buff);
   \   00000004   0x.... 0x....      BL       strlen
   \   00000008   0xB2C5             UXTB     R5,R0
   1848          	for(i=0,Hex=0;i<Len;i++){
   \   0000000A   0x2600             MOVS     R6,#+0
   \   0000000C   0x2D01             CMP      R5,#+1
   \   0000000E   0xDB0A             BLT.N    ??Atox_0
   \   00000010   0x1E68             SUBS     R0,R5,#+1
   \   00000012   0x0087             LSLS     R7,R0,#+2
   1849          		Hex|=(((int)Atox4(*Buff++))<<((Len-i-1)*4));
   \                     ??Atox_1:
   \   00000014   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   00000018   0x.... 0x....      BL       Atox4
   \   0000001C   0x40B8             LSLS     R0,R0,R7
   \   0000001E   0x4306             ORRS     R6,R0,R6
   1850          	}
   \   00000020   0x1F3F             SUBS     R7,R7,#+4
   \   00000022   0x1E6D             SUBS     R5,R5,#+1
   \   00000024   0xD1F6             BNE.N    ??Atox_1
   1851          	return(Hex);
   \                     ??Atox_0:
   \   00000026   0x4630             MOV      R0,R6
   \   00000028   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   1852          }
   1853          /*#################################################*/
   1854          /*## 입력된 2 Byte ASCII문자를 8Bit HEX로 변환.  ##*/
   1855          /*#################################################*/

   \                                 In section .text, align 2, keep-with-next
   1856          char Atox8(char *Buff)
   1857          {
   \                     Atox8:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1858          	char Data;
   1859          	Data=Atox4(*Buff++)<<4 & 0xF0;
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0x.... 0x....      BL       Atox4
   \   0000000A   0x4605             MOV      R5,R0
   1860          	Data|=Atox4(*Buff);
   1861          	return(Data);
   \   0000000C   0xF814 0x0F01      LDRB     R0,[R4, #+1]!
   \   00000010   0x.... 0x....      BL       Atox4
   \   00000014   0xEA40 0x1005      ORR      R0,R0,R5, LSL #+4
   \   00000018   0xB2C0             UXTB     R0,R0
   \   0000001A   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   1862          }
   1863          /*#################################################*/
   1864          /*## 입력된 한 Byte ASCII문자를 4Bit HEX로 변환. ##*/
   1865          /*#################################################*/

   \                                 In section .text, align 2, keep-with-next
   1866          char Atox4(char Ascii)
   1867          {
   1868             	if(Ascii>='0' && Ascii<='9') return(Ascii-'0');
   \                     Atox4:
   \   00000000   0xF1A0 0x0130      SUB      R1,R0,#+48
   \   00000004   0xB2C9             UXTB     R1,R1
   \   00000006   0x290A             CMP      R1,#+10
   \   00000008   0xD201             BCS.N    ??Atox4_0
   \   0000000A   0x4608             MOV      R0,R1
   \   0000000C   0x4770             BX       LR
   1869             	if(Ascii>='A' && Ascii<='F') return(Ascii-'A'+10);
   \                     ??Atox4_0:
   \   0000000E   0xF1A0 0x0141      SUB      R1,R0,#+65
   \   00000012   0x2906             CMP      R1,#+6
   \   00000014   0xBF38             IT       CC 
   \   00000016   0x3837             SUBCC    R0,R0,#+55
   \   00000018   0xD304             BCC.N    ??Atox4_1
   1870             	if(Ascii>='a' && Ascii<='f') return(Ascii-'a'+10);
   \   0000001A   0xF1A0 0x0161      SUB      R1,R0,#+97
   \   0000001E   0x2906             CMP      R1,#+6
   \   00000020   0xD202             BCS.N    ??Atox4_2
   \   00000022   0x3857             SUBS     R0,R0,#+87
   \                     ??Atox4_1:
   \   00000024   0xB2C0             UXTB     R0,R0
   \   00000026   0x4770             BX       LR
   1871             	return(0);
   \                     ??Atox4_2:
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x4770             BX       LR               ;; return
   1872          }
   1873          
   1874          
   1875          

   \                                 In section .text, align 2, keep-with-next
   1876          int lower(char c)
   1877          {
   1878          	if(c>='a'&&c<='z')
   \                     lower:
   \   00000000   0xF1A0 0x0161      SUB      R1,R0,#+97
   \   00000004   0x291A             CMP      R1,#+26
   \   00000006   0xBF38             IT       CC 
   \   00000008   0x3820             SUBCC    R0,R0,#+32
   1879          		return c+'A'-'a';
   1880          	else
   1881          
   1882          	return c;
   \   0000000A   0x4770             BX       LR               ;; return
   1883          }
   1884          
   1885          
   1886          
   1887          

   \                                 In section .text, align 2, keep-with-next
   1888          INT32S sSPI_DataRead(DevSPIxStr *Devptr, INT8U Path, INT8U OPCODE, INT32U ADDR, INT8U *DATA, INT32U nlen)
   1889          {
   \                     sSPI_DataRead:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4690             MOV      R8,R2
   \   00000008   0x461E             MOV      R6,R3
   \   0000000A   0x9F06             LDR      R7,[SP, #+24]
   \   0000000C   0x9D07             LDR      R5,[SP, #+28]
   1890          	INT8U err = 0;
                 	      ^
Warning[Pe177]: variable "err" was declared but never referenced
   1891          	INT8U tmp = 0;
   1892          	INT32U i = 0;
   1893          
   1894          //	OSSemPend(Devptr->OSSem, 0, &err);
   1895          
   1896          	Devptr->nDevNo = Path;
   \   0000000E   0x7021             STRB     R1,[R4, #+0]
   1897          
   1898          	iDev_SPIx_CS_RST(Devptr->nDevNo);
   \   00000010   0x4608             MOV      R0,R1
   \   00000012   0x.... 0x....      BL       iDev_SPIx_CS_RST
   1899          
   1900          	SetSPIxCommand_Test(Devptr->SPIx, OPCODE);
   \   00000016   0x4641             MOV      R1,R8
   \   00000018   0x7860             LDRB     R0,[R4, #+1]
   \   0000001A   0x.... 0x....      BL       SetSPIxCommand_Test
   1901          
   1902          	SetSPIxCommand_Test(Devptr->SPIx, (ADDR >> 16) & 0xFF);
   \   0000001E   0x0C30             LSRS     R0,R6,#+16
   \   00000020   0xB2C1             UXTB     R1,R0
   \   00000022   0x7860             LDRB     R0,[R4, #+1]
   \   00000024   0x.... 0x....      BL       SetSPIxCommand_Test
   1903          	SetSPIxCommand_Test(Devptr->SPIx, (ADDR >>  8) & 0xFF);
   \   00000028   0xF3C6 0x2107      UBFX     R1,R6,#+8,#+8
   \   0000002C   0x7860             LDRB     R0,[R4, #+1]
   \   0000002E   0x.... 0x....      BL       SetSPIxCommand_Test
   1904          	SetSPIxCommand_Test(Devptr->SPIx, (ADDR >>  0) & 0xFF);
   \   00000032   0xB2F1             UXTB     R1,R6
   \   00000034   0x7860             LDRB     R0,[R4, #+1]
   \   00000036   0x.... 0x....      BL       SetSPIxCommand_Test
   1905          
   1906          
   1907          	for(i = 0; i < nlen; i++)
   \   0000003A   0xB13D             CBZ.N    R5,??sSPI_DataRead_0
   1908          	{
   1909          		DATA[i] = SetSPIxCommand_Test(Devptr->SPIx, DATA[i]);
   \                     ??sSPI_DataRead_1:
   \   0000003C   0x7839             LDRB     R1,[R7, #+0]
   \   0000003E   0x7860             LDRB     R0,[R4, #+1]
   \   00000040   0x.... 0x....      BL       SetSPIxCommand_Test
   \   00000044   0xF807 0x0B01      STRB     R0,[R7], #+1
   1910          	}
   \   00000048   0x1E6D             SUBS     R5,R5,#+1
   \   0000004A   0xD1F7             BNE.N    ??sSPI_DataRead_1
   1911          
   1912          	iDev_SPIx_CS_SET(Devptr->nDevNo);
   \                     ??sSPI_DataRead_0:
   \   0000004C   0x7820             LDRB     R0,[R4, #+0]
   \   0000004E   0x.... 0x....      BL       iDev_SPIx_CS_SET
   1913          
   1914          	
   1915          //	OSSemPost(Devptr->OSSem);
   1916          
   1917          	return tmp;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1918          }
   1919          
   1920          
   1921          

   \                                 In section .text, align 2, keep-with-next
   1922          INT32S sSPI_SetRegister(DevSPIxStr *Devptr, INT8U Path, INT8U OPCODE, INT32U ADDR, INT8U *DATA, INT32U nlen)
   1923          {
   \                     sSPI_SetRegister:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4690             MOV      R8,R2
   \   00000008   0x9E06             LDR      R6,[SP, #+24]
   \   0000000A   0x9F07             LDR      R7,[SP, #+28]
   1924          	INT32U i = 0;
   \   0000000C   0x2500             MOVS     R5,#+0
   1925          	INT8U NeedAddr = FALSE;
   1926          
   1927          	Devptr->nDevNo = Path;
   \   0000000E   0x7021             STRB     R1,[R4, #+0]
   1928          
   1929          	iDev_SPIx_CS_RST(Devptr->nDevNo);
   \   00000010   0x4608             MOV      R0,R1
   \   00000012   0x.... 0x....      BL       iDev_SPIx_CS_RST
   1930          
   1931          	SetSPIxCommand(Devptr->SPIx, OPCODE);
   \   00000016   0x4641             MOV      R1,R8
   \   00000018   0x7860             LDRB     R0,[R4, #+1]
   \   0000001A   0x.... 0x....      BL       SetSPIxCommand
   1932          
   1933          	if(NeedAddr){
   1934          		SetSPIxCommand(Devptr->SPIx, (ADDR >> 16) & 0xFF);
   1935          		SetSPIxCommand(Devptr->SPIx, (ADDR >>  8) & 0xFF);
   1936          		SetSPIxCommand(Devptr->SPIx, (ADDR >>  0) & 0xFF);
   1937          	}
   1938          
   1939          	for(i = 0; i < nlen; i++)
   \   0000001E   0xB147             CBZ.N    R7,??sSPI_SetRegister_0
   1940          	{
   1941          		DATA[i] = SetSPIxCommand(Devptr->SPIx, DATA[i]);
   \                     ??sSPI_SetRegister_1:
   \   00000020   0x7831             LDRB     R1,[R6, #+0]
   \   00000022   0x7860             LDRB     R0,[R4, #+1]
   \   00000024   0x.... 0x....      BL       SetSPIxCommand
   \   00000028   0xF806 0x0B01      STRB     R0,[R6], #+1
   1942          	}
   \   0000002C   0x1C6D             ADDS     R5,R5,#+1
   \   0000002E   0x42BD             CMP      R5,R7
   \   00000030   0xD3F6             BCC.N    ??sSPI_SetRegister_1
   1943          
   1944          	iDev_SPIx_CS_SET(Devptr->nDevNo);
   \                     ??sSPI_SetRegister_0:
   \   00000032   0x7820             LDRB     R0,[R4, #+0]
   \   00000034   0x.... 0x....      BL       iDev_SPIx_CS_SET
   1945          
   1946          	return i;
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   1947          }

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "NON TESTED">`:
   \   00000000   0x4E 0x4F          DC8 "NON TESTED"
   \              0x4E 0x20    
   \              0x54 0x45    
   \              0x53 0x54    
   \              0x45 0x44    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "    TESTED">`:
   \   00000000   0x20 0x20          DC8 "    TESTED"
   \              0x20 0x20    
   \              0x54 0x45    
   \              0x53 0x54    
   \              0x45 0x44    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "AC(PSU)      :">`:
   \   00000000   0x41 0x43          DC8 "AC(PSU)      :"
   \              0x28 0x50    
   \              0x53 0x55    
   \              0x29 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "CL_PLL_LD    :">`:
   \   00000000   0x43 0x4C          DC8 "CL_PLL_LD    :"
   \              0x5F 0x50    
   \              0x4C 0x4C    
   \              0x5F 0x4C    
   \              0x44 0x20    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "LTEA_PLL_LD  :">`:
   \   00000000   0x4C 0x54          DC8 "LTEA_PLL_LD  :"
   \              0x45 0x41    
   \              0x5F 0x50    
   \              0x4C 0x4C    
   \              0x5F 0x4C    
   \              0x44 0x20    
   \              0x20 0x3A    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "WCDMA_PLL_LD :">`:
   \   00000000   0x57 0x43          DC8 "WCDMA_PLL_LD :"
   \              0x44 0x4D    
   \              0x41 0x5F    
   \              0x50 0x4C    
   \              0x4C 0x5F    
   \              0x4C 0x44    
   \              0x20 0x3A    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "F_DONE       :">`:
   \   00000000   0x46 0x5F          DC8 "F_DONE       :"
   \              0x44 0x4F    
   \              0x4E 0x45    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "DTU_Insert   :">`:
   \   00000000   0x44 0x54          DC8 "DTU_Insert   :"
   \              0x55 0x5F    
   \              0x49 0x6E    
   \              0x73 0x65    
   \              0x72 0x74    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "DTU_Insert1  :">`:
   \   00000000   0x44 0x54          DC8 "DTU_Insert1  :"
   \              0x55 0x5F    
   \              0x49 0x6E    
   \              0x73 0x65    
   \              0x72 0x74    
   \              0x31 0x20    
   \              0x20 0x3A    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "RF_Insert    :">`:
   \   00000000   0x52 0x46          DC8 "RF_Insert    :"
   \              0x5F 0x49    
   \              0x6E 0x73    
   \              0x65 0x72    
   \              0x74 0x20    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "EXT_Insert\\t  :">`:
   \   00000000   0x45 0x58          DC8 "EXT_Insert\t  :"
   \              0x54 0x5F    
   \              0x49 0x6E    
   \              0x73 0x65    
   \              0x72 0x74    
   \              0x09 0x20    
   \              0x20 0x3A    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "DET">`:
   \   00000000   0x44 0x45          DC8 "DET"
   \              0x54 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "ISO">`:
   \   00000000   0x49 0x53          DC8 "ISO"
   \              0x4F 0x00    

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "W">`:
   \   00000000   0x57 0x00          DC8 "W"

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "R">`:
   \   00000000   0x52 0x00          DC8 "R"

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "SPI">`:
   \   00000000   0x53 0x50          DC8 "SPI"
   \              0x49 0x00    

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "0">`:
   \   00000000   0x30 0x00          DC8 "0"

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\n\\r Unknown Command!!">`:
   \   00000000   0x0A 0x0D          DC8 "\012\015 Unknown Command!!"
   \              0x20 0x55    
   \              0x6E 0x6B    
   \              0x6E 0x6F    
   \              0x77 0x6E    
   \              0x20 0x43    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x21 0x21    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable112:
   \   00000000   0x41 0x00          DC8      "A",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable112_1:
   \   00000000   0x4F 0x00          DC8      "O",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable112_2:
   \   00000000   0x49 0x00          DC8      "I",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable112_3:
   \   00000000   0x........         DC32     TestTaskStk+0x7FC

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable112_4:
   \   00000000   0x........         DC32     gTestFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable112_5:
   \   00000000   0x........         DC32     MonStr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable112_6:
   \   00000000   0x........         DC32     SerPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable112_7:
   \   00000000   0x........         DC32     iUser_Value2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable112_8:
   \   00000000   0x43 0x00          DC8      "C",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable112_9:
   \   00000000   0x53 0x00          DC8      "S",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "HELP">`:
   \   00000000   0x48 0x45          DC8 "HELP"
   \              0x4C 0x50    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "FPGA">`:
   \   00000000   0x46 0x50          DC8 "FPGA"
   \              0x47 0x41    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "DTUPeakPower[%x][%x][...">`:
   \   00000000   0x44 0x54          DC8 "DTUPeakPower[%x][%x][%x][%x]:%d.%d \012"
   \              0x55 0x50    
   \              0x65 0x61    
   \              0x6B 0x50    
   \              0x6F 0x77    
   \              0x65 0x72    
   \              0x5B 0x25    
   \              0x78 0x5D    
   \              0x5B 0x25    
   \              0x78 0x5D    
   \              0x5B 0x25    
   \              0x78 0x5D    
   \              0x5B 0x25    
   \              0x78 0x5D    
   \              0x3A 0x25    
   \              0x64 0x2E    
   \              0x25 0x64    
   \              0x20 0x0A    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "DTUAverPower[%x][%x][...">`:
   \   00000000   0x44 0x54          DC8 "DTUAverPower[%x][%x][%x][%x]:%d.%d \012"
   \              0x55 0x41    
   \              0x76 0x65    
   \              0x72 0x50    
   \              0x6F 0x77    
   \              0x65 0x72    
   \              0x5B 0x25    
   \              0x78 0x5D    
   \              0x5B 0x25    
   \              0x78 0x5D    
   \              0x5B 0x25    
   \              0x78 0x5D    
   \              0x5B 0x25    
   \              0x78 0x5D    
   \              0x3A 0x25    
   \              0x64 0x2E    
   \              0x25 0x64    
   \              0x20 0x0A    
   \              0x00         
   \   00000025   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "ISOPower[%x]:[%x][%x]...">`:
   \   00000000   0x49 0x53          DC8 "ISOPower[%x]:[%x][%x]>[%x][%d] \012"
   \              0x4F 0x50    
   \              0x6F 0x77    
   \              0x65 0x72    
   \              0x5B 0x25    
   \              0x78 0x5D    
   \              0x3A 0x5B    
   \              0x25 0x78    
   \              0x5D 0x5B    
   \              0x25 0x78    
   \              0x5D 0x3E    
   \              0x5B 0x25    
   \              0x78 0x5D    
   \              0x5B 0x25    
   \              0x64 0x5D    
   \              0x20 0x0A    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "FPGA Write[%x]: data[...">`:
   \   00000000   0x46 0x50          DC8 "FPGA Write[%x]: data[%x]\012"
   \              0x47 0x41    
   \              0x20 0x57    
   \              0x72 0x69    
   \              0x74 0x65    
   \              0x5B 0x25    
   \              0x78 0x5D    
   \              0x3A 0x20    
   \              0x64 0x61    
   \              0x74 0x61    
   \              0x5B 0x25    
   \              0x78 0x5D    
   \              0x0A 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "FPGA Read[%x]: data[%x]\\n">`:
   \   00000000   0x46 0x50          DC8 "FPGA Read[%x]: data[%x]\012"
   \              0x47 0x41    
   \              0x20 0x52    
   \              0x65 0x61    
   \              0x64 0x5B    
   \              0x25 0x78    
   \              0x5D 0x3A    
   \              0x20 0x64    
   \              0x61 0x74    
   \              0x61 0x5B    
   \              0x25 0x78    
   \              0x5D 0x0A    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "RESET">`:
   \   00000000   0x52 0x45          DC8 "RESET"
   \              0x53 0x45    
   \              0x54 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "[%s]\\n">`:
   \   00000000   0x5B 0x25          DC8 "[%s]\012"
   \              0x73 0x5D    
   \              0x0A 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "[%02x]\\n">`:
   \   00000000   0x5B 0x25          DC8 "[%02x]\012"
   \              0x30 0x32    
   \              0x78 0x5D    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "FLASH">`:
   \   00000000   0x46 0x4C          DC8 "FLASH"
   \              0x41 0x53    
   \              0x48 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "[%02x]">`:
   \   00000000   0x5B 0x25          DC8 "[%02x]"
   \              0x30 0x32    
   \              0x78 0x5D    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "0xE9 tmp[%d]\\n">`:
   \   00000000   0x30 0x78          DC8 "0xE9 tmp[%d]\012"
   \              0x45 0x39    
   \              0x20 0x74    
   \              0x6D 0x70    
   \              0x5B 0x25    
   \              0x64 0x5D    
   \              0x0A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "0xB7 tmp[%d]\\n">`:
   \   00000000   0x30 0x78          DC8 "0xB7 tmp[%d]\012"
   \              0x42 0x37    
   \              0x20 0x74    
   \              0x6D 0x70    
   \              0x5B 0x25    
   \              0x64 0x5D    
   \              0x0A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "[%x]\\n">`:
   \   00000000   0x5B 0x25          DC8 "[%x]\012"
   \              0x78 0x5D    
   \              0x0A 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "tmp[%d]\\n">`:
   \   00000000   0x74 0x6D          DC8 "tmp[%d]\012"
   \              0x70 0x5B    
   \              0x25 0x64    
   \              0x5D 0x0A    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "tmp[%d]>>">`:
   \   00000000   0x74 0x6D          DC8 "tmp[%d]>>"
   \              0x70 0x5B    
   \              0x25 0x64    
   \              0x5D 0x3E    
   \              0x3E 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "70 tmp[%d]>>">`:
   \   00000000   0x37 0x30          DC8 "70 tmp[%d]>>"
   \              0x20 0x74    
   \              0x6D 0x70    
   \              0x5B 0x25    
   \              0x64 0x5D    
   \              0x3E 0x3E    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "[%x]">`:
   \   00000000   0x5B 0x25          DC8 "[%x]"
   \              0x78 0x5D    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "TEST">`:
   \   00000000   0x54 0x45          DC8 "TEST"
   \              0x53 0x54    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\n Default Back-up End...">`:
   \   00000000   0x0A 0x20          DC8 "\012 Default Back-up End -> Reboot...  \012\012"
   \              0x44 0x65    
   \              0x66 0x61    
   \              0x75 0x6C    
   \              0x74 0x20    
   \              0x42 0x61    
   \              0x63 0x6B    
   \              0x2D 0x75    
   \              0x70 0x20    
   \              0x45 0x6E    
   \              0x64 0x20    
   \              0x2D 0x3E    
   \              0x20 0x52    
   \              0x65 0x62    
   \              0x6F 0x6F    
   \              0x74 0x2E    
   \              0x2E 0x2E    
   \              0x20 0x20    
   \              0x0A 0x0A    
   \              0x00         
   \   00000027   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "SRAM">`:
   \   00000000   0x53 0x52          DC8 "SRAM"
   \              0x41 0x4D    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "ETC[%s]\\n">`:
   \   00000000   0x45 0x54          DC8 "ETC[%s]\012"
   \              0x43 0x5B    
   \              0x25 0x73    
   \              0x5D 0x0A    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable113:
   \   00000000   0x........         DC32     DTUTest

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable113_1:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable113_2:
   \   00000000   0x2E 0x00          DC8      ".",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable114:
   \   00000000   0x40240000         DC32     0x40240000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable114_1:
   \   00000000   0x40340000         DC32     0x40340000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable114_2:
   \   00000000   0x25 0x73          DC8      0x25, 0x73, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable114_3:
   \   00000000   0x........         DC32     AT25DFSpi

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "ADC Input">`:
   \   00000000   0x41 0x44          DC8 "ADC Input"
   \              0x43 0x20    
   \              0x49 0x6E    
   \              0x70 0x75    
   \              0x74 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\n* [%s] TEST START Ti...">`:
   \   00000000   0x0A 0x2A          DC8 "\012* [%s] TEST START TimeOut 5 Min]\012"
   \              0x20 0x5B    
   \              0x25 0x73    
   \              0x5D 0x20    
   \              0x54 0x45    
   \              0x53 0x54    
   \              0x20 0x53    
   \              0x54 0x41    
   \              0x52 0x54    
   \              0x20 0x54    
   \              0x69 0x6D    
   \              0x65 0x4F    
   \              0x75 0x74    
   \              0x20 0x35    
   \              0x20 0x4D    
   \              0x69 0x6E    
   \              0x5D 0x0A    
   \              0x00         
   \   00000023   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Dig Output">`:
   \   00000000   0x44 0x69          DC8 "Dig Output"
   \              0x67 0x20    
   \              0x4F 0x75    
   \              0x74 0x70    
   \              0x75 0x74    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%s test TimeOut\\n">`:
   \   00000000   0x25 0x73          DC8 "%s test TimeOut\012"
   \              0x20 0x74    
   \              0x65 0x73    
   \              0x74 0x20    
   \              0x54 0x69    
   \              0x6D 0x65    
   \              0x4F 0x75    
   \              0x74 0x0A    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%s test Canceled\\n">`:
   \   00000000   0x25 0x73          DC8 "%s test Canceled\012"
   \              0x20 0x74    
   \              0x65 0x73    
   \              0x74 0x20    
   \              0x43 0x61    
   \              0x6E 0x63    
   \              0x65 0x6C    
   \              0x65 0x64    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%s test Finished\\n">`:
   \   00000000   0x25 0x73          DC8 "%s test Finished\012"
   \              0x20 0x74    
   \              0x65 0x73    
   \              0x74 0x20    
   \              0x46 0x69    
   \              0x6E 0x69    
   \              0x73 0x68    
   \              0x65 0x64    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Dig Input">`:
   \   00000000   0x44 0x69          DC8 "Dig Input"
   \              0x67 0x20    
   \              0x49 0x6E    
   \              0x70 0x75    
   \              0x74 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\n* [%s TEST START Tim...">_1`:
   \   00000000   0x0A 0x2A          DC8 "\012* [%s TEST START TimeOut 5 Min]\012"
   \              0x20 0x5B    
   \              0x25 0x73    
   \              0x20 0x54    
   \              0x45 0x53    
   \              0x54 0x20    
   \              0x53 0x54    
   \              0x41 0x52    
   \              0x54 0x20    
   \              0x54 0x69    
   \              0x6D 0x65    
   \              0x4F 0x75    
   \              0x74 0x20    
   \              0x35 0x20    
   \              0x4D 0x69    
   \              0x6E 0x5D    
   \              0x0A 0x00    
   \   00000022   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%s Test TimeOut\\n">`:
   \   00000000   0x25 0x73          DC8 "%s Test TimeOut\012"
   \              0x20 0x54    
   \              0x65 0x73    
   \              0x74 0x20    
   \              0x54 0x69    
   \              0x6D 0x65    
   \              0x4F 0x75    
   \              0x74 0x0A    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%s Test Canceled\\n">`:
   \   00000000   0x25 0x73          DC8 "%s Test Canceled\012"
   \              0x20 0x54    
   \              0x65 0x73    
   \              0x74 0x20    
   \              0x43 0x61    
   \              0x6E 0x63    
   \              0x65 0x6C    
   \              0x65 0x64    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%s Test Finished\\n">`:
   \   00000000   0x25 0x73          DC8 "%s Test Finished\012"
   \              0x20 0x54    
   \              0x65 0x73    
   \              0x74 0x20    
   \              0x46 0x69    
   \              0x6E 0x69    
   \              0x73 0x68    
   \              0x65 0x64    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "COM \\275\\303\\307\\350">`:
   \   00000000   0x43 0x4F          DC8 "COM \275\303\307\350"
   \              0x4D 0x20    
   \              0xBD 0xC3    
   \              0xC7 0xE8    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\n* [%s TEST START Tim...">`:
   \   00000000   0x0A 0x2A          DC8 "\012* [%s TEST START TimeOut 5Min]\012"
   \              0x20 0x5B    
   \              0x25 0x73    
   \              0x20 0x54    
   \              0x45 0x53    
   \              0x54 0x20    
   \              0x53 0x54    
   \              0x41 0x52    
   \              0x54 0x20    
   \              0x54 0x69    
   \              0x6D 0x65    
   \              0x4F 0x75    
   \              0x74 0x20    
   \              0x35 0x4D    
   \              0x69 0x6E    
   \              0x5D 0x0A    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%s test Test TimeOut\\n">`:
   \   00000000   0x25 0x73          DC8 "%s test Test TimeOut\012"
   \              0x20 0x74    
   \              0x65 0x73    
   \              0x74 0x20    
   \              0x54 0x65    
   \              0x73 0x74    
   \              0x20 0x54    
   \              0x69 0x6D    
   \              0x65 0x4F    
   \              0x75 0x74    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%s test Test Canceled\\n">`:
   \   00000000   0x25 0x73          DC8 "%s test Test Canceled\012"
   \              0x20 0x74    
   \              0x65 0x73    
   \              0x74 0x20    
   \              0x54 0x65    
   \              0x73 0x74    
   \              0x20 0x43    
   \              0x61 0x6E    
   \              0x63 0x65    
   \              0x6C 0x65    
   \              0x64 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%s Test Test Finished\\n">`:
   \   00000000   0x25 0x73          DC8 "%s Test Test Finished\012"
   \              0x20 0x54    
   \              0x65 0x73    
   \              0x74 0x20    
   \              0x54 0x65    
   \              0x73 0x74    
   \              0x20 0x46    
   \              0x69 0x6E    
   \              0x69 0x73    
   \              0x68 0x65    
   \              0x64 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\n      RAM TEST OK!!\\n">`:
   \   00000000   0x0A 0x20          DC8 "\012      RAM TEST OK!!\012"
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x52    
   \              0x41 0x4D    
   \              0x20 0x54    
   \              0x45 0x53    
   \              0x54 0x20    
   \              0x4F 0x4B    
   \              0x21 0x21    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "[AIN0] : %d.%03d[V]\\n">`:
   \   00000000   0x5B 0x41          DC8 "[AIN0] : %d.%03d[V]\012"
   \              0x49 0x4E    
   \              0x30 0x5D    
   \              0x20 0x3A    
   \              0x20 0x25    
   \              0x64 0x2E    
   \              0x25 0x30    
   \              0x33 0x64    
   \              0x5B 0x56    
   \              0x5D 0x0A    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "[AIN1] : %d.%03d[V]\\n">`:
   \   00000000   0x5B 0x41          DC8 "[AIN1] : %d.%03d[V]\012"
   \              0x49 0x4E    
   \              0x31 0x5D    
   \              0x20 0x3A    
   \              0x20 0x25    
   \              0x64 0x2E    
   \              0x25 0x30    
   \              0x33 0x64    
   \              0x5B 0x56    
   \              0x5D 0x0A    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable118:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable118_1:
   \   00000000   0x2E 0x00          DC8      ".",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable118_2:
   \   00000000   0x........         DC32     N25QSpi

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable118_3:
   \   00000000   0x40020414         DC32     0x40020414

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable118_4:
   \   00000000   0x000493E0         DC32     0x493e0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable119:
   \   00000000   0x2A 0x20          DC8      0x2A, 0x20, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable119_1:
   \   00000000   0x0A 0x0A          DC8      0x0A, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable119_2:
   \   00000000   0x........         DC32     tinputStsOld

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable119_3:
   \   00000000   0x........         DC32     tinputSts

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable119_4:
   \   00000000   0x2C 0x20          DC8      0x2C, 0x20, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable119_5:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable119_6:
   \   00000000   0x60040000         DC32     0x60040000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable119_7:
   \   00000000   0x........         DC32     tIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable119_8:
   \   00000000   0x........         DC32     tRevData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable121:
   \   00000000   0x........         DC32     SerPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable122:
   \   00000000   0x........         DC32     iUser_Value2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable122_1:
   \   00000000   0x........         DC32     iDebugCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123:
   \   00000000   0x001B7740         DC32     0x1b7740

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123_1:
   \   00000000   0x25 0x73          DC8      0x25, 0x73, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123_2:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123_3:
   \   00000000   0x0A 0x0A          DC8      0x0A, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123_4:
   \   00000000   0x2A 0x0A          DC8      0x2A, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123_5:
   \   00000000   0x........         DC32     ADC_AVR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123_6:
   \   00000000   0x........         DC32     pUSART1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123_7:
   \   00000000   0x........         DC32     pUSART4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123_8:
   \   00000000   0x........         DC32     comtstcnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123_9:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123_10:
   \   00000000   0x40021810         DC32     0x40021810

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123_11:
   \   00000000   0x40020010         DC32     0x40020010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123_12:
   \   00000000   0x40020410         DC32     0x40020410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123_13:
   \   00000000   0x........         DC32     AttnCS1Val

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123_14:
   \   00000000   0x........         DC32     pPCA9555Str

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123_15:
   \   00000000   0x40021414         DC32     0x40021414

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123_16:
   \   00000000   0x40020014         DC32     0x40020014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123_17:
   \   00000000   0x40020414         DC32     0x40020414

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123_18:
   \   00000000   0x40021814         DC32     0x40021814

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123_19:
   \   00000000   0x........         DC32     AttnCS0Val

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123_20:
   \   00000000   0x........         DC32     tinputSts

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123_21:
   \   00000000   0x........         DC32     tinputStsOld

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123_22:
   \   00000000   0x........         DC32     SerPtr

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123_23:
   \   00000000   0x........         DC32     testResult

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable123_24:
   \   00000000   0x........         DC32     DTUTest

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%s: %d.%d[V], [raw:%04d]">`:
   \   00000000   0x25 0x73          DC8 "%s: %d.%d[V], [raw:%04d]"
   \              0x3A 0x20    
   \              0x25 0x64    
   \              0x2E 0x25    
   \              0x64 0x5B    
   \              0x56 0x5D    
   \              0x2C 0x20    
   \              0x5B 0x72    
   \              0x61 0x77    
   \              0x3A 0x25    
   \              0x30 0x34    
   \              0x64 0x5D    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\305\\353\\275\\305\\275\\303\\307\\350 S`:
   \   00000000   0xC5 0xEB          DC8 "\305\353\275\305\275\303\307\350 Ser4[MODEM] \275\303\307\350\300\273 \303\274\305\251\307\317\277\251 \301\326\274\274\277\344     "
   \              0xBD 0xC5    
   \              0xBD 0xC3    
   \              0xC7 0xE8    
   \              0x20 0x53    
   \              0x65 0x72    
   \              0x34 0x5B    
   \              0x4D 0x4F    
   \              0x44 0x45    
   \              0x4D 0x5D    
   \              0x20 0xBD    
   \              0xC3 0xC7    
   \              0xE8 0xC0    
   \              0xBB 0x20    
   \              0xC3 0xBC    
   \              0xC5 0xA9    
   \              0xC7 0xCF    
   \              0xBF 0xA9    
   \              0x20 0xC1    
   \              0xD6 0xBC    
   \              0xBC 0xBF    
   \              0xE4 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000031   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "[OK]">`:
   \   00000000   0x5B 0x4F          DC8 "[OK]"
   \              0x4B 0x5D    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "[FAIL 1]">`:
   \   00000000   0x5B 0x46          DC8 "[FAIL 1]"
   \              0x41 0x49    
   \              0x4C 0x20    
   \              0x31 0x5D    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "[FAIL 2]: %d">`:
   \   00000000   0x5B 0x46          DC8 "[FAIL 2]: %d"
   \              0x41 0x49    
   \              0x4C 0x20    
   \              0x32 0x5D    
   \              0x3A 0x20    
   \              0x25 0x64    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%02d. ">`:
   \   00000000   0x25 0x30          DC8 "%02d. "
   \              0x32 0x64    
   \              0x2E 0x20    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "[OFF]">`:
   \   00000000   0x5B 0x4F          DC8 "[OFF]"
   \              0x46 0x46    
   \              0x5D 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "[ON ]">`:
   \   00000000   0x5B 0x4F          DC8 "[ON ]"
   \              0x4E 0x20    
   \              0x5D 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%s\\300\\314 \\274\\366\\307\\340\\265\\30`:
   \   00000000   0x25 0x73          DC8 25H, 73H, 0C0H, 0CCH, 20H, 0BCH, 0F6H, 0C7H
   \              0xC0 0xCC    
   \              0x20 0xBC    
   \              0xF6 0xC7    
   \   00000008   0xE0 0xB5          DC8 0E0H, 0B5H, 0C7H, 0BEH, 0EEH, 20H, 0C0H, 0D6H
   \              0xC7 0xBE    
   \              0xEE 0x20    
   \              0xC0 0xD6    
   \   00000010   0xBD 0xC0          DC8 0BDH, 0C0H, 0B4H, 0CFH, 0B4H, 0D9H, 2EH, 20H
   \              0xB4 0xCF    
   \              0xB4 0xD9    
   \              0x2E 0x20    
   \   00000018   0xB0 0xE8          DC8 0B0H, 0E8H, 0BCH, 0D3H, 20H, 0C1H, 0F8H, 0C7H
   \              0xBC 0xD3    
   \              0x20 0xC1    
   \              0xF8 0xC7    
   \   00000020   0xE0 0xC7          DC8 0E0H, 0C7H, 0CFH, 0BDH, 0C3H, 0B0H, 0DAH, 0BDH
   \              0xCF 0xBD    
   \              0xC3 0xB0    
   \              0xDA 0xBD    
   \   00000028   0xC0 0xB4          DC8 0C0H, 0B4H, 0CFH, 0B1H, 0EEH, 3FH, 5BH, 59H
   \              0xCF 0xB1    
   \              0xEE 0x3F    
   \              0x5B 0x59    
   \   00000030   0x5D 0x65          DC8 5DH, 65H, 73H, 2CH, 20H, 5BH, 43H, 5DH
   \              0x73 0x2C    
   \              0x20 0x5B    
   \              0x43 0x5D    
   \   00000038   0x61 0x6E          DC8 61H, 6EH, 63H, 65H, 6CH, 0AH, 0
   \              0x63 0x65    
   \              0x6C 0x0A    
   \              0x00         
   \   0000003F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "CANCEL TEST \\n">`:
   \   00000000   0x43 0x41          DC8 "CANCEL TEST \012"
   \              0x4E 0x43    
   \              0x45 0x4C    
   \              0x20 0x54    
   \              0x45 0x53    
   \              0x54 0x20    
   \              0x0A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "* %s [VER:%d.%d]\\n">`:
   \   00000000   0x2A 0x20          DC8 "* %s [VER:%d.%d]\012"
   \              0x25 0x73    
   \              0x20 0x5B    
   \              0x56 0x45    
   \              0x52 0x3A    
   \              0x25 0x64    
   \              0x2E 0x25    
   \              0x64 0x5D    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "TRIO-MD RCU CTRL TEST...">`:
   \   00000000   0x54 0x52          DC8 "TRIO-MD RCU CTRL TEST PROGRAM"
   \              0x49 0x4F    
   \              0x2D 0x4D    
   \              0x44 0x20    
   \              0x52 0x43    
   \              0x55 0x20    
   \              0x43 0x54    
   \              0x52 0x4C    
   \              0x20 0x54    
   \              0x45 0x53    
   \              0x54 0x20    
   \              0x50 0x52    
   \              0x4F 0x47    
   \              0x52 0x41    
   \              0x4D 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*    -COMMAND 1st-\\n">`:
   \   00000000   0x2A 0x20          DC8 "*    -COMMAND 1st-\012"
   \              0x20 0x20    
   \              0x20 0x2D    
   \              0x43 0x4F    
   \              0x4D 0x4D    
   \              0x41 0x4E    
   \              0x44 0x20    
   \              0x31 0x73    
   \              0x74 0x2D    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*  ?        : help(th...">`:
   \   00000000   0x2A 0x20          DC8 "*  ?        : help(this message)\012"
   \              0x20 0x3F    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x3A 0x20    
   \              0x68 0x65    
   \              0x6C 0x70    
   \              0x28 0x74    
   \              0x68 0x69    
   \              0x73 0x20    
   \              0x6D 0x65    
   \              0x73 0x73    
   \              0x61 0x67    
   \              0x65 0x29    
   \              0x0A 0x00    
   \   00000022   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*  TEST I        : IN...">`:
   \   00000000   0x2A 0x20          DC8 "*  TEST I        : INPUT Test          [%s]\012"
   \              0x20 0x54    
   \              0x45 0x53    
   \              0x54 0x20    
   \              0x49 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x20 0x49    
   \              0x4E 0x50    
   \              0x55 0x54    
   \              0x20 0x54    
   \              0x65 0x73    
   \              0x74 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x5B    
   \              0x25 0x73    
   \              0x5D 0x0A    
   \              0x00         
   \   0000002D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*  TEST O        : OU...">`:
   \   00000000   0x2A 0x20          DC8 "*  TEST O        : OUTPUT Test         [%s]\012"
   \              0x20 0x54    
   \              0x45 0x53    
   \              0x54 0x20    
   \              0x4F 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x20 0x4F    
   \              0x55 0x54    
   \              0x50 0x55    
   \              0x54 0x20    
   \              0x54 0x65    
   \              0x73 0x74    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x5B    
   \              0x25 0x73    
   \              0x5D 0x0A    
   \              0x00         
   \   0000002D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*  TEST C        : SE...">`:
   \   00000000   0x2A 0x20          DC8 "*  TEST C        : SERIAL[UART]        [%s]\012"
   \              0x20 0x54    
   \              0x45 0x53    
   \              0x54 0x20    
   \              0x43 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x20 0x53    
   \              0x45 0x52    
   \              0x49 0x41    
   \              0x4C 0x5B    
   \              0x55 0x41    
   \              0x52 0x54    
   \              0x5D 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x5B    
   \              0x25 0x73    
   \              0x5D 0x0A    
   \              0x00         
   \   0000002D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*  TEST A        : AN...">`:
   \   00000000   0x2A 0x20          DC8 "*  TEST A        : ANALOG DECT         [%s]\012"
   \              0x20 0x54    
   \              0x45 0x53    
   \              0x54 0x20    
   \              0x41 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x20 0x41    
   \              0x4E 0x41    
   \              0x4C 0x4F    
   \              0x47 0x20    
   \              0x44 0x45    
   \              0x43 0x54    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x5B    
   \              0x25 0x73    
   \              0x5D 0x0A    
   \              0x00         
   \   0000002D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*  RESET         : RE...">`:
   \   00000000   0x2A 0x20          DC8 "*  RESET         : RESET\012"
   \              0x20 0x52    
   \              0x45 0x53    
   \              0x45 0x54    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x20 0x52    
   \              0x45 0x53    
   \              0x45 0x54    
   \              0x0A 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*  TEST SRAM\\t : SRAM ...">`:
   \   00000000   0x2A 0x20          DC8 "*  TEST SRAM\t : SRAM TEST\012"
   \              0x20 0x54    
   \              0x45 0x53    
   \              0x54 0x20    
   \              0x53 0x52    
   \              0x41 0x4D    
   \              0x09 0x20    
   \              0x3A 0x20    
   \              0x53 0x52    
   \              0x41 0x4D    
   \              0x20 0x54    
   \              0x45 0x53    
   \              0x54 0x0A    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*  FPGA DET 0(ADDR) :...">`:
   \   00000000   0x2A 0x20          DC8 "*  FPGA DET 0(ADDR) : DTU DET TEST\012"
   \              0x20 0x46    
   \              0x50 0x47    
   \              0x41 0x20    
   \              0x44 0x45    
   \              0x54 0x20    
   \              0x30 0x28    
   \              0x41 0x44    
   \              0x44 0x52    
   \              0x29 0x20    
   \              0x3A 0x20    
   \              0x44 0x54    
   \              0x55 0x20    
   \              0x44 0x45    
   \              0x54 0x20    
   \              0x54 0x45    
   \              0x53 0x54    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*  FPGA ISO 0(ADDR) :...">`:
   \   00000000   0x2A 0x20          DC8 "*  FPGA ISO 0(ADDR) : DTU ISO TEST\012"
   \              0x20 0x46    
   \              0x50 0x47    
   \              0x41 0x20    
   \              0x49 0x53    
   \              0x4F 0x20    
   \              0x30 0x28    
   \              0x41 0x44    
   \              0x44 0x52    
   \              0x29 0x20    
   \              0x3A 0x20    
   \              0x44 0x54    
   \              0x55 0x20    
   \              0x49 0x53    
   \              0x4F 0x20    
   \              0x54 0x45    
   \              0x53 0x54    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*  FPGA W 0(ADDR) 1(D...">`:
   \   00000000   0x2A 0x20          DC8 2AH, 20H, 20H, 46H, 50H, 47H, 41H, 20H
   \              0x20 0x46    
   \              0x50 0x47    
   \              0x41 0x20    
   \   00000008   0x57 0x20          DC8 57H, 20H, 30H, 28H, 41H, 44H, 44H, 52H
   \              0x30 0x28    
   \              0x41 0x44    
   \              0x44 0x52    
   \   00000010   0x29 0x20          DC8 29H, 20H, 31H, 28H, 44H, 61H, 74H, 61H
   \              0x31 0x28    
   \              0x44 0x61    
   \              0x74 0x61    
   \   00000018   0x29 0x20          DC8 29H, 20H, 20H, 20H, 20H, 3AH, 20H, 44H
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x20 0x44    
   \   00000020   0x54 0x55          DC8 54H, 55H, 20H, 52H, 45H, 47H, 20H, 57H
   \              0x20 0x52    
   \              0x45 0x47    
   \              0x20 0x57    
   \   00000028   0x72 0x69          DC8 72H, 69H, 74H, 65H, 20H, 54H, 45H, 53H
   \              0x74 0x65    
   \              0x20 0x54    
   \              0x45 0x53    
   \   00000030   0x54 0x0A          DC8 54H, 0AH, 0
   \              0x00         
   \   00000033   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*  FPGA R 0(ADDR)    ...">`:
   \   00000000   0x2A 0x20          DC8 "*  FPGA R 0(ADDR)            : DTU REG Read TEST\012"
   \              0x20 0x46    
   \              0x50 0x47    
   \              0x41 0x20    
   \              0x52 0x20    
   \              0x30 0x28    
   \              0x41 0x44    
   \              0x44 0x52    
   \              0x29 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x20 0x44    
   \              0x54 0x55    
   \              0x20 0x52    
   \              0x45 0x47    
   \              0x20 0x52    
   \              0x65 0x61    
   \              0x64 0x20    
   \              0x54 0x45    
   \              0x53 0x54    
   \              0x0A 0x00    
   \   00000032   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*  FLASH 0 W 0(ADDR) ...">`:
   \   00000000   0x2A 0x20          DC8 2AH, 20H, 20H, 46H, 4CH, 41H, 53H, 48H
   \              0x20 0x46    
   \              0x4C 0x41    
   \              0x53 0x48    
   \   00000008   0x20 0x30          DC8 20H, 30H, 20H, 57H, 20H, 30H, 28H, 41H
   \              0x20 0x57    
   \              0x20 0x30    
   \              0x28 0x41    
   \   00000010   0x44 0x44          DC8 44H, 44H, 52H, 29H, 20H, 31H, 28H, 44H
   \              0x52 0x29    
   \              0x20 0x31    
   \              0x28 0x44    
   \   00000018   0x61 0x74          DC8 61H, 74H, 61H, 29H, 20H, 3AH, 20H, 44H
   \              0x61 0x29    
   \              0x20 0x3A    
   \              0x20 0x44    
   \   00000020   0x54 0x55          DC8 54H, 55H, 20H, 46H, 6CH, 61H, 73H, 68H
   \              0x20 0x46    
   \              0x6C 0x61    
   \              0x73 0x68    
   \   00000028   0x20 0x52          DC8 20H, 52H, 45H, 47H, 20H, 57H, 72H, 69H
   \              0x45 0x47    
   \              0x20 0x57    
   \              0x72 0x69    
   \   00000030   0x74 0x65          DC8 74H, 65H, 20H, 54H, 45H, 53H, 54H, 0AH
   \              0x20 0x54    
   \              0x45 0x53    
   \              0x54 0x0A    
   \   00000038   0x00               DC8 0
   \   00000039   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*  FLASH 0 R 0(ADDR) ...">`:
   \   00000000   0x2A 0x20          DC8 2AH, 20H, 20H, 46H, 4CH, 41H, 53H, 48H
   \              0x20 0x46    
   \              0x4C 0x41    
   \              0x53 0x48    
   \   00000008   0x20 0x30          DC8 20H, 30H, 20H, 52H, 20H, 30H, 28H, 41H
   \              0x20 0x52    
   \              0x20 0x30    
   \              0x28 0x41    
   \   00000010   0x44 0x44          DC8 44H, 44H, 52H, 29H, 20H, 20H, 20H, 20H
   \              0x52 0x29    
   \              0x20 0x20    
   \              0x20 0x20    
   \   00000018   0x20 0x20          DC8 20H, 20H, 20H, 20H, 20H, 3AH, 20H, 44H
   \              0x20 0x20    
   \              0x20 0x3A    
   \              0x20 0x44    
   \   00000020   0x54 0x55          DC8 54H, 55H, 20H, 46H, 6CH, 61H, 73H, 68H
   \              0x20 0x46    
   \              0x6C 0x61    
   \              0x73 0x68    
   \   00000028   0x20 0x52          DC8 20H, 52H, 45H, 47H, 20H, 52H, 65H, 61H
   \              0x45 0x47    
   \              0x20 0x52    
   \              0x65 0x61    
   \   00000030   0x64 0x20          DC8 64H, 20H, 54H, 45H, 53H, 54H, 0AH, 0
   \              0x54 0x45    
   \              0x53 0x54    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*********************...">`:
   \   00000000   0x2A 0x2A          DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \   00000008   0x2A 0x2A          DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \   00000010   0x2A 0x2A          DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \   00000018   0x2A 0x2A          DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \   00000020   0x2A 0x2A          DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \   00000028   0x2A 0x2A          DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \   00000030   0x2A 0x2A          DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \   00000038   0x2A 0x2A          DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \   00000040   0x2A 0x2A          DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \   00000048   0x2A 0x2A          DC8 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 2AH, 0AH
   \              0x2A 0x2A    
   \              0x2A 0x2A    
   \              0x2A 0x0A    
   \   00000050   0x00               DC8 0
   \   00000051   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "TRIO-MD >>">`:
   \   00000000   0x54 0x52          DC8 "TRIO-MD >>"
   \              0x49 0x4F    
   \              0x2D 0x4D    
   \              0x44 0x20    
   \              0x3E 0x3E    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {0}>`:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "\\n">`:
   \   00000000   0x0A 0x00          DC8 "\012"

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "P">`:
   \   00000000   0x50 0x00          DC8 "P"

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "E9">`:
   \   00000000   0x45 0x39          DC8 "E9"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "B7">`:
   \   00000000   0x42 0x37          DC8 "B7"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "E">`:
   \   00000000   0x45 0x00          DC8 "E"

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "S">`:
   \   00000000   0x53 0x00          DC8 "S"

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "D">`:
   \   00000000   0x44 0x00          DC8 "D"

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "F">`:
   \   00000000   0x46 0x00          DC8 "F"

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "70">`:
   \   00000000   0x37 0x30          DC8 "70"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "1">`:
   \   00000000   0x31 0x00          DC8 "1"

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "A">`:
   \   00000000   0x41 0x00          DC8 "A"

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "O">`:
   \   00000000   0x4F 0x00          DC8 "O"

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "I">`:
   \   00000000   0x49 0x00          DC8 "I"

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "C">`:
   \   00000000   0x43 0x00          DC8 "C"

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant ".">`:
   \   00000000   0x2E 0x00          DC8 "."

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "%s">`:
   \   00000000   0x25 0x73          DC8 "%s"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "* ">`:
   \   00000000   0x2A 0x20          DC8 "* "
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "\\n\\n">`:
   \   00000000   0x0A 0x0A          DC8 "\012\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant ", ">`:
   \   00000000   0x2C 0x20          DC8 ", "
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "*\\n">`:
   \   00000000   0x2A 0x0A          DC8 "*\012"
   \              0x00         
   \   00000003   0x00               DC8 0
   1948          
   1949          
   1950          
   1951          ///////////////////////////////////////////////////////////////////////////////
   1952          // End of Source File
   1953          ////////////////////////
   1954          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       24  AdInputStatus
             24 -- Indirect call
             24 -> ADC_ChannelEnable
             24 -> ADC_CheckFinish
             24 -> ADC_Select
             24 -> AdctoVolt33V
             24 -> OSTimeDly
              0 -> PrintStar
             24 -> PrintStar
       24  AdcPrintf
              0 -- Indirect call
             24 -- Indirect call
             24 -> AdctoVolt33V
             24 -> AdctoVolt5opamp
       24  Atox
             24 -> Atox4
             24 -> strlen
        0  Atox4
       16  Atox8
             16 -> Atox4
       24  COMTestFunc
             24 -- Indirect call
             24 -> OSTimeDly
       56  CommandInterpret
             56 -- Indirect call
             56 -> AdInputStatus
             56 -> COMTestFunc
             56 -> CurrentInputStatus
             56 -> DTU_ReadData
             56 -> DTU_WriteData
             56 -> DefaultTable
             56 -> DownLoadBootingJump
             56 -> DownloadFlagClr
             56 -> ForDelay
             56 -> HwTestOutFunc
             56 -> OSTimeDly
             56 -> PrintLogo
             56 -> TimeOverCheck
             56 -> TimerRegist
             56 -> WriteEEprom
             56 -> __aeabi_d2iz
             56 -> __aeabi_ddiv
             56 -> __aeabi_dmul
             56 -> __aeabi_memcpy4
             56 -> __aeabi_memset4
             56 -> __aeabi_ui2d
             56 -> __iar_Log
             56 -> __iar_Stolx
             56 -> sFLASH_BL4kCheckErase
             56 -> sFLASH_DataRead
             56 -> sFLASH_DataWrite
             56 -> sFLASH_SetRegister
             56 -> sSPI_DataRead
             56 -> strcmp
       48  CurrentInputStatus
              0 -- Indirect call
             48 -> DigitalInputDiplay
             48 -> GPIOPortInit
              0 -> PrintStar
             48 -> PrintStar
       32  DigitalInputDiplay
             32 -- Indirect call
             32 -> OSTimeDly
       16  GetCommand
             16 -- Indirect call
             16 -> Parser
             16 -> lower
       48  HwTestOutFunc
             48 -> AttnDataOutput
             48 -> OSTimeDly
             48 -> pPCA9555BitRst
             48 -> pPCA9555BitSet
       24  KeyProc
             24 -- Indirect call
              0 -> Parser
             24 -> strcpy
             24 -> strlen
       32  OnCommand
             32 -- Indirect call
             32 -> AdInputStatus
             32 -> COMTestFunc
             32 -> CurrentInputStatus
             32 -> DownLoadBootingJump
             32 -> DownloadFlagClr
             32 -> ForDelay
             32 -> HwTestOutFunc
             32 -> OSTimeDly
             32 -> PrintLogo
             32 -> PromptOut
             32 -> TimeOverCheck
             32 -> TimerRegist
             32 -> __aeabi_memcpy4
        0  Parser
       16  PrintLogo
             16 -- Indirect call
              0 -> PrintStar
             16 -> PrintStar
        0  PrintStar
              0 -- Indirect call
        0  PromptOut
              0 -- Indirect call
        4  RAMAccesscheck
        0  SavetoTestBackup
        8  TestCommand
              0 -> PromptOut
              8 -> TimerRegist
        0  TestInit
              0 -> OSTaskCreate
       24  TestTask
             24 -- Indirect call
             24 -> CommandInterpret
             24 -> DownLoadBootingJump
             24 -> GetCommand
             24 -> OSTimeDly
             24 -> PrintLogo
             24 -> PromptOut
             24 -> TimeOverCheck
             24 -> __aeabi_memclr4
       16  WaringMssageReturn
             16 -- Indirect call
             16 -> OSTimeDly
             16 -> TimeOverCheck
             16 -> TimerRegist
       16  dGetHex
             16 -> htob
        0  htob
        0  lower
        8  returnmsgTest
              8 -- Indirect call
              0 -> WaringMssageReturn
       24  sSPI_DataRead
             24 -> SetSPIxCommand_Test
             24 -> iDev_SPIx_CS_RST
             24 -> iDev_SPIx_CS_SET
       24  sSPI_SetRegister
             24 -> SetSPIxCommand
             24 -> iDev_SPIx_CS_RST
             24 -> iDev_SPIx_CS_SET


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      12  ?<Constant "    TESTED">
       8  ?<Constant "%02d. ">
      20  ?<Constant "%s Test Canceled\n">
      20  ?<Constant "%s Test Finished\n">
      24  ?<Constant "%s Test Test Finished\n">
      20  ?<Constant "%s Test TimeOut\n">
      20  ?<Constant "%s test Canceled\n">
      20  ?<Constant "%s test Finished\n">
      24  ?<Constant "%s test Test Canceled\n">
      24  ?<Constant "%s test Test TimeOut\n">
      20  ?<Constant "%s test TimeOut\n">
       4  ?<Constant "%s">
      28  ?<Constant "%s: %d.%d[V], [raw:%04d]">
      64  ?<Constant "%s\300\314 \274\366\307\340\265\30
      20  ?<Constant "*    -COMMAND 1st-\n">
      36  ?<Constant "*  ?        : help(th...">
      56  ?<Constant "*  FLASH 0 R 0(ADDR) ...">
      60  ?<Constant "*  FLASH 0 W 0(ADDR) ...">
      36  ?<Constant "*  FPGA DET 0(ADDR) :...">
      36  ?<Constant "*  FPGA ISO 0(ADDR) :...">
      52  ?<Constant "*  FPGA R 0(ADDR)    ...">
      52  ?<Constant "*  FPGA W 0(ADDR) 1(D...">
      28  ?<Constant "*  RESET         : RE...">
      48  ?<Constant "*  TEST A        : AN...">
      48  ?<Constant "*  TEST C        : SE...">
      48  ?<Constant "*  TEST I        : IN...">
      48  ?<Constant "*  TEST O        : OU...">
      28  ?<Constant "*  TEST SRAM\t : SRAM ...">
       4  ?<Constant "* ">
      20  ?<Constant "* %s [VER:%d.%d]\n">
      84  ?<Constant "*********************...">
       4  ?<Constant "*\n">
       4  ?<Constant ", ">
       2  ?<Constant ".">
       2  ?<Constant "0">
      16  ?<Constant "0xB7 tmp[%d]\n">
      16  ?<Constant "0xE9 tmp[%d]\n">
       2  ?<Constant "1">
      16  ?<Constant "70 tmp[%d]>>">
       4  ?<Constant "70">
       2  ?<Constant "A">
      16  ?<Constant "AC(PSU)      :">
      12  ?<Constant "ADC Input">
       4  ?<Constant "B7">
       2  ?<Constant "C">
      16  ?<Constant "CANCEL TEST \n">
      16  ?<Constant "CL_PLL_LD    :">
      12  ?<Constant "COM \275\303\307\350">
       2  ?<Constant "D">
       4  ?<Constant "DET">
      40  ?<Constant "DTUAverPower[%x][%x][...">
      40  ?<Constant "DTUPeakPower[%x][%x][...">
      16  ?<Constant "DTU_Insert   :">
      16  ?<Constant "DTU_Insert1  :">
      12  ?<Constant "Dig Input">
      12  ?<Constant "Dig Output">
       2  ?<Constant "E">
       4  ?<Constant "E9">
      12  ?<Constant "ETC[%s]\n">
      16  ?<Constant "EXT_Insert\t  :">
       2  ?<Constant "F">
       8  ?<Constant "FLASH">
      28  ?<Constant "FPGA Read[%x]: data[%x]\n">
      28  ?<Constant "FPGA Write[%x]: data[...">
       8  ?<Constant "FPGA">
      16  ?<Constant "F_DONE       :">
       8  ?<Constant "HELP">
       2  ?<Constant "I">
       4  ?<Constant "ISO">
      36  ?<Constant "ISOPower[%x]:[%x][%x]...">
      16  ?<Constant "LTEA_PLL_LD  :">
      12  ?<Constant "NON TESTED">
       2  ?<Constant "O">
       2  ?<Constant "P">
       2  ?<Constant "R">
       8  ?<Constant "RESET">
      16  ?<Constant "RF_Insert    :">
       2  ?<Constant "S">
       4  ?<Constant "SPI">
       8  ?<Constant "SRAM">
       8  ?<Constant "TEST">
      12  ?<Constant "TRIO-MD >>">
      32  ?<Constant "TRIO-MD RCU CTRL TEST...">
       2  ?<Constant "W">
      16  ?<Constant "WCDMA_PLL_LD :">
       8  ?<Constant "[%02x]">
       8  ?<Constant "[%02x]\n">
       8  ?<Constant "[%s]\n">
       8  ?<Constant "[%x]">
       8  ?<Constant "[%x]\n">
      24  ?<Constant "[AIN0] : %d.%03d[V]\n">
      24  ?<Constant "[AIN1] : %d.%03d[V]\n">
      12  ?<Constant "[FAIL 1]">
      16  ?<Constant "[FAIL 2]: %d">
       8  ?<Constant "[OFF]">
       8  ?<Constant "[OK]">
       8  ?<Constant "[ON ]">
      52  ?<Constant "\305\353\275\305\275\303\307\350 S
      24  ?<Constant "\n      RAM TEST OK!!\n">
      40  ?<Constant "\n Default Back-up End...">
       2  ?<Constant "\n">
      36  ?<Constant "\n* [%s TEST START Tim...">
      36  ?<Constant "\n* [%s TEST START Tim...">_1
      36  ?<Constant "\n* [%s] TEST START Ti...">
       4  ?<Constant "\n\n">
      24  ?<Constant "\n\r Unknown Command!!">
      12  ?<Constant "tmp[%d]>>">
      12  ?<Constant "tmp[%d]\n">
       4  ?<Constant {0}>
       4  ??DataTable112
       4  ??DataTable112_1
       4  ??DataTable112_2
       4  ??DataTable112_3
       4  ??DataTable112_4
       4  ??DataTable112_5
       4  ??DataTable112_6
       4  ??DataTable112_7
       4  ??DataTable112_8
       4  ??DataTable112_9
       4  ??DataTable113
       4  ??DataTable113_1
       4  ??DataTable113_2
       4  ??DataTable114
       4  ??DataTable114_1
       4  ??DataTable114_2
       4  ??DataTable114_3
       4  ??DataTable118
       4  ??DataTable118_1
       4  ??DataTable118_2
       4  ??DataTable118_3
       4  ??DataTable118_4
       4  ??DataTable119
       4  ??DataTable119_1
       4  ??DataTable119_2
       4  ??DataTable119_3
       4  ??DataTable119_4
       4  ??DataTable119_5
       4  ??DataTable119_6
       4  ??DataTable119_7
       4  ??DataTable119_8
       4  ??DataTable121
       4  ??DataTable122
       4  ??DataTable122_1
       4  ??DataTable123
       4  ??DataTable123_1
       4  ??DataTable123_10
       4  ??DataTable123_11
       4  ??DataTable123_12
       4  ??DataTable123_13
       4  ??DataTable123_14
       4  ??DataTable123_15
       4  ??DataTable123_16
       4  ??DataTable123_17
       4  ??DataTable123_18
       4  ??DataTable123_19
       4  ??DataTable123_2
       4  ??DataTable123_20
       4  ??DataTable123_21
       4  ??DataTable123_22
       4  ??DataTable123_23
       4  ??DataTable123_24
       4  ??DataTable123_3
       4  ??DataTable123_4
       4  ??DataTable123_5
       4  ??DataTable123_6
       4  ??DataTable123_7
       4  ??DataTable123_8
       4  ??DataTable123_9
       8  ?Subroutine0
       6  ?Subroutine1
     150  AdInputStatus
      76  AdcPrintf
      42  Atox
      44  Atox4
      28  Atox8
     128  COMTestFunc
    2678  CommandInterpret
     294  CurrentInputStatus
      64  DTUTest
          Argc
          Argv
     180  DigitalInputDiplay
       1  FNDSTOPFlag
       1  FNDi
       1  FNDj
     144  GetCommand
     908  HwTestOutFunc
     342  KeyProc
     164  MonStr
     716  OnCommand
      70  Parser
     196  PrintLogo
       6  PrintStar
       4  PromptOut
      72  RAMAccesscheck
       4  SavetoTestBackup
       1  SysPath
      94  TestCommand
      16  TestInit
     142  TestTask
    2048  TestTaskStk
      98  WaringMssageReturn
       4  comtstcnt
      24  dGetHex
       1  gTestFlag
      30  htob
      12  lower
      20  returnmsgTest
      88  sSPI_DataRead
      62  sSPI_SetRegister
     188  tIndex
          PrevWRCnt
          PrevRDCnt
          rRevData
          PrevData
      32  tRevData
       1  tTestFlag
       4  testFNDCnt
       8  testResult
      88  tinputSts
          tDisplay
      52  tinputStsOld

 
   513 bytes in section .bss
    97 bytes in section .data
   246 bytes in section .rodata
 8 710 bytes in section .text
 2 048 bytes in section iram
 
 8 710 bytes of CODE  memory
   246 bytes of CONST memory
 2 658 bytes of DATA  memory

Errors: none
Warnings: 1

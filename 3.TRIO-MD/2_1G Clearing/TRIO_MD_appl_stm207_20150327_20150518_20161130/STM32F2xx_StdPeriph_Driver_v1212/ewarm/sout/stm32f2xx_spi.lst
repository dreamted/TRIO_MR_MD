###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     03/Sep/2014  15:31:57 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\src\stm32f2xx_spi.c       #
#    Command line =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\src\stm32f2xx_spi.c -D    #
#                    NDEBUG -lC D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_ #
#                    20140821\STM32F2xx_StdPeriph_Driver_v1212\ewarm\sout\    #
#                    -o D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821 #
#                    \STM32F2xx_StdPeriph_Driver_v1212\ewarm\sout\            #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.0\arm\INC\c\DLib_Config_Normal.h" -I         #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\..\ -I              #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\..\inc\ -I          #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\..\..\uC-CPU\ -I    #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\..\..\uC-LIB\ -I    #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\..\..\uCOS-II\Ports #
#                    \ -I D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_201408 #
#                    21\STM32F2xx_StdPeriph_Driver_v1212\ewarm\..\..\uCOS-II\ #
#                    Source\ -Oh                                              #
#    List file    =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\sout\stm32f2xx_spi. #
#                    lst                                                      #
#    Object file  =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\sout\stm32f2xx_spi. #
#                    o                                                        #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\STM32F2xx_StdPeriph_Driver_v1212\src\stm32f2xx_spi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_spi.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    18-April-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Serial peripheral interface (SPI):           
      9            *           - Initialization and Configuration
     10            *           - Data transfers functions
     11            *           - Hardware CRC Calculation
     12            *           - DMA transfers management
     13            *           - Interrupts and flags management 
     14            *           
     15            *  @verbatim
     16            *          
     17            *                    
     18            *          ===================================================================
     19            *                                 How to use this driver
     20            *          ===================================================================
     21            *          1. Enable peripheral clock using the following functions 
     22            *             RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE) for SPI1
     23            *             RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE) for SPI2
     24            *             RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE) for SPI3.
     25            *
     26            *          2. Enable SCK, MOSI, MISO and NSS GPIO clocks using RCC_AHB1PeriphClockCmd()
     27            *             function.
     28            *             In I2S mode, if an external clock source is used then the I2S CKIN pin GPIO
     29            *             clock should also be enabled.
     30            *
     31            *          3. Peripherals alternate function: 
     32            *                 - Connect the pin to the desired peripherals' Alternate 
     33            *                   Function (AF) using GPIO_PinAFConfig() function
     34            *                 - Configure the desired pin in alternate function by:
     35            *                   GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     36            *                 - Select the type, pull-up/pull-down and output speed via 
     37            *                   GPIO_PuPd, GPIO_OType and GPIO_Speed members
     38            *                 - Call GPIO_Init() function
     39            *              In I2S mode, if an external clock source is used then the I2S CKIN pin
     40            *              should be also configured in Alternate function Push-pull pull-up mode. 
     41            *        
     42            *          4. Program the Polarity, Phase, First Data, Baud Rate Prescaler, Slave 
     43            *             Management, Peripheral Mode and CRC Polynomial values using the SPI_Init()
     44            *             function.
     45            *             In I2S mode, program the Mode, Standard, Data Format, MCLK Output, Audio 
     46            *             frequency and Polarity using I2S_Init() function.
     47            *             For I2S mode, make sure that either:
     48            *              - I2S PLL is configured using the functions RCC_I2SCLKConfig(RCC_I2S2CLKSource_PLLI2S), 
     49            *                RCC_PLLI2SCmd(ENABLE) and RCC_GetFlagStatus(RCC_FLAG_PLLI2SRDY).
     50            *              or 
     51            *              - External clock source is configured using the function 
     52            *                RCC_I2SCLKConfig(RCC_I2S2CLKSource_Ext) and after setting correctly the define constant
     53            *                I2S_EXTERNAL_CLOCK_VAL in the stm32f2xx_conf.h file. 
     54            *
     55            *          5. Enable the NVIC and the corresponding interrupt using the function 
     56            *             SPI_ITConfig() if you need to use interrupt mode. 
     57            *
     58            *          6. When using the DMA mode 
     59            *                   - Configure the DMA using DMA_Init() function
     60            *                   - Active the needed channel Request using SPI_I2S_DMACmd() function
     61            * 
     62            *          7. Enable the SPI using the SPI_Cmd() function or enable the I2S using
     63            *             I2S_Cmd().
     64            * 
     65            *          8. Enable the DMA using the DMA_Cmd() function when using DMA mode. 
     66            *
     67            *          9. Optionally, you can enable/configure the following parameters without
     68            *             re-initialization (i.e there is no need to call again SPI_Init() function):
     69            *              - When bidirectional mode (SPI_Direction_1Line_Rx or SPI_Direction_1Line_Tx)
     70            *                is programmed as Data direction parameter using the SPI_Init() function
     71            *                it can be possible to switch between SPI_Direction_Tx or SPI_Direction_Rx
     72            *                using the SPI_BiDirectionalLineConfig() function.
     73            *              - When SPI_NSS_Soft is selected as Slave Select Management parameter 
     74            *                using the SPI_Init() function it can be possible to manage the 
     75            *                NSS internal signal using the SPI_NSSInternalSoftwareConfig() function.
     76            *              - Reconfigure the data size using the SPI_DataSizeConfig() function  
     77            *              - Enable or disable the SS output using the SPI_SSOutputCmd() function  
     78            *          
     79            *          10. To use the CRC Hardware calculation feature refer to the Peripheral 
     80            *              CRC hardware Calculation subsection.
     81            *   
     82            *
     83            * @note    This driver supports only the I2S clock scheme available in Silicon
     84            *          RevisionB and RevisionY.
     85            *     
     86            * @note    In I2S mode: if an external clock is used as source clock for the I2S,  
     87            *          then the define I2S_EXTERNAL_CLOCK_VAL in file stm32f2xx_conf.h should 
     88            *          be enabled and set to the value of the source clock frequency (in Hz).
     89            * 
     90            * @note    In SPI mode: To use the SPI TI mode, call the function SPI_TIModeCmd() 
     91            *          just after calling the function SPI_Init().
     92            *
     93            *  @endverbatim  
     94            *                                  
     95            ******************************************************************************
     96            * @attention
     97            *
     98            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     99            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
    100            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
    101            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
    102            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
    103            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
    104            *
    105            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
    106            ******************************************************************************  
    107            */ 
    108          
    109          /* Includes ------------------------------------------------------------------*/
    110          #include "stm32f2xx_spi.h"
    111          #include "stm32f2xx_rcc_1208.h"
    112          
    113          /** @addtogroup STM32F2xx_StdPeriph_Driver
    114            * @{
    115            */
    116          
    117          /** @defgroup SPI 
    118            * @brief SPI driver modules
    119            * @{
    120            */ 
    121          
    122          /* Private typedef -----------------------------------------------------------*/
    123          /* Private define ------------------------------------------------------------*/
    124          
    125          /* SPI registers Masks */
    126          #define CR1_CLEAR_MASK            ((uint16_t)0x3040)
    127          #define I2SCFGR_CLEAR_MASK        ((uint16_t)0xF040)
    128          
    129          /* RCC PLLs masks */
    130          #define PLLCFGR_PPLR_MASK         ((uint32_t)0x70000000)
    131          #define PLLCFGR_PPLN_MASK         ((uint32_t)0x00007FC0)
    132          
    133          #define SPI_CR2_FRF               ((uint16_t)0x0010)
    134          #define SPI_SR_TIFRFE             ((uint16_t)0x0100)
    135          
    136          /* Private macro -------------------------------------------------------------*/
    137          /* Private variables ---------------------------------------------------------*/
    138          /* Private function prototypes -----------------------------------------------*/
    139          /* Private functions ---------------------------------------------------------*/
    140          
    141          /** @defgroup SPI_Private_Functions
    142            * @{
    143            */
    144          
    145          /** @defgroup SPI_Group1 Initialization and Configuration functions
    146           *  @brief   Initialization and Configuration functions 
    147           *
    148          @verbatim   
    149           ===============================================================================
    150                            Initialization and Configuration functions
    151           ===============================================================================  
    152          
    153            This section provides a set of functions allowing to initialize the SPI Direction,
    154            SPI Mode, SPI Data Size, SPI Polarity, SPI Phase, SPI NSS Management, SPI Baud
    155            Rate Prescaler, SPI First Bit and SPI CRC Polynomial.
    156            
    157            The SPI_Init() function follows the SPI configuration procedures for Master mode
    158            and Slave mode (details for these procedures are available in reference manual
    159            (RM0033)).
    160            
    161          @endverbatim
    162            * @{
    163            */
    164          
    165          /**
    166            * @brief  Deinitialize the SPIx peripheral registers to their default reset values.
    167            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
    168            *         in SPI mode or 2 or 3 in I2S mode.   
    169            * @retval None
    170            */

   \                                 In section .text, align 2, keep-with-next
    171          void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
    172          {
   \                     SPI_I2S_DeInit:
   \   00000000   0xB580             PUSH     {R7,LR}
    173            /* Check the parameters */
    174            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    175          
    176            if (SPIx == SPI1)
   \   00000002   0x....             LDR.N    R1,??DataTable2  ;; 0x40013000
   \   00000004   0x4288             CMP      R0,R1
   \   00000006   0xD10B             BNE.N    ??SPI_I2S_DeInit_0
    177            {
    178              /* Enable SPI1 reset state */
    179              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0xF44F 0x5080      MOV      R0,#+4096
   \   0000000E   0x.... 0x....      BL       RCC_APB2PeriphResetCmd
    180              /* Release SPI1 from reset state */
    181              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0xF44F 0x5080      MOV      R0,#+4096
   \   00000018   0xE8BD 0x4004      POP      {R2,LR}
   \   0000001C   0x.... 0x....      B.W      RCC_APB2PeriphResetCmd
    182            }
    183            else if (SPIx == SPI2)
   \                     ??SPI_I2S_DeInit_0:
   \   00000020   0x....             LDR.N    R1,??DataTable2_1  ;; 0x40003800
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD108             BNE.N    ??SPI_I2S_DeInit_1
    184            {
    185              /* Enable SPI2 reset state */
    186              RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0xF44F 0x4080      MOV      R0,#+16384
   \   0000002C   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    187              /* Release SPI2 from reset state */
    188              RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0xF44F 0x4080      MOV      R0,#+16384
   \   00000036   0x....             B.N      ?Subroutine0
    189              }
    190            else
    191            {
    192              if (SPIx == SPI3)
   \                     ??SPI_I2S_DeInit_1:
   \   00000038   0x....             LDR.N    R1,??DataTable2_2  ;; 0x40003c00
   \   0000003A   0x4288             CMP      R0,R1
   \   0000003C   0xD108             BNE.N    ??SPI_I2S_DeInit_2
    193              {
    194                /* Enable SPI3 reset state */
    195                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
   \   0000003E   0x2101             MOVS     R1,#+1
   \   00000040   0xF44F 0x4000      MOV      R0,#+32768
   \   00000044   0x.... 0x....      BL       RCC_APB1PeriphResetCmd
    196                /* Release SPI3 from reset state */
    197                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0xF44F 0x4000      MOV      R0,#+32768
   \   0000004E   0x....             B.N      ?Subroutine0
    198              }
    199            }
    200          }
   \                     ??SPI_I2S_DeInit_2:
   \   00000050   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0xE8BD 0x4004      POP      {R2,LR}
   \   00000004   0x.... 0x....      B.W      RCC_APB1PeriphResetCmd
    201          
    202          /**
    203            * @brief  Initializes the SPIx peripheral according to the specified 
    204            *         parameters in the SPI_InitStruct.
    205            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    206            * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
    207            *         contains the configuration information for the specified SPI peripheral.
    208            * @retval None
    209            */
    210          

   \                                 In section .text, align 2, keep-with-next
    211          void SPI1Init(void)
    212          {
   \                     SPI1Init:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    213            SPI_InitTypeDef  SPI_InitStructure;
    214          
    215            RCC->__B.APB2ENR.SPI1EN = ENABLE;
   \   00000004   0x....             LDR.N    R0,??DataTable2_3  ;; 0x40023844
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    216           
    217            /*!< SPI configuration */
    218            SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    219            SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
   \   00000014   0xF44F 0x7082      MOV      R0,#+260
   \   00000018   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    220            SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x9001             STR      R0,[SP, #+4]
    221            SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
    222            SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
   \   00000020   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    223            SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
   \   00000024   0xF44F 0x7000      MOV      R0,#+512
   \   00000028   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    224            //SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4;
    225          	
    226            SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
   \   0000002C   0x2010             MOVS     R0,#+16
   \   0000002E   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    227            
    228            SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    229            SPI_InitStructure.SPI_CRCPolynomial = 7;
   \   00000038   0x2007             MOVS     R0,#+7
   \   0000003A   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    230            
    231            SPI_Init(SPI1, &SPI_InitStructure);
   \   0000003E   0x....             LDR.N    R4,??DataTable2  ;; 0x40013000
   \   00000040   0x....             B.N      ?Subroutine1
    232          
    233            /*!< Enable the sFLASH_SPI  */
    234            SPI_Cmd(SPI1, ENABLE);
    235          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0xA900             ADD      R1,SP,#+0
   \   00000002   0x4620             MOV      R0,R4
   \   00000004   0x.... 0x....      BL       SPI_Init
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       SPI_Cmd
   \   00000010   0xB006             ADD      SP,SP,#+24
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    236          

   \                                 In section .text, align 2, keep-with-next
    237          void SPI2Init(void)
    238          {
   \                     SPI2Init:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
    239            SPI_InitTypeDef  SPI_InitStructure;
    240          
    241            RCC->__B.APB1ENR.SPI2EN = ENABLE;
   \   00000004   0x....             LDR.N    R0,??DataTable2_4  ;; 0x40023840
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0xF441 0x4180      ORR      R1,R1,#0x4000
   \   0000000C   0x6001             STR      R1,[R0, #+0]
    242           
    243            /*!< SPI configuration */
    244            SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    245            SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
   \   00000014   0xF44F 0x7082      MOV      R0,#+260
   \   00000018   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    246            SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x9001             STR      R0,[SP, #+4]
    247            SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
    248            SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
   \   00000020   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    249            SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
   \   00000024   0xF44F 0x7000      MOV      R0,#+512
   \   00000028   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    250            //SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4;
    251          	
    252            SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
   \   0000002C   0x2010             MOVS     R0,#+16
   \   0000002E   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    253            
    254            SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xF8AD 0x000E      STRH     R0,[SP, #+14]
    255            SPI_InitStructure.SPI_CRCPolynomial = 7;
   \   00000038   0x2007             MOVS     R0,#+7
   \   0000003A   0xF8AD 0x0010      STRH     R0,[SP, #+16]
    256            
    257            SPI_Init(SPI2, &SPI_InitStructure);
   \   0000003E   0x....             LDR.N    R4,??DataTable2_1  ;; 0x40003800
   \   00000040                      REQUIRE ?Subroutine1
   \   00000040                      ;; // Fall through to label ?Subroutine1
    258          
    259            /*!< Enable the sFLASH_SPI  */
    260            SPI_Cmd(SPI2, ENABLE);
    261          }
    262          

   \                                 In section .text, align 2, keep-with-next
    263          void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
    264          {
    265            uint16_t tmpreg = 0;
    266            
    267            /* check the parameters */
    268            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    269            
    270            /* Check the SPI parameters */
    271            assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
    272            assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
    273            assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));
    274            assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
    275            assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
    276            assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
    277            assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
    278            assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
    279            assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
    280          
    281          /*---------------------------- SPIx CR1 Configuration ------------------------*/
    282            /* Get the SPIx CR1 value */
    283            tmpreg = SPIx->CR1;
    284            /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
    285            tmpreg &= CR1_CLEAR_MASK;
    286            /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
    287               master/salve mode, CPOL and CPHA */
    288            /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
    289            /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
    290            /* Set LSBFirst bit according to SPI_FirstBit value */
    291            /* Set BR bits according to SPI_BaudRatePrescaler value */
    292            /* Set CPOL bit according to SPI_CPOL value */
    293            /* Set CPHA bit according to SPI_CPHA value */
    294            tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
    295                            SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
    296                            SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
    297                            SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
    298            /* Write to SPIx CR1 */
    299            SPIx->CR1 = tmpreg;
   \                     SPI_Init:
   \   00000000   0x8802             LDRH     R2,[R0, #+0]
   \   00000002   0xF402 0x5241      AND      R2,R2,#0x3040
   \   00000006   0x880B             LDRH     R3,[R1, #+0]
   \   00000008   0x431A             ORRS     R2,R3,R2
   \   0000000A   0x884B             LDRH     R3,[R1, #+2]
   \   0000000C   0x431A             ORRS     R2,R3,R2
   \   0000000E   0x888B             LDRH     R3,[R1, #+4]
   \   00000010   0x431A             ORRS     R2,R3,R2
   \   00000012   0x88CB             LDRH     R3,[R1, #+6]
   \   00000014   0x431A             ORRS     R2,R3,R2
   \   00000016   0x890B             LDRH     R3,[R1, #+8]
   \   00000018   0x431A             ORRS     R2,R3,R2
   \   0000001A   0x894B             LDRH     R3,[R1, #+10]
   \   0000001C   0x431A             ORRS     R2,R3,R2
   \   0000001E   0x898B             LDRH     R3,[R1, #+12]
   \   00000020   0x431A             ORRS     R2,R3,R2
   \   00000022   0x89CB             LDRH     R3,[R1, #+14]
   \   00000024   0x431A             ORRS     R2,R3,R2
   \   00000026   0x8002             STRH     R2,[R0, #+0]
    300          
    301            /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
    302            SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
   \   00000028   0x8B82             LDRH     R2,[R0, #+28]
   \   0000002A   0xF24F 0x73FF      MOVW     R3,#+63487
   \   0000002E   0x401A             ANDS     R2,R3,R2
   \   00000030   0x8382             STRH     R2,[R0, #+28]
    303          /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
    304            /* Write to SPIx CRCPOLY */
    305            SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
   \   00000032   0x8A09             LDRH     R1,[R1, #+16]
   \   00000034   0x8201             STRH     R1,[R0, #+16]
    306          }
   \   00000036   0x4770             BX       LR               ;; return
    307          
    308          /**
    309            * @brief  Initializes the SPIx peripheral according to the specified 
    310            *         parameters in the I2S_InitStruct.
    311            * @param  SPIx: where x can be  2 or 3 to select the SPI peripheral (configured in I2S mode).
    312            * @param  I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
    313            *         contains the configuration information for the specified SPI peripheral
    314            *         configured in I2S mode.
    315            *           
    316            * @note   The function calculates the optimal prescaler needed to obtain the most 
    317            *         accurate audio frequency (depending on the I2S clock source, the PLL values 
    318            *         and the product configuration). But in case the prescaler value is greater 
    319            *         than 511, the default value (0x02) will be configured instead.    
    320            * 
    321            * @note   if an external clock is used as source clock for the I2S, then the define
    322            *         I2S_EXTERNAL_CLOCK_VAL in file stm32f2xx_conf.h should be enabled and set
    323            *         to the value of the the source clock frequency (in Hz).
    324            *  
    325            * @retval None
    326            */

   \                                 In section .text, align 2, keep-with-next
    327          void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
    328          {
   \                     I2S_Init:
   \   00000000   0xB4F0             PUSH     {R4-R7}
    329            uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
   \   00000002   0x2301             MOVS     R3,#+1
    330            uint32_t tmp = 0, i2sclk = 0;
    331          #ifndef I2S_EXTERNAL_CLOCK_VAL
    332            uint32_t pllm = 0, plln = 0, pllr = 0;
    333          #endif /* I2S_EXTERNAL_CLOCK_VAL */
    334            
    335            /* Check the I2S parameters */
    336            assert_param(IS_SPI_23_PERIPH(SPIx));
    337            assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
    338            assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
    339            assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
    340            assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
    341            assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
    342            assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
    343          
    344          /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
    345            /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    346            SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
   \   00000004   0x8B82             LDRH     R2,[R0, #+28]
   \   00000006   0xF24F 0x0440      MOVW     R4,#+61504
   \   0000000A   0x4022             ANDS     R2,R4,R2
   \   0000000C   0x8382             STRH     R2,[R0, #+28]
    347            SPIx->I2SPR = 0x0002;
   \   0000000E   0x2202             MOVS     R2,#+2
   \   00000010   0x8402             STRH     R2,[R0, #+32]
    348            
    349            /* Get the I2SCFGR register value */
    350            tmpreg = SPIx->I2SCFGR;
   \   00000012   0x8B82             LDRH     R2,[R0, #+28]
    351            
    352            /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
    353            if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
   \   00000014   0x688C             LDR      R4,[R1, #+8]
   \   00000016   0x2C02             CMP      R4,#+2
   \   00000018   0xBF08             IT       EQ 
   \   0000001A   0x2300             MOVEQ    R3,#+0
    354            {
    355              i2sodd = (uint16_t)0;
    356              i2sdiv = (uint16_t)2;   
   \   0000001C   0xD034             BEQ.N    ??I2S_Init_0
    357            }
    358            /* If the requested audio frequency is not the default, compute the prescaler */
    359            else
    360            {
    361              /* Check the frame length (For the Prescaler computing) *******************/
    362              if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
   \   0000001E   0x888C             LDRH     R4,[R1, #+4]
   \   00000020   0xB104             CBZ.N    R4,??I2S_Init_1
    363              {
    364                /* Packet length is 16 bits */
    365                packetlength = 1;
    366              }
    367              else
    368              {
    369                /* Packet length is 32 bits */
    370                packetlength = 2;
   \   00000022   0x2302             MOVS     R3,#+2
    371              }
    372          
    373              /* Get I2S source Clock frequency (only in Silicon RevisionB and RevisionY) */
    374                
    375              /* If an external I2S clock has to be used, this define should be set  
    376                 in the project configuration or in the stm32f2xx_conf.h file */
    377            #ifdef I2S_EXTERNAL_CLOCK_VAL     
    378              /* Set external clock as I2S clock source */
    379              if ((RCC->CFGR & RCC_CFGR_I2SSRC) == 0)
    380              {
    381                RCC->CFGR |= (uint32_t)RCC_CFGR_I2SSRC;
    382              }
    383              
    384              /* Set the I2S clock to the external clock  value */
    385              i2sclk = I2S_EXTERNAL_CLOCK_VAL;
    386          
    387            #else /* There is no define for External I2S clock source */
    388              /* Set PLLI2S as I2S clock source */
    389              if ((RCC->CFGR & RCC_CFGR_I2SSRC) != 0)
   \                     ??I2S_Init_1:
   \   00000024   0x....             LDR.N    R4,??DataTable2_5  ;; 0x40023804
   \   00000026   0x6865             LDR      R5,[R4, #+4]
   \   00000028   0x022D             LSLS     R5,R5,#+8
   \   0000002A   0xD503             BPL.N    ??I2S_Init_2
    390              {
    391                RCC->CFGR &= ~(uint32_t)RCC_CFGR_I2SSRC;
   \   0000002C   0x6865             LDR      R5,[R4, #+4]
   \   0000002E   0xF425 0x0500      BIC      R5,R5,#0x800000
   \   00000032   0x6065             STR      R5,[R4, #+4]
    392              }    
    393              
    394              /* Get the PLLI2SN value */
    395              plln = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6) & \
    396                                (RCC_PLLI2SCFGR_PLLI2SN >> 6));
   \                     ??I2S_Init_2:
   \   00000034   0x....             LDR.N    R5,??DataTable2_6  ;; 0x40023884
   \   00000036   0x682E             LDR      R6,[R5, #+0]
    397              
    398              /* Get the PLLI2SR value */
    399              pllr = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28) & \
    400                                (RCC_PLLI2SCFGR_PLLI2SR >> 28));
   \   00000038   0x682D             LDR      R5,[R5, #+0]
    401              
    402              /* Get the PLLM value */
    403              pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);      
   \   0000003A   0x6824             LDR      R4,[R4, #+0]
    404              
    405              /* Get the I2S source clock value */
    406              i2sclk = (uint32_t)(((HSE_VALUE / pllm) * plln) / pllr);
   \   0000003C   0x....             LDR.N    R7,??DataTable2_7  ;; 0x17d7840
   \   0000003E   0xF004 0x043F      AND      R4,R4,#0x3F
   \   00000042   0xFBB7 0xF4F4      UDIV     R4,R7,R4
   \   00000046   0xF3C6 0x1688      UBFX     R6,R6,#+6,#+9
   \   0000004A   0x4374             MULS     R4,R6,R4
   \   0000004C   0xF3C5 0x7502      UBFX     R5,R5,#+28,#+3
   \   00000050   0xFBB4 0xF5F5      UDIV     R5,R4,R5
    407            #endif /* I2S_EXTERNAL_CLOCK_VAL */
    408              
    409              /* Compute the Real divider depending on the MCLK output state, with a floating point */
    410              if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
   \   00000054   0x688C             LDR      R4,[R1, #+8]
   \   00000056   0x88CE             LDRH     R6,[R1, #+6]
   \   00000058   0xF44F 0x7700      MOV      R7,#+512
   \   0000005C   0x42BE             CMP      R6,R7
   \   0000005E   0xBF0E             ITEE     EQ 
   \   00000060   0x0A2B             LSREQ    R3,R5,#+8
   \   00000062   0x015B             LSLNE    R3,R3,#+5
   \   00000064   0xFBB5 0xF3F3      UDIVNE   R3,R5,R3
    411              {
    412                /* MCLK output is enabled */
    413                tmp = (uint16_t)(((((i2sclk / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
    414              }
    415              else
    416              {
    417                /* MCLK output is disabled */
    418                tmp = (uint16_t)(((((i2sclk / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
   \   00000068   0xEB03 0x0583      ADD      R5,R3,R3, LSL #+2
   \   0000006C   0x006B             LSLS     R3,R5,#+1
   \   0000006E   0xFBB3 0xF3F4      UDIV     R3,R3,R4
   \   00000072   0x1D5B             ADDS     R3,R3,#+5
   \   00000074   0xB29B             UXTH     R3,R3
    419              }
    420              
    421              /* Remove the flatting point */
    422              tmp = tmp / 10;  
   \   00000076   0x240A             MOVS     R4,#+10
   \   00000078   0xFBB3 0xF3F4      UDIV     R3,R3,R4
    423                
    424              /* Check the parity of the divider */
    425              i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
   \   0000007C   0xF003 0x0501      AND      R5,R3,#0x1
    426             
    427              /* Compute the i2sdiv prescaler */
    428              i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
   \   00000080   0x1B5B             SUBS     R3,R3,R5
   \   00000082   0x085C             LSRS     R4,R3,#+1
   \   00000084   0xB2A4             UXTH     R4,R4
    429             
    430              /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    431              i2sodd = (uint16_t) (i2sodd << 8);
   \   00000086   0x022B             LSLS     R3,R5,#+8
    432            }
    433          
    434            /* Test if the divider is 1 or 0 or greater than 0xFF */
    435            if ((i2sdiv < 2) || (i2sdiv > 0xFF))
   \                     ??I2S_Init_0:
   \   00000088   0x1EA5             SUBS     R5,R4,#+2
   \   0000008A   0x2DFE             CMP      R5,#+254
   \   0000008C   0xBF24             ITT      CS 
   \   0000008E   0x2402             MOVCS    R4,#+2
   \   00000090   0x2300             MOVCS    R3,#+0
    436            {
    437              /* Set the default values */
    438              i2sdiv = 2;
    439              i2sodd = 0;
    440            }
    441          
    442            /* Write to SPIx I2SPR register the computed value */
    443            SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
   \   00000092   0x4323             ORRS     R3,R3,R4
   \   00000094   0x88CC             LDRH     R4,[R1, #+6]
   \   00000096   0x4323             ORRS     R3,R4,R3
   \   00000098   0x8403             STRH     R3,[R0, #+32]
    444           
    445            /* Configure the I2S with the SPI_InitStruct values */
    446            tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
    447                            (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
    448                            (uint16_t)I2S_InitStruct->I2S_CPOL))));
    449           
    450            /* Write to SPIx I2SCFGR */  
    451            SPIx->I2SCFGR = tmpreg;
   \   0000009A   0x880B             LDRH     R3,[R1, #+0]
   \   0000009C   0x431A             ORRS     R2,R3,R2
   \   0000009E   0x884B             LDRH     R3,[R1, #+2]
   \   000000A0   0x431A             ORRS     R2,R3,R2
   \   000000A2   0x888B             LDRH     R3,[R1, #+4]
   \   000000A4   0x431A             ORRS     R2,R3,R2
   \   000000A6   0x8989             LDRH     R1,[R1, #+12]
   \   000000A8   0x4311             ORRS     R1,R1,R2
   \   000000AA   0xF441 0x6100      ORR      R1,R1,#0x800
   \   000000AE   0x8381             STRH     R1,[R0, #+28]
    452          }
   \   000000B0   0xBCF0             POP      {R4-R7}
   \   000000B2   0x4770             BX       LR               ;; return
    453          
    454          /**
    455            * @brief  Fills each SPI_InitStruct member with its default value.
    456            * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure which will be initialized.
    457            * @retval None
    458            */

   \                                 In section .text, align 2, keep-with-next
    459          void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
    460          {
    461          /*--------------- Reset SPI init structure parameters values -----------------*/
    462            /* Initialize the SPI_Direction member */
    463            SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
   \                     SPI_StructInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    464            /* initialize the SPI_Mode member */
    465            SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
   \   00000004   0x8041             STRH     R1,[R0, #+2]
    466            /* initialize the SPI_DataSize member */
    467            SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
   \   00000006   0x8081             STRH     R1,[R0, #+4]
    468            /* Initialize the SPI_CPOL member */
    469            SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
   \   00000008   0x80C1             STRH     R1,[R0, #+6]
    470            /* Initialize the SPI_CPHA member */
    471            SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
   \   0000000A   0x8101             STRH     R1,[R0, #+8]
    472            /* Initialize the SPI_NSS member */
    473            SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
   \   0000000C   0x8141             STRH     R1,[R0, #+10]
    474            /* Initialize the SPI_BaudRatePrescaler member */
    475            SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
   \   0000000E   0x8181             STRH     R1,[R0, #+12]
    476            /* Initialize the SPI_FirstBit member */
    477            SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
   \   00000010   0x81C1             STRH     R1,[R0, #+14]
    478            /* Initialize the SPI_CRCPolynomial member */
    479            SPI_InitStruct->SPI_CRCPolynomial = 7;
   \   00000012   0x2107             MOVS     R1,#+7
   \   00000014   0x8201             STRH     R1,[R0, #+16]
    480          }
   \   00000016   0x4770             BX       LR               ;; return
    481          
    482          /**
    483            * @brief  Fills each I2S_InitStruct member with its default value.
    484            * @param  I2S_InitStruct: pointer to a I2S_InitTypeDef structure which will be initialized.
    485            * @retval None
    486            */

   \                                 In section .text, align 2, keep-with-next
    487          void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
    488          {
    489          /*--------------- Reset I2S init structure parameters values -----------------*/
    490            /* Initialize the I2S_Mode member */
    491            I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
   \                     I2S_StructInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x8001             STRH     R1,[R0, #+0]
    492            
    493            /* Initialize the I2S_Standard member */
    494            I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
   \   00000004   0x8041             STRH     R1,[R0, #+2]
    495            
    496            /* Initialize the I2S_DataFormat member */
    497            I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
   \   00000006   0x8081             STRH     R1,[R0, #+4]
    498            
    499            /* Initialize the I2S_MCLKOutput member */
    500            I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
   \   00000008   0x80C1             STRH     R1,[R0, #+6]
    501            
    502            /* Initialize the I2S_AudioFreq member */
    503            I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
   \   0000000A   0x2102             MOVS     R1,#+2
   \   0000000C   0x6081             STR      R1,[R0, #+8]
    504            
    505            /* Initialize the I2S_CPOL member */
    506            I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x8181             STRH     R1,[R0, #+12]
    507          }
   \   00000012   0x4770             BX       LR               ;; return
    508          
    509          /**
    510            * @brief  Enables or disables the specified SPI peripheral.
    511            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    512            * @param  NewState: new state of the SPIx peripheral. 
    513            *          This parameter can be: ENABLE or DISABLE.
    514            * @retval None
    515            */

   \                                 In section .text, align 2, keep-with-next
    516          void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    517          {
    518            /* Check the parameters */
    519            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    520            assert_param(IS_FUNCTIONAL_STATE(NewState));
    521            if (NewState != DISABLE)
   \                     SPI_Cmd:
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x8801             LDRH     R1,[R0, #+0]
   \   00000004   0xBF12             ITEE     NE 
   \   00000006   0xF041 0x0140      ORRNE    R1,R1,#0x40
   \   0000000A   0xF64F 0x72BF      MOVWEQ   R2,#+65471
   \   0000000E   0x4011             ANDEQ    R1,R2,R1
    522            {
    523              /* Enable the selected SPI peripheral */
    524              SPIx->CR1 |= SPI_CR1_SPE;
    525            }
    526            else
    527            {
    528              /* Disable the selected SPI peripheral */
    529              SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
   \   00000010   0x8001             STRH     R1,[R0, #+0]
    530            }
    531          }
   \   00000012   0x4770             BX       LR               ;; return
    532          
    533          /**
    534            * @brief  Enables or disables the specified SPI peripheral (in I2S mode).
    535            * @param  SPIx: where x can be 2 or 3 to select the SPI peripheral.
    536            * @param  NewState: new state of the SPIx peripheral. 
    537            *         This parameter can be: ENABLE or DISABLE.
    538            * @retval None
    539            */

   \                                 In section .text, align 2, keep-with-next
    540          void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    541          {
    542            /* Check the parameters */
    543            assert_param(IS_SPI_23_PERIPH(SPIx));
    544            assert_param(IS_FUNCTIONAL_STATE(NewState));
    545            
    546            if (NewState != DISABLE)
   \                     I2S_Cmd:
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x8B81             LDRH     R1,[R0, #+28]
   \   00000004   0xBF12             ITEE     NE 
   \   00000006   0xF441 0x6180      ORRNE    R1,R1,#0x400
   \   0000000A   0xF64F 0x32FF      MOVWEQ   R2,#+64511
   \   0000000E   0x4011             ANDEQ    R1,R2,R1
    547            {
    548              /* Enable the selected SPI peripheral (in I2S mode) */
    549              SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
    550            }
    551            else
    552            {
    553              /* Disable the selected SPI peripheral in I2S mode */
    554              SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
   \   00000010   0x8381             STRH     R1,[R0, #+28]
    555            }
    556          }
   \   00000012   0x4770             BX       LR               ;; return
    557          
    558          /**
    559            * @brief  Configures the data size for the selected SPI.
    560            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    561            * @param  SPI_DataSize: specifies the SPI data size.
    562            *          This parameter can be one of the following values:
    563            *            @arg SPI_DataSize_16b: Set data frame format to 16bit
    564            *            @arg SPI_DataSize_8b: Set data frame format to 8bit
    565            * @retval None
    566            */

   \                                 In section .text, align 2, keep-with-next
    567          void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)
    568          {
    569            /* Check the parameters */
    570            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    571            assert_param(IS_SPI_DATASIZE(SPI_DataSize));
    572            /* Clear DFF bit */
    573            SPIx->CR1 &= (uint16_t)~SPI_DataSize_16b;
   \                     SPI_DataSizeConfig:
   \   00000000   0x8802             LDRH     R2,[R0, #+0]
   \   00000002   0xF24F 0x73FF      MOVW     R3,#+63487
   \   00000006   0x401A             ANDS     R2,R3,R2
   \   00000008   0x8002             STRH     R2,[R0, #+0]
    574            /* Set new DFF bit value */
    575            SPIx->CR1 |= SPI_DataSize;
   \   0000000A   0x8802             LDRH     R2,[R0, #+0]
   \   0000000C   0x4311             ORRS     R1,R1,R2
   \   0000000E   0x8001             STRH     R1,[R0, #+0]
    576          }
   \   00000010   0x4770             BX       LR               ;; return
    577          
    578          /**
    579            * @brief  Selects the data transfer direction in bidirectional mode for the specified SPI.
    580            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    581            * @param  SPI_Direction: specifies the data transfer direction in bidirectional mode. 
    582            *          This parameter can be one of the following values:
    583            *            @arg SPI_Direction_Tx: Selects Tx transmission direction
    584            *            @arg SPI_Direction_Rx: Selects Rx receive direction
    585            * @retval None
    586            */

   \                                 In section .text, align 2, keep-with-next
    587          void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
    588          {
    589            /* Check the parameters */
    590            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    591            assert_param(IS_SPI_DIRECTION(SPI_Direction));
    592            if (SPI_Direction == SPI_Direction_Tx)
   \                     SPI_BiDirectionalLineConfig:
   \   00000000   0xF5B1 0x4F80      CMP      R1,#+16384
   \   00000004   0x8801             LDRH     R1,[R0, #+0]
   \   00000006   0xBF0E             ITEE     EQ 
   \   00000008   0xF441 0x4180      ORREQ    R1,R1,#0x4000
   \   0000000C   0xF64B 0x72FF      MOVWNE   R2,#+49151
   \   00000010   0x4011             ANDNE    R1,R2,R1
    593            {
    594              /* Set the Tx only mode */
    595              SPIx->CR1 |= SPI_Direction_Tx;
    596            }
    597            else
    598            {
    599              /* Set the Rx only mode */
    600              SPIx->CR1 &= SPI_Direction_Rx;
   \   00000012   0x8001             STRH     R1,[R0, #+0]
    601            }
    602          }
   \   00000014   0x4770             BX       LR               ;; return
    603          
    604          /**
    605            * @brief  Configures internally by software the NSS pin for the selected SPI.
    606            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    607            * @param  SPI_NSSInternalSoft: specifies the SPI NSS internal state.
    608            *          This parameter can be one of the following values:
    609            *            @arg SPI_NSSInternalSoft_Set: Set NSS pin internally
    610            *            @arg SPI_NSSInternalSoft_Reset: Reset NSS pin internally
    611            * @retval None
    612            */

   \                                 In section .text, align 2, keep-with-next
    613          void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
    614          {
    615            /* Check the parameters */
    616            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    617            assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
    618            if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
   \                     SPI_NSSInternalSoftwareConfig:
   \   00000000   0xF64F 0x62FF      MOVW     R2,#+65279
   \   00000004   0x4291             CMP      R1,R2
   \   00000006   0x8801             LDRH     R1,[R0, #+0]
   \   00000008   0xBF1A             ITTE     NE 
   \   0000000A   0xF44F 0x7280      MOVNE    R2,#+256
   \   0000000E   0x4311             ORRNE    R1,R2,R1
   \   00000010   0x4011             ANDEQ    R1,R2,R1
    619            {
    620              /* Set NSS pin internally by software */
    621              SPIx->CR1 |= SPI_NSSInternalSoft_Set;
    622            }
    623            else
    624            {
    625              /* Reset NSS pin internally by software */
    626              SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
   \   00000012   0x8001             STRH     R1,[R0, #+0]
    627            }
    628          }
   \   00000014   0x4770             BX       LR               ;; return
    629          
    630          /**
    631            * @brief  Enables or disables the SS output for the selected SPI.
    632            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    633            * @param  NewState: new state of the SPIx SS output. 
    634            *          This parameter can be: ENABLE or DISABLE.
    635            * @retval None
    636            */

   \                                 In section .text, align 2, keep-with-next
    637          void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    638          {
    639            /* Check the parameters */
    640            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    641            assert_param(IS_FUNCTIONAL_STATE(NewState));
    642            if (NewState != DISABLE)
   \                     SPI_SSOutputCmd:
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x8881             LDRH     R1,[R0, #+4]
   \   00000004   0xBF12             ITEE     NE 
   \   00000006   0xF041 0x0104      ORRNE    R1,R1,#0x4
   \   0000000A   0xF64F 0x72FB      MOVWEQ   R2,#+65531
   \   0000000E   0x4011             ANDEQ    R1,R2,R1
    643            {
    644              /* Enable the selected SPI SS output */
    645              SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
    646            }
    647            else
    648            {
    649              /* Disable the selected SPI SS output */
    650              SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
   \   00000010   0x8081             STRH     R1,[R0, #+4]
    651            }
    652          }
   \   00000012   0x4770             BX       LR               ;; return
    653          
    654          /**
    655            * @brief  Enables or disables the SPIx/I2Sx DMA interface.
    656            *   
    657            * @note   This function can be called only after the SPI_Init() function has 
    658            *         been called. 
    659            * @note   When TI mode is selected, the control bits SSM, SSI, CPOL and CPHA 
    660            *         are not taken into consideration and are configured by hardware
    661            *         respectively to the TI mode requirements.  
    662            * 
    663            * @param  SPIx: where x can be 1, 2 or 3 
    664            * @param  NewState: new state of the selected SPI TI communication mode.
    665            *          This parameter can be: ENABLE or DISABLE.
    666            * @retval None
    667            */

   \                                 In section .text, align 2, keep-with-next
    668          void SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    669          {
    670            /* Check the parameters */
    671            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    672            assert_param(IS_FUNCTIONAL_STATE(NewState));
    673          
    674            if (NewState != DISABLE)
   \                     SPI_TIModeCmd:
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x8881             LDRH     R1,[R0, #+4]
   \   00000004   0xBF12             ITEE     NE 
   \   00000006   0xF041 0x0110      ORRNE    R1,R1,#0x10
   \   0000000A   0xF64F 0x72EF      MOVWEQ   R2,#+65519
   \   0000000E   0x4011             ANDEQ    R1,R2,R1
    675            {
    676              /* Enable the TI mode for the selected SPI peripheral */
    677              SPIx->CR2 |= SPI_CR2_FRF;
    678            }
    679            else
    680            {
    681              /* Disable the TI mode for the selected SPI peripheral */
    682              SPIx->CR2 &= (uint16_t)~SPI_CR2_FRF;
   \   00000010   0x8081             STRH     R1,[R0, #+4]
    683            }
    684          }
   \   00000012   0x4770             BX       LR               ;; return
    685          
    686          /**
    687            * @}
    688            */
    689          
    690          /** @defgroup SPI_Group2 Data transfers functions
    691           *  @brief   Data transfers functions
    692           *
    693          @verbatim   
    694           ===============================================================================
    695                                   Data transfers functions
    696           ===============================================================================  
    697          
    698            This section provides a set of functions allowing to manage the SPI data transfers
    699            
    700            In reception, data are received and then stored into an internal Rx buffer while 
    701            In transmission, data are first stored into an internal Tx buffer before being 
    702            transmitted.
    703          
    704            The read access of the SPI_DR register can be done using the SPI_I2S_ReceiveData()
    705            function and returns the Rx buffered value. Whereas a write access to the SPI_DR 
    706            can be done using SPI_I2S_SendData() function and stores the written data into 
    707            Tx buffer.
    708          
    709          @endverbatim
    710            * @{
    711            */
    712          
    713          /**
    714            * @brief  Returns the most recent received data by the SPIx/I2Sx peripheral. 
    715            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
    716            *         in SPI mode or 2 or 3 in I2S mode. 
    717            * @retval The value of the received data.
    718            */

   \                                 In section .text, align 2, keep-with-next
    719          uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
    720          {
    721            /* Check the parameters */
    722            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    723            
    724            /* Return the data in the DR register */
    725            return SPIx->DR;
   \                     SPI_I2S_ReceiveData:
   \   00000000   0x8980             LDRH     R0,[R0, #+12]
   \   00000002   0x4770             BX       LR               ;; return
    726          }
    727          
    728          /**
    729            * @brief  Transmits a Data through the SPIx/I2Sx peripheral.
    730            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
    731            *         in SPI mode or 2 or 3 in I2S mode.     
    732            * @param  Data: Data to be transmitted.
    733            * @retval None
    734            */

   \                                 In section .text, align 2, keep-with-next
    735          void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
    736          {
    737            /* Check the parameters */
    738            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    739            
    740            /* Write in the DR register the data to be sent */
    741            SPIx->DR = Data;
   \                     SPI_I2S_SendData:
   \   00000000   0x8181             STRH     R1,[R0, #+12]
    742          }
   \   00000002   0x4770             BX       LR               ;; return
    743          
    744          /**
    745            * @}
    746            */
    747          
    748          /** @defgroup SPI_Group3 Hardware CRC Calculation functions
    749           *  @brief   Hardware CRC Calculation functions
    750           *
    751          @verbatim   
    752           ===============================================================================
    753                                   Hardware CRC Calculation functions
    754           ===============================================================================  
    755          
    756            This section provides a set of functions allowing to manage the SPI CRC hardware 
    757            calculation
    758          
    759            SPI communication using CRC is possible through the following procedure:
    760               1. Program the Data direction, Polarity, Phase, First Data, Baud Rate Prescaler, 
    761                  Slave Management, Peripheral Mode and CRC Polynomial values using the SPI_Init()
    762                  function.
    763               2. Enable the CRC calculation using the SPI_CalculateCRC() function.
    764               3. Enable the SPI using the SPI_Cmd() function
    765               4. Before writing the last data to the TX buffer, set the CRCNext bit using the 
    766                SPI_TransmitCRC() function to indicate that after transmission of the last 
    767                data, the CRC should be transmitted.
    768               5. After transmitting the last data, the SPI transmits the CRC. The SPI_CR1_CRCNEXT
    769                  bit is reset. The CRC is also received and compared against the SPI_RXCRCR 
    770                  value. 
    771                  If the value does not match, the SPI_FLAG_CRCERR flag is set and an interrupt
    772                  can be generated when the SPI_I2S_IT_ERR interrupt is enabled.
    773          
    774          @note It is advised not to read the calculated CRC values during the communication.
    775          
    776          @note When the SPI is in slave mode, be careful to enable CRC calculation only 
    777                when the clock is stable, that is, when the clock is in the steady state. 
    778                If not, a wrong CRC calculation may be done. In fact, the CRC is sensitive 
    779                to the SCK slave input clock as soon as CRCEN is set, and this, whatever 
    780                the value of the SPE bit.
    781          
    782          @note With high bitrate frequencies, be careful when transmitting the CRC.
    783                As the number of used CPU cycles has to be as low as possible in the CRC 
    784                transfer phase, it is forbidden to call software functions in the CRC 
    785                transmission sequence to avoid errors in the last data and CRC reception. 
    786                In fact, CRCNEXT bit has to be written before the end of the transmission/reception 
    787                of the last data.
    788          
    789          @note For high bit rate frequencies, it is advised to use the DMA mode to avoid the
    790                degradation of the SPI speed performance due to CPU accesses impacting the 
    791                SPI bandwidth.
    792          
    793          @note When the STM32F2xx is configured as slave and the NSS hardware mode is 
    794                used, the NSS pin needs to be kept low between the data phase and the CRC 
    795                phase.
    796          
    797          @note When the SPI is configured in slave mode with the CRC feature enabled, CRC
    798                calculation takes place even if a high level is applied on the NSS pin. 
    799                This may happen for example in case of a multi-slave environment where the 
    800                communication master addresses slaves alternately.
    801          
    802          @note Between a slave de-selection (high level on NSS) and a new slave selection 
    803                (low level on NSS), the CRC value should be cleared on both master and slave
    804                sides in order to resynchronize the master and slave for their respective 
    805                CRC calculation.
    806          
    807          @note To clear the CRC, follow the procedure below:
    808                  1. Disable SPI using the SPI_Cmd() function
    809                  2. Disable the CRC calculation using the SPI_CalculateCRC() function.
    810                  3. Enable the CRC calculation using the SPI_CalculateCRC() function.
    811                  4. Enable SPI using the SPI_Cmd() function.
    812          
    813          @endverbatim
    814            * @{
    815            */
    816          
    817          /**
    818            * @brief  Enables or disables the CRC value calculation of the transferred bytes.
    819            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    820            * @param  NewState: new state of the SPIx CRC value calculation.
    821            *          This parameter can be: ENABLE or DISABLE.
    822            * @retval None
    823            */

   \                                 In section .text, align 2, keep-with-next
    824          void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
    825          {
    826            /* Check the parameters */
    827            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    828            assert_param(IS_FUNCTIONAL_STATE(NewState));
    829            if (NewState != DISABLE)
   \                     SPI_CalculateCRC:
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x8801             LDRH     R1,[R0, #+0]
   \   00000004   0xBF12             ITEE     NE 
   \   00000006   0xF441 0x5100      ORRNE    R1,R1,#0x2000
   \   0000000A   0xF64D 0x72FF      MOVWEQ   R2,#+57343
   \   0000000E   0x4011             ANDEQ    R1,R2,R1
    830            {
    831              /* Enable the selected SPI CRC calculation */
    832              SPIx->CR1 |= SPI_CR1_CRCEN;
    833            }
    834            else
    835            {
    836              /* Disable the selected SPI CRC calculation */
    837              SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
   \   00000010   0x8001             STRH     R1,[R0, #+0]
    838            }
    839          }
   \   00000012   0x4770             BX       LR               ;; return
    840          
    841          /**
    842            * @brief  Transmit the SPIx CRC value.
    843            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    844            * @retval None
    845            */

   \                                 In section .text, align 2, keep-with-next
    846          void SPI_TransmitCRC(SPI_TypeDef* SPIx)
    847          {
    848            /* Check the parameters */
    849            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    850            
    851            /* Enable the selected SPI CRC transmission */
    852            SPIx->CR1 |= SPI_CR1_CRCNEXT;
   \                     SPI_TransmitCRC:
   \   00000000   0x8801             LDRH     R1,[R0, #+0]
   \   00000002   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000006   0x8001             STRH     R1,[R0, #+0]
    853          }
   \   00000008   0x4770             BX       LR               ;; return
    854          
    855          /**
    856            * @brief  Returns the transmit or the receive CRC register value for the specified SPI.
    857            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    858            * @param  SPI_CRC: specifies the CRC register to be read.
    859            *          This parameter can be one of the following values:
    860            *            @arg SPI_CRC_Tx: Selects Tx CRC register
    861            *            @arg SPI_CRC_Rx: Selects Rx CRC register
    862            * @retval The selected CRC register value..
    863            */

   \                                 In section .text, align 2, keep-with-next
    864          uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)
    865          {
    866            uint16_t crcreg = 0;
    867            /* Check the parameters */
    868            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    869            assert_param(IS_SPI_CRC(SPI_CRC));
    870            if (SPI_CRC != SPI_CRC_Rx)
   \                     SPI_GetCRC:
   \   00000000   0x2901             CMP      R1,#+1
   \   00000002   0xD001             BEQ.N    ??SPI_GetCRC_0
    871            {
    872              /* Get the Tx CRC register */
    873              crcreg = SPIx->TXCRCR;
   \   00000004   0x8B00             LDRH     R0,[R0, #+24]
   \   00000006   0x4770             BX       LR
    874            }
    875            else
    876            {
    877              /* Get the Rx CRC register */
    878              crcreg = SPIx->RXCRCR;
   \                     ??SPI_GetCRC_0:
   \   00000008   0x8A80             LDRH     R0,[R0, #+20]
    879            }
    880            /* Return the selected CRC register */
    881            return crcreg;
   \   0000000A   0x4770             BX       LR               ;; return
    882          }
    883          
    884          /**
    885            * @brief  Returns the CRC Polynomial register value for the specified SPI.
    886            * @param  SPIx: where x can be 1, 2 or 3 to select the SPI peripheral.
    887            * @retval The CRC Polynomial register value.
    888            */

   \                                 In section .text, align 2, keep-with-next
    889          uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
    890          {
    891            /* Check the parameters */
    892            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    893            
    894            /* Return the CRC polynomial register */
    895            return SPIx->CRCPR;
   \                     SPI_GetCRCPolynomial:
   \   00000000   0x8A00             LDRH     R0,[R0, #+16]
   \   00000002   0x4770             BX       LR               ;; return
    896          }
    897          
    898          /**
    899            * @}
    900            */
    901          
    902          /** @defgroup SPI_Group4 DMA transfers management functions
    903           *  @brief   DMA transfers management functions
    904            *
    905          @verbatim   
    906           ===============================================================================
    907                                   DMA transfers management functions
    908           ===============================================================================  
    909          
    910          @endverbatim
    911            * @{
    912            */
    913          
    914          /**
    915            * @brief  Enables or disables the SPIx/I2Sx DMA interface.
    916            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
    917            *         in SPI mode or 2 or 3 in I2S mode. 
    918            * @param  SPI_I2S_DMAReq: specifies the SPI DMA transfer request to be enabled or disabled. 
    919            *          This parameter can be any combination of the following values:
    920            *            @arg SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
    921            *            @arg SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
    922            * @param  NewState: new state of the selected SPI DMA transfer request.
    923            *          This parameter can be: ENABLE or DISABLE.
    924            * @retval None
    925            */

   \                                 In section .text, align 2, keep-with-next
    926          void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
    927          {
    928            /* Check the parameters */
    929            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    930            assert_param(IS_FUNCTIONAL_STATE(NewState));
    931            assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
    932          
    933            if (NewState != DISABLE)
   \                     SPI_I2S_DMACmd:
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0x8882             LDRH     R2,[R0, #+4]
   \   00000004   0xBF14             ITE      NE 
   \   00000006   0x4311             ORRNE    R1,R1,R2
   \   00000008   0xEA22 0x0101      BICEQ    R1,R2,R1
    934            {
    935              /* Enable the selected SPI DMA requests */
    936              SPIx->CR2 |= SPI_I2S_DMAReq;
    937            }
    938            else
    939            {
    940              /* Disable the selected SPI DMA requests */
    941              SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
   \   0000000C   0x8081             STRH     R1,[R0, #+4]
    942            }
    943          }
   \   0000000E   0x4770             BX       LR               ;; return
    944          
    945          /**
    946            * @}
    947            */
    948          
    949          /** @defgroup SPI_Group5 Interrupts and flags management functions
    950           *  @brief   Interrupts and flags management functions
    951            *
    952          @verbatim   
    953           ===============================================================================
    954                                   Interrupts and flags management functions
    955           ===============================================================================  
    956          
    957            This section provides a set of functions allowing to configure the SPI Interrupts 
    958            sources and check or clear the flags or pending bits status.
    959            The user should identify which mode will be used in his application to manage 
    960            the communication: Polling mode, Interrupt mode or DMA mode. 
    961              
    962            Polling Mode
    963            =============
    964            In Polling Mode, the SPI/I2S communication can be managed by 9 flags:
    965               1. SPI_I2S_FLAG_TXE : to indicate the status of the transmit buffer register
    966               2. SPI_I2S_FLAG_RXNE : to indicate the status of the receive buffer register
    967               3. SPI_I2S_FLAG_BSY : to indicate the state of the communication layer of the SPI.
    968               4. SPI_FLAG_CRCERR : to indicate if a CRC Calculation error occur              
    969               5. SPI_FLAG_MODF : to indicate if a Mode Fault error occur
    970               6. SPI_I2S_FLAG_OVR : to indicate if an Overrun error occur
    971               7. I2S_FLAG_TIFRFE: to indicate a Frame Format error occurs.
    972               8. I2S_FLAG_UDR: to indicate an Underrun error occurs.
    973               9. I2S_FLAG_CHSIDE: to indicate Channel Side.
    974          
    975          @note Do not use the BSY flag to handle each data transmission or reception.  It is
    976                better to use the TXE and RXNE flags instead.
    977          
    978            In this Mode it is advised to use the following functions:
    979               - FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
    980               - void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
    981          
    982            Interrupt Mode
    983            ===============
    984            In Interrupt Mode, the SPI communication can be managed by 3 interrupt sources
    985            and 7 pending bits: 
    986            Pending Bits:
    987            ------------- 
    988               1. SPI_I2S_IT_TXE : to indicate the status of the transmit buffer register
    989               2. SPI_I2S_IT_RXNE : to indicate the status of the receive buffer register
    990               3. SPI_IT_CRCERR : to indicate if a CRC Calculation error occur (available in SPI mode only)            
    991               4. SPI_IT_MODF : to indicate if a Mode Fault error occur (available in SPI mode only)
    992               5. SPI_I2S_IT_OVR : to indicate if an Overrun error occur
    993               6. I2S_IT_UDR : to indicate an Underrun Error occurs (available in I2S mode only).
    994               7. I2S_FLAG_TIFRFE : to indicate a Frame Format error occurs (available in TI mode only).
    995          
    996            Interrupt Source:
    997            -----------------
    998               1. SPI_I2S_IT_TXE: specifies the interrupt source for the Tx buffer empty 
    999                                  interrupt.  
   1000               2. SPI_I2S_IT_RXNE : specifies the interrupt source for the Rx buffer not 
   1001                                    empty interrupt.
   1002               3. SPI_I2S_IT_ERR : specifies the interrupt source for the errors interrupt.
   1003          
   1004            In this Mode it is advised to use the following functions:
   1005               - void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState);
   1006               - ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
   1007               - void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
   1008          
   1009            DMA Mode
   1010            ========
   1011            In DMA Mode, the SPI communication can be managed by 2 DMA Channel requests:
   1012               1. SPI_I2S_DMAReq_Tx: specifies the Tx buffer DMA transfer request
   1013               2. SPI_I2S_DMAReq_Rx: specifies the Rx buffer DMA transfer request
   1014          
   1015            In this Mode it is advised to use the following function:
   1016              - void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState);
   1017          
   1018          @endverbatim
   1019            * @{
   1020            */
   1021          
   1022          /**
   1023            * @brief  Enables or disables the specified SPI/I2S interrupts.
   1024            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
   1025            *         in SPI mode or 2 or 3 in I2S mode.  
   1026            * @param  SPI_I2S_IT: specifies the SPI interrupt source to be enabled or disabled. 
   1027            *          This parameter can be one of the following values:
   1028            *            @arg SPI_I2S_IT_TXE: Tx buffer empty interrupt mask
   1029            *            @arg SPI_I2S_IT_RXNE: Rx buffer not empty interrupt mask
   1030            *            @arg SPI_I2S_IT_ERR: Error interrupt mask
   1031            * @param  NewState: new state of the specified SPI interrupt.
   1032            *          This parameter can be: ENABLE or DISABLE.
   1033            * @retval None
   1034            */

   \                                 In section .text, align 2, keep-with-next
   1035          void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
   1036          {
   1037            uint16_t itpos = 0, itmask = 0 ;
   1038            
   1039            /* Check the parameters */
   1040            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   1041            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1042            assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
   1043          
   1044            /* Get the SPI IT index */
   1045            itpos = SPI_I2S_IT >> 4;
   1046          
   1047            /* Set the IT mask */
   1048            itmask = (uint16_t)1 << (uint16_t)itpos;
   \                     SPI_I2S_ITConfig:
   \   00000000   0x2301             MOVS     R3,#+1
   \   00000002   0x0909             LSRS     R1,R1,#+4
   \   00000004   0xFA03 0xF101      LSL      R1,R3,R1
   \   00000008   0xB289             UXTH     R1,R1
   1049          
   1050            if (NewState != DISABLE)
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0x8882             LDRH     R2,[R0, #+4]
   \   0000000E   0xBF14             ITE      NE 
   \   00000010   0x4311             ORRNE    R1,R1,R2
   \   00000012   0xEA22 0x0101      BICEQ    R1,R2,R1
   1051            {
   1052              /* Enable the selected SPI interrupt */
   1053              SPIx->CR2 |= itmask;
   1054            }
   1055            else
   1056            {
   1057              /* Disable the selected SPI interrupt */
   1058              SPIx->CR2 &= (uint16_t)~itmask;
   \   00000016   0x8081             STRH     R1,[R0, #+4]
   1059            }
   1060          }
   \   00000018   0x4770             BX       LR               ;; return
   1061          
   1062          /**
   1063            * @brief  Checks whether the specified SPIx/I2Sx flag is set or not.
   1064            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
   1065            *         in SPI mode or 2 or 3 in I2S mode. 
   1066            * @param  SPI_I2S_FLAG: specifies the SPI flag to check. 
   1067            *          This parameter can be one of the following values:
   1068            *            @arg SPI_I2S_FLAG_TXE: Transmit buffer empty flag.
   1069            *            @arg SPI_I2S_FLAG_RXNE: Receive buffer not empty flag.
   1070            *            @arg SPI_I2S_FLAG_BSY: Busy flag.
   1071            *            @arg SPI_I2S_FLAG_OVR: Overrun flag.
   1072            *            @arg SPI_FLAG_MODF: Mode Fault flag.
   1073            *            @arg SPI_FLAG_CRCERR: CRC Error flag.
   1074            *            @arg SPI_I2S_FLAG_TIFRFE: Format Error.
   1075            *            @arg I2S_FLAG_UDR: Underrun Error flag.
   1076            *            @arg I2S_FLAG_CHSIDE: Channel Side flag.  
   1077            * @retval The new state of SPI_I2S_FLAG (SET or RESET).
   1078            */

   \                                 In section .text, align 2, keep-with-next
   1079          FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
   1080          {
   1081            FlagStatus bitstatus = RESET;
   \                     SPI_I2S_GetFlagStatus:
   \   00000000   0x2200             MOVS     R2,#+0
   1082            /* Check the parameters */
   1083            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   1084            assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
   1085            
   1086            /* Check the status of the specified SPI flag */
   1087            if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
   \   00000002   0x8900             LDRH     R0,[R0, #+8]
   \   00000004   0x4208             TST      R0,R1
   \   00000006   0xBF18             IT       NE 
   \   00000008   0x2201             MOVNE    R2,#+1
   1088            {
   1089              /* SPI_I2S_FLAG is set */
   1090              bitstatus = SET;
   1091            }
   1092            else
   1093            {
   1094              /* SPI_I2S_FLAG is reset */
   1095              bitstatus = RESET;
   1096            }
   1097            /* Return the SPI_I2S_FLAG status */
   1098            return  bitstatus;
   \   0000000A   0x4610             MOV      R0,R2
   \   0000000C   0x4770             BX       LR               ;; return
   1099          }
   1100          
   1101          /**
   1102            * @brief  Clears the SPIx CRC Error (CRCERR) flag.
   1103            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
   1104            *         in SPI mode or 2 or 3 in I2S mode. 
   1105            * @param  SPI_I2S_FLAG: specifies the SPI flag to clear. 
   1106            *          This function clears only CRCERR flag.
   1107            *            @arg SPI_FLAG_CRCERR: CRC Error flag.  
   1108            *  
   1109            * @note   OVR (OverRun error) flag is cleared by software sequence: a read 
   1110            *          operation to SPI_DR register (SPI_I2S_ReceiveData()) followed by a read 
   1111            *          operation to SPI_SR register (SPI_I2S_GetFlagStatus()).
   1112            * @note   UDR (UnderRun error) flag is cleared by a read operation to 
   1113            *          SPI_SR register (SPI_I2S_GetFlagStatus()).   
   1114            * @note   MODF (Mode Fault) flag is cleared by software sequence: a read/write 
   1115            *          operation to SPI_SR register (SPI_I2S_GetFlagStatus()) followed by a 
   1116            *          write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
   1117            *  
   1118            * @retval None
   1119            */

   \                                 In section .text, align 2, keep-with-next
   1120          void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
   1121          {
   1122            /* Check the parameters */
   1123            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   1124            assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
   1125              
   1126            /* Clear the selected SPI CRC Error (CRCERR) flag */
   1127            SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
   \                     SPI_I2S_ClearFlag:
   \   00000000   0x....             B.N      ?Subroutine2
   1128          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   0x43C9             MVNS     R1,R1
   \   00000002   0x8101             STRH     R1,[R0, #+8]
   \   00000004   0x4770             BX       LR               ;; return
   1129          
   1130          /**
   1131            * @brief  Checks whether the specified SPIx/I2Sx interrupt has occurred or not.
   1132            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
   1133            *         in SPI mode or 2 or 3 in I2S mode.   
   1134            * @param  SPI_I2S_IT: specifies the SPI interrupt source to check. 
   1135            *          This parameter can be one of the following values:
   1136            *            @arg SPI_I2S_IT_TXE: Transmit buffer empty interrupt.
   1137            *            @arg SPI_I2S_IT_RXNE: Receive buffer not empty interrupt.
   1138            *            @arg SPI_I2S_IT_OVR: Overrun interrupt.
   1139            *            @arg SPI_IT_MODF: Mode Fault interrupt.
   1140            *            @arg SPI_IT_CRCERR: CRC Error interrupt.
   1141            *            @arg I2S_IT_UDR: Underrun interrupt.  
   1142            *            @arg SPI_I2S_IT_TIFRFE: Format Error interrupt.  
   1143            * @retval The new state of SPI_I2S_IT (SET or RESET).
   1144            */

   \                                 In section .text, align 2, keep-with-next
   1145          ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
   1146          {
   \                     SPI_I2S_GetITStatus:
   \   00000000   0xB430             PUSH     {R4,R5}
   1147            ITStatus bitstatus = RESET;
   \   00000002   0x2200             MOVS     R2,#+0
   1148            uint16_t itpos = 0, itmask = 0, enablestatus = 0;
   1149          
   1150            /* Check the parameters */
   1151            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   1152            assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
   1153          
   1154            /* Get the SPI_I2S_IT index */
   1155            itpos = 0x01 << (SPI_I2S_IT & 0x0F);
   1156          
   1157            /* Get the SPI_I2S_IT IT mask */
   1158            itmask = SPI_I2S_IT >> 4;
   1159          
   1160            /* Set the IT mask */
   1161            itmask = 0x01 << itmask;
   1162          
   1163            /* Get the SPI_I2S_IT enable bit status */
   1164            enablestatus = (SPIx->CR2 & itmask) ;
   \   00000004   0x2301             MOVS     R3,#+1
   \   00000006   0x8884             LDRH     R4,[R0, #+4]
   \   00000008   0x090D             LSRS     R5,R1,#+4
   \   0000000A   0xFA03 0xF505      LSL      R5,R3,R5
   \   0000000E   0x402C             ANDS     R4,R5,R4
   1165          
   1166            /* Check the status of the specified SPI interrupt */
   1167            if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
   \   00000010   0x8900             LDRH     R0,[R0, #+8]
   \   00000012   0xF001 0x010F      AND      R1,R1,#0xF
   \   00000016   0xFA03 0xF101      LSL      R1,R3,R1
   \   0000001A   0x4208             TST      R0,R1
   \   0000001C   0xBF1C             ITT      NE 
   \   0000001E   0x2C00             CMPNE    R4,#+0
   \   00000020   0x2201             MOVNE    R2,#+1
   1168            {
   1169              /* SPI_I2S_IT is set */
   1170              bitstatus = SET;
   1171            }
   1172            else
   1173            {
   1174              /* SPI_I2S_IT is reset */
   1175              bitstatus = RESET;
   1176            }
   1177            /* Return the SPI_I2S_IT status */
   1178            return bitstatus;
   \   00000022   0x4610             MOV      R0,R2
   \   00000024   0xBC30             POP      {R4,R5}
   \   00000026   0x4770             BX       LR               ;; return
   1179          }
   1180          
   1181          /**
   1182            * @brief  Clears the SPIx CRC Error (CRCERR) interrupt pending bit.
   1183            * @param  SPIx: To select the SPIx/I2Sx peripheral, where x can be: 1, 2 or 3 
   1184            *         in SPI mode or 2 or 3 in I2S mode.  
   1185            * @param  SPI_I2S_IT: specifies the SPI interrupt pending bit to clear.
   1186            *         This function clears only CRCERR interrupt pending bit.   
   1187            *            @arg SPI_IT_CRCERR: CRC Error interrupt.
   1188            *   
   1189            * @note   OVR (OverRun Error) interrupt pending bit is cleared by software 
   1190            *          sequence: a read operation to SPI_DR register (SPI_I2S_ReceiveData()) 
   1191            *          followed by a read operation to SPI_SR register (SPI_I2S_GetITStatus()).
   1192            * @note   UDR (UnderRun Error) interrupt pending bit is cleared by a read 
   1193            *          operation to SPI_SR register (SPI_I2S_GetITStatus()).   
   1194            * @note   MODF (Mode Fault) interrupt pending bit is cleared by software sequence:
   1195            *          a read/write operation to SPI_SR register (SPI_I2S_GetITStatus()) 
   1196            *          followed by a write operation to SPI_CR1 register (SPI_Cmd() to enable 
   1197            *          the SPI).
   1198            * @retval None
   1199            */

   \                                 In section .text, align 2, keep-with-next
   1200          void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
   1201          {
   1202            uint16_t itpos = 0;
   1203            /* Check the parameters */
   1204            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   1205            assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));
   1206          
   1207            /* Get the SPI_I2S IT index */
   1208            itpos = 0x01 << (SPI_I2S_IT & 0x0F);
   1209          
   1210            /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
   1211            SPIx->SR = (uint16_t)~itpos;
   \                     SPI_I2S_ClearITPendingBit:
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0xF001 0x010F      AND      R1,R1,#0xF
   \   00000006   0xFA02 0xF101      LSL      R1,R2,R1
   \   0000000A   0xB289             UXTH     R1,R1
   \   0000000C                      REQUIRE ?Subroutine2
   \   0000000C                      ;; // Fall through to label ?Subroutine2
   1212          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x40013000         DC32     0x40013000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x40003800         DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x40003C00         DC32     0x40003c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x40023844         DC32     0x40023844

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x40023840         DC32     0x40023840

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_5:
   \   00000000   0x40023804         DC32     0x40023804

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_6:
   \   00000000   0x40023884         DC32     0x40023884

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_7:
   \   00000000   0x017D7840         DC32     0x17d7840
   1213          
   1214          /**
   1215            * @}
   1216            */
   1217          
   1218          /**
   1219            * @}
   1220            */ 
   1221          
   1222          /**
   1223            * @}
   1224            */ 
   1225          
   1226          /**
   1227            * @}
   1228            */ 
   1229          
   1230          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  I2S_Cmd
       16  I2S_Init
        0  I2S_StructInit
       32  SPI1Init
             32 -> SPI_Cmd
             32 -> SPI_Init
       32  SPI2Init
             32 -> SPI_Cmd
             32 -> SPI_Init
        0  SPI_BiDirectionalLineConfig
        0  SPI_CalculateCRC
        0  SPI_Cmd
        0  SPI_DataSizeConfig
        0  SPI_GetCRC
        0  SPI_GetCRCPolynomial
        0  SPI_I2S_ClearFlag
        0  SPI_I2S_ClearITPendingBit
        0  SPI_I2S_DMACmd
        8  SPI_I2S_DeInit
              0 -> RCC_APB1PeriphResetCmd
              8 -> RCC_APB1PeriphResetCmd
              0 -> RCC_APB2PeriphResetCmd
              8 -> RCC_APB2PeriphResetCmd
        0  SPI_I2S_GetFlagStatus
        8  SPI_I2S_GetITStatus
        0  SPI_I2S_ITConfig
        0  SPI_I2S_ReceiveData
        0  SPI_I2S_SendData
        0  SPI_Init
        0  SPI_NSSInternalSoftwareConfig
        0  SPI_SSOutputCmd
        0  SPI_StructInit
        0  SPI_TIModeCmd
        0  SPI_TransmitCRC


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       8  ?Subroutine0
      20  ?Subroutine1
       6  ?Subroutine2
      20  I2S_Cmd
     180  I2S_Init
      20  I2S_StructInit
      66  SPI1Init
      64  SPI2Init
      22  SPI_BiDirectionalLineConfig
      20  SPI_CalculateCRC
      20  SPI_Cmd
      18  SPI_DataSizeConfig
      12  SPI_GetCRC
       4  SPI_GetCRCPolynomial
       2  SPI_I2S_ClearFlag
      12  SPI_I2S_ClearITPendingBit
      16  SPI_I2S_DMACmd
      82  SPI_I2S_DeInit
      14  SPI_I2S_GetFlagStatus
      40  SPI_I2S_GetITStatus
      26  SPI_I2S_ITConfig
       4  SPI_I2S_ReceiveData
       4  SPI_I2S_SendData
      56  SPI_Init
      22  SPI_NSSInternalSoftwareConfig
      20  SPI_SSOutputCmd
      24  SPI_StructInit
      20  SPI_TIModeCmd
      10  SPI_TransmitCRC

 
 864 bytes in section .text
 
 864 bytes of CODE memory

Errors: none
Warnings: none

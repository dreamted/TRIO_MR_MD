###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     03/Sep/2014  15:32:03 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\src\stm32f2xx_dma.c       #
#    Command line =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\src\stm32f2xx_dma.c -D    #
#                    NDEBUG -lC D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_ #
#                    20140821\STM32F2xx_StdPeriph_Driver_v1212\ewarm\sout\    #
#                    -o D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821 #
#                    \STM32F2xx_StdPeriph_Driver_v1212\ewarm\sout\            #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.0\arm\INC\c\DLib_Config_Normal.h" -I         #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\..\ -I              #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\..\inc\ -I          #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\..\..\uC-CPU\ -I    #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\..\..\uC-LIB\ -I    #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\..\..\uCOS-II\Ports #
#                    \ -I D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_201408 #
#                    21\STM32F2xx_StdPeriph_Driver_v1212\ewarm\..\..\uCOS-II\ #
#                    Source\ -Oh                                              #
#    List file    =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\sout\stm32f2xx_dma. #
#                    lst                                                      #
#    Object file  =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\sout\stm32f2xx_dma. #
#                    o                                                        #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\STM32F2xx_StdPeriph_Driver_v1212\src\stm32f2xx_dma.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_dma.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    18-April-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Direct Memory Access controller (DMA):           
      9            *           - Initialization and Configuration
     10            *           - Data Counter
     11            *           - Double Buffer mode configuration and command  
     12            *           - Interrupts and flags management
     13            *           
     14            *  @verbatim
     15            *      
     16            *          ===================================================================      
     17            *                                 How to use this driver
     18            *          =================================================================== 
     19            *          1. Enable The DMA controller clock using RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_DMA1, ENABLE)
     20            *             function for DMA1 or using RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_DMA2, ENABLE)
     21            *             function for DMA2.
     22            *
     23            *          2. Enable and configure the peripheral to be connected to the DMA Stream
     24            *             (except for internal SRAM / FLASH memories: no initialization is 
     25            *             necessary). 
     26            *        
     27            *          3. For a given Stream, program the required configuration through following parameters:   
     28            *             Source and Destination addresses, Transfer Direction, Transfer size, Source and Destination 
     29            *             data formats, Circular or Normal mode, Stream Priority level, Source and Destination 
     30            *             Incrementation mode, FIFO mode and its Threshold (if needed), Burst mode for Source and/or 
     31            *             Destination (if needed) using the DMA_Init() function.
     32            *             To avoid filling un-nesecessary fields, you can call DMA_StructInit() function
     33            *             to initialize a given structure with default values (reset values), the modify
     34            *             only necessary fields (ie. Source and Destination addresses, Transfer size and Data Formats).
     35            *
     36            *          4. Enable the NVIC and the corresponding interrupt(s) using the function 
     37            *             DMA_ITConfig() if you need to use DMA interrupts. 
     38            *
     39            *          5. Optionally, if the Circular mode is enabled, you can use the Double buffer mode by configuring 
     40            *             the second Memory address and the first Memory to be used through the function 
     41            *             DMA_DoubleBufferModeConfig(). Then enable the Double buffer mode through the function
     42            *             DMA_DoubleBufferModeCmd(). These operations must be done before step 6.
     43            *    
     44            *          6. Enable the DMA stream using the DMA_Cmd() function. 
     45            *                
     46            *          7. Activate the needed Stream Request using PPP_DMACmd() function for
     47            *             any PPP peripheral except internal SRAM and FLASH (ie. SPI, USART ...)
     48            *             The function allowing this operation is provided in each PPP peripheral
     49            *             driver (ie. SPI_DMACmd for SPI peripheral).
     50            *             Once the Stream is enabled, it is not possible to modify its configuration
     51            *             unless the stream is stopped and disabled.
     52            *             After enabling the Stream, it is advised to monitor the EN bit status using
     53            *             the function DMA_GetCmdStatus(). In case of configuration errors or bus errors
     54            *             this bit will remain reset and all transfers on this Stream will remain on hold.      
     55            *
     56            *          8. Optionally, you can configure the number of data to be transferred
     57            *             when the Stream is disabled (ie. after each Transfer Complete event
     58            *             or when a Transfer Error occurs) using the function DMA_SetCurrDataCounter().
     59            *             And you can get the number of remaining data to be transferred using 
     60            *             the function DMA_GetCurrDataCounter() at run time (when the DMA Stream is
     61            *             enabled and running).  
     62            *                   
     63            *          9. To control DMA events you can use one of the following 
     64            *              two methods:
     65            *               a- Check on DMA Stream flags using the function DMA_GetFlagStatus().  
     66            *               b- Use DMA interrupts through the function DMA_ITConfig() at initialization
     67            *                  phase and DMA_GetITStatus() function into interrupt routines in
     68            *                  communication phase.  
     69            *              After checking on a flag you should clear it using DMA_ClearFlag()
     70            *              function. And after checking on an interrupt event you should 
     71            *              clear it using DMA_ClearITPendingBit() function.    
     72            *              
     73            *          10. Optionally, if Circular mode and Double Buffer mode are enabled, you can modify
     74            *              the Memory Addresses using the function DMA_MemoryTargetConfig(). Make sure that
     75            *              the Memory Address to be modified is not the one currently in use by DMA Stream.
     76            *              This condition can be monitored using the function DMA_GetCurrentMemoryTarget().
     77            *              
     78            *          11. Optionally, Pause-Resume operations may be performed:
     79            *              The DMA_Cmd() function may be used to perform Pause-Resume operation. When a 
     80            *              transfer is ongoing, calling this function to disable the Stream will cause the 
     81            *              transfer to be paused. All configuration registers and the number of remaining 
     82            *              data will be preserved. When calling again this function to re-enable the Stream, 
     83            *              the transfer will be resumed from the point where it was paused.          
     84            *                 
     85            * @note   Memory-to-Memory transfer is possible by setting the address of the memory into
     86            *         the Peripheral registers. In this mode, Circular mode and Double Buffer mode
     87            *         are not allowed.
     88            *  
     89            * @note   The FIFO is used mainly to reduce bus usage and to allow data packing/unpacking: it is
     90            *         possible to set different Data Sizes for the Peripheral and the Memory (ie. you can set
     91            *         Half-Word data size for the peripheral to access its data register and set Word data size
     92            *         for the Memory to gain in access time. Each two Half-words will be packed and written in
     93            *         a single access to a Word in the Memory).
     94            *    
     95            * @note  When FIFO is disabled, it is not allowed to configure different Data Sizes for Source
     96            *        and Destination. In this case the Peripheral Data Size will be applied to both Source
     97            *        and Destination.               
     98            *
     99            *  @endverbatim
    100            *                                  
    101            ******************************************************************************
    102            * @attention
    103            *
    104            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
    105            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
    106            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
    107            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
    108            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
    109            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
    110            *
    111            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
    112            ******************************************************************************  
    113            */ 
    114          
    115          /* Includes ------------------------------------------------------------------*/
    116          #if 0
    117          #include "stm32f2xx_dma.h"
    118          #include "stm32f2xx_rcc.h"
    119          #endif
    120          #include "stm32f2xx_1212.h"
    121          
    122          /** @addtogroup STM32F2xx_StdPeriph_Driver
    123            * @{
    124            */
    125          
    126          /** @defgroup DMA 
    127            * @brief DMA driver modules
    128            * @{
    129            */ 
    130          
    131          /* Private typedef -----------------------------------------------------------*/
    132          /* Private define ------------------------------------------------------------*/
    133          
    134          /* Masks Definition */
    135          #define TRANSFER_IT_ENABLE_MASK (uint32_t)(DMA_SxCR_TCIE | DMA_SxCR_HTIE | \
    136                                                     DMA_SxCR_TEIE | DMA_SxCR_DMEIE)
    137          
    138          #define DMA_Stream0_IT_MASK     (uint32_t)(DMA_LISR_FEIF0 | DMA_LISR_DMEIF0 | \
    139                                                     DMA_LISR_TEIF0 | DMA_LISR_HTIF0 | \
    140                                                     DMA_LISR_TCIF0)
    141          
    142          #define DMA_Stream1_IT_MASK     (uint32_t)(DMA_Stream0_IT_MASK << 6)
    143          #define DMA_Stream2_IT_MASK     (uint32_t)(DMA_Stream0_IT_MASK << 16)
    144          #define DMA_Stream3_IT_MASK     (uint32_t)(DMA_Stream0_IT_MASK << 22)
    145          #define DMA_Stream4_IT_MASK     (uint32_t)(DMA_Stream0_IT_MASK | (uint32_t)0x20000000)
    146          #define DMA_Stream5_IT_MASK     (uint32_t)(DMA_Stream1_IT_MASK | (uint32_t)0x20000000)
    147          #define DMA_Stream6_IT_MASK     (uint32_t)(DMA_Stream2_IT_MASK | (uint32_t)0x20000000)
    148          #define DMA_Stream7_IT_MASK     (uint32_t)(DMA_Stream3_IT_MASK | (uint32_t)0x20000000)
    149          #define TRANSFER_IT_MASK        (uint32_t)0x0F3C0F3C
    150          #define HIGH_ISR_MASK           (uint32_t)0x20000000
    151          #define RESERVED_MASK           (uint32_t)0x0F7D0F7D  
    152          
    153          /* Private macro -------------------------------------------------------------*/
    154          /* Private variables ---------------------------------------------------------*/
    155          /* Private function prototypes -----------------------------------------------*/
    156          /* Private functions ---------------------------------------------------------*/
    157          
    158          
    159          /** @defgroup DMA_Private_Functions
    160            * @{
    161            */
    162          
    163          /** @defgroup DMA_Group1 Initialization and Configuration functions
    164           *  @brief   Initialization and Configuration functions
    165           *
    166          @verbatim   
    167           ===============================================================================
    168                           Initialization and Configuration functions
    169           ===============================================================================  
    170          
    171            This subsection provides functions allowing to initialize the DMA Stream source
    172            and destination addresses, incrementation and data sizes, transfer direction, 
    173            buffer size, circular/normal mode selection, memory-to-memory mode selection 
    174            and Stream priority value.
    175            
    176            The DMA_Init() function follows the DMA configuration procedures as described in
    177            reference manual (RM0033) except the first point: waiting on EN bit to be reset.
    178            This condition should be checked by user application using the function DMA_GetCmdStatus()
    179            before calling the DMA_Init() function.
    180          
    181          @endverbatim
    182            * @{
    183            */
    184          
    185          /**
    186            * @brief  Deinitialize the DMAy Streamx registers to their default reset values.
    187            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    188            *         to 7 to select the DMA Stream.
    189            * @retval None
    190            */

   \                                 In section .text, align 2, keep-with-next
    191          void DMA_DeInit(DMA_Stream_TypeDef* DMAy_Streamx)
    192          {
    193            /* Check the parameters */
    194            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    195          
    196            /* Disable the selected DMAy Streamx */
    197            DMAy_Streamx->CR &= ~((uint32_t)DMA_SxCR_EN);
   \                     DMA_DeInit:
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x0849             LSRS     R1,R1,#+1
   \   00000004   0x0049             LSLS     R1,R1,#+1
   \   00000006   0x6001             STR      R1,[R0, #+0]
    198          
    199            /* Reset DMAy Streamx control register */
    200            DMAy_Streamx->CR  = 0;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6001             STR      R1,[R0, #+0]
    201            
    202            /* Reset DMAy Streamx Number of Data to Transfer register */
    203            DMAy_Streamx->NDTR = 0;
   \   0000000C   0x6041             STR      R1,[R0, #+4]
    204            
    205            /* Reset DMAy Streamx peripheral address register */
    206            DMAy_Streamx->PAR  = 0;
   \   0000000E   0x6081             STR      R1,[R0, #+8]
    207            
    208            /* Reset DMAy Streamx memory 0 address register */
    209            DMAy_Streamx->M0AR = 0;
   \   00000010   0x60C1             STR      R1,[R0, #+12]
    210          
    211            /* Reset DMAy Streamx memory 1 address register */
    212            DMAy_Streamx->M1AR = 0;
   \   00000012   0x6101             STR      R1,[R0, #+16]
    213          
    214            /* Reset DMAy Streamx FIFO control register */
    215            DMAy_Streamx->FCR = (uint32_t)0x00000021; 
   \   00000014   0x2121             MOVS     R1,#+33
   \   00000016   0x6141             STR      R1,[R0, #+20]
    216          
    217            /* Reset interrupt pending bits for the selected stream */
    218            if (DMAy_Streamx == DMA1_Stream0)
   \   00000018   0x....             LDR.N    R1,??DataTable5  ;; 0x40026010
   \   0000001A   0x4288             CMP      R0,R1
   \   0000001C   0xBF04             ITT      EQ 
   \   0000001E   0x....             LDREQ.N  R0,??DataTable5_1  ;; 0x40026008
   \   00000020   0x213D             MOVEQ    R1,#+61
    219            {
    220              /* Reset interrupt pending bits for DMA1 Stream0 */
    221              DMA1->LIFCR = DMA_Stream0_IT_MASK;
   \   00000022   0xD043             BEQ.N    ??DMA_DeInit_0
    222            }
    223            else if (DMAy_Streamx == DMA1_Stream1)
   \   00000024   0x....             LDR.N    R1,??DataTable5_2  ;; 0x40026028
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xBF04             ITT      EQ 
   \   0000002A   0x....             LDREQ.N  R0,??DataTable5_1  ;; 0x40026008
   \   0000002C   0xF44F 0x6174      MOVEQ    R1,#+3904
    224            {
    225              /* Reset interrupt pending bits for DMA1 Stream1 */
    226              DMA1->LIFCR = DMA_Stream1_IT_MASK;
   \   00000030   0xD03C             BEQ.N    ??DMA_DeInit_0
    227            }
    228            else if (DMAy_Streamx == DMA1_Stream2)
   \   00000032   0x....             LDR.N    R1,??DataTable5_3  ;; 0x40026040
   \   00000034   0x4288             CMP      R0,R1
   \   00000036   0xBF04             ITT      EQ 
   \   00000038   0x....             LDREQ.N  R0,??DataTable5_1  ;; 0x40026008
   \   0000003A   0xF44F 0x1174      MOVEQ    R1,#+3997696
    229            {
    230              /* Reset interrupt pending bits for DMA1 Stream2 */
    231              DMA1->LIFCR = DMA_Stream2_IT_MASK;
   \   0000003E   0xD035             BEQ.N    ??DMA_DeInit_0
    232            }
    233            else if (DMAy_Streamx == DMA1_Stream3)
   \   00000040   0x....             LDR.N    R1,??DataTable5_4  ;; 0x40026058
   \   00000042   0x4288             CMP      R0,R1
   \   00000044   0xBF08             IT       EQ 
   \   00000046   0x....             LDREQ.N  R0,??DataTable5_1  ;; 0x40026008
    234            {
    235              /* Reset interrupt pending bits for DMA1 Stream3 */
    236              DMA1->LIFCR = DMA_Stream3_IT_MASK;
   \   00000048   0xD02E             BEQ.N    ??DMA_DeInit_1
    237            }
    238            else if (DMAy_Streamx == DMA1_Stream4)
   \   0000004A   0x....             LDR.N    R1,??DataTable5_5  ;; 0x40026070
   \   0000004C   0x4288             CMP      R0,R1
   \   0000004E   0xBF04             ITT      EQ 
   \   00000050   0x....             LDREQ.N  R0,??DataTable5_1  ;; 0x40026008
   \   00000052   0x....             LDREQ.N  R1,??DataTable5_6  ;; 0x2000003d
    239            {
    240              /* Reset interrupt pending bits for DMA1 Stream4 */
    241              DMA1->HIFCR = DMA_Stream4_IT_MASK;
   \   00000054   0xD044             BEQ.N    ??DMA_DeInit_2
    242            }
    243            else if (DMAy_Streamx == DMA1_Stream5)
   \   00000056   0x....             LDR.N    R1,??DataTable5_7  ;; 0x40026088
   \   00000058   0x4288             CMP      R0,R1
   \   0000005A   0xBF04             ITT      EQ 
   \   0000005C   0x....             LDREQ.N  R0,??DataTable5_1  ;; 0x40026008
   \   0000005E   0x....             LDREQ.N  R1,??DataTable5_8  ;; 0x20000f40
    244            {
    245              /* Reset interrupt pending bits for DMA1 Stream5 */
    246              DMA1->HIFCR = DMA_Stream5_IT_MASK;
   \   00000060   0xD03E             BEQ.N    ??DMA_DeInit_2
    247            }
    248            else if (DMAy_Streamx == DMA1_Stream6)
   \   00000062   0x....             LDR.N    R1,??DataTable5_9  ;; 0x400260a0
   \   00000064   0x4288             CMP      R0,R1
   \   00000066   0xBF04             ITT      EQ 
   \   00000068   0x....             LDREQ.N  R0,??DataTable5_1  ;; 0x40026008
   \   0000006A   0x....             LDREQ.N  R1,??DataTable5_10  ;; 0x203d0000
    249            {
    250              /* Reset interrupt pending bits for DMA1 Stream6 */
    251              DMA1->HIFCR = (uint32_t)DMA_Stream6_IT_MASK;
   \   0000006C   0xD038             BEQ.N    ??DMA_DeInit_2
    252            }
    253            else if (DMAy_Streamx == DMA1_Stream7)
   \   0000006E   0x....             LDR.N    R1,??DataTable5_11  ;; 0x400260b8
   \   00000070   0x4288             CMP      R0,R1
   \   00000072   0xBF08             IT       EQ 
   \   00000074   0x....             LDREQ.N  R0,??DataTable5_1  ;; 0x40026008
    254            {
    255              /* Reset interrupt pending bits for DMA1 Stream7 */
    256              DMA1->HIFCR = DMA_Stream7_IT_MASK;
   \   00000076   0xD031             BEQ.N    ??DMA_DeInit_3
    257            }
    258            else if (DMAy_Streamx == DMA2_Stream0)
   \   00000078   0x....             LDR.N    R1,??DataTable5_12  ;; 0x40026410
   \   0000007A   0x4288             CMP      R0,R1
   \   0000007C   0xBF04             ITT      EQ 
   \   0000007E   0x....             LDREQ.N  R0,??DataTable5_13  ;; 0x40026408
   \   00000080   0x213D             MOVEQ    R1,#+61
    259            {
    260              /* Reset interrupt pending bits for DMA2 Stream0 */
    261              DMA2->LIFCR = DMA_Stream0_IT_MASK;
   \   00000082   0xD013             BEQ.N    ??DMA_DeInit_0
    262            }
    263            else if (DMAy_Streamx == DMA2_Stream1)
   \   00000084   0x....             LDR.N    R1,??DataTable5_14  ;; 0x40026428
   \   00000086   0x4288             CMP      R0,R1
   \   00000088   0xBF04             ITT      EQ 
   \   0000008A   0x....             LDREQ.N  R0,??DataTable5_13  ;; 0x40026408
   \   0000008C   0xF44F 0x6174      MOVEQ    R1,#+3904
    264            {
    265              /* Reset interrupt pending bits for DMA2 Stream1 */
    266              DMA2->LIFCR = DMA_Stream1_IT_MASK;
   \   00000090   0xD00C             BEQ.N    ??DMA_DeInit_0
    267            }
    268            else if (DMAy_Streamx == DMA2_Stream2)
   \   00000092   0x....             LDR.N    R1,??DataTable5_15  ;; 0x40026440
   \   00000094   0x4288             CMP      R0,R1
   \   00000096   0xBF04             ITT      EQ 
   \   00000098   0x....             LDREQ.N  R0,??DataTable5_13  ;; 0x40026408
   \   0000009A   0xF44F 0x1174      MOVEQ    R1,#+3997696
    269            {
    270              /* Reset interrupt pending bits for DMA2 Stream2 */
    271              DMA2->LIFCR = DMA_Stream2_IT_MASK;
   \   0000009E   0xD005             BEQ.N    ??DMA_DeInit_0
    272            }
    273            else if (DMAy_Streamx == DMA2_Stream3)
   \   000000A0   0x....             LDR.N    R1,??DataTable5_16  ;; 0x40026458
   \   000000A2   0x4288             CMP      R0,R1
   \   000000A4   0xD104             BNE.N    ??DMA_DeInit_4
    274            {
    275              /* Reset interrupt pending bits for DMA2 Stream3 */
    276              DMA2->LIFCR = DMA_Stream3_IT_MASK;
   \   000000A6   0x....             LDR.N    R0,??DataTable5_13  ;; 0x40026408
   \                     ??DMA_DeInit_1:
   \   000000A8   0xF04F 0x6174      MOV      R1,#+255852544
   \                     ??DMA_DeInit_0:
   \   000000AC   0x6001             STR      R1,[R0, #+0]
   \   000000AE   0x4770             BX       LR
    277            }
    278            else if (DMAy_Streamx == DMA2_Stream4)
   \                     ??DMA_DeInit_4:
   \   000000B0   0x....             LDR.N    R1,??DataTable5_17  ;; 0x40026470
   \   000000B2   0x4288             CMP      R0,R1
   \   000000B4   0xBF04             ITT      EQ 
   \   000000B6   0x....             LDREQ.N  R0,??DataTable5_13  ;; 0x40026408
   \   000000B8   0x....             LDREQ.N  R1,??DataTable5_6  ;; 0x2000003d
    279            {
    280              /* Reset interrupt pending bits for DMA2 Stream4 */
    281              DMA2->HIFCR = DMA_Stream4_IT_MASK;
   \   000000BA   0xD011             BEQ.N    ??DMA_DeInit_2
    282            }
    283            else if (DMAy_Streamx == DMA2_Stream5)
   \   000000BC   0x....             LDR.N    R1,??DataTable5_18  ;; 0x40026488
   \   000000BE   0x4288             CMP      R0,R1
   \   000000C0   0xBF04             ITT      EQ 
   \   000000C2   0x....             LDREQ.N  R0,??DataTable5_13  ;; 0x40026408
   \   000000C4   0x....             LDREQ.N  R1,??DataTable5_8  ;; 0x20000f40
    284            {
    285              /* Reset interrupt pending bits for DMA2 Stream5 */
    286              DMA2->HIFCR = DMA_Stream5_IT_MASK;
   \   000000C6   0xD00B             BEQ.N    ??DMA_DeInit_2
    287            }
    288            else if (DMAy_Streamx == DMA2_Stream6)
   \   000000C8   0x....             LDR.N    R1,??DataTable5_19  ;; 0x400264a0
   \   000000CA   0x4288             CMP      R0,R1
   \   000000CC   0xBF04             ITT      EQ 
   \   000000CE   0x....             LDREQ.N  R0,??DataTable5_13  ;; 0x40026408
   \   000000D0   0x....             LDREQ.N  R1,??DataTable5_10  ;; 0x203d0000
    289            {
    290              /* Reset interrupt pending bits for DMA2 Stream6 */
    291              DMA2->HIFCR = DMA_Stream6_IT_MASK;
   \   000000D2   0xD005             BEQ.N    ??DMA_DeInit_2
    292            }
    293            else 
    294            {
    295              if (DMAy_Streamx == DMA2_Stream7)
   \   000000D4   0x....             LDR.N    R1,??DataTable5_20  ;; 0x400264b8
   \   000000D6   0x4288             CMP      R0,R1
   \   000000D8   0xD103             BNE.N    ??DMA_DeInit_5
    296              {
    297                /* Reset interrupt pending bits for DMA2 Stream7 */
    298                DMA2->HIFCR = DMA_Stream7_IT_MASK;
   \   000000DA   0x....             LDR.N    R0,??DataTable5_13  ;; 0x40026408
   \                     ??DMA_DeInit_3:
   \   000000DC   0xF04F 0x513D      MOV      R1,#+792723456
   \                     ??DMA_DeInit_2:
   \   000000E0   0x6041             STR      R1,[R0, #+4]
    299              }
    300            }
    301          }
   \                     ??DMA_DeInit_5:
   \   000000E2   0x4770             BX       LR               ;; return
    302          
    303          /**
    304            * @brief  Initializes the DMAy Streamx according to the specified parameters in 
    305            *         the DMA_InitStruct structure.
    306            * @note   Before calling this function, it is recommended to check that the Stream 
    307            *         is actually disabled using the function DMA_GetCmdStatus().  
    308            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    309            *         to 7 to select the DMA Stream.
    310            * @param  DMA_InitStruct: pointer to a DMA_InitTypeDef structure that contains
    311            *         the configuration information for the specified DMA Stream.  
    312            * @retval None
    313            */

   \                                 In section .text, align 2, keep-with-next
    314          void DMA_Init(DMA_Stream_TypeDef* DMAy_Streamx, DMA_InitTypeDef* DMA_InitStruct)
    315          {
    316            uint32_t tmpreg = 0;
    317          
    318            /* Check the parameters */
    319            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    320            assert_param(IS_DMA_CHANNEL(DMA_InitStruct->DMA_Channel));
    321            assert_param(IS_DMA_DIRECTION(DMA_InitStruct->DMA_DIR));
    322            assert_param(IS_DMA_BUFFER_SIZE(DMA_InitStruct->DMA_BufferSize));
    323            assert_param(IS_DMA_PERIPHERAL_INC_STATE(DMA_InitStruct->DMA_PeripheralInc));
    324            assert_param(IS_DMA_MEMORY_INC_STATE(DMA_InitStruct->DMA_MemoryInc));
    325            assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(DMA_InitStruct->DMA_PeripheralDataSize));
    326            assert_param(IS_DMA_MEMORY_DATA_SIZE(DMA_InitStruct->DMA_MemoryDataSize));
    327            assert_param(IS_DMA_MODE(DMA_InitStruct->DMA_Mode));
    328            assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
    329            assert_param(IS_DMA_FIFO_MODE_STATE(DMA_InitStruct->DMA_FIFOMode));
    330            assert_param(IS_DMA_FIFO_THRESHOLD(DMA_InitStruct->DMA_FIFOThreshold));
    331            assert_param(IS_DMA_MEMORY_BURST(DMA_InitStruct->DMA_MemoryBurst));
    332            assert_param(IS_DMA_PERIPHERAL_BURST(DMA_InitStruct->DMA_PeripheralBurst));
    333          
    334            /*------------------------- DMAy Streamx CR Configuration ------------------*/
    335            /* Get the DMAy_Streamx CR value */
    336            tmpreg = DMAy_Streamx->CR;
    337          
    338            /* Clear CHSEL, MBURST, PBURST, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
    339            tmpreg &= ((uint32_t)~(DMA_SxCR_CHSEL | DMA_SxCR_MBURST | DMA_SxCR_PBURST | \
    340                                   DMA_SxCR_PL | DMA_SxCR_MSIZE | DMA_SxCR_PSIZE | \
    341                                   DMA_SxCR_MINC | DMA_SxCR_PINC | DMA_SxCR_CIRC | \
    342                                   DMA_SxCR_DIR));
    343          
    344            /* Configure DMAy Streamx: */
    345            /* Set CHSEL bits according to DMA_CHSEL value */
    346            /* Set DIR bits according to DMA_DIR value */
    347            /* Set PINC bit according to DMA_PeripheralInc value */
    348            /* Set MINC bit according to DMA_MemoryInc value */
    349            /* Set PSIZE bits according to DMA_PeripheralDataSize value */
    350            /* Set MSIZE bits according to DMA_MemoryDataSize value */
    351            /* Set CIRC bit according to DMA_Mode value */
    352            /* Set PL bits according to DMA_Priority value */
    353            /* Set MBURST bits according to DMA_MemoryBurst value */
    354            /* Set PBURST bits according to DMA_PeripheralBurst value */
    355            tmpreg |= DMA_InitStruct->DMA_Channel | DMA_InitStruct->DMA_DIR |
    356                      DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
    357                      DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
    358                      DMA_InitStruct->DMA_Mode | DMA_InitStruct->DMA_Priority |
    359                      DMA_InitStruct->DMA_MemoryBurst | DMA_InitStruct->DMA_PeripheralBurst;
    360          
    361            /* Write to DMAy Streamx CR register */
    362            DMAy_Streamx->CR = tmpreg;
   \                     DMA_Init:
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x....             LDR.N    R3,??DataTable5_21  ;; 0xf01c803f
   \   00000004   0x401A             ANDS     R2,R3,R2
   \   00000006   0x680B             LDR      R3,[R1, #+0]
   \   00000008   0x431A             ORRS     R2,R3,R2
   \   0000000A   0x68CB             LDR      R3,[R1, #+12]
   \   0000000C   0x431A             ORRS     R2,R3,R2
   \   0000000E   0x694B             LDR      R3,[R1, #+20]
   \   00000010   0x431A             ORRS     R2,R3,R2
   \   00000012   0x698B             LDR      R3,[R1, #+24]
   \   00000014   0x431A             ORRS     R2,R3,R2
   \   00000016   0x69CB             LDR      R3,[R1, #+28]
   \   00000018   0x431A             ORRS     R2,R3,R2
   \   0000001A   0x6A0B             LDR      R3,[R1, #+32]
   \   0000001C   0x431A             ORRS     R2,R3,R2
   \   0000001E   0x6A4B             LDR      R3,[R1, #+36]
   \   00000020   0x431A             ORRS     R2,R3,R2
   \   00000022   0x6A8B             LDR      R3,[R1, #+40]
   \   00000024   0x431A             ORRS     R2,R3,R2
   \   00000026   0x6B4B             LDR      R3,[R1, #+52]
   \   00000028   0x431A             ORRS     R2,R3,R2
   \   0000002A   0x6B8B             LDR      R3,[R1, #+56]
   \   0000002C   0x431A             ORRS     R2,R3,R2
   \   0000002E   0x6002             STR      R2,[R0, #+0]
    363          
    364            /*------------------------- DMAy Streamx FCR Configuration -----------------*/
    365            /* Get the DMAy_Streamx FCR value */
    366            tmpreg = DMAy_Streamx->FCR;
    367          
    368            /* Clear DMDIS and FTH bits */
    369            tmpreg &= (uint32_t)~(DMA_SxFCR_DMDIS | DMA_SxFCR_FTH);
    370          
    371            /* Configure DMAy Streamx FIFO: 
    372              Set DMDIS bits according to DMA_FIFOMode value 
    373              Set FTH bits according to DMA_FIFOThreshold value */
    374            tmpreg |= DMA_InitStruct->DMA_FIFOMode | DMA_InitStruct->DMA_FIFOThreshold;
    375          
    376            /* Write to DMAy Streamx CR */
    377            DMAy_Streamx->FCR = tmpreg;
   \   00000030   0x6942             LDR      R2,[R0, #+20]
   \   00000032   0x08D2             LSRS     R2,R2,#+3
   \   00000034   0x6B0B             LDR      R3,[R1, #+48]
   \   00000036   0xF8D1 0xC02C      LDR      R12,[R1, #+44]
   \   0000003A   0xEA4C 0x0303      ORR      R3,R12,R3
   \   0000003E   0xEA53 0x02C2      ORRS     R2,R3,R2, LSL #+3
   \   00000042   0x6142             STR      R2,[R0, #+20]
    378          
    379            /*------------------------- DMAy Streamx NDTR Configuration ----------------*/
    380            /* Write to DMAy Streamx NDTR register */
    381            DMAy_Streamx->NDTR = DMA_InitStruct->DMA_BufferSize;
   \   00000044   0x690A             LDR      R2,[R1, #+16]
   \   00000046   0x6042             STR      R2,[R0, #+4]
    382          
    383            /*------------------------- DMAy Streamx PAR Configuration -----------------*/
    384            /* Write to DMAy Streamx PAR */
    385            DMAy_Streamx->PAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
   \   00000048   0x684A             LDR      R2,[R1, #+4]
   \   0000004A   0x6082             STR      R2,[R0, #+8]
    386          
    387            /*------------------------- DMAy Streamx M0AR Configuration ----------------*/
    388            /* Write to DMAy Streamx M0AR */
    389            DMAy_Streamx->M0AR = DMA_InitStruct->DMA_Memory0BaseAddr;
   \   0000004C   0x6889             LDR      R1,[R1, #+8]
   \   0000004E   0x60C1             STR      R1,[R0, #+12]
    390          }
   \   00000050   0x4770             BX       LR               ;; return
    391          
    392          /**
    393            * @brief  Fills each DMA_InitStruct member with its default value.
    394            * @param  DMA_InitStruct : pointer to a DMA_InitTypeDef structure which will 
    395            *         be initialized.
    396            * @retval None
    397            */

   \                                 In section .text, align 2, keep-with-next
    398          void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
    399          {
    400            /*-------------- Reset DMA init structure parameters values ----------------*/
    401            /* Initialize the DMA_Channel member */
    402            DMA_InitStruct->DMA_Channel = 0;
   \                     DMA_StructInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x6001             STR      R1,[R0, #+0]
    403          
    404            /* Initialize the DMA_PeripheralBaseAddr member */
    405            DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
   \   00000004   0x6041             STR      R1,[R0, #+4]
    406          
    407            /* Initialize the DMA_Memory0BaseAddr member */
    408            DMA_InitStruct->DMA_Memory0BaseAddr = 0;
   \   00000006   0x6081             STR      R1,[R0, #+8]
    409          
    410            /* Initialize the DMA_DIR member */
    411            DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralToMemory;
   \   00000008   0x60C1             STR      R1,[R0, #+12]
    412          
    413            /* Initialize the DMA_BufferSize member */
    414            DMA_InitStruct->DMA_BufferSize = 0;
   \   0000000A   0x6101             STR      R1,[R0, #+16]
    415          
    416            /* Initialize the DMA_PeripheralInc member */
    417            DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
   \   0000000C   0x6141             STR      R1,[R0, #+20]
    418          
    419            /* Initialize the DMA_MemoryInc member */
    420            DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
   \   0000000E   0x6181             STR      R1,[R0, #+24]
    421          
    422            /* Initialize the DMA_PeripheralDataSize member */
    423            DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
   \   00000010   0x61C1             STR      R1,[R0, #+28]
    424          
    425            /* Initialize the DMA_MemoryDataSize member */
    426            DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
   \   00000012   0x6201             STR      R1,[R0, #+32]
    427          
    428            /* Initialize the DMA_Mode member */
    429            DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
   \   00000014   0x6241             STR      R1,[R0, #+36]
    430          
    431            /* Initialize the DMA_Priority member */
    432            DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
   \   00000016   0x6281             STR      R1,[R0, #+40]
    433          
    434            /* Initialize the DMA_FIFOMode member */
    435            DMA_InitStruct->DMA_FIFOMode = DMA_FIFOMode_Disable;
   \   00000018   0x62C1             STR      R1,[R0, #+44]
    436          
    437            /* Initialize the DMA_FIFOThreshold member */
    438            DMA_InitStruct->DMA_FIFOThreshold = DMA_FIFOThreshold_1QuarterFull;
   \   0000001A   0x6301             STR      R1,[R0, #+48]
    439          
    440            /* Initialize the DMA_MemoryBurst member */
    441            DMA_InitStruct->DMA_MemoryBurst = DMA_MemoryBurst_Single;
   \   0000001C   0x6341             STR      R1,[R0, #+52]
    442          
    443            /* Initialize the DMA_PeripheralBurst member */
    444            DMA_InitStruct->DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
   \   0000001E   0x6381             STR      R1,[R0, #+56]
    445          }
   \   00000020   0x4770             BX       LR               ;; return
    446          
    447          /**
    448            * @brief  Enables or disables the specified DMAy Streamx.
    449            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    450            *         to 7 to select the DMA Stream.
    451            * @param  NewState: new state of the DMAy Streamx. 
    452            *          This parameter can be: ENABLE or DISABLE.
    453            *
    454            * @note  This function may be used to perform Pause-Resume operation. When a
    455            *        transfer is ongoing, calling this function to disable the Stream will
    456            *        cause the transfer to be paused. All configuration registers and the
    457            *        number of remaining data will be preserved. When calling again this
    458            *        function to re-enable the Stream, the transfer will be resumed from
    459            *        the point where it was paused.          
    460            *    
    461            * @note  After configuring the DMA Stream (DMA_Init() function) and enabling the
    462            *        stream, it is recommended to check (or wait until) the DMA Stream is
    463            *        effectively enabled. A Stream may remain disabled if a configuration 
    464            *        parameter is wrong.
    465            *        After disabling a DMA Stream, it is also recommended to check (or wait
    466            *        until) the DMA Stream is effectively disabled. If a Stream is disabled 
    467            *        while a data transfer is ongoing, the current data will be transferred
    468            *        and the Stream will be effectively disabled only after the transfer of
    469            *        this single data is finished.            
    470            *    
    471            * @retval None
    472            */

   \                                 In section .text, align 2, keep-with-next
    473          void DMA_Cmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState)
    474          {
    475            /* Check the parameters */
    476            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    477            assert_param(IS_FUNCTIONAL_STATE(NewState));
    478          
    479            if (NewState != DISABLE)
   \                     DMA_Cmd:
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xBF12             ITEE     NE 
   \   00000006   0xF041 0x0101      ORRNE    R1,R1,#0x1
   \   0000000A   0x0849             LSREQ    R1,R1,#+1
   \   0000000C   0x0049             LSLEQ    R1,R1,#+1
    480            {
    481              /* Enable the selected DMAy Streamx by setting EN bit */
    482              DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_EN;
    483            }
    484            else
    485            {
    486              /* Disable the selected DMAy Streamx by clearing EN bit */
    487              DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_EN;
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    488            }
    489          }
   \   00000010   0x4770             BX       LR               ;; return
    490          
    491          /**
    492            * @brief  Configures, when the PINC (Peripheral Increment address mode) bit is
    493            *         set, if the peripheral address should be incremented with the data 
    494            *         size (configured with PSIZE bits) or by a fixed offset equal to 4
    495            *         (32-bit aligned addresses).
    496            *   
    497            * @note   This function has no effect if the Peripheral Increment mode is disabled.
    498            *     
    499            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    500            *          to 7 to select the DMA Stream.
    501            * @param  DMA_Pincos: specifies the Peripheral increment offset size.
    502            *          This parameter can be one of the following values:
    503            *            @arg DMA_PINCOS_Psize: Peripheral address increment is done  
    504            *                                   accordingly to PSIZE parameter.
    505            *            @arg DMA_PINCOS_WordAligned: Peripheral address increment offset is 
    506            *                                         fixed to 4 (32-bit aligned addresses). 
    507            * @retval None
    508            */

   \                                 In section .text, align 2, keep-with-next
    509          void DMA_PeriphIncOffsetSizeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_Pincos)
    510          {
    511            /* Check the parameters */
    512            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    513            assert_param(IS_DMA_PINCOS_SIZE(DMA_Pincos));
    514          
    515            /* Check the needed Peripheral increment offset */
    516            if(DMA_Pincos != DMA_PINCOS_Psize)
   \                     DMA_PeriphIncOffsetSizeConfig:
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xBF14             ITE      NE 
   \   00000006   0xF441 0x4100      ORRNE    R1,R1,#0x8000
   \   0000000A   0xF421 0x4100      BICEQ    R1,R1,#0x8000
    517            {
    518              /* Configure DMA_SxCR_PINCOS bit with the input parameter */
    519              DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PINCOS;     
    520            }
    521            else
    522            {
    523              /* Clear the PINCOS bit: Peripheral address incremented according to PSIZE */
    524              DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PINCOS;    
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    525            }
    526          }
   \   00000010   0x4770             BX       LR               ;; return
    527          
    528          /**
    529            * @brief  Configures, when the DMAy Streamx is disabled, the flow controller for
    530            *         the next transactions (Peripheral or Memory).
    531            *       
    532            * @note   Before enabling this feature, check if the used peripheral supports 
    533            *         the Flow Controller mode or not.    
    534            *  
    535            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    536            *          to 7 to select the DMA Stream.
    537            * @param  DMA_FlowCtrl: specifies the DMA flow controller.
    538            *          This parameter can be one of the following values:
    539            *            @arg DMA_FlowCtrl_Memory: DMAy_Streamx transactions flow controller is 
    540            *                                      the DMA controller.
    541            *            @arg DMA_FlowCtrl_Peripheral: DMAy_Streamx transactions flow controller 
    542            *                                          is the peripheral.    
    543            * @retval None
    544            */

   \                                 In section .text, align 2, keep-with-next
    545          void DMA_FlowControllerConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FlowCtrl)
    546          {
    547            /* Check the parameters */
    548            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    549            assert_param(IS_DMA_FLOW_CTRL(DMA_FlowCtrl));
    550          
    551            /* Check the needed flow controller  */
    552            if(DMA_FlowCtrl != DMA_FlowCtrl_Memory)
   \                     DMA_FlowControllerConfig:
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xBF14             ITE      NE 
   \   00000006   0xF041 0x0120      ORRNE    R1,R1,#0x20
   \   0000000A   0xF021 0x0120      BICEQ    R1,R1,#0x20
    553            {
    554              /* Configure DMA_SxCR_PFCTRL bit with the input parameter */
    555              DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_PFCTRL;   
    556            }
    557            else
    558            {
    559              /* Clear the PFCTRL bit: Memory is the flow controller */
    560              DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_PFCTRL;    
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    561            }
    562          }
   \   00000010   0x4770             BX       LR               ;; return
    563          /**
    564            * @}
    565            */
    566          
    567          /** @defgroup DMA_Group2 Data Counter functions
    568           *  @brief   Data Counter functions 
    569           *
    570          @verbatim   
    571           ===============================================================================
    572                                     Data Counter functions
    573           ===============================================================================  
    574          
    575            This subsection provides function allowing to configure and read the buffer size
    576            (number of data to be transferred). 
    577          
    578            The DMA data counter can be written only when the DMA Stream is disabled 
    579            (ie. after transfer complete event).
    580          
    581            The following function can be used to write the Stream data counter value:
    582              - void DMA_SetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx, uint16_t Counter);
    583          
    584          @note It is advised to use this function rather than DMA_Init() in situations where
    585                only the Data buffer needs to be reloaded.
    586          
    587          @note If the Source and Destination Data Sizes are different, then the value written in
    588                data counter, expressing the number of transfers, is relative to the number of 
    589                transfers from the Peripheral point of view.
    590                ie. If Memory data size is Word, Peripheral data size is Half-Words, then the value
    591                to be configured in the data counter is the number of Half-Words to be transferred
    592                from/to the peripheral.
    593          
    594            The DMA data counter can be read to indicate the number of remaining transfers for
    595            the relative DMA Stream. This counter is decremented at the end of each data 
    596            transfer and when the transfer is complete: 
    597             - If Normal mode is selected: the counter is set to 0.
    598             - If Circular mode is selected: the counter is reloaded with the initial value
    599               (configured before enabling the DMA Stream)
    600             
    601            The following function can be used to read the Stream data counter value:
    602               - uint16_t DMA_GetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx);
    603          
    604          @endverbatim
    605            * @{
    606            */
    607          
    608          /**
    609            * @brief  Writes the number of data units to be transferred on the DMAy Streamx.
    610            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    611            *          to 7 to select the DMA Stream.
    612            * @param  Counter: Number of data units to be transferred (from 0 to 65535) 
    613            *          Number of data items depends only on the Peripheral data format.
    614            *            
    615            * @note   If Peripheral data format is Bytes: number of data units is equal 
    616            *         to total number of bytes to be transferred.
    617            *           
    618            * @note   If Peripheral data format is Half-Word: number of data units is  
    619            *         equal to total number of bytes to be transferred / 2.
    620            *           
    621            * @note   If Peripheral data format is Word: number of data units is equal 
    622            *         to total  number of bytes to be transferred / 4.
    623            *      
    624            * @note   In Memory-to-Memory transfer mode, the memory buffer pointed by 
    625            *         DMAy_SxPAR register is considered as Peripheral.
    626            *      
    627            * @retval The number of remaining data units in the current DMAy Streamx transfer.
    628            */

   \                                 In section .text, align 2, keep-with-next
    629          void DMA_SetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx, uint16_t Counter)
    630          {
    631            /* Check the parameters */
    632            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    633          
    634            /* Write the number of data units to be transferred */
    635            DMAy_Streamx->NDTR = (uint16_t)Counter;
   \                     DMA_SetCurrDataCounter:
   \   00000000   0x6041             STR      R1,[R0, #+4]
    636          }
   \   00000002   0x4770             BX       LR               ;; return
    637          
    638          /**
    639            * @brief  Returns the number of remaining data units in the current DMAy Streamx transfer.
    640            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    641            *          to 7 to select the DMA Stream.
    642            * @retval The number of remaining data units in the current DMAy Streamx transfer.
    643            */

   \                                 In section .text, align 2, keep-with-next
    644          uint16_t DMA_GetCurrDataCounter(DMA_Stream_TypeDef* DMAy_Streamx)
    645          {
    646            /* Check the parameters */
    647            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    648          
    649            /* Return the number of remaining data units for DMAy Streamx */
    650            return ((uint16_t)(DMAy_Streamx->NDTR));
   \                     DMA_GetCurrDataCounter:
   \   00000000   0x6840             LDR      R0,[R0, #+4]
   \   00000002   0xB280             UXTH     R0,R0
   \   00000004   0x4770             BX       LR               ;; return
    651          }
    652          /**
    653            * @}
    654            */
    655          
    656          /** @defgroup DMA_Group3 Double Buffer mode functions
    657           *  @brief   Double Buffer mode functions 
    658           *
    659          @verbatim   
    660           ===============================================================================
    661                                   Double Buffer mode functions
    662           ===============================================================================  
    663          
    664            This subsection provides function allowing to configure and control the double 
    665            buffer mode parameters.
    666            
    667            The Double Buffer mode can be used only when Circular mode is enabled.
    668            The Double Buffer mode cannot be used when transferring data from Memory to Memory.
    669            
    670            The Double Buffer mode allows to set two different Memory addresses from/to which
    671            the DMA controller will access alternatively (after completing transfer to/from target
    672            memory 0, it will start transfer to/from target memory 1).
    673            This allows to reduce software overhead for double buffering and reduce the CPU
    674            access time.
    675          
    676            Two functions must be called before calling the DMA_Init() function:
    677             - void DMA_DoubleBufferModeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t Memory1BaseAddr,
    678                                          uint32_t DMA_CurrentMemory);
    679             - void DMA_DoubleBufferModeCmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState);
    680             
    681            DMA_DoubleBufferModeConfig() is called to configure the Memory 1 base address and the first
    682            Memory target from/to which the transfer will start after enabling the DMA Stream.
    683            Then DMA_DoubleBufferModeCmd() must be called to enable the Double Buffer mode (or disable 
    684            it when it should not be used).
    685            
    686             
    687            Two functions can be called dynamically when the transfer is ongoing (or when the DMA Stream is 
    688            stopped) to modify on of the target Memories addresses or to check wich Memory target is currently
    689             used:
    690              - void DMA_MemoryTargetConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t MemoryBaseAddr,
    691                                      uint32_t DMA_MemoryTarget);
    692              - uint32_t DMA_GetCurrentMemoryTarget(DMA_Stream_TypeDef* DMAy_Streamx);
    693          
    694            DMA_MemoryTargetConfig() can be called to modify the base address of one of the two target Memories.
    695            The Memory of which the base address will be modified must not be currently be used by the DMA Stream
    696            (ie. if the DMA Stream is currently transferring from Memory 1 then you can only modify base address
    697            of target Memory 0 and vice versa).
    698            To check this condition, it is recommended to use the function DMA_GetCurrentMemoryTarget() which
    699            returns the index of the Memory target currently in use by the DMA Stream.
    700          
    701          @endverbatim
    702            * @{
    703            */
    704            
    705          /**
    706            * @brief  Configures, when the DMAy Streamx is disabled, the double buffer mode 
    707            *         and the current memory target.
    708            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    709            *          to 7 to select the DMA Stream.
    710            * @param  Memory1BaseAddr: the base address of the second buffer (Memory 1)  
    711            * @param  DMA_CurrentMemory: specifies which memory will be first buffer for
    712            *         the transactions when the Stream will be enabled. 
    713            *          This parameter can be one of the following values:
    714            *            @arg DMA_Memory_0: Memory 0 is the current buffer.
    715            *            @arg DMA_Memory_1: Memory 1 is the current buffer.  
    716            *       
    717            * @note   Memory0BaseAddr is set by the DMA structure configuration in DMA_Init().
    718            *   
    719            * @retval None
    720            */

   \                                 In section .text, align 2, keep-with-next
    721          void DMA_DoubleBufferModeConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t Memory1BaseAddr,
    722                                          uint32_t DMA_CurrentMemory)
    723          {  
    724            /* Check the parameters */
    725            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    726            assert_param(IS_DMA_CURRENT_MEM(DMA_CurrentMemory));
    727          
    728            if (DMA_CurrentMemory != DMA_Memory_0)
   \                     DMA_DoubleBufferModeConfig:
   \   00000000   0x2A00             CMP      R2,#+0
   \   00000002   0x6802             LDR      R2,[R0, #+0]
   \   00000004   0xBF14             ITE      NE 
   \   00000006   0xF442 0x2200      ORRNE    R2,R2,#0x80000
   \   0000000A   0xF422 0x2200      BICEQ    R2,R2,#0x80000
    729            {
    730              /* Set Memory 1 as current memory address */
    731              DMAy_Streamx->CR |= (uint32_t)(DMA_SxCR_CT);    
    732            }
    733            else
    734            {
    735              /* Set Memory 0 as current memory address */
    736              DMAy_Streamx->CR &= ~(uint32_t)(DMA_SxCR_CT);    
   \   0000000E   0x6002             STR      R2,[R0, #+0]
    737            }
    738          
    739            /* Write to DMAy Streamx M1AR */
    740            DMAy_Streamx->M1AR = Memory1BaseAddr;
   \   00000010   0x6101             STR      R1,[R0, #+16]
    741          }
   \   00000012   0x4770             BX       LR               ;; return
    742          
    743          /**
    744            * @brief  Enables or disables the double buffer mode for the selected DMA stream.
    745            * @note   This function can be called only when the DMA Stream is disabled.  
    746            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    747            *          to 7 to select the DMA Stream.
    748            * @param  NewState: new state of the DMAy Streamx double buffer mode. 
    749            *          This parameter can be: ENABLE or DISABLE.
    750            * @retval None
    751            */

   \                                 In section .text, align 2, keep-with-next
    752          void DMA_DoubleBufferModeCmd(DMA_Stream_TypeDef* DMAy_Streamx, FunctionalState NewState)
    753          {  
    754            /* Check the parameters */
    755            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    756            assert_param(IS_FUNCTIONAL_STATE(NewState));
    757          
    758            /* Configure the Double Buffer mode */
    759            if (NewState != DISABLE)
   \                     DMA_DoubleBufferModeCmd:
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0xBF14             ITE      NE 
   \   00000006   0xF441 0x2180      ORRNE    R1,R1,#0x40000
   \   0000000A   0xF421 0x2180      BICEQ    R1,R1,#0x40000
    760            {
    761              /* Enable the Double buffer mode */
    762              DMAy_Streamx->CR |= (uint32_t)DMA_SxCR_DBM;
    763            }
    764            else
    765            {
    766              /* Disable the Double buffer mode */
    767              DMAy_Streamx->CR &= ~(uint32_t)DMA_SxCR_DBM;
   \   0000000E   0x6001             STR      R1,[R0, #+0]
    768            }
    769          }
   \   00000010   0x4770             BX       LR               ;; return
    770          
    771          /**
    772            * @brief  Configures the Memory address for the next buffer transfer in double
    773            *         buffer mode (for dynamic use). This function can be called when the
    774            *         DMA Stream is enabled and when the transfer is ongoing.  
    775            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    776            *          to 7 to select the DMA Stream.
    777            * @param  MemoryBaseAddr: The base address of the target memory buffer
    778            * @param  DMA_MemoryTarget: Next memory target to be used. 
    779            *         This parameter can be one of the following values:
    780            *            @arg DMA_Memory_0: To use the memory address 0
    781            *            @arg DMA_Memory_1: To use the memory address 1
    782            * 
    783            * @note    It is not allowed to modify the Base Address of a target Memory when
    784            *          this target is involved in the current transfer. ie. If the DMA Stream
    785            *          is currently transferring to/from Memory 1, then it not possible to
    786            *          modify Base address of Memory 1, but it is possible to modify Base
    787            *          address of Memory 0.
    788            *          To know which Memory is currently used, you can use the function
    789            *          DMA_GetCurrentMemoryTarget().             
    790            *  
    791            * @retval None
    792            */

   \                                 In section .text, align 2, keep-with-next
    793          void DMA_MemoryTargetConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t MemoryBaseAddr,
    794                                     uint32_t DMA_MemoryTarget)
    795          {
    796            /* Check the parameters */
    797            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    798            assert_param(IS_DMA_CURRENT_MEM(DMA_MemoryTarget));
    799              
    800            /* Check the Memory target to be configured */
    801            if (DMA_MemoryTarget != DMA_Memory_0)
   \                     DMA_MemoryTargetConfig:
   \   00000000   0xB10A             CBZ.N    R2,??DMA_MemoryTargetConfig_0
    802            {
    803              /* Write to DMAy Streamx M1AR */
    804              DMAy_Streamx->M1AR = MemoryBaseAddr;    
   \   00000002   0x6101             STR      R1,[R0, #+16]
   \   00000004   0x4770             BX       LR
    805            }  
    806            else
    807            {
    808              /* Write to DMAy Streamx M0AR */
    809              DMAy_Streamx->M0AR = MemoryBaseAddr;  
   \                     ??DMA_MemoryTargetConfig_0:
   \   00000006   0x60C1             STR      R1,[R0, #+12]
    810            }
    811          }
   \   00000008   0x4770             BX       LR               ;; return
    812          
    813          /**
    814            * @brief  Returns the current memory target used by double buffer transfer.
    815            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    816            *          to 7 to select the DMA Stream.
    817            * @retval The memory target number: 0 for Memory0 or 1 for Memory1. 
    818            */

   \                                 In section .text, align 2, keep-with-next
    819          uint32_t DMA_GetCurrentMemoryTarget(DMA_Stream_TypeDef* DMAy_Streamx)
    820          {
    821            uint32_t tmp = 0;
    822            
    823            /* Check the parameters */
    824            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    825          
    826            /* Get the current memory target */
    827            if ((DMAy_Streamx->CR & DMA_SxCR_CT) != 0)
   \                     DMA_GetCurrentMemoryTarget:
   \   00000000   0x6800             LDR      R0,[R0, #+0]
    828            {
    829              /* Current memory buffer used is Memory 1 */
    830              tmp = 1;
    831            }  
    832            else
    833            {
    834              /* Current memory buffer used is Memory 0 */
    835              tmp = 0;    
    836            }
    837            return tmp;
   \   00000002   0x0CC0             LSRS     R0,R0,#+19
   \   00000004   0x....             B.N      ?Subroutine0
    838          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000004   0x4770             BX       LR               ;; return
    839          /**
    840            * @}
    841            */
    842          
    843          /** @defgroup DMA_Group4 Interrupts and flags management functions
    844           *  @brief   Interrupts and flags management functions 
    845           *
    846          @verbatim   
    847           ===============================================================================
    848                            Interrupts and flags management functions
    849           ===============================================================================  
    850          
    851            This subsection provides functions allowing to
    852             - Check the DMA enable status
    853             - Check the FIFO status 
    854             - Configure the DMA Interrupts sources and check or clear the flags or pending bits status.   
    855             
    856           1. DMA Enable status:
    857             After configuring the DMA Stream (DMA_Init() function) and enabling the stream,
    858             it is recommended to check (or wait until) the DMA Stream is effectively enabled.
    859             A Stream may remain disabled if a configuration parameter is wrong.
    860             After disabling a DMA Stream, it is also recommended to check (or wait until) the DMA
    861             Stream is effectively disabled. If a Stream is disabled while a data transfer is ongoing, 
    862             the current data will be transferred and the Stream will be effectively disabled only after
    863             this data transfer completion.
    864             To monitor this state it is possible to use the following function:
    865               - FunctionalState DMA_GetCmdStatus(DMA_Stream_TypeDef* DMAy_Streamx); 
    866           
    867           2. FIFO Status:
    868             It is possible to monitor the FIFO status when a transfer is ongoing using the following 
    869             function:
    870               - uint32_t DMA_GetFIFOStatus(DMA_Stream_TypeDef* DMAy_Streamx); 
    871           
    872           3. DMA Interrupts and Flags:
    873            The user should identify which mode will be used in his application to manage the
    874            DMA controller events: Polling mode or Interrupt mode. 
    875              
    876            Polling Mode
    877            =============
    878              Each DMA stream can be managed through 4 event Flags:
    879              (x : DMA Stream number )
    880                 1. DMA_FLAG_FEIFx  : to indicate that a FIFO Mode Transfer Error event occurred.
    881                 2. DMA_FLAG_DMEIFx : to indicate that a Direct Mode Transfer Error event occurred.
    882                 3. DMA_FLAG_TEIFx  : to indicate that a Transfer Error event occurred.
    883                 4. DMA_FLAG_HTIFx  : to indicate that a Half-Transfer Complete event occurred.
    884                 5. DMA_FLAG_TCIFx  : to indicate that a Transfer Complete event occurred .       
    885          
    886             In this Mode it is advised to use the following functions:
    887                - FlagStatus DMA_GetFlagStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG);
    888                - void DMA_ClearFlag(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG);
    889          
    890            Interrupt Mode
    891            ===============
    892              Each DMA Stream can be managed through 4 Interrupts:
    893          
    894              Interrupt Source
    895              ----------------
    896                 1. DMA_IT_FEIFx  : specifies the interrupt source for the  FIFO Mode Transfer Error event.
    897                 2. DMA_IT_DMEIFx : specifies the interrupt source for the Direct Mode Transfer Error event.
    898                 3. DMA_IT_TEIFx  : specifies the interrupt source for the Transfer Error event.
    899                 4. DMA_IT_HTIFx  : specifies the interrupt source for the Half-Transfer Complete event.
    900                 5. DMA_IT_TCIFx  : specifies the interrupt source for the a Transfer Complete event. 
    901               
    902            In this Mode it is advised to use the following functions:
    903               - void DMA_ITConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT, FunctionalState NewState);
    904               - ITStatus DMA_GetITStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT);
    905               - void DMA_ClearITPendingBit(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT);
    906          
    907          @endverbatim
    908            * @{
    909            */
    910          
    911          /**
    912            * @brief  Returns the status of EN bit for the specified DMAy Streamx.
    913            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    914            *          to 7 to select the DMA Stream.
    915            *   
    916            * @note    After configuring the DMA Stream (DMA_Init() function) and enabling
    917            *          the stream, it is recommended to check (or wait until) the DMA Stream
    918            *          is effectively enabled. A Stream may remain disabled if a configuration
    919            *          parameter is wrong.
    920            *          After disabling a DMA Stream, it is also recommended to check (or wait 
    921            *          until) the DMA Stream is effectively disabled. If a Stream is disabled
    922            *          while a data transfer is ongoing, the current data will be transferred
    923            *          and the Stream will be effectively disabled only after the transfer
    924            *          of this single data is finished.  
    925            *      
    926            * @retval Current state of the DMAy Streamx (ENABLE or DISABLE).
    927            */

   \                                 In section .text, align 2, keep-with-next
    928          FunctionalState DMA_GetCmdStatus(DMA_Stream_TypeDef* DMAy_Streamx)
    929          {
    930            FunctionalState state = DISABLE;
    931          
    932            /* Check the parameters */
    933            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    934          
    935            if ((DMAy_Streamx->CR & (uint32_t)DMA_SxCR_EN) != 0)
   \                     DMA_GetCmdStatus:
   \   00000000   0x6800             LDR      R0,[R0, #+0]
    936            {
    937              /* The selected DMAy Streamx EN bit is set (DMA is still transferring) */
    938              state = ENABLE;
    939            }
    940            else
    941            {
    942              /* The selected DMAy Streamx EN bit is cleared (DMA is disabled and 
    943                  all transfers are complete) */
    944              state = DISABLE;
    945            }
    946            return state;
   \   00000002                      REQUIRE ?Subroutine0
   \   00000002                      ;; // Fall through to label ?Subroutine0
    947          }
    948          
    949          /**
    950            * @brief  Returns the current DMAy Streamx FIFO filled level.
    951            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0 
    952            *         to 7 to select the DMA Stream.
    953            * @retval The FIFO filling state.
    954            *           - DMA_FIFOStatus_Less1QuarterFull: when FIFO is less than 1 quarter-full 
    955            *                                               and not empty.
    956            *           - DMA_FIFOStatus_1QuarterFull: if more than 1 quarter-full.
    957            *           - DMA_FIFOStatus_HalfFull: if more than 1 half-full.
    958            *           - DMA_FIFOStatus_3QuartersFull: if more than 3 quarters-full.
    959            *           - DMA_FIFOStatus_Empty: when FIFO is empty
    960            *           - DMA_FIFOStatus_Full: when FIFO is full
    961            */

   \                                 In section .text, align 2, keep-with-next
    962          uint32_t DMA_GetFIFOStatus(DMA_Stream_TypeDef* DMAy_Streamx)
    963          {
    964            uint32_t tmpreg = 0;
    965           
    966            /* Check the parameters */
    967            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    968            
    969            /* Get the FIFO level bits */
    970            tmpreg = (uint32_t)((DMAy_Streamx->FCR & DMA_SxFCR_FS));
   \                     DMA_GetFIFOStatus:
   \   00000000   0x6940             LDR      R0,[R0, #+20]
    971            
    972            return tmpreg;
   \   00000002   0xF000 0x0038      AND      R0,R0,#0x38
   \   00000006   0x4770             BX       LR               ;; return
    973          }
    974          
    975          /**
    976            * @brief  Checks whether the specified DMAy Streamx flag is set or not.
    977            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
    978            *          to 7 to select the DMA Stream.
    979            * @param  DMA_FLAG: specifies the flag to check.
    980            *          This parameter can be one of the following values:
    981            *            @arg DMA_FLAG_TCIFx:  Streamx transfer complete flag
    982            *            @arg DMA_FLAG_HTIFx:  Streamx half transfer complete flag
    983            *            @arg DMA_FLAG_TEIFx:  Streamx transfer error flag
    984            *            @arg DMA_FLAG_DMEIFx: Streamx direct mode error flag
    985            *            @arg DMA_FLAG_FEIFx:  Streamx FIFO error flag
    986            *         Where x can be 0 to 7 to select the DMA Stream.
    987            * @retval The new state of DMA_FLAG (SET or RESET).
    988            */

   \                                 In section .text, align 2, keep-with-next
    989          FlagStatus DMA_GetFlagStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
    990          {
    991            FlagStatus bitstatus = RESET;
   \                     DMA_GetFlagStatus:
   \   00000000   0x2200             MOVS     R2,#+0
    992            DMA_TypeDef* DMAy;
    993            uint32_t tmpreg = 0;
    994          
    995            /* Check the parameters */
    996            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
    997            assert_param(IS_DMA_GET_FLAG(DMA_FLAG));
    998          
    999            /* Determine the DMA to which belongs the stream */
   1000            if (DMAy_Streamx < DMA2_Stream0)
   \   00000002   0x....             LDR.N    R3,??DataTable5_12  ;; 0x40026410
   \   00000004   0x4298             CMP      R0,R3
   \   00000006   0xBF34             ITE      CC 
   \   00000008   0x....             LDRCC.N  R0,??DataTable5_22  ;; 0x40026000
   \   0000000A   0x....             LDRCS.N  R0,??DataTable5_23  ;; 0x40026400
   1001            {
   1002              /* DMAy_Streamx belongs to DMA1 */
   1003              DMAy = DMA1; 
   1004            } 
   1005            else 
   1006            {
   1007              /* DMAy_Streamx belongs to DMA2 */
   1008              DMAy = DMA2; 
   1009            }
   1010          
   1011            /* Check if the flag is in HISR or LISR */
   1012            if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
   \   0000000C   0x008B             LSLS     R3,R1,#+2
   \   0000000E   0xBF4C             ITE      MI 
   \   00000010   0x6840             LDRMI    R0,[R0, #+4]
   \   00000012   0x6800             LDRPL    R0,[R0, #+0]
   1013            {
   1014              /* Get DMAy HISR register value */
   1015              tmpreg = DMAy->HISR;
   1016            }
   1017            else
   1018            {
   1019              /* Get DMAy LISR register value */
   1020              tmpreg = DMAy->LISR;
   1021            }   
   1022           
   1023            /* Mask the reserved bits */
   1024            tmpreg &= (uint32_t)RESERVED_MASK;
   1025          
   1026            /* Check the status of the specified DMA flag */
   1027            if ((tmpreg & DMA_FLAG) != (uint32_t)RESET)
   \   00000014   0x4008             ANDS     R0,R1,R0
   \   00000016   0x....             LDR.N    R1,??DataTable5_24  ;; 0xf7d0f7d
   \   00000018   0x4208             TST      R0,R1
   \   0000001A   0xBF18             IT       NE 
   \   0000001C   0x2201             MOVNE    R2,#+1
   1028            {
   1029              /* DMA_FLAG is set */
   1030              bitstatus = SET;
   1031            }
   1032            else
   1033            {
   1034              /* DMA_FLAG is reset */
   1035              bitstatus = RESET;
   1036            }
   1037          
   1038            /* Return the DMA_FLAG status */
   1039            return  bitstatus;
   \   0000001E   0x4610             MOV      R0,R2
   \   00000020   0x4770             BX       LR               ;; return
   1040          }
   1041          
   1042          /**
   1043            * @brief  Clears the DMAy Streamx's pending flags.
   1044            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
   1045            *          to 7 to select the DMA Stream.
   1046            * @param  DMA_FLAG: specifies the flag to clear.
   1047            *          This parameter can be any combination of the following values:
   1048            *            @arg DMA_FLAG_TCIFx:  Streamx transfer complete flag
   1049            *            @arg DMA_FLAG_HTIFx:  Streamx half transfer complete flag
   1050            *            @arg DMA_FLAG_TEIFx:  Streamx transfer error flag
   1051            *            @arg DMA_FLAG_DMEIFx: Streamx direct mode error flag
   1052            *            @arg DMA_FLAG_FEIFx:  Streamx FIFO error flag
   1053            *         Where x can be 0 to 7 to select the DMA Stream.   
   1054            * @retval None
   1055            */

   \                                 In section .text, align 2, keep-with-next
   1056          void DMA_ClearFlag(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_FLAG)
   1057          {
   1058            DMA_TypeDef* DMAy;
   1059          
   1060            /* Check the parameters */
   1061            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   1062            assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));
   1063          
   1064            /* Determine the DMA to which belongs the stream */
   1065            if (DMAy_Streamx < DMA2_Stream0)
   \                     DMA_ClearFlag:
   \   00000000   0x....             LDR.N    R2,??DataTable5_12  ;; 0x40026410
   \   00000002   0x4290             CMP      R0,R2
   \   00000004   0xBF34             ITE      CC 
   \   00000006   0x....             LDRCC.N  R0,??DataTable5_22  ;; 0x40026000
   \   00000008   0x....             LDRCS.N  R0,??DataTable5_23  ;; 0x40026400
   1066            {
   1067              /* DMAy_Streamx belongs to DMA1 */
   1068              DMAy = DMA1; 
   1069            } 
   1070            else 
   1071            {
   1072              /* DMAy_Streamx belongs to DMA2 */
   1073              DMAy = DMA2; 
   \   0000000A   0x....             LDR.N    R2,??DataTable5_24  ;; 0xf7d0f7d
   \   0000000C   0x400A             ANDS     R2,R2,R1
   \   0000000E   0x0089             LSLS     R1,R1,#+2
   \   00000010   0xD501             BPL.N    ??DMA_ClearFlag_0
   1074            }
   1075          
   1076            /* Check if LIFCR or HIFCR register is targeted */
   1077            if ((DMA_FLAG & HIGH_ISR_MASK) != (uint32_t)RESET)
   1078            {
   1079              /* Set DMAy HIFCR register clear flag bits */
   1080              DMAy->HIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
   \   00000012   0x60C2             STR      R2,[R0, #+12]
   \   00000014   0x4770             BX       LR
   1081            }
   1082            else 
   1083            {
   1084              /* Set DMAy LIFCR register clear flag bits */
   1085              DMAy->LIFCR = (uint32_t)(DMA_FLAG & RESERVED_MASK);
   \                     ??DMA_ClearFlag_0:
   \   00000016   0x6082             STR      R2,[R0, #+8]
   1086            }    
   1087          }
   \   00000018   0x4770             BX       LR               ;; return
   1088          
   1089          /**
   1090            * @brief  Enables or disables the specified DMAy Streamx interrupts.
   1091            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
   1092            *          to 7 to select the DMA Stream.
   1093            * @param DMA_IT: specifies the DMA interrupt sources to be enabled or disabled. 
   1094            *          This parameter can be any combination of the following values:
   1095            *            @arg DMA_IT_TC:  Transfer complete interrupt mask
   1096            *            @arg DMA_IT_HT:  Half transfer complete interrupt mask
   1097            *            @arg DMA_IT_TE:  Transfer error interrupt mask
   1098            *            @arg DMA_IT_FE:  FIFO error interrupt mask
   1099            * @param  NewState: new state of the specified DMA interrupts.
   1100            *          This parameter can be: ENABLE or DISABLE.
   1101            * @retval None
   1102            */

   \                                 In section .text, align 2, keep-with-next
   1103          void DMA_ITConfig(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT, FunctionalState NewState)
   1104          {
   1105            /* Check the parameters */
   1106            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   1107            assert_param(IS_DMA_CONFIG_IT(DMA_IT));
   1108            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1109          
   1110            /* Check if the DMA_IT parameter contains a FIFO interrupt */
   1111            if ((DMA_IT & DMA_IT_FE) != 0)
   \                     DMA_ITConfig:
   \   00000000   0x060B             LSLS     R3,R1,#+24
   \   00000002   0xD507             BPL.N    ??DMA_ITConfig_0
   1112            {
   1113              if (NewState != DISABLE)
   \   00000004   0x2A00             CMP      R2,#+0
   \   00000006   0x6943             LDR      R3,[R0, #+20]
   \   00000008   0xBF14             ITE      NE 
   \   0000000A   0xF043 0x0380      ORRNE    R3,R3,#0x80
   \   0000000E   0xF023 0x0380      BICEQ    R3,R3,#0x80
   1114              {
   1115                /* Enable the selected DMA FIFO interrupts */
   1116                DMAy_Streamx->FCR |= (uint32_t)DMA_IT_FE;
   1117              }    
   1118              else 
   1119              {
   1120                /* Disable the selected DMA FIFO interrupts */
   1121                DMAy_Streamx->FCR &= ~(uint32_t)DMA_IT_FE;  
   \   00000012   0x6143             STR      R3,[R0, #+20]
   1122              }
   1123            }
   1124          
   1125            /* Check if the DMA_IT parameter contains a Transfer interrupt */
   1126            if (DMA_IT != DMA_IT_FE)
   \                     ??DMA_ITConfig_0:
   \   00000014   0x2980             CMP      R1,#+128
   \   00000016   0xD008             BEQ.N    ??DMA_ITConfig_1
   1127            {
   1128              if (NewState != DISABLE)
   \   00000018   0xF001 0x011E      AND      R1,R1,#0x1E
   \   0000001C   0x2A00             CMP      R2,#+0
   \   0000001E   0x6802             LDR      R2,[R0, #+0]
   \   00000020   0xBF14             ITE      NE 
   \   00000022   0x4311             ORRNE    R1,R1,R2
   \   00000024   0xEA22 0x0101      BICEQ    R1,R2,R1
   1129              {
   1130                /* Enable the selected DMA transfer interrupts */
   1131                DMAy_Streamx->CR |= (uint32_t)(DMA_IT  & TRANSFER_IT_ENABLE_MASK);
   1132              }
   1133              else
   1134              {
   1135                /* Disable the selected DMA transfer interrupts */
   1136                DMAy_Streamx->CR &= ~(uint32_t)(DMA_IT & TRANSFER_IT_ENABLE_MASK);
   \   00000028   0x6001             STR      R1,[R0, #+0]
   1137              }    
   1138            }
   1139          }
   \                     ??DMA_ITConfig_1:
   \   0000002A   0x4770             BX       LR               ;; return
   1140          
   1141          /**
   1142            * @brief  Checks whether the specified DMAy Streamx interrupt has occurred or not.
   1143            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
   1144            *          to 7 to select the DMA Stream.
   1145            * @param  DMA_IT: specifies the DMA interrupt source to check.
   1146            *          This parameter can be one of the following values:
   1147            *            @arg DMA_IT_TCIFx:  Streamx transfer complete interrupt
   1148            *            @arg DMA_IT_HTIFx:  Streamx half transfer complete interrupt
   1149            *            @arg DMA_IT_TEIFx:  Streamx transfer error interrupt
   1150            *            @arg DMA_IT_DMEIFx: Streamx direct mode error interrupt
   1151            *            @arg DMA_IT_FEIFx:  Streamx FIFO error interrupt
   1152            *         Where x can be 0 to 7 to select the DMA Stream.
   1153            * @retval The new state of DMA_IT (SET or RESET).
   1154            */

   \                                 In section .text, align 2, keep-with-next
   1155          ITStatus DMA_GetITStatus(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
   1156          {
   1157            ITStatus bitstatus = RESET;
   \                     DMA_GetITStatus:
   \   00000000   0x2200             MOVS     R2,#+0
   1158            DMA_TypeDef* DMAy;
   1159            uint32_t tmpreg = 0, enablestatus = 0;
   1160          
   1161            /* Check the parameters */
   1162            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   1163            assert_param(IS_DMA_GET_IT(DMA_IT));
   1164           
   1165            /* Determine the DMA to which belongs the stream */
   1166            if (DMAy_Streamx < DMA2_Stream0)
   \   00000002   0x....             LDR.N    R3,??DataTable5_12  ;; 0x40026410
   \   00000004   0x4298             CMP      R0,R3
   \   00000006   0xBF34             ITE      CC 
   \   00000008   0x....             LDRCC.N  R3,??DataTable5_22  ;; 0x40026000
   \   0000000A   0x....             LDRCS.N  R3,??DataTable5_23  ;; 0x40026400
   1167            {
   1168              /* DMAy_Streamx belongs to DMA1 */
   1169              DMAy = DMA1; 
   1170            } 
   1171            else 
   1172            {
   1173              /* DMAy_Streamx belongs to DMA2 */
   1174              DMAy = DMA2; 
   1175            }
   1176          
   1177            /* Check if the interrupt enable bit is in the CR or FCR register */
   1178            if ((DMA_IT & TRANSFER_IT_MASK) != (uint32_t)RESET)
   \   0000000C   0x.... 0x....      LDR.W    R12,??DataTable5_25  ;; 0xf3c0f3c
   \   00000010   0xEA11 0x0F0C      TST      R1,R12
   \   00000014   0xBF1E             ITTT     NE 
   \   00000016   0x6800             LDRNE    R0,[R0, #+0]
   \   00000018   0xEA00 0x20D1      ANDNE    R0,R0,R1, LSR #+11
   \   0000001C   0xF000 0x001E      ANDNE    R0,R0,#0x1E
   1179            {
   1180              /* Get the interrupt enable position mask in CR register */
   1181              tmpreg = (uint32_t)((DMA_IT >> 11) & TRANSFER_IT_ENABLE_MASK);   
   1182              
   1183              /* Check the enable bit in CR register */
   1184              enablestatus = (uint32_t)(DMAy_Streamx->CR & tmpreg);
   \   00000020   0xBF04             ITT      EQ 
   \   00000022   0x6940             LDREQ    R0,[R0, #+20]
   \   00000024   0xF000 0x0080      ANDEQ    R0,R0,#0x80
   1185            }
   1186            else 
   1187            {
   1188              /* Check the enable bit in FCR register */
   1189              enablestatus = (uint32_t)(DMAy_Streamx->FCR & DMA_IT_FE); 
   1190            }
   1191           
   1192            /* Check if the interrupt pending flag is in LISR or HISR */
   1193            if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
   \   00000028   0xEA5F 0x0C81      LSLS     R12,R1,#+2
   \   0000002C   0xBF4C             ITE      MI 
   \   0000002E   0x685B             LDRMI    R3,[R3, #+4]
   \   00000030   0x681B             LDRPL    R3,[R3, #+0]
   1194            {
   1195              /* Get DMAy HISR register value */
   1196              tmpreg = DMAy->HISR ;
   1197            }
   1198            else
   1199            {
   1200              /* Get DMAy LISR register value */
   1201              tmpreg = DMAy->LISR ;
   1202            } 
   1203          
   1204            /* mask all reserved bits */
   1205            tmpreg &= (uint32_t)RESERVED_MASK;
   1206          
   1207            /* Check the status of the specified DMA interrupt */
   1208            if (((tmpreg & DMA_IT) != (uint32_t)RESET) && (enablestatus != (uint32_t)RESET))
   \   00000032   0x4019             ANDS     R1,R1,R3
   \   00000034   0x....             LDR.N    R3,??DataTable5_24  ;; 0xf7d0f7d
   \   00000036   0x4219             TST      R1,R3
   \   00000038   0xBF1C             ITT      NE 
   \   0000003A   0x2800             CMPNE    R0,#+0
   \   0000003C   0x2201             MOVNE    R2,#+1
   1209            {
   1210              /* DMA_IT is set */
   1211              bitstatus = SET;
   1212            }
   1213            else
   1214            {
   1215              /* DMA_IT is reset */
   1216              bitstatus = RESET;
   1217            }
   1218          
   1219            /* Return the DMA_IT status */
   1220            return  bitstatus;
   \   0000003E   0x4610             MOV      R0,R2
   \   00000040   0x4770             BX       LR               ;; return
   1221          }
   1222          
   1223          /**
   1224            * @brief  Clears the DMAy Streamx's interrupt pending bits.
   1225            * @param  DMAy_Streamx: where y can be 1 or 2 to select the DMA and x can be 0
   1226            *          to 7 to select the DMA Stream.
   1227            * @param  DMA_IT: specifies the DMA interrupt pending bit to clear.
   1228            *          This parameter can be any combination of the following values:
   1229            *            @arg DMA_IT_TCIFx:  Streamx transfer complete interrupt
   1230            *            @arg DMA_IT_HTIFx:  Streamx half transfer complete interrupt
   1231            *            @arg DMA_IT_TEIFx:  Streamx transfer error interrupt
   1232            *            @arg DMA_IT_DMEIFx: Streamx direct mode error interrupt
   1233            *            @arg DMA_IT_FEIFx:  Streamx FIFO error interrupt
   1234            *         Where x can be 0 to 7 to select the DMA Stream.
   1235            * @retval None
   1236            */

   \                                 In section .text, align 2, keep-with-next
   1237          void DMA_ClearITPendingBit(DMA_Stream_TypeDef* DMAy_Streamx, uint32_t DMA_IT)
   1238          {
   1239            DMA_TypeDef* DMAy;
   1240          
   1241            /* Check the parameters */
   1242            assert_param(IS_DMA_ALL_PERIPH(DMAy_Streamx));
   1243            assert_param(IS_DMA_CLEAR_IT(DMA_IT));
   1244          
   1245            /* Determine the DMA to which belongs the stream */
   1246            if (DMAy_Streamx < DMA2_Stream0)
   \                     DMA_ClearITPendingBit:
   \   00000000   0x....             LDR.N    R2,??DataTable5_12  ;; 0x40026410
   \   00000002   0x4290             CMP      R0,R2
   \   00000004   0xBF34             ITE      CC 
   \   00000006   0x....             LDRCC.N  R0,??DataTable5_22  ;; 0x40026000
   \   00000008   0x....             LDRCS.N  R0,??DataTable5_23  ;; 0x40026400
   1247            {
   1248              /* DMAy_Streamx belongs to DMA1 */
   1249              DMAy = DMA1; 
   1250            } 
   1251            else 
   1252            {
   1253              /* DMAy_Streamx belongs to DMA2 */
   1254              DMAy = DMA2; 
   \   0000000A   0x....             LDR.N    R2,??DataTable5_24  ;; 0xf7d0f7d
   \   0000000C   0x400A             ANDS     R2,R2,R1
   \   0000000E   0x0089             LSLS     R1,R1,#+2
   \   00000010   0xD501             BPL.N    ??DMA_ClearITPendingBit_0
   1255            }
   1256          
   1257            /* Check if LIFCR or HIFCR register is targeted */
   1258            if ((DMA_IT & HIGH_ISR_MASK) != (uint32_t)RESET)
   1259            {
   1260              /* Set DMAy HIFCR register clear interrupt bits */
   1261              DMAy->HIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
   \   00000012   0x60C2             STR      R2,[R0, #+12]
   \   00000014   0x4770             BX       LR
   1262            }
   1263            else 
   1264            {
   1265              /* Set DMAy LIFCR register clear interrupt bits */
   1266              DMAy->LIFCR = (uint32_t)(DMA_IT & RESERVED_MASK);
   \                     ??DMA_ClearITPendingBit_0:
   \   00000016   0x6082             STR      R2,[R0, #+8]
   1267            }   
   1268          }
   \   00000018   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x40026010         DC32     0x40026010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0x40026008         DC32     0x40026008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x40026028         DC32     0x40026028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x40026040         DC32     0x40026040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x40026058         DC32     0x40026058

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x40026070         DC32     0x40026070

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x2000003D         DC32     0x2000003d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x40026088         DC32     0x40026088

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x20000F40         DC32     0x20000f40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x400260A0         DC32     0x400260a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x203D0000         DC32     0x203d0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x400260B8         DC32     0x400260b8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_12:
   \   00000000   0x40026410         DC32     0x40026410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_13:
   \   00000000   0x40026408         DC32     0x40026408

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_14:
   \   00000000   0x40026428         DC32     0x40026428

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_15:
   \   00000000   0x40026440         DC32     0x40026440

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_16:
   \   00000000   0x40026458         DC32     0x40026458

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_17:
   \   00000000   0x40026470         DC32     0x40026470

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_18:
   \   00000000   0x40026488         DC32     0x40026488

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_19:
   \   00000000   0x400264A0         DC32     0x400264a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_20:
   \   00000000   0x400264B8         DC32     0x400264b8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_21:
   \   00000000   0xF01C803F         DC32     0xf01c803f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_22:
   \   00000000   0x40026000         DC32     0x40026000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_23:
   \   00000000   0x40026400         DC32     0x40026400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_24:
   \   00000000   0x0F7D0F7D         DC32     0xf7d0f7d

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_25:
   \   00000000   0x0F3C0F3C         DC32     0xf3c0f3c
   1269          
   1270          /**
   1271            * @}
   1272            */
   1273          
   1274          /**
   1275            * @}
   1276            */
   1277          
   1278          /**
   1279            * @}
   1280            */
   1281          
   1282          /**
   1283            * @}
   1284            */
   1285          
   1286          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  DMA_ClearFlag
        0  DMA_ClearITPendingBit
        0  DMA_Cmd
        0  DMA_DeInit
        0  DMA_DoubleBufferModeCmd
        0  DMA_DoubleBufferModeConfig
        0  DMA_FlowControllerConfig
        0  DMA_GetCmdStatus
        0  DMA_GetCurrDataCounter
        0  DMA_GetCurrentMemoryTarget
        0  DMA_GetFIFOStatus
        0  DMA_GetFlagStatus
        0  DMA_GetITStatus
        0  DMA_ITConfig
        0  DMA_Init
        0  DMA_MemoryTargetConfig
        0  DMA_PeriphIncOffsetSizeConfig
        0  DMA_SetCurrDataCounter
        0  DMA_StructInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_15
       4  ??DataTable5_16
       4  ??DataTable5_17
       4  ??DataTable5_18
       4  ??DataTable5_19
       4  ??DataTable5_2
       4  ??DataTable5_20
       4  ??DataTable5_21
       4  ??DataTable5_22
       4  ??DataTable5_23
       4  ??DataTable5_24
       4  ??DataTable5_25
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
       6  ?Subroutine0
      26  DMA_ClearFlag
      26  DMA_ClearITPendingBit
      18  DMA_Cmd
     228  DMA_DeInit
      18  DMA_DoubleBufferModeCmd
      20  DMA_DoubleBufferModeConfig
      18  DMA_FlowControllerConfig
       2  DMA_GetCmdStatus
       6  DMA_GetCurrDataCounter
       6  DMA_GetCurrentMemoryTarget
       8  DMA_GetFIFOStatus
      34  DMA_GetFlagStatus
      66  DMA_GetITStatus
      44  DMA_ITConfig
      82  DMA_Init
      10  DMA_MemoryTargetConfig
      18  DMA_PeriphIncOffsetSizeConfig
       4  DMA_SetCurrDataCounter
      34  DMA_StructInit

 
 778 bytes in section .text
 
 778 bytes of CODE memory

Errors: none
Warnings: none

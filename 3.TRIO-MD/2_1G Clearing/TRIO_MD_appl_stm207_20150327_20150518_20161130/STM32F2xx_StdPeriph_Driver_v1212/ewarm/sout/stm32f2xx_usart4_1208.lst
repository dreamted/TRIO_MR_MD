###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     16/Sep/2014  12:22:24 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140916\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\src\stm32f2xx_usart4_1208 #
#                    .c                                                       #
#    Command line =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140916\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\src\stm32f2xx_usart4_1208 #
#                    .c -D NDEBUG -lC D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_s #
#                    tm207_20140916\STM32F2xx_StdPeriph_Driver_v1212\ewarm\so #
#                    ut\ -o D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_2014 #
#                    0916\STM32F2xx_StdPeriph_Driver_v1212\ewarm\sout\        #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.0\arm\INC\c\DLib_Config_Normal.h" -I         #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140916\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\..\ -I              #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140916\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\..\inc\ -I          #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140916\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\..\..\uC-CPU\ -I    #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140916\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\..\..\uC-LIB\ -I    #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140916\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\..\..\uCOS-II\Ports #
#                    \ -I D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_201409 #
#                    16\STM32F2xx_StdPeriph_Driver_v1212\ewarm\..\..\uCOS-II\ #
#                    Source\ -Oh                                              #
#    List file    =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140916\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\sout\stm32f2xx_usar #
#                    t4_1208.lst                                              #
#    Object file  =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140916\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\sout\stm32f2xx_usar #
#                    t4_1208.o                                                #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140916\STM32F2xx_StdPeriph_Driver_v1212\src\stm32f2xx_usart4_1208.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_usart.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    18-April-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Universal synchronous asynchronous receiver
      9            *          transmitter (USART):           
     10            *           - Initialization and Configuration
     11            *           - Data transfers
     12            *           - Multi-Processor Communication
     13            *           - LIN mode
     14            *           - Half-duplex mode
     15            *           - Smartcard mode
     16            *           - IrDA mode
     17            *           - DMA transfers management
     18            *           - Interrupts and flags management 
     19            *           
     20            *  @verbatim
     21            *      
     22            *          ===================================================================
     23            *                                 How to use this driver
     24            *          ===================================================================
     25            *          1. Enable peripheral clock using the follwoing functions
     26            *             RCC_APB2PeriphClockCmd(RCC_APB2Periph_USARTx, ENABLE) for USART1 and USART6 
     27            *             RCC_APB1PeriphClockCmd(RCC_APB1Periph_USARTx, ENABLE) for USART2, USART3, UART4 or UART5.
     28            *
     29            *          2.  According to the USART mode, enable the GPIO clocks using 
     30            *              RCC_AHB1PeriphClockCmd() function. (The I/O can be TX, RX, CTS, 
     31            *              or/and SCLK). 
     32            *
     33            *          3. Peripheral's alternate function: 
     34            *                 - Connect the pin to the desired peripherals' Alternate 
     35            *                   Function (AF) using GPIO_PinAFConfig() function
     36            *                 - Configure the desired pin in alternate function by:
     37            *                   GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     38            *                 - Select the type, pull-up/pull-down and output speed via 
     39            *                   GPIO_PuPd, GPIO_OType and GPIO_Speed members
     40            *                 - Call GPIO_Init() function
     41            *        
     42            *          4. Program the Baud Rate, Word Length , Stop Bit, Parity, Hardware 
     43            *             flow control and Mode(Receiver/Transmitter) using the USART_Init()
     44            *             function.
     45            *
     46            *          5. For synchronous mode, enable the clock and program the polarity,
     47            *             phase and last bit using the USART_ClockInit() function.
     48            *
     49            *          5. Enable the NVIC and the corresponding interrupt using the function 
     50            *             USART_ITConfig() if you need to use interrupt mode. 
     51            *
     52            *          6. When using the DMA mode 
     53            *                   - Configure the DMA using DMA_Init() function
     54            *                   - Active the needed channel Request using USART_DMACmd() function
     55            * 
     56            *          7. Enable the USART using the USART_Cmd() function.
     57            * 
     58            *          8. Enable the DMA using the DMA_Cmd() function, when using DMA mode. 
     59            *
     60            *          Refer to Multi-Processor, LIN, half-duplex, Smartcard, IrDA sub-sections
     61            *          for more details
     62            *          
     63            *          In order to reach higher communication baudrates, it is possible to
     64            *          enable the oversampling by 8 mode using the function USART_OverSampling8Cmd().
     65            *          This function should be called after enabling the USART clock (RCC_APBxPeriphClockCmd())
     66            *          and before calling the function USART_Init().
     67            *          
     68            *  @endverbatim
     69            *        
     70            ******************************************************************************
     71            * @attention
     72            *
     73            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     74            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     75            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     76            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     77            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     78            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     79            *
     80            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     81            ******************************************************************************  
     82            */ 
     83          
     84          /* Includes ------------------------------------------------------------------*/
     85          #include "stm32f2xx_usart4_1208.h"
     86          
     87          /** @addtogroup STM32F2xx_StdPeriph_Driver
     88            * @{
     89            */
     90          
     91          /** @defgroup USART 
     92            * @brief USART driver modules
     93            * @{
     94            */
     95          
     96          /* Private typedef -----------------------------------------------------------*/
     97          /* Private define ------------------------------------------------------------*/
     98          
     99          
    100          /* Private macro -------------------------------------------------------------*/
    101          /* Private variables ---------------------------------------------------------*/
    102          #if !defined (OS_INCLUDED) 
    103          	INT8U Rx4Buff[Rx4BuffLen];
    104          	INT8U Tx4Buff[Tx4BuffLen];
    105          
    106          	INT16U	Rx4RdCnt = 0, Rx4WrCnt = 0;
    107          	INT16U	Tx4RdCnt = 0, Tx4WrCnt = 0;
    108          #else

   \                                 In section iram, align 4
    109          	INT8U Rx4Buff[Rx4BuffLen] @ "iram";
   \                     Rx4Buff:
   \   00000000                      DS8 5120

   \                                 In section iram, align 4
    110          	INT8U Tx4Buff[Tx4BuffLen] @ "iram";
   \                     Tx4Buff:
   \   00000000                      DS8 5120
    111          

   \                                 In section iram, align 4
    112          	INT16U	Rx4RdCnt @ "iram"= 0, Rx4WrCnt @ "iram" = 0;
   \                     Rx4RdCnt:
   \   00000000   0x0000             DC16 0
   \                     Rx4WrCnt:
   \   00000002   0x0000             DC16 0
    113          	INT16U	Tx4RdCnt @ "iram"= 0, Tx4WrCnt @ "iram" = 0;
   \                     Tx4RdCnt:
   \   00000004   0x0000             DC16 0
   \                     Tx4WrCnt:
   \   00000006   0x0000             DC16 0
    114          #endif
    115          
    116          #if !defined (OS_INCLUDED) 
    117          __SerStrPtr pUSART4 = {
    118          
    119          #else
    120          __SerStrPtr pUSART4 @ "iram" = {
   \                     pUSART4:
   \   00000008   0x........         DC32 InitUSART4, USART4CheckByte, USART4RxGetByte, USART4PutStr
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000018   0x........         DC32 USART4Printf, USART4PutChar, USART4PutToBuffer, USART4TxCheckByte
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000028   0x........         DC32 USART4BuffClear, USART4TxClear
   \              0x........   
   \   00000030   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    121          #endif
    122          	InitUSART4,
    123          	USART4CheckByte,
    124          	USART4RxGetByte,
    125          	USART4PutStr,
    126          	USART4Printf,
    127          	USART4PutChar,
    128          	USART4PutToBuffer,
    129          	USART4TxCheckByte,
    130          	USART4BuffClear,
    131          	USART4TxClear
    132          };
    133          /* Private function prototypes -----------------------------------------------*/
    134          /* Private functions ---------------------------------------------------------*/
    135          
    136          /** @defgroup USART_Private_Functions
    137            * @{
    138            */
    139          
    140          /** @defgroup USART_Group1 Initialization and Configuration functions
    141           *  @brief   Initialization and Configuration functions 
    142           *
    143          @verbatim   
    144           ===============================================================================
    145                            Initialization and Configuration functions
    146           ===============================================================================  
    147          
    148            This subsection provides a set of functions allowing to initialize the USART 
    149            in asynchronous and in synchronous modes.
    150             - For the asynchronous mode only these parameters can be configured: 
    151                  - Baud Rate
    152                  - Word Length 
    153                  - Stop Bit
    154                  - Parity: If the parity is enabled, then the MSB bit of the data written
    155                    in the data register is transmitted but is changed by the parity bit.
    156                    Depending on the frame length defined by the M bit (8-bits or 9-bits),
    157                    the possible USART frame formats are as listed in the following table:
    158             +-------------------------------------------------------------+     
    159             |   M bit |  PCE bit  |            USART frame                |
    160             |---------------------|---------------------------------------|             
    161             |    0    |    0      |    | SB | 8 bit data | STB |          |
    162             |---------|-----------|---------------------------------------|  
    163             |    0    |    1      |    | SB | 7 bit data | PB | STB |     |
    164             |---------|-----------|---------------------------------------|  
    165             |    1    |    0      |    | SB | 9 bit data | STB |          |
    166             |---------|-----------|---------------------------------------|  
    167             |    1    |    1      |    | SB | 8 bit data | PB | STB |     |
    168             +-------------------------------------------------------------+            
    169                  - Hardware flow control
    170                  - Receiver/transmitter modes
    171          
    172            The USART_Init() function follows the USART  asynchronous configuration procedure
    173            (details for the procedure are available in reference manual (RM0033)).
    174          
    175            - For the synchronous mode in addition to the asynchronous mode parameters these 
    176              parameters should be also configured:
    177                  - USART Clock Enabled
    178                  - USART polarity
    179                  - USART phase
    180                  - USART LastBit
    181            
    182            These parameters can be configured using the USART_ClockInit() function.
    183          
    184          @endverbatim
    185            * @{
    186            */
    187            
    188          /**
    189            * @brief  Deinitializes the USARTx peripheral registers to their default reset values.
    190            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    191            *         UART peripheral.
    192            * @retval None
    193            */

   \                                 In section .text, align 2, keep-with-next
    194          void InitUSART4(INT32U nBps, INT32U nLCR)
    195          {
   \                     InitUSART4:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    196          	USART_InitTypeDef USART_InitStructure;
    197          
    198          ///
    199          // PORT INIT
    200          	RCC->__B.AHB1ENR.IOPCEN = ENABLE;
   \   00000004   0x....             LDR.N    R2,??DataTable9_1  ;; 0x40023830
   \   00000006   0x6813             LDR      R3,[R2, #+0]
   \   00000008   0xF043 0x0304      ORR      R3,R3,#0x4
   \   0000000C   0x6013             STR      R3,[R2, #+0]
    201          	RCC->__B.APB1ENR.UART4EN = ENABLE;
   \   0000000E   0x6913             LDR      R3,[R2, #+16]
   \   00000010   0xF443 0x2300      ORR      R3,R3,#0x80000
   \   00000014   0x6113             STR      R3,[R2, #+16]
    202          	
    203          //	__PC10_U4_TX(); 			// USART4_TX
    204          //	__PC11_U4_RX(); 			// USART4_RX
    205          
    206          
    207          ////////////////////////////////////////////////////////////////////////////////
    208          	USART_InitStructure.USART_BaudRate = nBps;
   \   00000016   0x9000             STR      R0,[SP, #+0]
    209          
    210          	if( ((nLCR >> 4) & 0x01) ==  (_DATA8BIT >> 4)) {
   \   00000018   0x06C8             LSLS     R0,R1,#+27
   \   0000001A   0xBF54             ITE      PL 
   \   0000001C   0x2000             MOVPL    R0,#+0
   \   0000001E   0xF44F 0x5080      MOVMI    R0,#+4096
    211          			USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    212          	}
    213          	else	USART_InitStructure.USART_WordLength = USART_WordLength_9b;
   \   00000022   0xF8AD 0x0004      STRH     R0,[SP, #+4]
    214          
    215          ////////////////////////////////////////////////////////////////////////////////
    216          	if( ((nLCR >> 2) & 0x02) ==  (_05STOP >> 2)) {
    217          		USART_InitStructure.USART_StopBits = USART_StopBits_0_5;
    218          	}
    219          	else if( ((nLCR >> 2) & 0x02) ==  (_1_STOP >> 2)) {
   \   00000026   0x0888             LSRS     R0,R1,#+2
   \   00000028   0x0780             LSLS     R0,R0,#+30
   \   0000002A   0xBF54             ITE      PL 
   \   0000002C   0x2000             MOVPL    R0,#+0
   \   0000002E   0xF44F 0x5000      MOVMI    R0,#+8192
    220          			USART_InitStructure.USART_StopBits = USART_StopBits_1;
    221          	}
    222          	else if( ((nLCR >> 2) & 0x02) ==  (_2_STOP >> 2)) {
    223          			USART_InitStructure.USART_StopBits = USART_StopBits_2;
   \   00000032   0xF8AD 0x0006      STRH     R0,[SP, #+6]
    224          	}
    225          	else	USART_InitStructure.USART_StopBits = USART_StopBits_1_5;
    226          	
    227          ////////////////////////////////////////////////////////////////////////////////
    228          	
    229          	if(((nLCR >> 0) & 0x03) == (_NONPARITY >> 0)){
   \   00000036   0xF011 0x0003      ANDS     R0,R1,#0x3
   \   0000003A   0xBF08             IT       EQ 
   \   0000003C   0x2000             MOVEQ    R0,#+0
    230          		USART_InitStructure.USART_Parity = USART_Parity_No;
   \   0000003E   0xD005             BEQ.N    ??InitUSART4_0
    231          	}
    232          	else if(((nLCR >> 0) & 0x03) == (_ODDPARITY >> 0)){
   \   00000040   0x2801             CMP      R0,#+1
   \   00000042   0xBF0C             ITE      EQ 
   \   00000044   0xF44F 0x60C0      MOVEQ    R0,#+1536
   \   00000048   0xF44F 0x6080      MOVNE    R0,#+1024
    233          		USART_InitStructure.USART_Parity = USART_Parity_Odd;
    234          	}
    235          	else{
    236          		USART_InitStructure.USART_Parity = USART_Parity_Even;
   \                     ??InitUSART4_0:
   \   0000004C   0xF8AD 0x0008      STRH     R0,[SP, #+8]
    237          	}
    238          	
    239          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   \   00000050   0x2000             MOVS     R0,#+0
   \   00000052   0xF8AD 0x000C      STRH     R0,[SP, #+12]
    240          	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
   \   00000056   0x200C             MOVS     R0,#+12
   \   00000058   0xF8AD 0x000A      STRH     R0,[SP, #+10]
    241          
    242          	/* USART configuration */
    243          	USART_Init(UART4, &USART_InitStructure);
   \   0000005C   0x....             LDR.N    R4,??DataTable9_2  ;; 0x40004c00
   \   0000005E   0xA900             ADD      R1,SP,#+0
   \   00000060   0x4620             MOV      R0,R4
   \   00000062   0x.... 0x....      BL       USART_Init
    244          
    245          #if defined (OS_INCLUDED) 
    246          	pUSART4.sem = OSSemCreate(1);
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0x.... 0x....      BL       OSSemCreate
   \   0000006C   0x....             LDR.N    R1,??DataTable9_3
   \   0000006E   0x6308             STR      R0,[R1, #+48]
    247          #endif
    248          	/* Enable USART */
    249          	USART_Cmd(UART4, ENABLE);
   \   00000070   0x2101             MOVS     R1,#+1
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0x.... 0x....      BL       USART_Cmd
    250          
    251          //	USART_ITConfig(UART4, USART_IT_TXE, DISABLE);
    252          
    253          	USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);
   \   00000078   0x2201             MOVS     R2,#+1
   \   0000007A   0xF240 0x5125      MOVW     R1,#+1317
   \   0000007E   0x4620             MOV      R0,R4
   \   00000080   0x.... 0x....      BL       USART_ITConfig
    254          	NVIC_Init(UART4_IRQn, ENABLE); 
   \   00000084   0x2101             MOVS     R1,#+1
   \   00000086   0x2034             MOVS     R0,#+52
   \   00000088   0x.... 0x....      BL       NVIC_Init
    255          
    256          	USART4Printf("\n");	
   \   0000008C   0x....             ADR.N    R0,??DataTable9  ;; "\n"
   \   0000008E   0x.... 0x....      BL       USART4Printf
    257          }
   \   00000092   0xB004             ADD      SP,SP,#+16
   \   00000094   0xBD10             POP      {R4,PC}          ;; return
    258          
    259          /*******************************************************************************
    260            * @brief  Interrupt handler USART4 global interrupt request
    261            * @param  None 
    262            * @retval None
    263            *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    264          void USART4_IRQIntHandler(void)
    265          {
   \                     USART4_IRQIntHandler:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    266          
    267          	INT16U tmp = UART4->SR;
   \   00000002   0x....             LDR.N    R4,??DataTable9_2  ;; 0x40004c00
   \   00000004   0x8825             LDRH     R5,[R4, #+0]
    268          
    269          #ifdef OS_INCLUDED
    270          	INT32U cpu_sr;
    271          	CPU_CRITICAL_ENTER();                                       // Tell uC/OS-II that we are starting an ISR
   \   00000006   0x.... 0x....      BL       CPU_SR_Save
    272          	OSIntNesting++;
   \   0000000A   0x....             LDR.N    R1,??DataTable9_4
   \   0000000C   0x780A             LDRB     R2,[R1, #+0]
   \   0000000E   0x1C52             ADDS     R2,R2,#+1
   \   00000010   0x700A             STRB     R2,[R1, #+0]
    273          	CPU_CRITICAL_EXIT();
   \   00000012   0x.... 0x....      BL       CPU_SR_Restore
    274          #endif /* OS_INCLUDED */
    275          	// Rx Data Received
    276          	if(tmp & ( 1 << __RXNE))
   \   00000016   0x06A8             LSLS     R0,R5,#+26
   \   00000018   0xD511             BPL.N    ??USART4_IRQIntHandler_0
    277          	{
    278          		Rx4Buff[Rx4WrCnt%Rx4BuffLen] = UART4->DR;		// When the receive register is read, the RDR bit is automatically cleared.
   \   0000001A   0x....             LDR.N    R0,??DataTable9_3
   \   0000001C   0x8841             LDRH     R1,[R0, #+2]
   \   0000001E   0x058A             LSLS     R2,R1,#+22
   \   00000020   0x0D92             LSRS     R2,R2,#+22
   \   00000022   0xEB02 0x0282      ADD      R2,R2,R2, LSL #+2
   \   00000026   0x....             LDR.N    R3,??DataTable9_5
   \   00000028   0x88A4             LDRH     R4,[R4, #+4]
   \   0000002A   0x54D4             STRB     R4,[R2, R3]
    279          		if(++Rx4WrCnt >= Rx4BuffLen) Rx4WrCnt = 0;
   \   0000002C   0x1C49             ADDS     R1,R1,#+1
   \   0000002E   0x8041             STRH     R1,[R0, #+2]
   \   00000030   0xB289             UXTH     R1,R1
   \   00000032   0xF5B1 0x5FA0      CMP      R1,#+5120
   \   00000036   0xD320             BCC.N    ??USART4_IRQIntHandler_1
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x8041             STRH     R1,[R0, #+2]
   \   0000003C   0x....             B.N      ?Subroutine0
    280          	}
    281          	else if(tmp & ( 1 << __TXE))
   \                     ??USART4_IRQIntHandler_0:
   \   0000003E   0x0628             LSLS     R0,R5,#+24
   \   00000040   0xD51A             BPL.N    ??USART4_IRQIntHandler_2
    282          	{
    283          		if(Tx4RdCnt != Tx4WrCnt)
   \   00000042   0x....             LDR.N    R0,??DataTable9_3
   \   00000044   0x8881             LDRH     R1,[R0, #+4]
   \   00000046   0x88C2             LDRH     R2,[R0, #+6]
   \   00000048   0x4291             CMP      R1,R2
   \   0000004A   0xD010             BEQ.N    ??USART4_IRQIntHandler_3
    284          		{
    285          			UART4->DR = Tx4Buff[Tx4RdCnt%Tx4BuffLen];
   \   0000004C   0x0589             LSLS     R1,R1,#+22
   \   0000004E   0x0D89             LSRS     R1,R1,#+22
   \   00000050   0xEB01 0x0181      ADD      R1,R1,R1, LSL #+2
   \   00000054   0x....             LDR.N    R2,??DataTable9_6
   \   00000056   0x5C89             LDRB     R1,[R1, R2]
   \   00000058   0x80A1             STRH     R1,[R4, #+4]
    286          			if(++Tx4RdCnt >= Tx4BuffLen ) Tx4RdCnt = 0;
   \   0000005A   0x8881             LDRH     R1,[R0, #+4]
   \   0000005C   0x1C49             ADDS     R1,R1,#+1
   \   0000005E   0x8081             STRH     R1,[R0, #+4]
   \   00000060   0xB289             UXTH     R1,R1
   \   00000062   0xF5B1 0x5FA0      CMP      R1,#+5120
   \   00000066   0xD308             BCC.N    ??USART4_IRQIntHandler_1
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x8081             STRH     R1,[R0, #+4]
   \   0000006C   0x....             B.N      ?Subroutine0
    287          		}
    288          		else UART4->__B.CR1.TXEIE = DISABLE;
   \                     ??USART4_IRQIntHandler_3:
   \   0000006E   0x68E0             LDR      R0,[R4, #+12]
   \   00000070   0xF020 0x0080      BIC      R0,R0,#0x80
   \   00000074   0x60E0             STR      R0,[R4, #+12]
   \   00000076   0x....             B.N      ?Subroutine0
    289          	}
    290          	else // error, dummy read
    291          	{
    292          		tmp =  UART4->DR;
   \                     ??USART4_IRQIntHandler_2:
   \   00000078   0x88A0             LDRH     R0,[R4, #+4]
    293          	}
    294          
    295          #ifdef OS_INCLUDED
    296          	OSIntExit();												// Tell uC/OS-II that we are leaving the ISR
   \                     ??USART4_IRQIntHandler_1:
   \   0000007A                      REQUIRE ?Subroutine0
   \   0000007A                      ;; // Fall through to label ?Subroutine0
    297          #endif /* OS_INCLUDED */
    298          
    299          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000004   0x.... 0x....      B.W      OSIntExit
    300          

   \                                 In section .text, align 2, keep-with-next
    301          unsigned char USART4PutToBuffer(unsigned char Data)
    302          {
   \                     USART4PutToBuffer:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4605             MOV      R5,R0
    303          #ifdef OS_INCLUDED
    304          	INT8U err;
    305          	//////////////////////////////////////////////////
    306          
    307          	OSSemPend(pUSART4.sem, 0, &err);
   \   00000004   0x....             LDR.N    R4,??DataTable9_3
   \   00000006   0xAA00             ADD      R2,SP,#+0
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6B20             LDR      R0,[R4, #+48]
   \   0000000C   0x.... 0x....      BL       OSSemPend
    308          #endif /* OS_INCLUDED */
    309          	//////////////////////////////////////////////////
    310          	Tx4Buff[Tx4WrCnt%Tx4BuffLen] = Data;
   \   00000010   0x88E0             LDRH     R0,[R4, #+6]
   \   00000012   0x0581             LSLS     R1,R0,#+22
   \   00000014   0x0D89             LSRS     R1,R1,#+22
   \   00000016   0xEB01 0x0181      ADD      R1,R1,R1, LSL #+2
   \   0000001A   0x....             LDR.N    R2,??DataTable9_6
   \   0000001C   0x548D             STRB     R5,[R1, R2]
    311          	if(++Tx4WrCnt >= Tx4BuffLen) Tx4WrCnt = 0;
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0xB280             UXTH     R0,R0
   \   00000022   0xF5B0 0x5FA0      CMP      R0,#+5120
   \   00000026   0xBF28             IT       CS 
   \   00000028   0x2000             MOVCS    R0,#+0
   \   0000002A   0x80E0             STRH     R0,[R4, #+6]
    312          	
    313          	UART4->__B.CR1.TXEIE = ENABLE; 		
   \   0000002C   0x....             LDR.N    R0,??DataTable9_7  ;; 0x40004c0c
   \   0000002E   0x6801             LDR      R1,[R0, #+0]
   \   00000030   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000034   0x6001             STR      R1,[R0, #+0]
    314          	///////////////////////////////////////////////////
    315          #ifdef OS_INCLUDED
    316          	OSSemPost(pUSART4.sem);
   \   00000036   0x6B20             LDR      R0,[R4, #+48]
   \   00000038   0x.... 0x....      BL       OSSemPost
    317          #endif /* OS_INCLUDED */
    318          
    319          	return 0;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    320          }
    321          
    322          
    323          
    324          //Not using interrupt

   \                                 In section .text, align 2, keep-with-next
    325          unsigned char USART4PutChar(unsigned char Data)
    326          {
   \                     USART4PutChar:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    327          	#ifdef OS_INCLUDED
    328          		INT8U err;
    329          		//////////////////////////////////////////////////
    330          	
    331          		OSSemPend(pUSART4.sem, 0, &err);
   \   00000004   0x....             LDR.N    R5,??DataTable9_3
   \   00000006   0xAA00             ADD      R2,SP,#+0
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6B28             LDR      R0,[R5, #+48]
   \   0000000C   0x.... 0x....      BL       OSSemPend
    332          	#endif /* OS_INCLUDED */
    333          		UART4->__B.DR.DR = Data;
   \   00000010   0x....             LDR.N    R0,??DataTable9_2  ;; 0x40004c00
   \   00000012   0x6841             LDR      R1,[R0, #+4]
   \   00000014   0xF364 0x0108      BFI      R1,R4,#+0,#+9
   \   00000018   0x6041             STR      R1,[R0, #+4]
    334          		while(!UART4->__B.SR.TXE);
   \                     ??USART4PutChar_0:
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0x0609             LSLS     R1,R1,#+24
   \   0000001E   0xD5FC             BPL.N    ??USART4PutChar_0
    335          	#ifdef OS_INCLUDED
    336          		OSSemPost(pUSART4.sem);
   \   00000020   0x6B28             LDR      R0,[R5, #+48]
   \   00000022   0x.... 0x....      BL       OSSemPost
    337          	#endif /* OS_INCLUDED */
    338          	return Data;
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    339          }
    340          

   \                                 In section .text, align 2, keep-with-next
    341          unsigned long int USART4Printf( const char *format, ...)
    342          {
   \                     USART4Printf:
   \   00000000   0xB40E             PUSH     {R1-R3}
   \   00000002   0xB530             PUSH     {R4,R5,LR}
    343          	unsigned long int i, cnt;
    344          //	char buf[128];
    345          	char *buf = (char *)&Tx4Buff[Tx4BuffLen-256];
    346          	
    347          	va_list argptr;
    348          
    349          	va_start(argptr, format);
   \   00000004   0xAA03             ADD      R2,SP,#+12
    350          	cnt = vsprintf(buf, format, argptr);
   \   00000006   0x....             LDR.N    R4,??DataTable9_8
   \   00000008   0x4601             MOV      R1,R0
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       vsprintf
   \   00000010   0x4605             MOV      R5,R0
    351          	va_end( argptr );
    352          
    353          	for(i = 0;;i++)
   \   00000012   0xE008             B.N      ??USART4Printf_0
    354          	{
    355          		if(buf[i] == 0) break;
    356          		if(buf[i] == '\n') USART4PutToBuffer('\r');
   \                     ??USART4Printf_1:
   \   00000014   0x280A             CMP      R0,#+10
   \   00000016   0xBF04             ITT      EQ 
   \   00000018   0x200D             MOVEQ    R0,#+13
   \   0000001A   0x.... 0x....      BLEQ     USART4PutToBuffer
    357          		USART4PutToBuffer(buf[i]);
   \   0000001E   0xF814 0x0B01      LDRB     R0,[R4], #+1
   \   00000022   0x.... 0x....      BL       USART4PutToBuffer
   \                     ??USART4Printf_0:
   \   00000026   0x7820             LDRB     R0,[R4, #+0]
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD1F3             BNE.N    ??USART4Printf_1
    358          	}
    359          
    360          	while(!USART4TxCheckByte())
   \                     ??USART4Printf_2:
   \   0000002C   0x.... 0x....      BL       USART4TxCheckByte
   \   00000030   0xB918             CBNZ.N   R0,??USART4Printf_3
    361          	{
    362          #ifdef OS_INCLUDED
    363          	OSTimeDly(1);
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x.... 0x....      BL       OSTimeDly
   \   00000038   0xE7F8             B.N      ??USART4Printf_2
    364          #endif /* OS_INCLUDED */
    365          	}
    366          
    367          	return cnt;
   \                     ??USART4Printf_3:
   \   0000003A   0x4628             MOV      R0,R5
   \   0000003C   0xBC30             POP      {R4,R5}
   \   0000003E   0xF85D 0xFB10      LDR      PC,[SP], #+16    ;; return
    368          }
    369          
    370          //#define OS_INCLUDED
    371          

   \                                 In section .text, align 2, keep-with-next
    372          void USART4PutStr(unsigned char *Str, unsigned short int Length, int iEn)
    373          {
   \                     USART4PutStr:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4617             MOV      R7,R2
    374          	u32 i = 0;
    375          
    376          	USART4BuffClear();
   \   00000008   0x.... 0x....      BL       USART4BuffClear
    377          	
    378          #ifdef OS_INCLUDED
    379          	INT8U err;
    380          	OSSemPend(pUSART4.sem, 0, &err);
   \   0000000C   0x....             LDR.N    R4,??DataTable9_3
   \   0000000E   0xAA00             ADD      R2,SP,#+0
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x6B20             LDR      R0,[R4, #+48]
   \   00000014   0x.... 0x....      BL       OSSemPend
    381          #endif /* OS_INCLUDED */
    382          
    383          
    384          	for(i = 0; i < Length; i++)
   \   00000018   0x88E0             LDRH     R0,[R4, #+6]
   \   0000001A   0xB15E             CBZ.N    R6,??USART4PutStr_0
   \   0000001C   0x....             LDR.N    R1,??DataTable9_6
    385          	{
    386          		Tx4Buff[Tx4WrCnt++] = Str[i];
   \                     ??USART4PutStr_1:
   \   0000001E   0x782A             LDRB     R2,[R5, #+0]
   \   00000020   0x5442             STRB     R2,[R0, R1]
   \   00000022   0x1C40             ADDS     R0,R0,#+1
    387          		if(Tx4WrCnt >= Tx4BuffLen) Tx4WrCnt = 0;
   \   00000024   0xB280             UXTH     R0,R0
   \   00000026   0xF5B0 0x5FA0      CMP      R0,#+5120
   \   0000002A   0xBF28             IT       CS 
   \   0000002C   0x2000             MOVCS    R0,#+0
    388          	}
   \   0000002E   0x1C6D             ADDS     R5,R5,#+1
   \   00000030   0x1E76             SUBS     R6,R6,#+1
   \   00000032   0xD1F4             BNE.N    ??USART4PutStr_1
   \                     ??USART4PutStr_0:
   \   00000034   0x80E0             STRH     R0,[R4, #+6]
    389          
    390          	if(iEn)
   \   00000036   0xB127             CBZ.N    R7,??USART4PutStr_2
    391          	{
    392          		UART4->__B.CR1.TXEIE = ENABLE;
   \   00000038   0x....             LDR.N    R0,??DataTable9_7  ;; 0x40004c0c
   \   0000003A   0x6801             LDR      R1,[R0, #+0]
   \   0000003C   0xF041 0x0180      ORR      R1,R1,#0x80
   \   00000040   0x6001             STR      R1,[R0, #+0]
    393          	}	
    394          #ifdef OS_INCLUDED
    395          		OSSemPost(pUSART4.sem);
   \                     ??USART4PutStr_2:
   \   00000042   0x6B20             LDR      R0,[R4, #+48]
   \   00000044   0x.... 0x....      BL       OSSemPost
    396          #endif /* OS_INCLUDED */
    397          }
   \   00000048   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    398          

   \                                 In section .text, align 2, keep-with-next
    399          signed short int USART4RxGetByte(void)
    400          {
    401          	s16 RetVal = 0;
    402          
    403          #ifndef OS_INCLUDED
    404          	while(Rx4RdCnt == Rx4WrCnt);
    405          #else
    406          	if(Rx4RdCnt == Rx4WrCnt) return -1;
   \                     USART4RxGetByte:
   \   00000000   0x....             LDR.N    R1,??DataTable9_3
   \   00000002   0x880A             LDRH     R2,[R1, #+0]
   \   00000004   0x8848             LDRH     R0,[R1, #+2]
   \   00000006   0x4282             CMP      R2,R0
   \   00000008   0xD102             BNE.N    ??USART4RxGetByte_0
   \   0000000A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000000E   0x4770             BX       LR
    407          #endif
    408          
    409          	RetVal = Rx4Buff[Rx4RdCnt%Rx4BuffLen];
   \                     ??USART4RxGetByte_0:
   \   00000010   0x0590             LSLS     R0,R2,#+22
   \   00000012   0x0D80             LSRS     R0,R0,#+22
   \   00000014   0xEB00 0x0080      ADD      R0,R0,R0, LSL #+2
   \   00000018   0x....             LDR.N    R3,??DataTable9_5
   \   0000001A   0x5CC0             LDRB     R0,[R0, R3]
    410          	if(++Rx4RdCnt >= Rx4BuffLen) Rx4RdCnt = 0;
   \   0000001C   0x1C52             ADDS     R2,R2,#+1
   \   0000001E   0x800A             STRH     R2,[R1, #+0]
   \   00000020   0xB292             UXTH     R2,R2
   \   00000022   0xF5B2 0x5FA0      CMP      R2,#+5120
   \   00000026   0xBF24             ITT      CS 
   \   00000028   0x2200             MOVCS    R2,#+0
   \   0000002A   0x800A             STRHCS   R2,[R1, #+0]
    411          
    412          	return (RetVal & 0xff);
   \   0000002C   0x4770             BX       LR               ;; return
    413          }
    414          

   \                                 In section .text, align 2, keep-with-next
    415          unsigned char USART4CheckByte(unsigned short int ByteCnt, unsigned short int *Recv)
    416          {
   \                     USART4CheckByte:
   \   00000000   0xB430             PUSH     {R4,R5}
    417          	u32 i = 0, j = 0;
    418          	u8 RetVal = TRUE;
   \   00000002   0x2201             MOVS     R2,#+1
    419          
    420          	*Recv = 0;
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x800B             STRH     R3,[R1, #+0]
    421          	i = (u32) Rx4RdCnt;
   \   00000008   0x....             LDR.N    R3,??DataTable9_3
   \   0000000A   0x881C             LDRH     R4,[R3, #+0]
    422          	j = (u32) Rx4WrCnt;
   \   0000000C   0x885B             LDRH     R3,[R3, #+2]
    423          
    424          	if(i == j) RetVal = FALSE;
   \   0000000E   0x429C             CMP      R4,R3
   \   00000010   0xD00E             BEQ.N    ??USART4CheckByte_0
    425          	else if(i < j)
   \   00000012   0x1900             ADDS     R0,R0,R4
   \   00000014   0x429C             CMP      R4,R3
   \   00000016   0xD203             BCS.N    ??USART4CheckByte_1
    426          	{
    427          		*Recv = j - i;
   \   00000018   0x1B1C             SUBS     R4,R3,R4
   \   0000001A   0x800C             STRH     R4,[R1, #+0]
    428          		i = i + ByteCnt;
    429          		if(i > j) RetVal = FALSE;
   \   0000001C   0x4283             CMP      R3,R0
   \   0000001E   0xE006             B.N      ??USART4CheckByte_2
    430          	}
    431          	else if(i > j)
    432          	{
    433          		*Recv = (Rx4BuffLen +j) - i;
   \                     ??USART4CheckByte_1:
   \   00000020   0xF503 0x55A0      ADD      R5,R3,#+5120
   \   00000024   0x1B2C             SUBS     R4,R5,R4
   \   00000026   0x800C             STRH     R4,[R1, #+0]
    434          		i = i + ByteCnt;
    435          		j = j + Rx4BuffLen;
    436          		if(i > j) RetVal = FALSE; 
   \   00000028   0xF503 0x51A0      ADD      R1,R3,#+5120
   \   0000002C   0x4281             CMP      R1,R0
   \                     ??USART4CheckByte_2:
   \   0000002E   0xD200             BCS.N    ??USART4CheckByte_3
   \                     ??USART4CheckByte_0:
   \   00000030   0x2200             MOVS     R2,#+0
    437          	}
    438          	return (RetVal);
   \                     ??USART4CheckByte_3:
   \   00000032   0x4610             MOV      R0,R2
   \   00000034   0xBC30             POP      {R4,R5}
   \   00000036   0x4770             BX       LR               ;; return
    439          }
    440          

   \                                 In section .text, align 2, keep-with-next
    441          void USART4BuffClear(void)
    442          {
    443          	Rx4RdCnt = 0;
   \                     USART4BuffClear:
   \   00000000   0x....             LDR.N    R0,??DataTable9_3
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x8001             STRH     R1,[R0, #+0]
    444          	Rx4WrCnt = 0;
   \   00000006   0x8041             STRH     R1,[R0, #+2]
    445          	Tx4RdCnt = 0;
   \   00000008   0x....             B.N      ?Subroutine1
    446          	Tx4WrCnt = 0;
    447          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0x8081             STRH     R1,[R0, #+4]
   \   00000002   0x80C1             STRH     R1,[R0, #+6]
   \   00000004   0x4770             BX       LR               ;; return
    448          

   \                                 In section .text, align 2, keep-with-next
    449          void USART4TxClear(void)
    450          {
    451          	Tx4RdCnt = 0;
   \                     USART4TxClear:
   \   00000000   0x....             LDR.N    R0,??DataTable9_3
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004                      REQUIRE ?Subroutine1
   \   00000004                      ;; // Fall through to label ?Subroutine1
    452          	Tx4WrCnt = 0;
    453          }
    454          
    455          /*******************************************************************************
    456            * @brief  if the bytes have been transmitted, retrun true or not
    457            * @param  None
    458            * @retval TRUE/FALSE
    459            ******************************************************************************/
    460          

   \                                 In section .text, align 2, keep-with-next
    461          signed short int USART4TxCheckByte(void)
    462          {
    463          	if(Tx4RdCnt == Tx4WrCnt) return TRUE;
   \                     USART4TxCheckByte:
   \   00000000   0x....             LDR.N    R0,??DataTable9_3
   \   00000002   0x8881             LDRH     R1,[R0, #+4]
   \   00000004   0x88C0             LDRH     R0,[R0, #+6]
   \   00000006   0x4281             CMP      R1,R0
   \   00000008   0xD101             BNE.N    ??USART4TxCheckByte_0
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x4770             BX       LR
    464          	else return FALSE;
   \                     ??USART4TxCheckByte_0:
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4770             BX       LR               ;; return
    465          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x40023830         DC32     0x40023830

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x40004C00         DC32     0x40004c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     Rx4RdCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     Rx4Buff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     Tx4Buff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x40004C0C         DC32     0x40004c0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x........         DC32     Tx4Buff+0x1300

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "\\n">`:
   \   00000000   0x0A 0x00          DC8 "\012"
    466          
    467          
    468          
    469          
    470          /**
    471            * @brief  Initializes the USARTx peripheral Clock according to the 
    472            *         specified parameters in the USART_ClockInitStruct .
    473            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART peripheral.
    474            * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure that
    475            *         contains the configuration information for the specified  USART peripheral.
    476            * @note   The Smart Card and Synchronous modes are not available for UART4 and UART5.    
    477            * @retval None
    478            */
    479          
    480          /**
    481            * @brief  Fills each USART_ClockInitStruct member with its default value.
    482            * @param  USART_ClockInitStruct: pointer to a USART_ClockInitTypeDef structure
    483            *         which will be initialized.
    484            * @retval None
    485            */
    486          
    487          
    488          /**
    489            * @brief  Enables or disables the specified USART peripheral.
    490            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    491            *         UART peripheral.
    492            * @param  NewState: new state of the USARTx peripheral.
    493            *          This parameter can be: ENABLE or DISABLE.
    494            * @retval None
    495            */
    496          
    497          
    498          /**
    499            * @brief  Sets the system clock prescaler.
    500            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    501            *         UART peripheral.
    502            * @param  USART_Prescaler: specifies the prescaler clock. 
    503            * @note   The function is used for IrDA mode with UART4 and UART5.   
    504            * @retval None
    505            */
    506          
    507          /**
    508            * @brief  Enables or disables the USART's 8x oversampling mode.
    509            * @note   This function has to be called before calling USART_Init() function
    510            *         in order to have correct baudrate Divider value.
    511            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    512            *         UART peripheral.
    513            * @param  NewState: new state of the USART 8x oversampling mode.
    514            *          This parameter can be: ENABLE or DISABLE.
    515            * @retval None
    516            */
    517            
    518          
    519          /**
    520            * @brief  Enables or disables the USART's one bit sampling method.
    521            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    522            *         UART peripheral.
    523            * @param  NewState: new state of the USART one bit sampling method.
    524            *          This parameter can be: ENABLE or DISABLE.
    525            * @retval None
    526            */
    527          
    528          /**
    529            * @}
    530            */
    531          
    532          /** @defgroup USART_Group2 Data transfers functions
    533           *  @brief   Data transfers functions 
    534           *
    535          @verbatim   
    536           ===============================================================================
    537                                      Data transfers functions
    538           ===============================================================================  
    539          
    540            This subsection provides a set of functions allowing to manage the USART data 
    541            transfers.
    542            
    543            During an USART reception, data shifts in least significant bit first through 
    544            the RX pin. In this mode, the USART_DR register consists of a buffer (RDR) 
    545            between the internal bus and the received shift register.
    546          
    547            When a transmission is taking place, a write instruction to the USART_DR register 
    548            stores the data in the TDR register and which is copied in the shift register 
    549            at the end of the current transmission.
    550          
    551            The read access of the USART_DR register can be done using the USART_ReceiveData()
    552            function and returns the RDR buffered value. Whereas a write access to the USART_DR 
    553            can be done using USART_SendData() function and stores the written data into 
    554            TDR buffer.
    555          
    556          @endverbatim
    557            * @{
    558            */
    559          
    560          /**
    561            * @brief  Transmits single data through the USARTx peripheral.
    562            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    563            *         UART peripheral.
    564            * @param  Data: the data to transmit.
    565            * @retval None
    566            */
    567          
    568          
    569          /**
    570            * @brief  Returns the most recent received data by the USARTx peripheral.
    571            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    572            *         UART peripheral.
    573            * @retval The received data.
    574            */
    575          
    576          /**
    577            * @}
    578            */
    579          
    580          /** @defgroup USART_Group3 MultiProcessor Communication functions
    581           *  @brief   Multi-Processor Communication functions 
    582           *
    583          @verbatim   
    584           ===============================================================================
    585                              Multi-Processor Communication functions
    586           ===============================================================================  
    587          
    588            This subsection provides a set of functions allowing to manage the USART 
    589            multiprocessor communication.
    590            
    591            For instance one of the USARTs can be the master, its TX output is connected to 
    592            the RX input of the other USART. The others are slaves, their respective TX outputs 
    593            are logically ANDed together and connected to the RX input of the master.
    594          
    595            USART multiprocessor communication is possible through the following procedure:
    596               1. Program the Baud rate, Word length = 9 bits, Stop bits, Parity, Mode transmitter 
    597                  or Mode receiver and hardware flow control values using the USART_Init()
    598                  function.
    599               2. Configures the USART address using the USART_SetAddress() function.
    600               3. Configures the wake up method (USART_WakeUp_IdleLine or USART_WakeUp_AddressMark)
    601                  using USART_WakeUpConfig() function only for the slaves.
    602               4. Enable the USART using the USART_Cmd() function.
    603               5. Enter the USART slaves in mute mode using USART_ReceiverWakeUpCmd() function.
    604          
    605            The USART Slave exit from mute mode when receive the wake up condition.
    606          
    607          @endverbatim
    608            * @{
    609            */
    610          
    611          /**
    612            * @brief  Sets the address of the USART node.
    613            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    614            *         UART peripheral.
    615            * @param  USART_Address: Indicates the address of the USART node.
    616            * @retval None
    617            */
    618          
    619          
    620          /**
    621            * @brief  Determines if the USART is in mute mode or not.
    622            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    623            *         UART peripheral.
    624            * @param  NewState: new state of the USART mute mode.
    625            *          This parameter can be: ENABLE or DISABLE.
    626            * @retval None
    627            */
    628          
    629          /**
    630            * @brief  Selects the USART WakeUp method.
    631            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    632            *         UART peripheral.
    633            * @param  USART_WakeUp: specifies the USART wakeup method.
    634            *          This parameter can be one of the following values:
    635            *            @arg USART_WakeUp_IdleLine: WakeUp by an idle line detection
    636            *            @arg USART_WakeUp_AddressMark: WakeUp by an address mark
    637            * @retval None
    638            */
    639          
    640          
    641          /**
    642            * @}
    643            */
    644          
    645          /** @defgroup USART_Group4 LIN mode functions
    646           *  @brief   LIN mode functions 
    647           *
    648          @verbatim   
    649           ===============================================================================
    650                                          LIN mode functions
    651           ===============================================================================  
    652          
    653            This subsection provides a set of functions allowing to manage the USART LIN 
    654            Mode communication.
    655            
    656            In LIN mode, 8-bit data format with 1 stop bit is required in accordance with 
    657            the LIN standard.
    658          
    659            Only this LIN Feature is supported by the USART IP:
    660              - LIN Master Synchronous Break send capability and LIN slave break detection
    661                capability :  13-bit break generation and 10/11 bit break detection
    662          
    663          
    664            USART LIN Master transmitter communication is possible through the following procedure:
    665               1. Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
    666                  Mode transmitter or Mode receiver and hardware flow control values using 
    667                  the USART_Init() function.
    668               2. Enable the USART using the USART_Cmd() function.
    669               3. Enable the LIN mode using the USART_LINCmd() function.
    670               4. Send the break character using USART_SendBreak() function.
    671          
    672            USART LIN Master receiver communication is possible through the following procedure:
    673               1. Program the Baud rate, Word length = 8bits, Stop bits = 1bit, Parity, 
    674                  Mode transmitter or Mode receiver and hardware flow control values using 
    675                  the USART_Init() function.
    676               2. Enable the USART using the USART_Cmd() function.
    677               3. Configures the break detection length using the USART_LINBreakDetectLengthConfig()
    678                  function.
    679               4. Enable the LIN mode using the USART_LINCmd() function.
    680          
    681          
    682          @note In LIN mode, the following bits must be kept cleared:
    683                  - CLKEN in the USART_CR2 register,
    684                  - STOP[1:0], SCEN, HDSEL and IREN in the USART_CR3 register.
    685          
    686          @endverbatim
    687            * @{
    688            */
    689          
    690          /**
    691            * @brief  Sets the USART LIN Break detection length.
    692            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    693            *         UART peripheral.
    694            * @param  USART_LINBreakDetectLength: specifies the LIN break detection length.
    695            *          This parameter can be one of the following values:
    696            *            @arg USART_LINBreakDetectLength_10b: 10-bit break detection
    697            *            @arg USART_LINBreakDetectLength_11b: 11-bit break detection
    698            * @retval None
    699            */
    700          
    701          /**
    702            * @brief  Enables or disables the USART's LIN mode.
    703            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    704            *         UART peripheral.
    705            * @param  NewState: new state of the USART LIN mode.
    706            *          This parameter can be: ENABLE or DISABLE.
    707            * @retval None
    708            */
    709          
    710          
    711          /**
    712            * @brief  Transmits break characters.
    713            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    714            *         UART peripheral.
    715            * @retval None
    716            */
    717          
    718          
    719          /**
    720            * @}
    721            */
    722          
    723          /** @defgroup USART_Group5 Halfduplex mode function
    724           *  @brief   Half-duplex mode function 
    725           *
    726          @verbatim   
    727           ===============================================================================
    728                                   Half-duplex mode function
    729           ===============================================================================  
    730          
    731            This subsection provides a set of functions allowing to manage the USART 
    732            Half-duplex communication.
    733            
    734            The USART can be configured to follow a single-wire half-duplex protocol where 
    735            the TX and RX lines are internally connected.
    736          
    737            USART Half duplex communication is possible through the following procedure:
    738               1. Program the Baud rate, Word length, Stop bits, Parity, Mode transmitter 
    739                  or Mode receiver and hardware flow control values using the USART_Init()
    740                  function.
    741               2. Configures the USART address using the USART_SetAddress() function.
    742               3. Enable the USART using the USART_Cmd() function.
    743               4. Enable the half duplex mode using USART_HalfDuplexCmd() function.
    744          
    745          
    746          @note The RX pin is no longer used
    747          @note In Half-duplex mode the following bits must be kept cleared:
    748                  - LINEN and CLKEN bits in the USART_CR2 register.
    749                  - SCEN and IREN bits in the USART_CR3 register.
    750          
    751          @endverbatim
    752            * @{
    753            */
    754          
    755          /**
    756            * @brief  Enables or disables the USART's Half Duplex communication.
    757            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    758            *         UART peripheral.
    759            * @param  NewState: new state of the USART Communication.
    760            *          This parameter can be: ENABLE or DISABLE.
    761            * @retval None
    762            */
    763          
    764          
    765          /**
    766            * @}
    767            */
    768          
    769          
    770          /** @defgroup USART_Group6 Smartcard mode functions
    771           *  @brief   Smartcard mode functions 
    772           *
    773          @verbatim   
    774           ===============================================================================
    775                                         Smartcard mode functions
    776           ===============================================================================  
    777          
    778            This subsection provides a set of functions allowing to manage the USART 
    779            Smartcard communication.
    780            
    781            The Smartcard interface is designed to support asynchronous protocol Smartcards as
    782            defined in the ISO 7816-3 standard.
    783          
    784            The USART can provide a clock to the smartcard through the SCLK output.
    785            In smartcard mode, SCLK is not associated to the communication but is simply derived 
    786            from the internal peripheral input clock through a 5-bit prescaler.
    787          
    788            Smartcard communication is possible through the following procedure:
    789               1. Configures the Smartcard Prescaler using the USART_SetPrescaler() function.
    790               2. Configures the Smartcard Guard Time using the USART_SetGuardTime() function.
    791               3. Program the USART clock using the USART_ClockInit() function as following:
    792                  - USART Clock enabled
    793                  - USART CPOL Low
    794                  - USART CPHA on first edge
    795                  - USART Last Bit Clock Enabled
    796               4. Program the Smartcard interface using the USART_Init() function as following:
    797                  - Word Length = 9 Bits
    798                  - 1.5 Stop Bit
    799                  - Even parity
    800                  - BaudRate = 12096 baud
    801                  - Hardware flow control disabled (RTS and CTS signals)
    802                  - Tx and Rx enabled
    803               5. Optionally you can enable the parity error interrupt using the USART_ITConfig()
    804                  function
    805               6. Enable the USART using the USART_Cmd() function.
    806               7. Enable the Smartcard NACK using the USART_SmartCardNACKCmd() function.
    807               8. Enable the Smartcard interface using the USART_SmartCardCmd() function.
    808          
    809            Please refer to the ISO 7816-3 specification for more details.
    810          
    811          
    812          @note It is also possible to choose 0.5 stop bit for receiving but it is recommended 
    813                to use 1.5 stop bits for both transmitting and receiving to avoid switching 
    814                between the two configurations.
    815          @note In smartcard mode, the following bits must be kept cleared:
    816                  - LINEN bit in the USART_CR2 register.
    817                  - HDSEL and IREN bits in the USART_CR3 register.
    818          @note Smartcard mode is available on USART peripherals only (not available on UART4 
    819                and UART5 peripherals).
    820          
    821          @endverbatim
    822            * @{
    823            */
    824          
    825          /**
    826            * @brief  Sets the specified USART guard time.
    827            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
    828            *         UART peripheral.
    829            * @param  USART_GuardTime: specifies the guard time.   
    830            * @retval None
    831            */
    832          
    833          /**
    834            * @brief  Enables or disables the USART's Smart Card mode.
    835            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
    836            *         UART peripheral.
    837            * @param  NewState: new state of the Smart Card mode.
    838            *          This parameter can be: ENABLE or DISABLE.      
    839            * @retval None
    840            */
    841          
    842          
    843          /**
    844            * @brief  Enables or disables NACK transmission.
    845            * @param  USARTx: where x can be 1, 2, 3 or 6 to select the USART or 
    846            *         UART peripheral.
    847            * @param  NewState: new state of the NACK transmission.
    848            *          This parameter can be: ENABLE or DISABLE.  
    849            * @retval None
    850            */
    851          
    852          /**
    853            * @}
    854            */
    855          
    856          /** @defgroup USART_Group7 IrDA mode functions
    857           *  @brief   IrDA mode functions 
    858           *
    859          @verbatim   
    860           ===============================================================================
    861                                          IrDA mode functions
    862           ===============================================================================  
    863          
    864            This subsection provides a set of functions allowing to manage the USART 
    865            IrDA communication.
    866            
    867            IrDA is a half duplex communication protocol. If the Transmitter is busy, any data
    868            on the IrDA receive line will be ignored by the IrDA decoder and if the Receiver 
    869            is busy, data on the TX from the USART to IrDA will not be encoded by IrDA.
    870            While receiving data, transmission should be avoided as the data to be transmitted
    871            could be corrupted.
    872          
    873            IrDA communication is possible through the following procedure:
    874               1. Program the Baud rate, Word length = 8 bits, Stop bits, Parity, Transmitter/Receiver 
    875                  modes and hardware flow control values using the USART_Init() function.
    876               2. Enable the USART using the USART_Cmd() function.
    877               3. Configures the IrDA pulse width by configuring the prescaler using  
    878                  the USART_SetPrescaler() function.
    879               4. Configures the IrDA  USART_IrDAMode_LowPower or USART_IrDAMode_Normal mode
    880                  using the USART_IrDAConfig() function.
    881               5. Enable the IrDA using the USART_IrDACmd() function.
    882          
    883          @note A pulse of width less than two and greater than one PSC period(s) may or may
    884                not be rejected.
    885          @note The receiver set up time should be managed by software. The IrDA physical layer
    886                specification specifies a minimum of 10 ms delay between transmission and 
    887                reception (IrDA is a half duplex protocol).
    888          @note In IrDA mode, the following bits must be kept cleared:
    889                  - LINEN, STOP and CLKEN bits in the USART_CR2 register.
    890                  - SCEN and HDSEL bits in the USART_CR3 register.
    891          
    892          @endverbatim
    893            * @{
    894            */
    895          
    896          /**
    897            * @brief  Configures the USART's IrDA interface.
    898            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    899            *         UART peripheral.
    900            * @param  USART_IrDAMode: specifies the IrDA mode.
    901            *          This parameter can be one of the following values:
    902            *            @arg USART_IrDAMode_LowPower
    903            *            @arg USART_IrDAMode_Normal
    904            * @retval None
    905            */
    906          
    907          /**
    908            * @brief  Enables or disables the USART's IrDA interface.
    909            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    910            *         UART peripheral.
    911            * @param  NewState: new state of the IrDA mode.
    912            *          This parameter can be: ENABLE or DISABLE.
    913            * @retval None
    914            */
    915          
    916          
    917          /**
    918            * @}
    919            */
    920          
    921          /** @defgroup USART_Group8 DMA transfers management functions
    922           *  @brief   DMA transfers management functions
    923           *
    924          @verbatim   
    925           ===============================================================================
    926                                DMA transfers management functions
    927           ===============================================================================  
    928          
    929          @endverbatim
    930            * @{
    931            */
    932            
    933          /**
    934            * @brief  Enables or disables the USART's DMA interface.
    935            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
    936            *         UART peripheral.
    937            * @param  USART_DMAReq: specifies the DMA request.
    938            *          This parameter can be any combination of the following values:
    939            *            @arg USART_DMAReq_Tx: USART DMA transmit request
    940            *            @arg USART_DMAReq_Rx: USART DMA receive request
    941            * @param  NewState: new state of the DMA Request sources.
    942            *          This parameter can be: ENABLE or DISABLE.   
    943            * @retval None
    944            */
    945          
    946          /**
    947            * @}
    948            */
    949            
    950          /** @defgroup USART_Group9 Interrupts and flags management functions
    951           *  @brief   Interrupts and flags management functions 
    952           *
    953          @verbatim   
    954           ===============================================================================
    955                             Interrupts and flags management functions
    956           ===============================================================================  
    957          
    958            This subsection provides a set of functions allowing to configure the USART 
    959            Interrupts sources, DMA channels requests and check or clear the flags or 
    960            pending bits status.
    961            The user should identify which mode will be used in his application to manage 
    962            the communication: Polling mode, Interrupt mode or DMA mode. 
    963              
    964            Polling Mode
    965            =============
    966            In Polling Mode, the SPI communication can be managed by 10 flags:
    967               1. USART_FLAG_TXE : to indicate the status of the transmit buffer register
    968               2. USART_FLAG_RXNE : to indicate the status of the receive buffer register
    969               3. USART_FLAG_TC : to indicate the status of the transmit operation
    970               4. USART_FLAG_IDLE : to indicate the status of the Idle Line             
    971               5. USART_FLAG_CTS : to indicate the status of the nCTS input
    972               6. USART_FLAG_LBD : to indicate the status of the LIN break detection
    973               7. USART_FLAG_NE : to indicate if a noise error occur
    974               8. USART_FLAG_FE : to indicate if a frame error occur
    975               9. USART_FLAG_PE : to indicate if a parity error occur
    976               10. USART_FLAG_ORE : to indicate if an Overrun error occur
    977          
    978            In this Mode it is advised to use the following functions:
    979                - FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG);
    980                - void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG);
    981          
    982            Interrupt Mode
    983            ===============
    984            In Interrupt Mode, the USART communication can be managed by 8 interrupt sources
    985            and 10 pending bits: 
    986          
    987            Pending Bits:
    988            ------------- 
    989               1. USART_IT_TXE : to indicate the status of the transmit buffer register
    990               2. USART_IT_RXNE : to indicate the status of the receive buffer register
    991               3. USART_IT_TC : to indicate the status of the transmit operation
    992               4. USART_IT_IDLE : to indicate the status of the Idle Line             
    993               5. USART_IT_CTS : to indicate the status of the nCTS input
    994               6. USART_IT_LBD : to indicate the status of the LIN break detection
    995               7. USART_IT_NE : to indicate if a noise error occur
    996               8. USART_IT_FE : to indicate if a frame error occur
    997               9. USART_IT_PE : to indicate if a parity error occur
    998               10. USART_IT_ORE : to indicate if an Overrun error occur
    999          
   1000            Interrupt Source:
   1001            -----------------
   1002               1. USART_IT_TXE : specifies the interrupt source for the Tx buffer empty 
   1003                                 interrupt. 
   1004               2. USART_IT_RXNE : specifies the interrupt source for the Rx buffer not 
   1005                                  empty interrupt.
   1006               3. USART_IT_TC : specifies the interrupt source for the Transmit complete 
   1007                                 interrupt. 
   1008               4. USART_IT_IDLE : specifies the interrupt source for the Idle Line interrupt.             
   1009               5. USART_IT_CTS : specifies the interrupt source for the CTS interrupt. 
   1010               6. USART_IT_LBD : specifies the interrupt source for the LIN break detection
   1011                                 interrupt. 
   1012               7. USART_IT_PE : specifies the interrupt source for the parity error interrupt. 
   1013               8. USART_IT_ERR :  specifies the interrupt source for the errors interrupt.
   1014          
   1015          @note Some parameters are coded in order to use them as interrupt source or as pending bits.
   1016          
   1017            In this Mode it is advised to use the following functions:
   1018               - void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState);
   1019               - ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT);
   1020               - void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT);
   1021          
   1022            DMA Mode
   1023            ========
   1024            In DMA Mode, the USART communication can be managed by 2 DMA Channel requests:
   1025               1. USART_DMAReq_Tx: specifies the Tx buffer DMA transfer request
   1026               2. USART_DMAReq_Rx: specifies the Rx buffer DMA transfer request
   1027          
   1028            In this Mode it is advised to use the following function:
   1029               - void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState);
   1030          
   1031          @endverbatim
   1032            * @{
   1033            */
   1034          
   1035          /**
   1036            * @brief  Enables or disables the specified USART interrupts.
   1037            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1038            *         UART peripheral.
   1039            * @param  USART_IT: specifies the USART interrupt sources to be enabled or disabled.
   1040            *          This parameter can be one of the following values:
   1041            *            @arg USART_IT_CTS:  CTS change interrupt
   1042            *            @arg USART_IT_LBD:  LIN Break detection interrupt
   1043            *            @arg USART_IT_TXE:  Transmit Data Register empty interrupt
   1044            *            @arg USART_IT_TC:   Transmission complete interrupt
   1045            *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
   1046            *            @arg USART_IT_IDLE: Idle line detection interrupt
   1047            *            @arg USART_IT_PE:   Parity Error interrupt
   1048            *            @arg USART_IT_ERR:  Error interrupt(Frame error, noise error, overrun error)
   1049            * @param  NewState: new state of the specified USARTx interrupts.
   1050            *          This parameter can be: ENABLE or DISABLE.
   1051            * @retval None
   1052            */
   1053          
   1054          /**
   1055            * @brief  Checks whether the specified USART flag is set or not.
   1056            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1057            *         UART peripheral.
   1058            * @param  USART_FLAG: specifies the flag to check.
   1059            *          This parameter can be one of the following values:
   1060            *            @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5)
   1061            *            @arg USART_FLAG_LBD:  LIN Break detection flag
   1062            *            @arg USART_FLAG_TXE:  Transmit data register empty flag
   1063            *            @arg USART_FLAG_TC:   Transmission Complete flag
   1064            *            @arg USART_FLAG_RXNE: Receive data register not empty flag
   1065            *            @arg USART_FLAG_IDLE: Idle Line detection flag
   1066            *            @arg USART_FLAG_ORE:  OverRun Error flag
   1067            *            @arg USART_FLAG_NE:   Noise Error flag
   1068            *            @arg USART_FLAG_FE:   Framing Error flag
   1069            *            @arg USART_FLAG_PE:   Parity Error flag
   1070            * @retval The new state of USART_FLAG (SET or RESET).
   1071            */
   1072          
   1073          /**
   1074            * @brief  Clears the USARTx's pending flags.
   1075            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1076            *         UART peripheral.
   1077            * @param  USART_FLAG: specifies the flag to clear.
   1078            *          This parameter can be any combination of the following values:
   1079            *            @arg USART_FLAG_CTS:  CTS Change flag (not available for UART4 and UART5).
   1080            *            @arg USART_FLAG_LBD:  LIN Break detection flag.
   1081            *            @arg USART_FLAG_TC:   Transmission Complete flag.
   1082            *            @arg USART_FLAG_RXNE: Receive data register not empty flag.
   1083            *   
   1084            * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
   1085            *          error) and IDLE (Idle line detected) flags are cleared by software 
   1086            *          sequence: a read operation to USART_SR register (USART_GetFlagStatus()) 
   1087            *          followed by a read operation to USART_DR register (USART_ReceiveData()).
   1088            * @note   RXNE flag can be also cleared by a read to the USART_DR register 
   1089            *          (USART_ReceiveData()).
   1090            * @note   TC flag can be also cleared by software sequence: a read operation to 
   1091            *          USART_SR register (USART_GetFlagStatus()) followed by a write operation
   1092            *          to USART_DR register (USART_SendData()).
   1093            * @note   TXE flag is cleared only by a write to the USART_DR register 
   1094            *          (USART_SendData()).
   1095            *   
   1096            * @retval None
   1097            */
   1098          
   1099          
   1100          /**
   1101            * @brief  Checks whether the specified USART interrupt has occurred or not.
   1102            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1103            *         UART peripheral.
   1104            * @param  USART_IT: specifies the USART interrupt source to check.
   1105            *          This parameter can be one of the following values:
   1106            *            @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
   1107            *            @arg USART_IT_LBD:  LIN Break detection interrupt
   1108            *            @arg USART_IT_TXE:  Transmit Data Register empty interrupt
   1109            *            @arg USART_IT_TC:   Transmission complete interrupt
   1110            *            @arg USART_IT_RXNE: Receive Data register not empty interrupt
   1111            *            @arg USART_IT_IDLE: Idle line detection interrupt
   1112            *            @arg USART_IT_ORE:  OverRun Error interrupt
   1113            *            @arg USART_IT_NE:   Noise Error interrupt
   1114            *            @arg USART_IT_FE:   Framing Error interrupt
   1115            *            @arg USART_IT_PE:   Parity Error interrupt
   1116            * @retval The new state of USART_IT (SET or RESET).
   1117            */
   1118          
   1119          
   1120          /**
   1121            * @brief  Clears the USARTx's interrupt pending bits.
   1122            * @param  USARTx: where x can be 1, 2, 3, 4, 5 or 6 to select the USART or 
   1123            *         UART peripheral.
   1124            * @param  USART_IT: specifies the interrupt pending bit to clear.
   1125            *          This parameter can be one of the following values:
   1126            *            @arg USART_IT_CTS:  CTS change interrupt (not available for UART4 and UART5)
   1127            *            @arg USART_IT_LBD:  LIN Break detection interrupt
   1128            *            @arg USART_IT_TC:   Transmission complete interrupt. 
   1129            *            @arg USART_IT_RXNE: Receive Data register not empty interrupt.
   1130            *
   1131            * @note   PE (Parity error), FE (Framing error), NE (Noise error), ORE (OverRun 
   1132            *          error) and IDLE (Idle line detected) pending bits are cleared by 
   1133            *          software sequence: a read operation to USART_SR register 
   1134            *          (USART_GetITStatus()) followed by a read operation to USART_DR register 
   1135            *          (USART_ReceiveData()).
   1136            * @note   RXNE pending bit can be also cleared by a read to the USART_DR register 
   1137            *          (USART_ReceiveData()).
   1138            * @note   TC pending bit can be also cleared by software sequence: a read 
   1139            *          operation to USART_SR register (USART_GetITStatus()) followed by a write 
   1140            *          operation to USART_DR register (USART_SendData()).
   1141            * @note   TXE pending bit is cleared only by a write to the USART_DR register 
   1142            *          (USART_SendData()).
   1143            *  
   1144            * @retval None
   1145            */
   1146          
   1147          
   1148          /**
   1149            * @}
   1150            */
   1151          
   1152          /**
   1153            * @}
   1154            */
   1155          
   1156          /**
   1157            * @}
   1158            */
   1159          
   1160          /**
   1161            * @}
   1162            */
   1163          
   1164          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       24  InitUSART4
             24 -> NVIC_Init
             24 -> OSSemCreate
             24 -> USART4Printf
             24 -> USART_Cmd
             24 -> USART_ITConfig
             24 -> USART_Init
        0  USART4BuffClear
        8  USART4CheckByte
       24  USART4Printf
             24 -> OSTimeDly
             24 -> USART4PutToBuffer
             24 -> USART4TxCheckByte
             24 -> vsprintf
       16  USART4PutChar
             16 -> OSSemPend
             16 -> OSSemPost
       24  USART4PutStr
             24 -> OSSemPend
             24 -> OSSemPost
             24 -> USART4BuffClear
       16  USART4PutToBuffer
             16 -> OSSemPend
             16 -> OSSemPost
        0  USART4RxGetByte
        0  USART4TxCheckByte
        0  USART4TxClear
       16  USART4_IRQIntHandler
             16 -> CPU_SR_Restore
             16 -> CPU_SR_Save
              0 -> OSIntExit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Constant "\n">
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       8  ?Subroutine0
       6  ?Subroutine1
     150  InitUSART4
    5120  Rx4Buff
      52  Rx4RdCnt
          Rx4WrCnt
          Tx4RdCnt
          Tx4WrCnt
          pUSART4
    5120  Tx4Buff
      10  USART4BuffClear
      56  USART4CheckByte
      66  USART4Printf
      42  USART4PutChar
      74  USART4PutStr
      64  USART4PutToBuffer
      46  USART4RxGetByte
      18  USART4TxCheckByte
       4  USART4TxClear
     122  USART4_IRQIntHandler

 
      2 bytes in section .rodata
    702 bytes in section .text
 10 292 bytes in section iram
 
    702 bytes of CODE  memory
      2 bytes of CONST memory
 10 292 bytes of DATA  memory

Errors: none
Warnings: none

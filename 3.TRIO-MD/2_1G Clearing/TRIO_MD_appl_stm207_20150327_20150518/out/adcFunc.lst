###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     18/May/2015  16:57:39 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\code\adcFunc.c                                    #
#    Command line =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\code\adcFunc.c -lC D:\Project\TRIO_MD\3.F_W\TRIO_ #
#                    MD_appl_stm207_20150327_20150518\out\ -o                 #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\out\ --endian=little --cpu=Cortex-M3 -e           #
#                    --fpu=None --dlib_config "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_2 #
#                    0150327_20150518\include\ -I                             #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\STM32F2xx_StdPeriph_Driver_v1212\ -I              #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\STM32F2xx_StdPeriph_Driver_v1212\inc\ -I          #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\uC-CPU\ -I D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_ #
#                    stm207_20150327_20150518\uC-LIB\ -I                      #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\uCOS-II\Ports\ -I D:\Project\TRIO_MD\3.F_W\TRIO_M #
#                    D_appl_stm207_20150327_20150518\uCOS-II\Source\ -I       #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\uC-Probe\ -Oh --use_c++_inline                    #
#    List file    =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\out\adcFunc.lst                                   #
#    Object file  =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\out\adcFunc.o                                     #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20150518\code\adcFunc.c
      1          /******************** (C) COPYRIGHT 2007 STMicroelectronics ********************
      2          * File Name          : stm32f10x_adc.c
      3          * Author             : MCD Application Team
      4          * Version            : V1.0
      5          * Date               : 10/08/2007
      6          * Description        : This file provides all the ADC firmware functions.
      7          ********************************************************************************/
      8          #define ADC_C
      9          
     10          // Includes ////////////////////////////////////////////////////////////////////
     11          #include "../include/main.h"

   \                                 In section .text, align 4, keep-with-next
   \   __absolute unsigned long const AdcBuffMax[19]
   \                     AdcBuffMax:
   \   00000000   0x00000064         DC32 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 10, 10
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x0000000A   
   \              0x0000000A   
   \   00000038   0x0000000A         DC32 10, 10, 0, 0, 0
   \              0x0000000A   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   

   \                                 In section .text, align 4, keep-with-next
   \   __absolute unsigned long const Adc3BuffMax[19]
   \                     Adc3BuffMax:
   \   00000000   0x00000064         DC32 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 100, 10, 10
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x00000064   
   \              0x0000000A   
   \              0x0000000A   
   \   00000038   0x0000000A         DC32 10, 10, 0, 0, 0
   \              0x0000000A   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute INT32U const AdcEn
   \                     AdcEn:
   \   00000000   0x00000003         DC32 3

   \                                 In section .rodata, align 4, keep-with-next
   \   __absolute INT32U const Adc3En
   \                     Adc3En:
   \   00000000   0x00000003         DC32 3

   \                                 In section .bss, align 4
   \   __absolute INT16U ADC_AVR_VALUE0[100]
   \                     ADC_AVR_VALUE0:
   \   00000000                      DS8 200

   \                                 In section .bss, align 4
   \   __absolute INT16U ADC_AVR_VALUE1[100]
   \                     ADC_AVR_VALUE1:
   \   00000000                      DS8 200

   \                                 In section .data, align 4
   \   __absolute unsigned short *ADC_AVR[19]
   \                     ADC_AVR:
   \   00000000   0x........         DC32 ADC_AVR_VALUE0, ADC_AVR_VALUE1, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H
   \              0x........   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \   0000002C   0x00000000         DC32 0H, 0H, 0H, 0H, 0H
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \   00000040   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .data, align 4
   \   __absolute unsigned short *ADC3_AVR[19]
   \                     ADC3_AVR:
   \   00000000   0x........         DC32 ADC_AVR_VALUE0, ADC_AVR_VALUE1, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H, 0H
   \              0x........   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \   0000002C   0x00000000         DC32 0H, 0H, 0H, 0H, 0H
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \   00000040   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .bss, align 4
   \   __absolute INT16U ADC_DATA[19]
   \                     ADC_DATA:
   \   00000000                      DS8 40

   \                                 In section .bss, align 4
   \   __absolute INT32U ADC_SUM[19]
   \                     ADC_SUM:
   \   00000000                      DS8 76

   \                                 In section .bss, align 4
   \   __absolute INT8U ADCIndex
   \                     ADCIndex:
   \   00000000                      DS8 1
   \   __absolute INT8U ASTART
   \                     ASTART:
   \   00000001                      DS8 1
   \   __absolute INT8U ADC3Index
   \                     ADC3Index:
   \   00000002                      DS8 1
   \   __absolute INT8U ASTART3
   \                     ASTART3:
   \   00000003                      DS8 1
   \   __absolute INT8U ADCSTART[19]
   \                     ADCSTART:
   \   00000004                      DS8 20
   \   __absolute INT16U ADC_WRCNT[19]
   \                     ADC_WRCNT:
   \   00000018                      DS8 40

   \                                 In section .bss, align 4
   \   __absolute INT8U ADC3START[19]
   \                     ADC3START:
   \   00000000                      DS8 20
   \   __absolute INT16U ADC3_WRCNT[19]
   \                     ADC3_WRCNT:
   \   00000014                      DS8 40

   \                                 In section .bss, align 4
   \   __absolute INT16U ADC_DATA1[30]
   \                     ADC_DATA1:
   \   00000000                      DS8 60
     12          

   \                                 In section .text, align 2, keep-with-next
     13          void ADCInit(int INT_EN)
     14          {
   \                     ADCInit:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
     15          	INT32U cpu_sr;
     16          
     17          	ADC_Common_TypeDef *ADCb = ADC;
     18          	ADC_TypeDef *ADCx = ADC1;	
     19          //	ADC_TypeDef *ADCy = ADC2;	
     20          
     21          	OS_ENTER_CRITICAL();
   \   00000004   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000008   0x4605             MOV      R5,R0
     22          
     23          	ADCIndex = 0;
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable12
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x7001             STRB     R1,[R0, #+0]
     24          	ASTART = 0;
   \   00000012   0x7041             STRB     R1,[R0, #+1]
     25          
     26          	ADC3Index = 0;
   \   00000014   0x7081             STRB     R1,[R0, #+2]
     27          	ASTART3 = 0;
   \   00000016   0x70C1             STRB     R1,[R0, #+3]
     28          
     29          
     30          	ADCx->__B.SQR1.L = 0;	// 1EA
   \   00000018   0x.... 0x....      LDR.W    R6,??DataTable12_1  ;; 0x40012004
   \   0000001C   0x6AB0             LDR      R0,[R6, #+40]
   \   0000001E   0xF420 0x0070      BIC      R0,R0,#0xF00000
   \   00000022   0x62B0             STR      R0,[R6, #+40]
     31          	ADCx->__B.SQR3.SQ1 = 0; // Start Zer0
   \   00000024   0x6B30             LDR      R0,[R6, #+48]
   \   00000026   0x0940             LSRS     R0,R0,#+5
   \   00000028   0x0140             LSLS     R0,R0,#+5
   \   0000002A   0x6330             STR      R0,[R6, #+48]
     32          
     33          	NVIC_Init(ADC_IRQn, INT_EN);
   \   0000002C   0x4621             MOV      R1,R4
   \   0000002E   0x2012             MOVS     R0,#+18
   \   00000030   0x.... 0x....      BL       NVIC_Init
     34          
     35          	// ADC1 regular channel14 configuration
     36          	ADCx->__B.SMPR1.Data = 0x00FFFFFF;				// ADC_SampleTime_239Cycles5
   \   00000034   0xF06F 0x407F      MVN      R0,#-16777216
   \   00000038   0x60B0             STR      R0,[R6, #+8]
     37          	ADCx->__B.SMPR2.Data = 0x3FFFFFFF;				// ADC_SampleTime_239Cycles5
   \   0000003A   0xF06F 0x4040      MVN      R0,#-1073741824
   \   0000003E   0x60F0             STR      R0,[R6, #+12]
     38          
     39          	// ADC
     40          	ADCb->__B.CCR.MULT = __dMODE_INDEPENDENT;		// Multi ADC Mode
   \   00000040   0x....             LDR.N    R0,??DataTable12_2  ;; 0x40012304
   \   00000042   0x6801             LDR      R1,[R0, #+0]
   \   00000044   0x0949             LSRS     R1,R1,#+5
   \   00000046   0x0149             LSLS     R1,R1,#+5
   \   00000048   0x6001             STR      R1,[R0, #+0]
     41          //	ADCb->__B.CCR.MULT = __dMODE_FastInterl;		// Multi ADC Mode
     42          
     43          	ADCb->__B.CCR.DELAY = __DLY_5CYL;				// Delay between 2 sampling Phases
   \   0000004A   0x6801             LDR      R1,[R0, #+0]
   \   0000004C   0xF421 0x6170      BIC      R1,R1,#0xF00
   \   00000050   0x6001             STR      R1,[R0, #+0]
     44          //	ADCb->__B.CCR.DMA = __DMA_DISABLE;				// DMA Mode (for Multi ADC mode)
     45          	ADCb->__B.CCR.ADCPRE = __PRE_DIV8;				// PreScaler, 30MHz/8 = 3.75Mhz
   \   00000052   0x6801             LDR      R1,[R0, #+0]
   \   00000054   0xF441 0x3140      ORR      R1,R1,#0x30000
   \   00000058   0x6001             STR      R1,[R0, #+0]
     46          #if 0	
     47          	1개 67uSec   __PRE_DIV8
     48          	1개 33uSec   __PRE_DIV4
     49          	1개 16uSec   __PRE_DIV2
     50          #endif
     51          	ADCb->__B.CCR.VBATE = DISABLE;					// Delay between 2 sampling Phases
   \   0000005A   0x6801             LDR      R1,[R0, #+0]
   \   0000005C   0xF421 0x0180      BIC      R1,R1,#0x400000
   \   00000060   0x6001             STR      R1,[R0, #+0]
     52          	ADCb->__B.CCR.TSVREFE = ENABLE; 				// temperature sensor enable
   \   00000062   0x6801             LDR      R1,[R0, #+0]
   \   00000064   0xF441 0x0100      ORR      R1,R1,#0x800000
   \   00000068   0x6001             STR      R1,[R0, #+0]
     53          #if 1	
     54          	// ADC1 configuration
     55          	ADCx->__B.CR1.OVRIE = DISABLE;					// Overrun interrupt
   \   0000006A   0x6830             LDR      R0,[R6, #+0]
   \   0000006C   0xF020 0x6080      BIC      R0,R0,#0x4000000
   \   00000070   0x6030             STR      R0,[R6, #+0]
     56          	ADCx->__B.CR1.RES	= __RES_12BIT;					// Resolution
   \   00000072   0x6830             LDR      R0,[R6, #+0]
   \   00000074   0xF020 0x7040      BIC      R0,R0,#0x3000000
   \   00000078   0x6030             STR      R0,[R6, #+0]
     57          	ADCx->__B.CR1.AWDEN = DISABLE;					// Analog watchdog
   \   0000007A   0x6830             LDR      R0,[R6, #+0]
   \   0000007C   0xF420 0x0000      BIC      R0,R0,#0x800000
   \   00000080   0x6030             STR      R0,[R6, #+0]
     58          	ADCx->__B.CR1.SCAN = DISABLE;					// Scan Mode
   \   00000082   0x6830             LDR      R0,[R6, #+0]
   \   00000084   0xF420 0x7080      BIC      R0,R0,#0x100
   \   00000088   0x6030             STR      R0,[R6, #+0]
     59          	ADCx->__B.CR1.EOCIE = INT_EN;					// interrupt enable
   \   0000008A   0x6830             LDR      R0,[R6, #+0]
   \   0000008C   0xF364 0x1045      BFI      R0,R4,#+5,#+1
   \   00000090   0x6030             STR      R0,[R6, #+0]
     60          
     61          	ADCx->__B.CR2.CONT = DISABLE;					// Continuous Conversion
   \   00000092   0x6870             LDR      R0,[R6, #+4]
   \   00000094   0xF020 0x0002      BIC      R0,R0,#0x2
   \   00000098   0x6070             STR      R0,[R6, #+4]
     62          	ADCx->__B.CR2.DMAMODE = DISABLE;				// DMA Mode
   \   0000009A   0x6870             LDR      R0,[R6, #+4]
   \   0000009C   0xF420 0x7080      BIC      R0,R0,#0x100
   \   000000A0   0x6070             STR      R0,[R6, #+4]
     63          	ADCx->__B.CR2.DDS = DISABLE;					// DMA Disable selection (for single ADC mode)
   \   000000A2   0x6870             LDR      R0,[R6, #+4]
   \   000000A4   0xF420 0x7000      BIC      R0,R0,#0x200
   \   000000A8   0x6070             STR      R0,[R6, #+4]
     64          	ADCx->__B.CR2.ALIGN = __ALI_Right;				// Data Alignment
   \   000000AA   0x6870             LDR      R0,[R6, #+4]
   \   000000AC   0xF420 0x6000      BIC      R0,R0,#0x800
   \   000000B0   0x6070             STR      R0,[R6, #+4]
     65          	ADCx->__B.CR2.EXTSEL = __T1_CC1;				// Start conversion of regular channels
   \   000000B2   0x6870             LDR      R0,[R6, #+4]
   \   000000B4   0xF020 0x6070      BIC      R0,R0,#0xF000000
   \   000000B8   0x6070             STR      R0,[R6, #+4]
     66          	ADCx->__B.CR2.EXTEN = DISABLE;					// External Trigger Enable
   \   000000BA   0x6870             LDR      R0,[R6, #+4]
   \   000000BC   0xF020 0x5040      BIC      R0,R0,#0x30000000
   \   000000C0   0x6070             STR      R0,[R6, #+4]
     67          	ADCx->__B.CR2.ADON = ENABLE;					// Enable ADC1
   \   000000C2   0x6870             LDR      R0,[R6, #+4]
   \   000000C4   0xF040 0x0001      ORR      R0,R0,#0x1
   \   000000C8   0x6070             STR      R0,[R6, #+4]
     68          #endif
     69          #if 0
     70          
     71          	ADCy->__B.SQR1.L = 0;	// 1EA
     72          	ADCy->__B.SQR3.SQ1 = 0; // Start Zer0
     73          
     74          	// ADC1 regular channel14 configuration
     75          	ADCy->__B.SMPR1.Data = 0x00FFFFFF;				// ADC_SampleTime_239Cycles5
     76          	ADCy->__B.SMPR2.Data = 0x3FFFFFFF;				// ADC_SampleTime_239Cycles5
     77          
     78          	ADCy->__B.CR1.OVRIE = DISABLE;					// Overrun interrupt
     79          	ADCy->__B.CR1.RES	= __RES_12BIT;				// Resolution
     80          	ADCy->__B.CR1.AWDEN = DISABLE;					// Analog watchdog
     81          	ADCy->__B.CR1.SCAN = DISABLE;					// Scan Mode
     82          	ADCy->__B.CR1.EOCIE = INT_EN;					// interrupt enable
     83          
     84          	ADCy->__B.CR2.CONT = DISABLE;					// Continuous Conversion
     85          	ADCy->__B.CR2.DMAMODE = DISABLE;				// DMA Mode
     86          	ADCy->__B.CR2.DDS = DISABLE;					// DMA Disable selection (for single ADC mode)
     87          	ADCy->__B.CR2.ALIGN = __ALI_Right;				// Data Alignment
     88          	ADCy->__B.CR2.EXTSEL = __T1_CC1;				// Start conversion of regular channels
     89          	ADCy->__B.CR2.EXTEN = DISABLE;					// External Trigger Enable
     90          	ADCy->__B.CR2.ADON = ENABLE;					// Enable ADC1
     91          #endif
     92          	
     93          	// Start ADC1 Software Conversion
     94          	OS_EXIT_CRITICAL();
   \   000000CA   0x4628             MOV      R0,R5
   \   000000CC   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   000000D0   0x.... 0x....      B.W      OS_CPU_SR_Restore
     95          }
     96          
     97          

   \                                 In section .text, align 2, keep-with-next
     98          INT8U ADC_CheckFinish(INT8U channel)
     99          {
    100          	//SerPtr->printf("c111: %d, ADCSTART = %d\n", channel, ADCSTART[channel]);
    101          	if(ADCSTART[channel] == ADCFINISH) return TRUE;
   \                     ADC_CheckFinish:
   \   00000000   0x....             LDR.N    R1,??DataTable12
   \   00000002   0x1840             ADDS     R0,R0,R1
   \   00000004   0x7900             LDRB     R0,[R0, #+4]
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD101             BNE.N    ??ADC_CheckFinish_0
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x4770             BX       LR
    102          	return FALSE;
   \                     ??ADC_CheckFinish_0:
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4770             BX       LR               ;; return
    103          }
    104          

   \                                 In section .text, align 2, keep-with-next
    105          void ADC_ChannelEnable(INT8U channel)
    106          {
    107          	ADCSTART[channel] = ADCIDLE;
   \                     ADC_ChannelEnable:
   \   00000000   0x....             LDR.N    R1,??DataTable12
   \   00000002   0x1840             ADDS     R0,R0,R1
   \   00000004   0x2100             MOVS     R1,#+0
   \   00000006   0x7101             STRB     R1,[R0, #+4]
    108          }
   \   00000008   0x4770             BX       LR               ;; return
    109          
    110          
    111          
    112          

   \                                 In section .text, align 2, keep-with-next
    113          INT8U ADC3_CheckFinish(INT8U channel)
    114          {
    115          	//SerPtr->printf("c111: %d, ADCSTART = %d\n", channel, ADCSTART[channel]);
    116          	if(ADC3START[channel] == ADCFINISH) return TRUE;
   \                     ADC3_CheckFinish:
   \   00000000   0x....             LDR.N    R1,??DataTable12_3
   \   00000002   0x5C40             LDRB     R0,[R0, R1]
   \   00000004   0x2802             CMP      R0,#+2
   \   00000006   0xD101             BNE.N    ??ADC3_CheckFinish_0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
    117          	return FALSE;
   \                     ??ADC3_CheckFinish_0:
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
    118          }
    119          

   \                                 In section .text, align 2, keep-with-next
    120          void ADC3_ChannelEnable(INT8U channel)
    121          {
    122          	ADC3START[channel] = ADCIDLE;
   \                     ADC3_ChannelEnable:
   \   00000000   0x....             LDR.N    R1,??DataTable12_3
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x5442             STRB     R2,[R0, R1]
    123          }
   \   00000006   0x4770             BX       LR               ;; return
    124          
    125          
    126          /*******************************************************************************
    127          * Function Name  : ADC1_SWStart
    128          * Description    : get ADC Value directly(only case no_interrupt mode
    129          *                  group channel.
    130          * Input          : - channel: where x can be 1 or 2 to select the ADC channel
    131          * Output         : None
    132          * Return         : - direct ADCx channel 12 bit value
    133          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    134          void ADC1_SWStart(void)
    135          {
    136              int i;
    137          
    138          	if(ADC1->__B.CR1.EOCIE && ASTART == RESET)
   \                     ADC1_SWStart:
   \   00000000   0x....             LDR.N    R0,??DataTable12_1  ;; 0x40012004
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x0689             LSLS     R1,R1,#+26
   \   00000006   0xD400             BMI.N    ??ADC1_SWStart_0
   \   00000008   0x4770             BX       LR
   \                     ??ADC1_SWStart_0:
   \   0000000A   0xB4F0             PUSH     {R4-R7}
   \   0000000C   0x....             LDR.N    R1,??DataTable12
   \   0000000E   0x784A             LDRB     R2,[R1, #+1]
   \   00000010   0xBB2A             CBNZ.N   R2,??ADC1_SWStart_1
    139          	{
    140          		for(i = 0; i < __ADCMAX ; i++)
   \   00000012   0x2213             MOVS     R2,#+19
   \   00000014   0x2303             MOVS     R3,#+3
   \   00000016   0x2413             MOVS     R4,#+19
    141          		{
    142          			ADCIndex++;
    143          			ADCIndex %= __ADCMAX;
   \                     ??ADC1_SWStart_2:
   \   00000018   0x780D             LDRB     R5,[R1, #+0]
   \   0000001A   0x1C6D             ADDS     R5,R5,#+1
   \   0000001C   0xB2ED             UXTB     R5,R5
   \   0000001E   0xFB95 0xF6F4      SDIV     R6,R5,R4
   \   00000022   0xFB04 0x5516      MLS      R5,R4,R6,R5
   \   00000026   0x700D             STRB     R5,[R1, #+0]
    144          
    145          			if(((AdcEn >> ADCIndex) & 0x01) && ADCSTART[ADCIndex] == ADCIDLE)
   \   00000028   0x780D             LDRB     R5,[R1, #+0]
   \   0000002A   0xFA23 0xF605      LSR      R6,R3,R5
   \   0000002E   0x07F6             LSLS     R6,R6,#+31
   \   00000030   0xD513             BPL.N    ??ADC1_SWStart_3
   \   00000032   0x186F             ADDS     R7,R5,R1
   \   00000034   0x793E             LDRB     R6,[R7, #+4]
   \   00000036   0xB986             CBNZ.N   R6,??ADC1_SWStart_3
    146          			{
    147          				ADC_WRCNT[ADCIndex] = 0;
   \   00000038   0xEB01 0x0245      ADD      R2,R1,R5, LSL #+1
   \   0000003C   0x2300             MOVS     R3,#+0
   \   0000003E   0x8313             STRH     R3,[R2, #+24]
    148          				ASTART = SET;
   \   00000040   0x2201             MOVS     R2,#+1
   \   00000042   0x704A             STRB     R2,[R1, #+1]
    149          
    150          				ADCSTART[ADCIndex] = ADCING;
   \   00000044   0x713A             STRB     R2,[R7, #+4]
    151          				ADC1->__B.SQR3.SQ1 = ADCIndex;
   \   00000046   0x6B01             LDR      R1,[R0, #+48]
   \   00000048   0xF365 0x0104      BFI      R1,R5,#+0,#+5
   \   0000004C   0x6301             STR      R1,[R0, #+48]
    152          				ADC1->__B.CR2.SWSTART = ENABLE;
   \   0000004E   0x6841             LDR      R1,[R0, #+4]
   \   00000050   0xF041 0x4180      ORR      R1,R1,#0x40000000
   \   00000054   0x6041             STR      R1,[R0, #+4]
    153          				break;
   \   00000056   0xBCF0             POP      {R4-R7}
   \   00000058   0x4770             BX       LR
    154          			}
    155          		}
   \                     ??ADC1_SWStart_3:
   \   0000005A   0x1E52             SUBS     R2,R2,#+1
   \   0000005C   0xD1DC             BNE.N    ??ADC1_SWStart_2
    156          	}
    157          
    158          }
   \                     ??ADC1_SWStart_1:
   \   0000005E   0xBCF0             POP      {R4-R7}
   \   00000060   0x4770             BX       LR               ;; return
    159          

   \                                 In section .text, align 2, keep-with-next
    160          void ADC3_SWStart(void)
    161          {
    162              int i;
    163          
    164          	if(ADC2->__B.CR1.EOCIE && ASTART3 == RESET)
   \                     ADC3_SWStart:
   \   00000000   0x....             LDR.N    R0,??DataTable12_4  ;; 0x40012104
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x0689             LSLS     R1,R1,#+26
   \   00000006   0xD400             BMI.N    ??ADC3_SWStart_0
   \   00000008   0x4770             BX       LR
   \                     ??ADC3_SWStart_0:
   \   0000000A   0xB470             PUSH     {R4-R6}
   \   0000000C   0x....             LDR.N    R1,??DataTable12
   \   0000000E   0x78CA             LDRB     R2,[R1, #+3]
   \   00000010   0xBB2A             CBNZ.N   R2,??ADC3_SWStart_1
    165          	{
    166          		for(i = 0; i < __ADCMAX ; i++)
   \   00000012   0x2313             MOVS     R3,#+19
   \   00000014   0x....             LDR.N    R2,??DataTable12_3
   \   00000016   0x2413             MOVS     R4,#+19
    167          		{
    168          			ADC3Index++;
    169          			ADC3Index %= __ADCMAX;
   \                     ??ADC3_SWStart_2:
   \   00000018   0x788D             LDRB     R5,[R1, #+2]
   \   0000001A   0x1C6D             ADDS     R5,R5,#+1
   \   0000001C   0xB2ED             UXTB     R5,R5
   \   0000001E   0xFB95 0xF6F4      SDIV     R6,R5,R4
   \   00000022   0xFB04 0x5516      MLS      R5,R4,R6,R5
   \   00000026   0x708D             STRB     R5,[R1, #+2]
    170          
    171          			if(((Adc3En >> ADC3Index) & 0x01) && ADC3START[ADC3Index] == ADCIDLE)
   \   00000028   0x788D             LDRB     R5,[R1, #+2]
   \   0000002A   0x2603             MOVS     R6,#+3
   \   0000002C   0x40EE             LSRS     R6,R6,R5
   \   0000002E   0x07F6             LSLS     R6,R6,#+31
   \   00000030   0xD513             BPL.N    ??ADC3_SWStart_3
   \   00000032   0x5CAE             LDRB     R6,[R5, R2]
   \   00000034   0xB98E             CBNZ.N   R6,??ADC3_SWStart_3
    172          			{
    173          				ADC3_WRCNT[ADC3Index] = 0;
   \   00000036   0xEB02 0x0345      ADD      R3,R2,R5, LSL #+1
   \   0000003A   0x2400             MOVS     R4,#+0
   \   0000003C   0x829C             STRH     R4,[R3, #+20]
    174          				ASTART3 = SET;
   \   0000003E   0x2301             MOVS     R3,#+1
   \   00000040   0x70CB             STRB     R3,[R1, #+3]
    175          
    176          				ADC3START[ADCIndex] = ADCING;
   \   00000042   0x7809             LDRB     R1,[R1, #+0]
   \   00000044   0x548B             STRB     R3,[R1, R2]
    177          				ADC2->__B.SQR3.SQ1 = ADCIndex;
   \   00000046   0x6B02             LDR      R2,[R0, #+48]
   \   00000048   0xF361 0x0204      BFI      R2,R1,#+0,#+5
   \   0000004C   0x6302             STR      R2,[R0, #+48]
    178          				ADC2->__B.CR2.SWSTART = ENABLE;
   \   0000004E   0x6841             LDR      R1,[R0, #+4]
   \   00000050   0xF041 0x4180      ORR      R1,R1,#0x40000000
   \   00000054   0x6041             STR      R1,[R0, #+4]
    179          				break;
   \   00000056   0xBC70             POP      {R4-R6}
   \   00000058   0x4770             BX       LR
    180          			}
    181          		}
   \                     ??ADC3_SWStart_3:
   \   0000005A   0x1E5B             SUBS     R3,R3,#+1
   \   0000005C   0xD1DC             BNE.N    ??ADC3_SWStart_2
    182          	}
    183          
    184          }
   \                     ??ADC3_SWStart_1:
   \   0000005E   0xBC70             POP      {R4-R6}
   \   00000060   0x4770             BX       LR               ;; return
    185          
    186          
    187          
    188          /*******************************************************************************
    189          * Function Name  : GetAdcValue
    190          * Description    : get ADC Value directly(only case no_interrupt mode
    191          *                  group channel.
    192          * Input          : - channel: where x can be 1 or 2 to select the ADC channel
    193          * Output         : None
    194          * Return         : - direct ADCx channel 12 bit value
    195          *******************************************************************************/
    196          

   \                                 In section .text, align 2, keep-with-next
    197          INT16U GetAdcValue(INT8U channel)
    198          {
    199          
    200          //	ADC1->__B.CR2.SWSTART = ENABLE;
    201          
    202          	if(!ADC1->__B.CR2.ADON) return 0;
   \                     GetAdcValue:
   \   00000000   0x....             LDR.N    R1,??DataTable12_5  ;; 0x40012000
   \   00000002   0x688A             LDR      R2,[R1, #+8]
   \   00000004   0x07D2             LSLS     R2,R2,#+31
   \   00000006   0xD514             BPL.N    ??GetAdcValue_0
    203          	if(!ADC1->__B.CR1.EOCIE)
   \   00000008   0x684A             LDR      R2,[R1, #+4]
   \   0000000A   0x0692             LSLS     R2,R2,#+26
   \   0000000C   0xD411             BMI.N    ??GetAdcValue_0
    204          	{
    205          		ADC1->__B.SQR3.SQ1 = channel;
   \   0000000E   0x6B4A             LDR      R2,[R1, #+52]
   \   00000010   0xF360 0x0204      BFI      R2,R0,#+0,#+5
   \   00000014   0x634A             STR      R2,[R1, #+52]
    206          		ADC1->__B.CR2.SWSTART = ENABLE;		// ADC1->CONVERTER START
   \   00000016   0x688A             LDR      R2,[R1, #+8]
   \   00000018   0xF042 0x4280      ORR      R2,R2,#0x40000000
   \   0000001C   0x608A             STR      R2,[R1, #+8]
    207          		
    208          		while(!ADC1->__B.SR.EOC);
   \                     ??GetAdcValue_1:
   \   0000001E   0x680A             LDR      R2,[R1, #+0]
   \   00000020   0x0792             LSLS     R2,R2,#+30
   \   00000022   0xD5FC             BPL.N    ??GetAdcValue_1
    209          		ADC_DATA[channel] = ADC1->DR;
   \   00000024   0x....             LDR.N    R2,??DataTable12_6
   \   00000026   0x6CC9             LDR      R1,[R1, #+76]
   \   00000028   0xF822 0x1010      STRH     R1,[R2, R0, LSL #+1]
    210          		return ADC_DATA[channel];
   \   0000002C   0xF832 0x0010      LDRH     R0,[R2, R0, LSL #+1]
   \   00000030   0x4770             BX       LR
    211          	}
    212          	return 0;
   \                     ??GetAdcValue_0:
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x4770             BX       LR               ;; return
    213          }
    214          
    215          
    216          // Return Value는 1000배가 곱한 값이다. ex) 3.403[V]->3403 return 됨..
    217          // 12bit Value
    218          

   \                                 In section .text, align 2, keep-with-next
    219          INT16U AdctoVolt33V(INT16U Data)
    220          {
    221          	INT32U RetVal;
    222          
    223          	RetVal = (((Data)*3300) / (1 << 12));
    224              return (INT16U)RetVal;
   \                     AdctoVolt33V:
   \   00000000   0xF640 0x41E4      MOVW     R1,#+3300
   \   00000004   0x4348             MULS     R0,R1,R0
   \   00000006   0x12C1             ASRS     R1,R0,#+11
   \   00000008   0xEB00 0x5011      ADD      R0,R0,R1, LSR #+20
   \   0000000C   0x....             B.N      ?Subroutine0
    225          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0x0100             LSLS     R0,R0,#+4
   \   00000002   0x0C00             LSRS     R0,R0,#+16
   \   00000004   0x4770             BX       LR               ;; return
    226          

   \                                 In section .text, align 2, keep-with-next
    227          INT16U AdctoVolt5opamp(INT16U Data)
    228          {
    229          	INT32U  RetVal;
    230          
    231          	RetVal = ( (((INT32U)(Data)*3300)/665 )*(665 + 340))/(1 << 12);
    232          
    233              return (INT16U)RetVal;
   \                     AdctoVolt5opamp:
   \   00000000   0xF640 0x41E4      MOVW     R1,#+3300
   \   00000004   0x4348             MULS     R0,R1,R0
   \   00000006   0xF240 0x2199      MOVW     R1,#+665
   \   0000000A   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000000E   0xF240 0x31ED      MOVW     R1,#+1005
   \   00000012   0x4348             MULS     R0,R1,R0
   \   00000014                      REQUIRE ?Subroutine0
   \   00000014                      ;; // Fall through to label ?Subroutine0
    234          }
    235          

   \                                 In section .text, align 2, keep-with-next
    236          void SwapData(INT16U *a, INT16U *b)
    237          {
    238          	INT16U temp = *a;
   \                     SwapData:
   \   00000000   0x8802             LDRH     R2,[R0, #+0]
    239          
    240          	*a = *b;
   \   00000002   0x880B             LDRH     R3,[R1, #+0]
   \   00000004   0x8003             STRH     R3,[R0, #+0]
    241          	
    242          	*b = temp;
   \   00000006   0x800A             STRH     R2,[R1, #+0]
    243          }
   \   00000008   0x4770             BX       LR               ;; return
    244          
    245          
    246          //
    247          
    248          /*******************************************************************************
    249          * Function Name  : SelectSortMax
    250          * Description    : 각 ADC값들을내림차순으로 정리하여, 낮은수치 몇개를 정리하여 높은수로만 평균값함..
    251          *				   GARBAGENO: 버리는 낮은 값들.. 1이면 낮은값 1개를 버린다.
    252          *
    253          *					이 함수는 인터럽트 내에서 average를 취하지 않을 때,
    254          *					메인 호출 함수 내에서 호출하여 사용한다.
    255          * Input          : - aptr: 각 Channel의 ADC DATA들...(ADC_AVR)
    256          * Output         : None
    257          * Return         : 높은수 값들의 평균값.
    258          * Example		 : ADC_DATA[ADC_Channel_0] = SelectSort(ADC_AVR[ADC_Channel_0]);
    259          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    260          INT16U SelectAverage(INT16U *aptr, INT16U nlen)
    261          {
    262          	int i = 0;
    263          	INT32U sum = 0;
   \                     SelectAverage:
   \   00000000   0x2200             MOVS     R2,#+0
    264          	for(i = 0 ; i < nlen; i++)
   \   00000002   0x000B             MOVS     R3,R1
   \   00000004   0xD004             BEQ.N    ??SelectAverage_0
    265          	{
    266          		sum += aptr[i];
   \                     ??SelectAverage_1:
   \   00000006   0xF830 0xCB02      LDRH     R12,[R0], #+2
   \   0000000A   0x4462             ADD      R2,R12,R2
    267          	}
   \   0000000C   0x1E49             SUBS     R1,R1,#+1
   \   0000000E   0xD1FA             BNE.N    ??SelectAverage_1
    268          
    269          	return (INT16U)(sum/nlen);
   \                     ??SelectAverage_0:
   \   00000010   0xFBB2 0xF0F3      UDIV     R0,R2,R3
   \   00000014   0xB280             UXTH     R0,R0
   \   00000016   0x4770             BX       LR               ;; return
    270          	
    271          }
    272          
    273          

   \                                 In section .text, align 2, keep-with-next
    274          INT16U SelectMax(INT16U *aptr, INT16U nlen)
    275          {
    276          	int i = 0;
    277          	INT16U tmpMax = 0;
   \                     SelectMax:
   \   00000000   0x2200             MOVS     R2,#+0
    278          	for(i = 0 ; i < nlen; i++)
   \   00000002   0xB131             CBZ.N    R1,??SelectMax_0
    279          	{
    280          		if(tmpMax < aptr[i]) tmpMax = aptr[i];
   \                     ??SelectMax_1:
   \   00000004   0x8803             LDRH     R3,[R0, #+0]
   \   00000006   0x429A             CMP      R2,R3
   \   00000008   0xBF38             IT       CC 
   \   0000000A   0x461A             MOVCC    R2,R3
    281          	}
   \   0000000C   0x1C80             ADDS     R0,R0,#+2
   \   0000000E   0x1E49             SUBS     R1,R1,#+1
   \   00000010   0xD1F8             BNE.N    ??SelectMax_1
    282          
    283          	return tmpMax;
   \                     ??SelectMax_0:
   \   00000012   0x4610             MOV      R0,R2
   \   00000014   0x4770             BX       LR               ;; return
    284          }
    285          
    286          

   \                                 In section .text, align 2, keep-with-next
    287          INT16U SelectSortMax(INT16U *aptr, INT16U nlen)
    288          {
   \                     SelectSortMax:
   \   00000000   0xB4F0             PUSH     {R4-R7}
    289          	int i, j ;
    290          
    291          	if(nlen > __ADCAVR) nlen = __ADCAVR;
   \   00000002   0x2965             CMP      R1,#+101
   \   00000004   0xBF28             IT       CS 
   \   00000006   0x2164             MOVCS    R1,#+100
    292          
    293          	for(i = 0 ; i < nlen - 1; i++)
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x1E4B             SUBS     R3,R1,#+1
   \   0000000C   0x2B01             CMP      R3,#+1
   \   0000000E   0xDB18             BLT.N    ??SelectSortMax_0
   \   00000010   0x4604             MOV      R4,R0
    294          	{
    295          
    296          		for(j = i+1; j < nlen; j++ )
   \                     ??SelectSortMax_1:
   \   00000012   0x1C52             ADDS     R2,R2,#+1
   \   00000014   0x4615             MOV      R5,R2
   \   00000016   0x428A             CMP      R2,R1
   \   00000018   0xDA10             BGE.N    ??SelectSortMax_2
   \   0000001A   0xEB00 0x0645      ADD      R6,R0,R5, LSL #+1
    297          		{
    298          			if(aptr[i] > aptr[j])
   \                     ??SelectSortMax_3:
   \   0000001E   0x8837             LDRH     R7,[R6, #+0]
   \   00000020   0xF8B4 0xC000      LDRH     R12,[R4, #+0]
   \   00000024   0x4567             CMP      R7,R12
   \   00000026   0xD205             BCS.N    ??SelectSortMax_4
    299          			{
    300          				SwapData( &aptr[i] , &aptr[j]) ;
   \   00000028   0x4667             MOV      R7,R12
   \   0000002A   0xF8B6 0xC000      LDRH     R12,[R6, #+0]
   \   0000002E   0xF8A4 0xC000      STRH     R12,[R4, #+0]
   \   00000032   0x8037             STRH     R7,[R6, #+0]
    301          			}
    302          		}
   \                     ??SelectSortMax_4:
   \   00000034   0x1C6D             ADDS     R5,R5,#+1
   \   00000036   0x1CB6             ADDS     R6,R6,#+2
   \   00000038   0x428D             CMP      R5,R1
   \   0000003A   0xDBF0             BLT.N    ??SelectSortMax_3
    303           	}
   \                     ??SelectSortMax_2:
   \   0000003C   0x1CA4             ADDS     R4,R4,#+2
   \   0000003E   0x429A             CMP      R2,R3
   \   00000040   0xDBE7             BLT.N    ??SelectSortMax_1
    304          	return aptr[nlen-1];
   \                     ??SelectSortMax_0:
   \   00000042   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \   00000046   0xF830 0x0C02      LDRH     R0,[R0, #-2]
   \   0000004A   0xBCF0             POP      {R4-R7}
   \   0000004C   0x4770             BX       LR               ;; return
    305          }
    306          
    307          
    308          /*******************************************************************************
    309          * Function Name  : SelectSort
    310          * Description    : 각 ADC값들을내림차순으로 정리하여, 낮은수치 몇개를 정리하여 높은수로만 평균값함..
    311          *				   GARBAGENO: 버리는 낮은 값들.. 1이면 낮은값 1개를 버린다.
    312          *
    313          *					이 함수는 인터럽트 내에서 average를 취하지 않을 때,
    314          *					메인 호출 함수 내에서 호출하여 사용한다.
    315          * Input          : - aptr: 각 Channel의 ADC DATA들...(ADC_AVR)
    316          * Output         : None
    317          * Return         : 높은수 값들의 평균값.
    318          * Example		 : ADC_DATA[ADC_Channel_0] = SelectSort(ADC_AVR[ADC_Channel_0]);
    319          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    320          INT16U SelectSort(INT16U *aptr, INT16U MAXGARBAGENO, INT16U MINGARBAGENO, INT16U nlen)
    321          {
   \                     SelectSort:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB0B2             SUB      SP,SP,#+200
    322          	int sum = 0;
   \   00000006   0x2400             MOVS     R4,#+0
    323          	int i , j ;
    324          	INT32U sumtotal;
    325          	INT16U tbuf[__ADCAVR];
    326          
    327          	if(nlen > __ADCAVR) nlen = __ADCAVR;
   \   00000008   0x2B65             CMP      R3,#+101
   \   0000000A   0xBF28             IT       CS 
   \   0000000C   0x2364             MOVCS    R3,#+100
   \   0000000E   0x....             B.N      ?Subroutine1
    328          
    329          	for(i = 0; i < nlen; i++)
    330          	{
    331          		tbuf[i] = aptr[i];
    332          		sumtotal += aptr[i]; 
    333          	}
    334          
    335          	for(i = 0 ; i < nlen - 1; i++)
    336          	{
    337          
    338          		for(j = i+1; j < nlen; j++ )
    339          		{
    340          			if(tbuf[i] > tbuf[j])
    341          			{
    342          				SwapData( &tbuf[i] , &tbuf[j]) ;
    343          			}
    344          		}
    345           	}
    346          
    347          	for(i = MINGARBAGENO; i < nlen - MAXGARBAGENO; i++)
    348          	{
    349          		sum += tbuf[i];
    350          	}
    351          
    352          	return (INT16U)(sum/(nlen-MAXGARBAGENO-MINGARBAGENO));
    353          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0xD200             BCS.N    ??Subroutine1_0
   \   00000002   0xB13B             CBZ.N    R3,??Subroutine1_1
   \                     ??Subroutine1_0:
   \   00000004   0xAD00             ADD      R5,SP,#+0
   \   00000006   0x461E             MOV      R6,R3
   \                     ??Subroutine1_2:
   \   00000008   0xF830 0x7B02      LDRH     R7,[R0], #+2
   \   0000000C   0xF825 0x7B02      STRH     R7,[R5], #+2
   \   00000010   0x1E76             SUBS     R6,R6,#+1
   \   00000012   0xD1F9             BNE.N    ??Subroutine1_2
   \                     ??Subroutine1_1:
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x1E5D             SUBS     R5,R3,#+1
   \   00000018   0x2D01             CMP      R5,#+1
   \   0000001A   0xDB1B             BLT.N    ??Subroutine1_3
   \   0000001C   0xAE00             ADD      R6,SP,#+0
   \                     ??Subroutine1_4:
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0x4680             MOV      R8,R0
   \   00000022   0x4298             CMP      R0,R3
   \   00000024   0xDA13             BGE.N    ??Subroutine1_5
   \   00000026   0xAF00             ADD      R7,SP,#+0
   \   00000028   0xEB07 0x0C48      ADD      R12,R7,R8, LSL #+1
   \                     ??Subroutine1_6:
   \   0000002C   0xF8BC 0xE000      LDRH     LR,[R12, #+0]
   \   00000030   0x8837             LDRH     R7,[R6, #+0]
   \   00000032   0x45BE             CMP      LR,R7
   \   00000034   0xD205             BCS.N    ??Subroutine1_7
   \   00000036   0x46BE             MOV      LR,R7
   \   00000038   0xF8BC 0x7000      LDRH     R7,[R12, #+0]
   \   0000003C   0x8037             STRH     R7,[R6, #+0]
   \   0000003E   0xF8AC 0xE000      STRH     LR,[R12, #+0]
   \                     ??Subroutine1_7:
   \   00000042   0xF108 0x0801      ADD      R8,R8,#+1
   \   00000046   0xF10C 0x0C02      ADD      R12,R12,#+2
   \   0000004A   0x4598             CMP      R8,R3
   \   0000004C   0xDBEE             BLT.N    ??Subroutine1_6
   \                     ??Subroutine1_5:
   \   0000004E   0x1CB6             ADDS     R6,R6,#+2
   \   00000050   0x42A8             CMP      R0,R5
   \   00000052   0xDBE4             BLT.N    ??Subroutine1_4
   \                     ??Subroutine1_3:
   \   00000054   0x4610             MOV      R0,R2
   \   00000056   0x1A59             SUBS     R1,R3,R1
   \   00000058   0x428A             CMP      R2,R1
   \   0000005A   0xDA08             BGE.N    ??Subroutine1_8
   \   0000005C   0xAB00             ADD      R3,SP,#+0
   \   0000005E   0xEB03 0x0340      ADD      R3,R3,R0, LSL #+1
   \                     ??Subroutine1_9:
   \   00000062   0xF833 0x5B02      LDRH     R5,[R3], #+2
   \   00000066   0x192C             ADDS     R4,R5,R4
   \   00000068   0x1C40             ADDS     R0,R0,#+1
   \   0000006A   0x4288             CMP      R0,R1
   \   0000006C   0xDBF9             BLT.N    ??Subroutine1_9
   \                     ??Subroutine1_8:
   \   0000006E   0x1A88             SUBS     R0,R1,R2
   \   00000070   0xFB94 0xF0F0      SDIV     R0,R4,R0
   \   00000074   0xB280             UXTH     R0,R0
   \   00000076   0xB032             ADD      SP,SP,#+200
   \   00000078   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    354          
    355          
    356          /*******************************************************************************
    357          * Function Name  : ADC_IRQHandler(period = 40us): 1000= 25
    358          * Description    : Enables or disables the selected ADC software start conversion .
    359          * Input          : - ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
    360          *                  - NewState: new state of the selected ADC software start conversion.
    361          *                    This parameter can be: ENABLE or DISABLE.
    362          * Output         : None
    363          * Return         : None
    364          *******************************************************************************/
    365          

   \                                 In section .text, align 2, keep-with-next
    366          void ADC_IRQInitHandler(void)
    367          {
   \                     ADC_IRQInitHandler:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    368          //	OSIntEnter();
    369          	INT32U cpu_sr;
    370          
    371          	CPU_CRITICAL_ENTER();										// Tell uC/OS-II that we are starting an ISR
   \   00000002   0x.... 0x....      BL       CPU_SR_Save
    372          	OSIntNesting++;
   \   00000006   0x....             LDR.N    R1,??DataTable12_7
   \   00000008   0x780A             LDRB     R2,[R1, #+0]
   \   0000000A   0x1C52             ADDS     R2,R2,#+1
   \   0000000C   0x700A             STRB     R2,[R1, #+0]
    373          	CPU_CRITICAL_EXIT();
   \   0000000E   0x.... 0x....      BL       CPU_SR_Restore
    374          
    375          //	if (ADC1->__B.SR.EOC)
    376          	{		
    377          		ADC_AVR[ADCIndex][ ADC_WRCNT[ADCIndex] ] = ADC1->DR;
   \   00000012   0x....             LDR.N    R0,??DataTable12
   \   00000014   0x7801             LDRB     R1,[R0, #+0]
   \   00000016   0xEB00 0x0241      ADD      R2,R0,R1, LSL #+1
   \   0000001A   0x....             LDR.N    R3,??DataTable12_8  ;; 0x40012008
   \   0000001C   0x8B14             LDRH     R4,[R2, #+24]
   \   0000001E   0x....             LDR.N    R5,??DataTable12_9
   \   00000020   0xF855 0x5021      LDR      R5,[R5, R1, LSL #+2]
   \   00000024   0x6C5E             LDR      R6,[R3, #+68]
   \   00000026   0xF825 0x6014      STRH     R6,[R5, R4, LSL #+1]
    378          
    379          		if(++ADC_WRCNT[ADCIndex] >= AdcBuffMax[ADCIndex])
   \   0000002A   0x8B14             LDRH     R4,[R2, #+24]
   \   0000002C   0x1C64             ADDS     R4,R4,#+1
   \   0000002E   0x8314             STRH     R4,[R2, #+24]
   \   00000030   0xB2A4             UXTH     R4,R4
   \   00000032   0x.... 0x....      ADR.W    R5,AdcBuffMax
   \   00000036   0xF855 0x5021      LDR      R5,[R5, R1, LSL #+2]
   \   0000003A   0x42AC             CMP      R4,R5
   \   0000003C   0xD306             BCC.N    ??ADC_IRQInitHandler_0
    380          		{
    381          			ADC_WRCNT[ADCIndex] = 0;
   \   0000003E   0x2300             MOVS     R3,#+0
   \   00000040   0x8313             STRH     R3,[R2, #+24]
    382          			ADCSTART[ADCIndex] = ADCFINISH;
   \   00000042   0x1809             ADDS     R1,R1,R0
   \   00000044   0x2202             MOVS     R2,#+2
   \   00000046   0x710A             STRB     R2,[R1, #+4]
    383          			ASTART = FALSE;
   \   00000048   0x7043             STRB     R3,[R0, #+1]
   \   0000004A   0x....             B.N      ?Subroutine2
    384          		}
    385          		else{
    386          			ADC1->__B.CR2.SWSTART = ENABLE;
   \                     ??ADC_IRQInitHandler_0:
   \   0000004C   0x6818             LDR      R0,[R3, #+0]
   \   0000004E   0xF040 0x4080      ORR      R0,R0,#0x40000000
   \   00000052   0x6018             STR      R0,[R3, #+0]
    387          		}
    388          //		RUNLEDSEL ^= 1;
    389          	}
    390          #if 0
    391          	if (ADC2->__B.SR.EOC)
    392          	{		
    393          		ADC_AVR[ADCIndex][ ADC_WRCNT[ADCIndex] ] = ADC2->DR;
    394          
    395          		if(++ADC_WRCNT[ADCIndex] >= AdcBuffMax[ADCIndex])
    396          		{
    397          			ADC_WRCNT[ADCIndex] = 0;
    398          			ADCSTART[ADCIndex] = ADCFINISH;
    399          			ASTART = FALSE;
    400          		}
    401          		else{
    402          			ADC2->__B.CR2.SWSTART = ENABLE;
    403          		}
    404          //		RUNLEDSEL ^= 1;
    405          	}	
    406          #endif	
    407          //	RUNLEDSEL ^= 1;
    408          
    409          	OSIntExit();											// Tell uC/OS-II that we are leaving the ISR
   \   00000054                      REQUIRE ?Subroutine2
   \   00000054                      ;; // Fall through to label ?Subroutine2
    410          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000004   0x.... 0x....      B.W      OSIntExit
    411          
    412          
    413          
    414          

   \                                 In section .text, align 2, keep-with-next
    415          void ADC3_IRQInitHandler(void)
    416          {
   \                     ADC3_IRQInitHandler:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    417          //	OSIntEnter();
    418          	INT32U cpu_sr;
    419          
    420          	CPU_CRITICAL_ENTER();										// Tell uC/OS-II that we are starting an ISR
   \   00000002   0x.... 0x....      BL       CPU_SR_Save
    421          	OSIntNesting++;
   \   00000006   0x....             LDR.N    R1,??DataTable12_7
   \   00000008   0x780A             LDRB     R2,[R1, #+0]
   \   0000000A   0x1C52             ADDS     R2,R2,#+1
   \   0000000C   0x700A             STRB     R2,[R1, #+0]
    422          	CPU_CRITICAL_EXIT();
   \   0000000E   0x.... 0x....      BL       CPU_SR_Restore
    423          
    424          //	if (ADC1->__B.SR.EOC)
    425          	{		
    426          		ADC3_AVR[ADC3Index][ ADC3_WRCNT[ADC3Index] ] = ADC3->DR;
   \   00000012   0x....             LDR.N    R0,??DataTable12
   \   00000014   0x7881             LDRB     R1,[R0, #+2]
   \   00000016   0x....             LDR.N    R2,??DataTable12_3
   \   00000018   0xEB02 0x0441      ADD      R4,R2,R1, LSL #+1
   \   0000001C   0x....             LDR.N    R3,??DataTable12_10  ;; 0x40012208
   \   0000001E   0x8AA5             LDRH     R5,[R4, #+20]
   \   00000020   0x....             LDR.N    R6,??DataTable12_11
   \   00000022   0xF856 0x6021      LDR      R6,[R6, R1, LSL #+2]
   \   00000026   0x6C5F             LDR      R7,[R3, #+68]
   \   00000028   0xF826 0x7015      STRH     R7,[R6, R5, LSL #+1]
    427          
    428          		if(++ADC3_WRCNT[ADC3Index] >= Adc3BuffMax[ADC3Index])
   \   0000002C   0x8AA5             LDRH     R5,[R4, #+20]
   \   0000002E   0x1C6D             ADDS     R5,R5,#+1
   \   00000030   0x82A5             STRH     R5,[R4, #+20]
   \   00000032   0xB2AD             UXTH     R5,R5
   \   00000034   0x.... 0x....      ADR.W    R6,Adc3BuffMax
   \   00000038   0xF856 0x6021      LDR      R6,[R6, R1, LSL #+2]
   \   0000003C   0x42B5             CMP      R5,R6
   \   0000003E   0xD306             BCC.N    ??ADC3_IRQInitHandler_0
    429          		{
    430          			ADC3_WRCNT[ADC3Index] = 0;
   \   00000040   0x2300             MOVS     R3,#+0
   \   00000042   0x82A3             STRH     R3,[R4, #+20]
    431          			ADC3START[ADC3Index] = ADCFINISH;
   \   00000044   0x2302             MOVS     R3,#+2
   \   00000046   0x548B             STRB     R3,[R1, R2]
    432          			ASTART3 = FALSE;
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0x70C1             STRB     R1,[R0, #+3]
   \   0000004C   0xE003             B.N      ??ADC3_IRQInitHandler_1
    433          		}
    434          		else{
    435          			ADC3->__B.CR2.SWSTART = ENABLE;
   \                     ??ADC3_IRQInitHandler_0:
   \   0000004E   0x6818             LDR      R0,[R3, #+0]
   \   00000050   0xF040 0x4080      ORR      R0,R0,#0x40000000
   \   00000054   0x6018             STR      R0,[R3, #+0]
    436          		}
    437          	}
    438          	RUNLEDSEL ^= 1;
   \                     ??ADC3_IRQInitHandler_1:
   \   00000056   0x....             LDR.N    R0,??DataTable12_12  ;; 0x40020414
   \   00000058   0x6801             LDR      R1,[R0, #+0]
   \   0000005A   0xF081 0x0104      EOR      R1,R1,#0x4
   \   0000005E   0x6001             STR      R1,[R0, #+0]
    439          
    440          	OSIntExit();											// Tell uC/OS-II that we are leaving the ISR
   \   00000060   0xE8BD 0x40F1      POP      {R0,R4-R7,LR}
   \   00000064   0x.... 0x....      B.W      OSIntExit
    441          }
    442          

   \                                 In section .text, align 2, keep-with-next
    443          int ReadEnvTempTable(int Adcvalue)
    444          {
    445          	INT32S tmpx10 = AdctoVolt33V(Adcvalue);
    446          
    447          	tmpx10 = (tmpx10 - 500);
    448          
    449          	return tmpx10;	// 10배 값이 return 된다. 
   \                     ReadEnvTempTable:
   \   00000000   0xB280             UXTH     R0,R0
   \   00000002   0xF640 0x41E4      MOVW     R1,#+3300
   \   00000006   0x4348             MULS     R0,R1,R0
   \   00000008   0x12C1             ASRS     R1,R0,#+11
   \   0000000A   0xEB00 0x5011      ADD      R0,R0,R1, LSR #+20
   \   0000000E   0x0100             LSLS     R0,R0,#+4
   \   00000010   0x0C00             LSRS     R0,R0,#+16
   \   00000012   0xF5A0 0x70FA      SUB      R0,R0,#+500
   \   00000016   0x4770             BX       LR               ;; return
    450          }
    451          

   \                                 In section .text, align 2, keep-with-next
    452          void BubbleSort(INT16U array[], INT16U min, INT16U max)
    453          {
    454              // loop through every item in the array
    455              for (int i = min ; i <= max ; i++)
   \                     BubbleSort:
   \   00000000   0x428A             CMP      R2,R1
   \   00000002   0xDA00             BGE.N    ??BubbleSort_0
   \   00000004   0x4770             BX       LR
   \                     ??BubbleSort_0:
   \   00000006   0xB470             PUSH     {R4-R6}
    456              {
    457                  // loop a second time from the back of the array
    458                  for (int j = max ; j > i ; j--)
   \                     ??BubbleSort_1:
   \   00000008   0x4613             MOV      R3,R2
   \   0000000A   0x4291             CMP      R1,R2
   \   0000000C   0xDA0D             BGE.N    ??BubbleSort_2
   \   0000000E   0xEB00 0x0443      ADD      R4,R0,R3, LSL #+1
    459                  {
    460                      // swap the elements if necessary
    461                      if (array[j-1] > array[j])
   \                     ??BubbleSort_3:
   \   00000012   0xF834 0x5C02      LDRH     R5,[R4, #-2]
   \   00000016   0x8826             LDRH     R6,[R4, #+0]
   \   00000018   0x42AE             CMP      R6,R5
   \   0000001A   0xBF3C             ITT      CC 
   \   0000001C   0xF824 0x6C02      STRHCC   R6,[R4, #-2]
   \   00000020   0x8025             STRHCC   R5,[R4, #+0]
    462                      {
    463                          int copy = array[j-1] ;
    464                          array[j-1] = array[j] ;
    465                          array[j] = copy ;
    466                      }
    467                  }
   \   00000022   0x1E5B             SUBS     R3,R3,#+1
   \   00000024   0x1EA4             SUBS     R4,R4,#+2
   \   00000026   0x4299             CMP      R1,R3
   \   00000028   0xDBF3             BLT.N    ??BubbleSort_3
    468              }
   \                     ??BubbleSort_2:
   \   0000002A   0x1C49             ADDS     R1,R1,#+1
   \   0000002C   0x428A             CMP      R2,R1
   \   0000002E   0xDAEB             BGE.N    ??BubbleSort_1
    469          }
   \   00000030   0xBC70             POP      {R4-R6}
   \   00000032   0x4770             BX       LR               ;; return
    470           

   \                                 In section .text, align 2, keep-with-next
    471          INT16U Average_Sum(INT16U *aptr,INT16U AvgMAX, INT16U AvgMIN, INT16U nlen)
    472          {
   \                     Average_Sum:
   \   00000000   0xB430             PUSH     {R4,R5}
    473          	INT32U sum = 0;
   \   00000002   0x2400             MOVS     R4,#+0
    474              int i= 0;
    475          	for(i = AvgMIN; i < (nlen - AvgMAX); i++)
   \   00000004   0x4615             MOV      R5,R2
   \   00000006   0x1A59             SUBS     R1,R3,R1
   \   00000008   0x428A             CMP      R2,R1
   \   0000000A   0xDA07             BGE.N    ??Average_Sum_0
   \   0000000C   0xEB00 0x0045      ADD      R0,R0,R5, LSL #+1
    476          	{
    477          		sum += aptr[i];
   \                     ??Average_Sum_1:
   \   00000010   0xF830 0x3B02      LDRH     R3,[R0], #+2
   \   00000014   0x191C             ADDS     R4,R3,R4
    478          
    479          	}
   \   00000016   0x1C6D             ADDS     R5,R5,#+1
   \   00000018   0x428D             CMP      R5,R1
   \   0000001A   0xDBF9             BLT.N    ??Average_Sum_1
    480          	return sum = ((INT16U)(sum/(nlen- AvgMAX-AvgMIN)));
   \                     ??Average_Sum_0:
   \   0000001C   0x1A88             SUBS     R0,R1,R2
   \   0000001E   0xFBB4 0xF0F0      UDIV     R0,R4,R0
   \   00000022   0xB280             UXTH     R0,R0
   \   00000024   0xBC30             POP      {R4,R5}
   \   00000026   0x4770             BX       LR               ;; return
    481          }
    482          
    483          
    484          
    485          

   \                                 In section .text, align 2, keep-with-next
    486          INT16U SelectSort_1(INT16U *aptr,INT16U *AvgValue, INT16U *PeakValue, INT16U AvgMAX, INT16U AvgMIN, INT16U PeakMAX, INT16U PeakMIN, INT16U nlen)
    487          {
   \                     SelectSort_1:
   \   00000000   0xE92D 0x4FF6      PUSH     {R1,R2,R4-R11,LR}
   \   00000004   0xB0B2             SUB      SP,SP,#+200
   \   00000006   0x461C             MOV      R4,R3
   \   00000008   0x993D             LDR      R1,[SP, #+244]
   \   0000000A   0x9A3E             LDR      R2,[SP, #+248]
   \   0000000C   0x9B3F             LDR      R3,[SP, #+252]
   \   0000000E   0x9F40             LDR      R7,[SP, #+256]
    488          	int sum = 0;
   \   00000010   0xF04F 0x0800      MOV      R8,#+0
    489          	int sum1 = 0;
   \   00000014   0x46C2             MOV      R10,R8
    490          	
    491          	int i= 0 , j = 0;
   \   00000016   0x46C4             MOV      R12,R8
    492          	INT32U sumtotal;
    493          	INT16U tbuf[__ADCAVR];
    494          
    495          	if(nlen > __ADCAVR) nlen = __ADCAVR;
   \   00000018   0xB2BF             UXTH     R7,R7
   \   0000001A   0x2F65             CMP      R7,#+101
   \   0000001C   0xBF28             IT       CS 
   \   0000001E   0x2764             MOVCS    R7,#+100
   \   00000020   0xD201             BCS.N    ??SelectSort_1_0
    496          
    497          	for(i = 0; i < nlen; i++)
   \   00000022   0x2F01             CMP      R7,#+1
   \   00000024   0xDB08             BLT.N    ??SelectSort_1_1
    498          	{
    499          		tbuf[i] = aptr[i];
   \                     ??SelectSort_1_0:
   \   00000026   0xF830 0xE01C      LDRH     LR,[R0, R12, LSL #+1]
   \   0000002A   0xAD00             ADD      R5,SP,#+0
   \   0000002C   0xF825 0xE01C      STRH     LR,[R5, R12, LSL #+1]
    500          		sumtotal += aptr[i]; 
    501          	}
   \   00000030   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   00000034   0x45BC             CMP      R12,R7
   \   00000036   0xDBF6             BLT.N    ??SelectSort_1_0
    502          #if 1
    503          	for(i = 0 ; i < nlen - 1; i++)
   \                     ??SelectSort_1_1:
   \   00000038   0x46C4             MOV      R12,R8
   \   0000003A   0xF1A7 0x0B01      SUB      R11,R7,#+1
   \   0000003E   0xF1BB 0x0F01      CMP      R11,#+1
   \   00000042   0xDB1B             BLT.N    ??SelectSort_1_2
   \   00000044   0xAE00             ADD      R6,SP,#+0
    504          	{
    505          		for(j = i+1; j < nlen; j++ )
   \                     ??SelectSort_1_3:
   \   00000046   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   0000004A   0x46E6             MOV      LR,R12
   \   0000004C   0x45BC             CMP      R12,R7
   \   0000004E   0xDA12             BGE.N    ??SelectSort_1_4
   \   00000050   0xA800             ADD      R0,SP,#+0
   \   00000052   0xEB00 0x004E      ADD      R0,R0,LR, LSL #+1
    506          		{
    507          			if(tbuf[i] > tbuf[j])
   \                     ??SelectSort_1_5:
   \   00000056   0x8805             LDRH     R5,[R0, #+0]
   \   00000058   0xF8B6 0x9000      LDRH     R9,[R6, #+0]
   \   0000005C   0x454D             CMP      R5,R9
   \   0000005E   0xD205             BCS.N    ??SelectSort_1_6
    508          			{
    509          				SwapData( &tbuf[i] , &tbuf[j]) ;
   \   00000060   0x464D             MOV      R5,R9
   \   00000062   0xF8B0 0x9000      LDRH     R9,[R0, #+0]
   \   00000066   0xF8A6 0x9000      STRH     R9,[R6, #+0]
   \   0000006A   0x8005             STRH     R5,[R0, #+0]
    510          			}
    511          		}
   \                     ??SelectSort_1_6:
   \   0000006C   0xF10E 0x0E01      ADD      LR,LR,#+1
   \   00000070   0x1C80             ADDS     R0,R0,#+2
   \   00000072   0x45BE             CMP      LR,R7
   \   00000074   0xDBEF             BLT.N    ??SelectSort_1_5
    512           	}
   \                     ??SelectSort_1_4:
   \   00000076   0x1CB6             ADDS     R6,R6,#+2
   \   00000078   0x45DC             CMP      R12,R11
   \   0000007A   0xDBE4             BLT.N    ??SelectSort_1_3
    513          #endif
    514          	for(i = AvgMIN; i < (nlen - AvgMAX); i++)
   \                     ??SelectSort_1_2:
   \   0000007C   0xB289             UXTH     R1,R1
   \   0000007E   0x468C             MOV      R12,R1
   \   00000080   0x1B38             SUBS     R0,R7,R4
   \   00000082   0x4281             CMP      R1,R0
   \   00000084   0xDA09             BGE.N    ??SelectSort_1_7
   \   00000086   0xAC00             ADD      R4,SP,#+0
   \   00000088   0xEB04 0x044C      ADD      R4,R4,R12, LSL #+1
    515          	{
    516          		sum += tbuf[i];
   \                     ??SelectSort_1_8:
   \   0000008C   0xF834 0xEB02      LDRH     LR,[R4], #+2
   \   00000090   0x44F0             ADD      R8,LR,R8
    517          	}
   \   00000092   0xF10C 0x0C01      ADD      R12,R12,#+1
   \   00000096   0x4584             CMP      R12,R0
   \   00000098   0xDBF8             BLT.N    ??SelectSort_1_8
    518          	*AvgValue = ((INT16U)(sum/(nlen- AvgMAX-AvgMIN)));
   \                     ??SelectSort_1_7:
   \   0000009A   0x1A44             SUBS     R4,R0,R1
   \   0000009C   0xFB98 0xF4F4      SDIV     R4,R8,R4
   \   000000A0   0x9D32             LDR      R5,[SP, #+200]
   \   000000A2   0x802C             STRH     R4,[R5, #+0]
    519          
    520          
    521          	for(i = PeakMIN; i < (nlen - PeakMAX); i++)
   \   000000A4   0xB29B             UXTH     R3,R3
   \   000000A6   0x461C             MOV      R4,R3
   \   000000A8   0xB292             UXTH     R2,R2
   \   000000AA   0x1ABA             SUBS     R2,R7,R2
   \   000000AC   0x4293             CMP      R3,R2
   \   000000AE   0xDA08             BGE.N    ??SelectSort_1_9
   \   000000B0   0xAF00             ADD      R7,SP,#+0
   \   000000B2   0xEB07 0x0744      ADD      R7,R7,R4, LSL #+1
    522          	{
    523          //		SerPtr->printf("Sort[%d][%d]\n",i, tbuf[i]);
    524          
    525          		sum1 += tbuf[i];
   \                     ??SelectSort_1_10:
   \   000000B6   0xF837 0x5B02      LDRH     R5,[R7], #+2
   \   000000BA   0x44AA             ADD      R10,R5,R10
    526          	}
   \   000000BC   0x1C64             ADDS     R4,R4,#+1
   \   000000BE   0x4294             CMP      R4,R2
   \   000000C0   0xDBF9             BLT.N    ??SelectSort_1_10
    527          	*PeakValue = ((INT16U)(sum1/(nlen-PeakMAX-PeakMIN)));
   \                     ??SelectSort_1_9:
   \   000000C2   0x1AD2             SUBS     R2,R2,R3
   \   000000C4   0xFB9A 0xF2F2      SDIV     R2,R10,R2
   \   000000C8   0x9B33             LDR      R3,[SP, #+204]
   \   000000CA   0x801A             STRH     R2,[R3, #+0]
    528          
    529          	return (INT16U)(sum/(nlen-(AvgMAX-AvgMIN)));
   \   000000CC   0x1808             ADDS     R0,R1,R0
   \   000000CE   0xFB98 0xF0F0      SDIV     R0,R8,R0
   \   000000D2   0xB280             UXTH     R0,R0
   \   000000D4   0xB034             ADD      SP,SP,#+208
   \   000000D6   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    530          }
    531          
    532          
    533          

   \                                 In section .text, align 2, keep-with-next
    534          INT16U SelectSort_MinMax(INT16U *aptr, INT16U MAXGARBAGENO, INT16U MINGARBAGENO, INT16U nlen, INT8U Mode)
    535          {
   \                     SelectSort_MinMax:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB0B2             SUB      SP,SP,#+200
    536          	int sum = 0;
   \   00000006   0x2400             MOVS     R4,#+0
    537          	int i , j ;
    538          	INT16U tbuf[__ADCAVR];
    539          
    540          	if(nlen > __ADCAVR) nlen = __ADCAVR;
   \   00000008   0x2B65             CMP      R3,#+101
   \   0000000A   0xBF28             IT       CS 
   \   0000000C   0x2364             MOVCS    R3,#+100
   \   0000000E                      REQUIRE ?Subroutine1
   \   0000000E                      ;; // Fall through to label ?Subroutine1
    541          	
    542          	for(i = 0; i < nlen; i++)
    543          	{
    544          		tbuf[i] = aptr[i];
    545          	}
    546          
    547          	for(i = 0 ; i < nlen - 1; i++)
    548          	{
    549          		for(j = i+1; j < nlen; j++ )
    550          		{
    551          			if(tbuf[i] > tbuf[j])
    552          			{
    553          				SwapData( &tbuf[i] , &tbuf[j]);
    554          			}
    555          		}
    556           	}
    557          
    558          	for(i = MINGARBAGENO; i < (nlen - MAXGARBAGENO); i++)
    559          	{
    560          		sum += tbuf[i];
    561          
    562          		
    563          		#ifdef _DEBUG_Test
    564          		if(AmpSts->ShunDownValue == 2)
    565          		{
    566          			if(Mode == Enable)
    567          			{
    568          				pUSART2.printf("Sort[%d][%d]\n",i, tbuf[i]);
    569          			}
    570          		}
    571          		#endif
    572          	}
    573          
    574          	return (INT16U)(sum/(nlen-MAXGARBAGENO-MINGARBAGENO));
    575          }
    576          
    577          
    578          
    579          
    580          static int quick_sort_partition( INT16U array[], int start_pos, int end_pos)
    581          {
    582          
    583          	float pivot = array[start_pos];       // Smaller than pivot on left; larger on right
    584          	int left_index = start_pos;    // First element
    585          	int right_index = end_pos; // Last element
    586          
    587          	while ( 1 ) // Loop forever; return once partitioning is completed
    588          	{
    589          		// Skip over large elements on right
    590          
    591          		while ( array[right_index] > pivot && right_index >= start_pos )      
    592          		right_index--;
    593          
    594          		// Skip over small elements on left
    595          
    596          		while ( array[left_index] < pivot && left_index <= end_pos )        
    597          		left_index ++;                    
    598          
    599          		if ( left_index < right_index )          // Exchange if halves aren't complete
    600          		{
    601          			INT16U temp = array[left_index];
    602          
    603          			array[left_index] = array[right_index];
    604          
    605          			array[right_index] = temp;
    606          
    607          			left_index ++ ;                         // Skip over exchanged values
    608          			right_index -- ;
    609          		}
    610          	else                                            // Otherwise, return location of pivot
    611          
    612          	return  right_index;
    613          	}
    614          }
    615          
    616           
    617           

   \                                 In section .text, align 2, keep-with-next
    618          void quick_sort( INT16U array[], int start_pos, int end_pos)
    619          {
   \                     quick_sort:
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4690             MOV      R8,R2
    620          
    621             if ( start_pos == end_pos ) // Only one element
   \   0000000A   0x4545             CMP      R5,R8
   \   0000000C   0xD031             BEQ.N    ??quick_sort_0
    622             return;
    623          
    624             int middle_pos = quick_sort_partition( array, start_pos, end_pos);  // Reposition elements
   \                     ??quick_sort_1:
   \   0000000E   0xF834 0x0015      LDRH     R0,[R4, R5, LSL #+1]
   \   00000012   0x.... 0x....      BL       __aeabi_ui2f
   \   00000016   0x4681             MOV      R9,R0
   \   00000018   0x462E             MOV      R6,R5
   \   0000001A   0x4647             MOV      R7,R8
   \   0000001C   0xE007             B.N      ??quick_sort_2
   \                     ??quick_sort_3:
   \   0000001E   0xF834 0x0017      LDRH     R0,[R4, R7, LSL #+1]
   \   00000022   0xF824 0x0016      STRH     R0,[R4, R6, LSL #+1]
   \   00000026   0xF824 0xA017      STRH     R10,[R4, R7, LSL #+1]
   \   0000002A   0x1C76             ADDS     R6,R6,#+1
   \                     ??quick_sort_4:
   \   0000002C   0x1E7F             SUBS     R7,R7,#+1
   \                     ??quick_sort_2:
   \   0000002E   0xF834 0x0017      LDRH     R0,[R4, R7, LSL #+1]
   \   00000032   0x.... 0x....      BL       __aeabi_ui2f
   \   00000036   0x4601             MOV      R1,R0
   \   00000038   0x4648             MOV      R0,R9
   \   0000003A   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000003E   0xD203             BCS.N    ??quick_sort_5
   \   00000040   0x42AF             CMP      R7,R5
   \   00000042   0xDB01             BLT.N    ??quick_sort_5
   \   00000044   0xE7F2             B.N      ??quick_sort_4
   \                     ??quick_sort_6:
   \   00000046   0x1C76             ADDS     R6,R6,#+1
   \                     ??quick_sort_5:
   \   00000048   0xF834 0xA016      LDRH     R10,[R4, R6, LSL #+1]
   \   0000004C   0x4650             MOV      R0,R10
   \   0000004E   0x.... 0x....      BL       __aeabi_ui2f
   \   00000052   0x4649             MOV      R1,R9
   \   00000054   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000058   0xD201             BCS.N    ??quick_sort_7
   \   0000005A   0x45B0             CMP      R8,R6
   \   0000005C   0xDAF3             BGE.N    ??quick_sort_6
   \                     ??quick_sort_7:
   \   0000005E   0x42BE             CMP      R6,R7
   \   00000060   0xDBDD             BLT.N    ??quick_sort_3
    625          
    626             quick_sort( array, start_pos, middle_pos);          // Sort left half
   \   00000062   0x463A             MOV      R2,R7
   \   00000064   0x4629             MOV      R1,R5
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0xF7FF 0xFFCA      BL       quick_sort
    627             quick_sort( array, middle_pos + 1, end_pos);     	// Sort right half
   \   0000006C   0x1C7D             ADDS     R5,R7,#+1
    628          }
   \   0000006E   0x4545             CMP      R5,R8
   \   00000070   0xD1CD             BNE.N    ??quick_sort_1
   \                     ??quick_sort_0:
   \   00000072   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    629          
    630           
    631          
    632          

   \                                 In section .text, align 2, keep-with-next
    633          void SortSelect(INT16U *aptr, int start_pos, int end_pos)
    634          {
    635          	BubbleSort(aptr,start_pos,end_pos-1);
   \                     SortSelect:
   \   00000000   0x1E52             SUBS     R2,R2,#+1
   \   00000002   0xB292             UXTH     R2,R2
   \   00000004   0xB289             UXTH     R1,R1
   \   00000006   0x....             B.N      BubbleSort
    636          //	quick_sort(aptr,start_pos, end_pos-1);
    637          //	mergeSort(aptr,start_pos, end_pos-1);
    638          }
    639          

   \                                 In section .text, align 2, keep-with-next
    640          INT32U average_rssi(INT16U rssi[], int array_size)
    641          {
   \                     average_rssi:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    642          
    643          	INT16U sum = 0;
    644          	int i;
    645          
    646          	if(array_size > __ADCAVR) array_size = __ADCAVR;
   \   00000006   0x2D65             CMP      R5,#+101
   \   00000008   0xBFAE             ITEE     GE 
   \   0000000A   0x2564             MOVGE    R5,#+100
   \   0000000C   0x2600             MOVLT    R6,#+0
   \   0000000E   0x2D01             CMPLT    R5,#+1
    647          
    648          	for(i=0; i<array_size; i++)
   \   00000010   0xDB00             BLT.N    ??average_rssi_0
   \   00000012   0x462E             MOV      R6,R5
    649          	{
    650          	//	   SerPtr->printf("0 : array_size[%d][%d]>[%d]\n", i,rssi[i],array_size);
    651          	}
    652          
    653          	quick_sort(rssi, 0, array_size-1);
   \                     ??average_rssi_0:
   \   00000014   0x1E6A             SUBS     R2,R5,#+1
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x.... 0x....      BL       quick_sort
    654          
    655          	sum += rssi[i];
    656          
    657          	sum /= (array_size-20);
    658          
    659          	return sum;
   \   0000001C   0xF834 0x0016      LDRH     R0,[R4, R6, LSL #+1]
   \   00000020   0xF1A5 0x0114      SUB      R1,R5,#+20
   \   00000024   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000028   0xB280             UXTH     R0,R0
   \   0000002A   0xBD70             POP      {R4-R6,PC}       ;; return
    660          }
    661           

   \                                 In section .text, align 2, keep-with-next
    662          void insertionSort(INT16U array[], INT16U min, INT16U max)
    663          {
    664          	int key ;
    665          	// we loop through all elements in the original array from the second element
    666          	for (int j = 1 ; j <= max ; j++)
   \                     insertionSort:
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xB902             CBNZ.N   R2,??insertionSort_0
   \   00000004   0x4770             BX       LR
   \                     ??insertionSort_0:
   \   00000006   0xB4F0             PUSH     {R4-R7}
   \   00000008   0x1C83             ADDS     R3,R0,#+2
    667          	{
    668          		// store the current element as the key
    669          		key = array[j] ;
   \                     ??insertionSort_1:
   \   0000000A   0x881C             LDRH     R4,[R3, #+0]
    670          		// get the element just before the current element
    671          		int i = j - 1 ;
   \   0000000C   0x1E4D             SUBS     R5,R1,#+1
   \   0000000E   0xEB00 0x0645      ADD      R6,R0,R5, LSL #+1
   \                     ??insertionSort_2:
   \   00000012   0x8837             LDRH     R7,[R6, #+0]
   \   00000014   0x42BC             CMP      R4,R7
   \   00000016   0xDA04             BGE.N    ??insertionSort_3
    672          		// loop through all elements from the key to the start
    673          		// check if the current element is smaller than the key
    674          		while (i >= 0 && array[i] > key)
    675          		{
    676          		 // we move the current element backward
    677          		 array[i+1] = array[i] ;
   \   00000018   0x8077             STRH     R7,[R6, #+2]
    678          		 i-- ;
   \   0000001A   0x1E6D             SUBS     R5,R5,#+1
   \   0000001C   0x1EB6             SUBS     R6,R6,#+2
    679          		}
   \   0000001E   0x2D00             CMP      R5,#+0
   \   00000020   0xD5F7             BPL.N    ??insertionSort_2
    680          		// we finally move the key
    681          		array[i+1] = key ;
   \                     ??insertionSort_3:
   \   00000022   0xEB00 0x0545      ADD      R5,R0,R5, LSL #+1
   \   00000026   0x806C             STRH     R4,[R5, #+2]
    682          	}
   \   00000028   0x1C49             ADDS     R1,R1,#+1
   \   0000002A   0x1C9B             ADDS     R3,R3,#+2
   \   0000002C   0x428A             CMP      R2,R1
   \   0000002E   0xDAEC             BGE.N    ??insertionSort_1
    683          }
   \   00000030   0xBCF0             POP      {R4-R7}
   \   00000032   0x4770             BX       LR               ;; return
    684          
    685          

   \                                 In section .text, align 2, keep-with-next
    686          void mergeSort(INT16U array[], INT16U min, INT16U max)
    687          {
   \                     mergeSort:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
    688          	int i;
    689          	
    690          	for(i=0; i<max; i++)
    691          	{
    692          //	   SerPtr->printf("0 : array_size[%d][%d]>[%d]\n", i,array[i],max);
    693          	}
    694          
    695              // prerequisite
    696              if (min < max)
   \   00000008   0x42B5             CMP      R5,R6
   \   0000000A   0xD21D             BCS.N    ??mergeSort_0
    697              {
    698                  // get the middle point
    699                  int mid = (int)floor((max+min)/2) ;
   \   0000000C   0x19A8             ADDS     R0,R5,R6
   \   0000000E   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   00000012   0x1040             ASRS     R0,R0,#+1
   \   00000014   0x.... 0x....      BL       __aeabi_i2d
   \   00000018   0x.... 0x....      BL       floor
   \   0000001C   0x.... 0x....      BL       __aeabi_d2iz
   \   00000020   0x4607             MOV      R7,R0
    700                  
    701                  // apply merge sort to both parts of this
    702                  mergeSort(array, min, mid) ;
   \   00000022   0xB2BA             UXTH     R2,R7
   \   00000024   0x4629             MOV      R1,R5
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0xF7FF 0xFFEA      BL       mergeSort
    703                  mergeSort(array, mid+1, max) ;
   \   0000002C   0x4632             MOV      R2,R6
   \   0000002E   0x1C79             ADDS     R1,R7,#+1
   \   00000030   0xB289             UXTH     R1,R1
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0xF7FF 0xFFE4      BL       mergeSort
    704                  
    705                  // and finally merge all that sorted stuff
    706                  merge(array, min, max, mid) ;
   \   00000038   0xB2BB             UXTH     R3,R7
   \   0000003A   0x4632             MOV      R2,R6
   \   0000003C   0x4629             MOV      R1,R5
   \   0000003E   0x4620             MOV      R0,R4
   \   00000040   0xB001             ADD      SP,SP,#+4
   \   00000042   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \   00000046   0x....             B.N      merge
    707              }
    708          
    709          
    710          }
   \                     ??mergeSort_0:
   \   00000048   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    711          

   \                                 In section .text, align 2, keep-with-next
    712          void merge(INT16U array[], INT16U min, INT16U max, INT16U mid)
    713          {
   \                     merge:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB0E4             SUB      SP,SP,#+400
    714              int firstIndex = min ;
   \   00000006   0x460E             MOV      R6,R1
    715              int secondIndex = mid + 1 ;
   \   00000008   0x1C5D             ADDS     R5,R3,#+1
    716              int index = min ;
   \   0000000A   0x460C             MOV      R4,R1
   \   0000000C   0xAF00             ADD      R7,SP,#+0
   \   0000000E   0xE011             B.N      ??merge_0
    717          //    int tempArray[max] ;
    718              int tempArray[__ADCAVR] ;
    719              // if there are still objects in both arrays
    720              while ((firstIndex <= mid) && (secondIndex <= max))
    721              {
    722                  if (array[firstIndex] < array[secondIndex])
    723                  {
    724                      tempArray[index] = array[firstIndex] ;
    725                      index++ ;
    726                      firstIndex++ ;
    727                  }
    728                  else
    729                  {
    730                      tempArray[index] = array[secondIndex] ;
   \                     ??merge_1:
   \   00000010   0xF847 0xC024      STR      R12,[R7, R4, LSL #+2]
    731                      index++ ;
   \   00000014   0x4674             MOV      R4,LR
    732                      secondIndex++ ;
   \   00000016   0x1C6D             ADDS     R5,R5,#+1
   \                     ??merge_2:
   \   00000018   0x42AA             CMP      R2,R5
   \   0000001A   0xDB2D             BLT.N    ??merge_3
    733                  }
   \   0000001C   0xF830 0xC015      LDRH     R12,[R0, R5, LSL #+1]
   \   00000020   0xF830 0x8016      LDRH     R8,[R0, R6, LSL #+1]
   \   00000024   0xF104 0x0E01      ADD      LR,R4,#+1
   \   00000028   0x45E0             CMP      R8,R12
   \   0000002A   0xD2F1             BCS.N    ??merge_1
   \   0000002C   0xF847 0x8024      STR      R8,[R7, R4, LSL #+2]
   \   00000030   0x4674             MOV      R4,LR
   \   00000032   0x1C76             ADDS     R6,R6,#+1
    734              }
   \                     ??merge_0:
   \   00000034   0x42B3             CMP      R3,R6
   \   00000036   0xDAEF             BGE.N    ??merge_2
   \   00000038   0x42AA             CMP      R2,R5
   \   0000003A   0xDB0C             BLT.N    ??merge_4
   \   0000003C   0xEB00 0x0345      ADD      R3,R0,R5, LSL #+1
   \   00000040   0xAE00             ADD      R6,SP,#+0
   \   00000042   0xEB06 0x0684      ADD      R6,R6,R4, LSL #+2
    735              
    736              // terminates the object of the lower array
    737              while (firstIndex <= mid)
    738              {
    739                  tempArray[index] = array[firstIndex] ;
    740                  index++ ;
    741                  firstIndex++ ;
    742              }
    743              
    744              // terminates the object of the upper array
    745              while (secondIndex <= max)
    746              {
    747                  tempArray[index] = array[secondIndex] ;
   \                     ??merge_5:
   \   00000046   0xF833 0x7B02      LDRH     R7,[R3], #+2
   \   0000004A   0xF846 0x7B04      STR      R7,[R6], #+4
    748                  index++ ;
   \   0000004E   0x1C64             ADDS     R4,R4,#+1
    749                  secondIndex++ ;
   \   00000050   0x1C6D             ADDS     R5,R5,#+1
   \   00000052   0x42AA             CMP      R2,R5
   \   00000054   0xDAF7             BGE.N    ??merge_5
    750              }
    751              
    752              // transfer to the initial array
    753              for (int i = min ; i < index ; i++)
   \                     ??merge_4:
   \   00000056   0x42A1             CMP      R1,R4
   \   00000058   0xDA0B             BGE.N    ??merge_6
   \   0000005A   0xEB00 0x0041      ADD      R0,R0,R1, LSL #+1
   \   0000005E   0xAA00             ADD      R2,SP,#+0
   \   00000060   0xEB02 0x0281      ADD      R2,R2,R1, LSL #+2
    754                  array[i] = tempArray[i] ;
   \                     ??merge_7:
   \   00000064   0xF852 0x3B04      LDR      R3,[R2], #+4
   \   00000068   0xF820 0x3B02      STRH     R3,[R0], #+2
   \   0000006C   0x1C49             ADDS     R1,R1,#+1
   \   0000006E   0x42A1             CMP      R1,R4
   \   00000070   0xDBF8             BLT.N    ??merge_7
    755          }
   \                     ??merge_6:
   \   00000072   0xB064             ADD      SP,SP,#+400
   \   00000074   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??merge_3:
   \   00000078   0xF830 0x2016      LDRH     R2,[R0, R6, LSL #+1]
   \   0000007C   0xF847 0x2024      STR      R2,[R7, R4, LSL #+2]
   \   00000080   0x1C64             ADDS     R4,R4,#+1
   \   00000082   0x1C76             ADDS     R6,R6,#+1
   \   00000084   0x42B3             CMP      R3,R6
   \   00000086   0xDAF7             BGE.N    ??merge_3
   \   00000088   0xE7E5             B.N      ??merge_4
    756          

   \                                 In section .text, align 2, keep-with-next
    757          FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
    758          {
    759            FlagStatus bitstatus = RESET;
   \                     ADC_GetFlagStatus:
   \   00000000   0x2200             MOVS     R2,#+0
    760            /* Check the parameters */
    761            assert_param(IS_ADC_ALL_PERIPH(ADCx));
    762            assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
    763          
    764            /* Check the status of the specified ADC flag */
    765            if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xB2C0             UXTB     R0,R0
   \   00000006   0x4208             TST      R0,R1
   \   00000008   0xBF18             IT       NE 
   \   0000000A   0x2201             MOVNE    R2,#+1
    766            {
    767              /* ADC_FLAG is set */
    768              bitstatus = SET;
    769            }
    770            else
    771            {
    772              /* ADC_FLAG is reset */
    773              bitstatus = RESET;
    774            }
    775            /* Return the ADC_FLAG status */
    776            return  bitstatus;
   \   0000000C   0x4610             MOV      R0,R2
   \   0000000E   0x4770             BX       LR               ;; return
    777          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   0x........         DC32     ADCIndex

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_1:
   \   00000000   0x40012004         DC32     0x40012004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_2:
   \   00000000   0x40012304         DC32     0x40012304

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_3:
   \   00000000   0x........         DC32     ADC3START

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_4:
   \   00000000   0x40012104         DC32     0x40012104

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_5:
   \   00000000   0x40012000         DC32     0x40012000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_6:
   \   00000000   0x........         DC32     ADC_DATA

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_7:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_8:
   \   00000000   0x40012008         DC32     0x40012008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_9:
   \   00000000   0x........         DC32     ADC_AVR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_10:
   \   00000000   0x40012208         DC32     0x40012208

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_11:
   \   00000000   0x........         DC32     ADC3_AVR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable12_12:
   \   00000000   0x40020414         DC32     0x40020414
    778          
    779          
    780          /******************* (C) COPYRIGHT 2007 STMicroelectronics *****END OF FILE****/
    781          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  ADC1_SWStart
        0  ADC3_ChannelEnable
        0  ADC3_CheckFinish
       24  ADC3_IRQInitHandler
             24 -> CPU_SR_Restore
             24 -> CPU_SR_Save
              0 -> OSIntExit
       12  ADC3_SWStart
       16  ADCInit
             16 -> NVIC_Init
              0 -> OS_CPU_SR_Restore
             16 -> OS_CPU_SR_Save
        0  ADC_ChannelEnable
        0  ADC_CheckFinish
        0  ADC_GetFlagStatus
       16  ADC_IRQInitHandler
             16 -> CPU_SR_Restore
             16 -> CPU_SR_Save
              0 -> OSIntExit
        0  AdctoVolt33V
        0  AdctoVolt5opamp
        8  Average_Sum
       12  BubbleSort
        0  GetAdcValue
        0  ReadEnvTempTable
        0  SelectAverage
        0  SelectMax
      224  SelectSort
       16  SelectSortMax
      244  SelectSort_1
      224  SelectSort_MinMax
        0  SortSelect
              0 -> BubbleSort
        0  SwapData
       16  average_rssi
             16 -> quick_sort
       16  insertionSort
      424  merge
       24  mergeSort
             24 -> __aeabi_d2iz
             24 -> __aeabi_i2d
             24 -> floor
              0 -> merge
             24 -> mergeSort
       32  quick_sort
             32 -> __aeabi_cfcmple
             32 -> __aeabi_ui2f
             32 -> quick_sort


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_10
       4  ??DataTable12_11
       4  ??DataTable12_12
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable12_4
       4  ??DataTable12_5
       4  ??DataTable12_6
       4  ??DataTable12_7
       4  ??DataTable12_8
       4  ??DataTable12_9
       6  ?Subroutine0
     124  ?Subroutine1
       8  ?Subroutine2
      98  ADC1_SWStart
      60  ADC3START
          ADC3_WRCNT
      76  ADC3_AVR
       8  ADC3_ChannelEnable
      16  ADC3_CheckFinish
     104  ADC3_IRQInitHandler
      98  ADC3_SWStart
      64  ADCIndex
          ASTART
          ADC3Index
          ASTART3
          ADCSTART
          ADC_WRCNT
     212  ADCInit
      76  ADC_AVR
     200  ADC_AVR_VALUE0
     200  ADC_AVR_VALUE1
      10  ADC_ChannelEnable
      18  ADC_CheckFinish
      40  ADC_DATA
      60  ADC_DATA1
      16  ADC_GetFlagStatus
      84  ADC_IRQInitHandler
      76  ADC_SUM
      76  Adc3BuffMax
       4  Adc3En
      76  AdcBuffMax
       4  AdcEn
      14  AdctoVolt33V
      20  AdctoVolt5opamp
      40  Average_Sum
      52  BubbleSort
      54  GetAdcValue
      24  ReadEnvTempTable
      24  SelectAverage
      22  SelectMax
      16  SelectSort
      78  SelectSortMax
     218  SelectSort_1
      14  SelectSort_MinMax
       8  SortSelect
      10  SwapData
      44  average_rssi
      52  insertionSort
     138  merge
      74  mergeSort
     118  quick_sort

 
   700 bytes in section .bss
   152 bytes in section .data
     8 bytes in section .rodata
 2 026 bytes in section .text
 
 2 026 bytes of CODE  memory
     8 bytes of CONST memory
   852 bytes of DATA  memory

Errors: none
Warnings: none

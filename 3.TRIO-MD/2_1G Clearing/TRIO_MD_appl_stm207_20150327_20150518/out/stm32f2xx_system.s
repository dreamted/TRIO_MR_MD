///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR ANSI C/C++ Compiler V6.21.1.52794/W32 for ARM    29/Oct/2012  10:52:04 /
// Copyright 1999-2011 IAR Systems AB.                                        /
//                                                                            /
//    Cpu mode     =  thumb                                                   /
//    Endian       =  little                                                  /
//    Source file  =  D:\Work\Project\2012\NL_INBUILD\STM32F2xx_StdPeriph_Dri /
//                    ver\stm32f2xx_system.c                                  /
//    Command line =  D:\Work\Project\2012\NL_INBUILD\STM32F2xx_StdPeriph_Dri /
//                    ver\stm32f2xx_system.c -D OS_INCLUDED -D APPL_SRC -lA   /
//                    D:\Work\Project\2012\NL_INBUILD\FW\MU\out\ -o           /
//                    D:\Work\Project\2012\NL_INBUILD\FW\MU\out\              /
//                    --endian=little --cpu=Cortex-M3 -e --fpu=None           /
//                    --dlib_config "C:\Programming\IAR Systems\Embedded      /
//                    Workbench 6.0\arm\INC\c\DLib_Config_Normal.h" -I        /
//                    D:\Work\Project\2012\NL_INBUILD\FW\MU\include\ -I       /
//                    D:\Work\Project\2012\NL_INBUILD\FW\MU\..\..\STM32F2xx_S /
//                    tdPeriph_Driver\ -I D:\Work\Project\2012\NL_INBUILD\FW\ /
//                    MU\..\..\STM32F2xx_StdPeriph_Driver\inc\ -I             /
//                    D:\Work\Project\2012\NL_INBUILD\FW\MU\uC-CPU\ -I        /
//                    D:\Work\Project\2012\NL_INBUILD\FW\MU\uC-LIB\ -I        /
//                    D:\Work\Project\2012\NL_INBUILD\FW\MU\uCOS-II\Ports\    /
//                    -I D:\Work\Project\2012\NL_INBUILD\FW\MU\uCOS-II\Source /
//                    \ -I D:\Work\Project\2012\NL_INBUILD\FW\MU\uC-Probe\    /
//                    -Oh --use_c++_inline                                    /
//    List file    =  D:\Work\Project\2012\NL_INBUILD\FW\MU\out\stm32f2xx_sys /
//                    tem.s                                                   /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME stm32f2xx_system

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__dlib_file_descriptor", "0"
        RTMODEL "__dlib_full_locale_support", "0"
        AAPCS BASE,INTERWORK
        PRESERVE8
        REQUIRE8

        #define SHT_PROGBITS 0x1

        EXTERN __iar_program_start

        PUBLIC AHBPrescTable
        PUBLIC SystemCoreClock
        PUBLIC SystemCoreClockUpdate
        PUBLIC SystemInit
        
        CFI Names cfiNames0
        CFI StackFrame CFA R13 DATA
        CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
        CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 2
        CFI DataAlign 4
        CFI ReturnAddress R14 CODE
        CFI CFA R13+0
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI R8 SameValue
        CFI R9 SameValue
        CFI R10 SameValue
        CFI R11 SameValue
        CFI R12 Undefined
        CFI R14 SameValue
        CFI EndCommon cfiCommon0
        
// D:\Work\Project\2012\NL_INBUILD\STM32F2xx_StdPeriph_Driver\stm32f2xx_system.c
//    1 /**
//    2   ******************************************************************************
//    3   * @file    system_stm32f2xx.c
//    4   * @author  MCD Application Team
//    5   * @version V1.0.0
//    6   * @date    18-April-2011
//    7   * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer System Source File.
//    8   *          This file contains the system clock configuration for STM32F2xx devices,
//    9   *          and is generated by the clock configuration tool
//   10   *          "STM32f2xx_Clock_Configuration_V1.0.0.xls"
//   11   *             
//   12   * 1.  This file provides two functions and one global variable to be called from 
//   13   *     user application:
//   14   *      - SystemInit(): Setups the system clock (System clock source, PLL Multiplier
//   15   *                      and Divider factors, AHB/APBx prescalers and Flash settings),
//   16   *                      depending on the configuration made in the clock xls tool. 
//   17   *                      This function is called at startup just after reset and 
//   18   *                      before branch to main program. This call is made inside
//   19   *                      the "startup_stm32f2xx.s" file.
//   20   *
//   21   *      - SystemCoreClock variable: Contains the core clock (HCLK), it can be used
//   22   *                                  by the user application to setup the SysTick 
//   23   *                                  timer or configure other parameters.
//   24   *                                     
//   25   *      - SystemCoreClockUpdate(): Updates the variable SystemCoreClock and must
//   26   *                                 be called whenever the core clock is changed
//   27   *                                 during program execution.
//   28   *
//   29   * 2. After each device reset the HSI (16 MHz) is used as system clock source.
//   30   *    Then SystemInit() function is called, in "startup_stm32f2xx.s" file, to
//   31   *    configure the system clock before to branch to main program.
//   32   *
//   33   * 3. If the system clock source selected by user fails to startup, the SystemInit()
//   34   *    function will do nothing and HSI still used as system clock source. User can 
//   35   *    add some code to deal with this issue inside the SetSysClock() function.
//   36   *
//   37   * 4. The default value of HSE crystal is set to 25MHz, refer to "HSE_VALUE" define
//   38   *    in "stm32f2xx.h" file. When HSE is used as system clock source, directly or
//   39   *    through PLL, and you are using different crystal you have to adapt the HSE
//   40   *    value to your own configuration.
//   41   *
//   42   * 5. This file configures the system clock as follows:
//   43   *=============================================================================
//   44   *=============================================================================
//   45   *        Supported STM32F2xx device revision    | Rev B and Y
//   46   *-----------------------------------------------------------------------------
//   47   *        System Clock source                    | PLL (HSE)
//   48   *-----------------------------------------------------------------------------
//   49   *        SYSCLK(Hz)                             | 120000000
//   50   *-----------------------------------------------------------------------------
//   51   *        HCLK(Hz)                               | 120000000
//   52   *-----------------------------------------------------------------------------
//   53   *        AHB Prescaler                          | 1
//   54   *-----------------------------------------------------------------------------
//   55   *        APB1 Prescaler                         | 4
//   56   *-----------------------------------------------------------------------------
//   57   *        APB2 Prescaler                         | 2
//   58   *-----------------------------------------------------------------------------
//   59   *        HSE Frequency(Hz)                      | 25000000
//   60   *-----------------------------------------------------------------------------
//   61   *        PLL_M                                  | 25
//   62   *-----------------------------------------------------------------------------
//   63   *        PLL_N                                  | 240
//   64   *-----------------------------------------------------------------------------
//   65   *        PLL_P                                  | 2
//   66   *-----------------------------------------------------------------------------
//   67   *        PLL_Q                                  | 5
//   68   *-----------------------------------------------------------------------------
//   69   *        PLLI2S_N                               | NA
//   70   *-----------------------------------------------------------------------------
//   71   *        PLLI2S_R                               | NA
//   72   *-----------------------------------------------------------------------------
//   73   *        I2S input clock                        | NA
//   74   *-----------------------------------------------------------------------------
//   75   *        VDD(V)                                 | 3.3
//   76   *-----------------------------------------------------------------------------
//   77   *        Flash Latency(WS)                      | 3
//   78   *-----------------------------------------------------------------------------
//   79   *        Prefetch Buffer                        | ON
//   80   *-----------------------------------------------------------------------------
//   81   *        Instruction cache                      | ON
//   82   *-----------------------------------------------------------------------------
//   83   *        Data cache                             | ON
//   84   *-----------------------------------------------------------------------------
//   85   *        Require 48MHz for USB OTG FS,          | Enabled
//   86   *        SDIO and RNG clock                     |
//   87   *-----------------------------------------------------------------------------
//   88   *=============================================================================
//   89   ****************************************************************************** 
//   90   * @attention
//   91   *
//   92   * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
//   93   * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
//   94   * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
//   95   * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
//   96   * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
//   97   * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
//   98   *
//   99   * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
//  100   ******************************************************************************  
//  101   */
//  102 
//  103 /** @addtogroup CMSIS
//  104   * @{
//  105   */
//  106 
//  107 /** @addtogroup stm32f2xx_system
//  108   * @{
//  109   */  
//  110   
//  111 /** @addtogroup STM32F2xx_System_Private_Includes
//  112   * @{
//  113   */
//  114 
//  115 #include "stm32f2xx_system.h"
//  116 
//  117 /**
//  118   * @}
//  119   */
//  120 
//  121 /** @addtogroup STM32F2xx_System_Private_TypesDefinitions
//  122   * @{
//  123   */
//  124 
//  125 /**
//  126   * @}
//  127   */
//  128 
//  129 /** @addtogroup STM32F2xx_System_Private_Defines
//  130   * @{
//  131   */
//  132 
//  133 /*!< Uncomment the following line if you need to use external SRAM mounted
//  134      on STM322xG_EVAL board as data memory  */
//  135 /* #define DATA_IN_ExtSRAM */
//  136 
//  137 /**
//  138   * @}
//  139   */
//  140 
//  141 /** @addtogroup STM32F2xx_System_Private_Macros
//  142   * @{
//  143   */
//  144 
//  145 /**
//  146   * @}
//  147   */
//  148 
//  149 /** @addtogroup STM32F2xx_System_Private_Variables
//  150   * @{
//  151   */
//  152 

        SECTION `.data`:DATA:REORDER:NOROOT(2)
//  153   uint32_t SystemCoreClock = 120000000;
//  154 
//  155   __I uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
AHBPrescTable:
        DATA
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9
SystemCoreClock:
        DC32 120000000
//  156 
//  157 /**
//  158   * @}
//  159   */
//  160 
//  161 
//  162 
//  163 /** @addtogroup STM32F2xx_System_Private_Functions
//  164   * @{
//  165   */
//  166 
//  167 /**
//  168   * @brief  Setup the microcontroller system
//  169   *         Initialize the Embedded Flash Interface, the PLL and update the 
//  170   *         SystemFrequency variable.
//  171   * @param  None
//  172   * @retval None
//  173   */
//  174 

        SECTION `.text`:CODE:NOROOT(1)
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function SystemInit
        THUMB
//  175 void SystemInit(void)
//  176 {
SystemInit:
        PUSH     {R7,LR}
        CFI R14 Frame(CFA, -4)
        CFI CFA R13+8
//  177 	/* Reset the RCC clock configuration to the default reset state ------------*/
//  178 	/* Set HSION bit */
//  179 	/* Reset HSEON, CSSON and PLLON bits */
//  180 	RCC->CR &= (uint32_t)0xFEF6FFFF;
        LDR.N    R0,??DataTable2  ;; 0x40023800
        LDR      R1,[R0, #+0]
        LDR.N    R2,??DataTable2_1  ;; 0xfef6ffff
        ANDS     R1,R2,R1
        STR      R1,[R0, #+0]
//  181 
//  182 	/* Reset PLLCFGR register */
//  183 	RCC->PLLCFGR = 0x24003010;
        LDR.N    R1,??DataTable2_2  ;; 0x24003010
        STR      R1,[R0, #+4]
//  184 
//  185 	/* Reset HSEBYP bit */
//  186 	RCC->CR &= (uint32_t)0xFFFBFFFF;
        LDR      R1,[R0, #+0]
        BIC      R1,R1,#0x40000
        STR      R1,[R0, #+0]
//  187 
//  188 	/* Disable all interrupts */
//  189 	RCC->CIR = 0x00000000;
        MOVS     R1,#+0
        STR      R1,[R0, #+12]
//  190 
//  191 #ifdef DATA_IN_ExtSRAM
//  192   	SystemInit_ExtMemCtl(); 
//  193 #endif /* DATA_IN_ExtSRAM */
//  194          
//  195 	/* Configure the System clock source, PLL Multiplier and Divider factors, 
//  196     	AHB/APBx prescalers and Flash settings ----------------------------------*/
//  197 #if !defined (APPL_SRC)
//  198 	SetSysClock(FALSE);//SetSysClock(TRUE);
//  199 #else
//  200 	SetSysClock(FALSE);
        MOVS     R0,#+0
        BL       SetSysClock
//  201 #endif
//  202   	/* Configure the Vector Table location add offset address ------------------*/
//  203 #ifdef VECT_TAB_SRAM
//  204 	SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; 	/* Vector Table Relocation in Internal SRAM */
//  205 #else
//  206 	#if !defined (APPL_SRC)
//  207 		SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; 	/* Vector Table Relocation in Internal FLASH */
//  208 	#endif /* APPL_SRC */
//  209 #endif /* VECT_TAB_SRAM */
//  210 
//  211 #if defined (APPL_SRC)
//  212 	__iar_program_start();
        POP      {R0,LR}
        CFI R14 SameValue
        CFI CFA R13+0
        B.W      __iar_program_start
        CFI EndBlock cfiBlock0
//  213 #endif
//  214 }
//  215 
//  216 /**
//  217   * @brief  Update SystemCoreClock variable according to Clock Register Values.
//  218   *         The SystemCoreClock variable contains the core clock (HCLK), it can
//  219   *         be used by the user application to setup the SysTick timer or configure
//  220   *         other parameters.
//  221   *           
//  222   * @note   Each time the core clock (HCLK) changes, this function must be called
//  223   *         to update SystemCoreClock variable value. Otherwise, any configuration
//  224   *         based on this variable will be incorrect.         
//  225   *     
//  226   * @note   - The system frequency computed by this function is not the real 
//  227   *           frequency in the chip. It is calculated based on the predefined 
//  228   *           constant and the selected clock source:
//  229   *             
//  230   *           - If SYSCLK source is HSI, SystemCoreClock will contain the HSI_VALUE(*)
//  231   *                                              
//  232   *           - If SYSCLK source is HSE, SystemCoreClock will contain the HSE_VALUE(**)
//  233   *                          
//  234   *           - If SYSCLK source is PLL, SystemCoreClock will contain the HSE_VALUE(**) 
//  235   *             or HSI_VALUE(*) multiplied/divided by the PLL factors.
//  236   *         
//  237   *         (*) HSI_VALUE is a constant defined in stm32f2xx.h file (default value
//  238   *             16 MHz) but the real value may vary depending on the variations
//  239   *             in voltage and temperature.   
//  240   *    
//  241   *         (**) HSE_VALUE is a constant defined in stm32f2xx.h file (default value
//  242   *              25 MHz), user has to ensure that HSE_VALUE is same as the real
//  243   *              frequency of the crystal used. Otherwise, this function may
//  244   *              have wrong result.
//  245   *                
//  246   *         - The result of this function could be not correct when using fractional
//  247   *           value for HSE crystal.
//  248   *     
//  249   * @param  None
//  250   * @retval None
//  251   */

        SECTION `.text`:CODE:NOROOT(1)
        CFI Block cfiBlock1 Using cfiCommon0
        CFI Function SystemCoreClockUpdate
        THUMB
//  252 void SystemCoreClockUpdate(void)
//  253 {
//  254 	uint32_t tmp = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
//  255   
//  256 	/* Get SYSCLK source -------------------------------------------------------*/
//  257 	tmp = RCC->CFGR & RCC_CFGR_SWS;
SystemCoreClockUpdate:
        LDR.N    R0,??DataTable2_3  ;; 0x40023804
        LDR      R1,[R0, #+4]
//  258 
//  259 	switch (tmp)
        AND      R1,R1,#0xC
        CMP      R1,#+4
        BEQ.N    ??SystemCoreClockUpdate_0
        CMP      R1,#+8
        BEQ.N    ??SystemCoreClockUpdate_1
//  260 	{
//  261 		case 0x00:  /* HSI used as system clock source */
//  262 		  SystemCoreClock = HSI_VALUE;
        LDR.N    R1,??DataTable2_4  ;; 0xf42400
//  263 		  break;
        B.N      ??SystemCoreClockUpdate_2
//  264 		case 0x04:  /* HSE used as system clock source */
//  265 		  SystemCoreClock = HSE_VALUE;
??SystemCoreClockUpdate_0:
        LDR.N    R1,??DataTable2_5  ;; 0x17d7840
//  266 		  break;
        B.N      ??SystemCoreClockUpdate_2
//  267 		case 0x08:  /* PLL used as system clock source */
//  268 
//  269 		  /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLL_M) * PLL_N
//  270 		     SYSCLK = PLL_VCO / PLL_P
//  271 		     */    
//  272 		  pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
??SystemCoreClockUpdate_1:
        LDR      R1,[R0, #+0]
//  273 		  pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
        LDR      R2,[R0, #+0]
        AND      R2,R2,#0x3F
//  274 		  
//  275 		  if (pllsource != 0)
        LSLS     R1,R1,#+9
        ITE      MI 
        LDRMI.N  R1,??DataTable2_5  ;; 0x17d7840
        LDRPL.N  R1,??DataTable2_4  ;; 0xf42400
//  276 		  {
//  277 		    /* HSE used as PLL clock source */
//  278 		    pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
//  279 		  }
//  280 		  else
//  281 		  {
//  282 		    /* HSI used as PLL clock source */
//  283 		    pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
        UDIV     R1,R1,R2
        LDR      R2,[R0, #+0]
        UBFX     R2,R2,#+6,#+9
        MULS     R1,R2,R1
//  284 		  }
//  285 
//  286 		  pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
        LDR      R2,[R0, #+0]
//  287 		  SystemCoreClock = pllvco/pllp;
        UBFX     R2,R2,#+16,#+2
        ADDS     R2,R2,#+1
        LSLS     R2,R2,#+1
        UDIV     R1,R1,R2
//  288 		  break;
??SystemCoreClockUpdate_2:
        LDR.N    R2,??DataTable2_6
        STR      R1,[R2, #+16]
//  289 		default:
//  290 		  SystemCoreClock = HSI_VALUE;
//  291 		  break;
//  292 	}
//  293 	/* Compute HCLK frequency --------------------------------------------------*/
//  294 	/* Get HCLK prescaler */
//  295 	tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
//  296 	/* HCLK frequency */
//  297 	SystemCoreClock >>= tmp;
        LDR      R0,[R0, #+4]
        UBFX     R0,R0,#+4,#+4
        LDRB     R0,[R0, R2]
        LSR      R0,R1,R0
        STR      R0,[R2, #+16]
//  298 }
        BX       LR               ;; return
        CFI EndBlock cfiBlock1
//  299 
//  300 /**
//  301   * @brief  Configures the System clock source, PLL Multiplier and Divider factors, 
//  302   *         AHB/APBx prescalers and Flash settings
//  303   * @Note   This function should be called only once the RCC clock configuration  
//  304   *         is reset to the default reset state (done in SystemInit() function).   
//  305   * @param  None
//  306   * @retval None
//  307   */

        SECTION `.text`:CODE:NOROOT(1)
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function SetSysClock
        THUMB
//  308 static void SetSysClock(u8 IsItHSE)
//  309 {
SetSysClock:
        SUB      SP,SP,#+12
        CFI CFA R13+12
//  310 /******************************************************************************/
//  311 /*            PLL (clocked by HSE) used as System clock source                */
//  312 /******************************************************************************/
//  313 	__IO uint32_t StartUpCounter = 0, HSEStatus = 0x01;
        MOVS     R1,#+0
        STR      R1,[SP, #+4]
        MOVS     R1,#+1
        STR      R1,[SP, #+8]
//  314 
//  315 	vu32 PLLM = 0;
        MOVS     R1,#+0
        STR      R1,[SP, #+0]
//  316 	
//  317   	/* Enable HSE */
//  318 	if(IsItHSE)
        CBZ.N    R0,??SetSysClock_0
//  319 	{
//  320 		RCC->CR |= ((uint32_t)RCC_CR_HSEON);
        LDR.N    R1,??DataTable2  ;; 0x40023800
        LDR      R0,[R1, #+0]
        ORR      R0,R0,#0x10000
        STR      R0,[R1, #+0]
//  321 
//  322 		/* Wait till HSE is ready and if Time out is reached exit */
//  323 		do
//  324 		{
//  325 			HSEStatus = RCC->CR & RCC_CR_HSERDY;
??SetSysClock_1:
        LDR      R0,[R1, #+0]
        AND      R0,R0,#0x20000
        STR      R0,[SP, #+8]
//  326 			StartUpCounter++;
        LDR      R0,[SP, #+4]
        ADDS     R0,R0,#+1
        STR      R0,[SP, #+4]
//  327 		} while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
        LDR      R0,[SP, #+8]
        CBNZ.N   R0,??SetSysClock_2
        LDR      R0,[SP, #+4]
        CMP      R0,#+1280
        BNE.N    ??SetSysClock_1
//  328 
//  329 		if ((RCC->CR & RCC_CR_HSERDY) != RESET)	IsItHSE = SET;
??SetSysClock_2:
        LDR      R0,[R1, #+0]
//  330 		else									IsItHSE = RESET;
        LSRS     R0,R0,#+17
        ANDS     R0,R0,#0x1
//  331 	}
//  332 	else{
//  333 
//  334 	}
//  335 
//  336 	if(IsItHSE)
        IT       NE 
        MOVNE    R1,#+25
//  337 	{
//  338 		PLLM = HSE_VALUE/1000000;
        BNE.N    ??SetSysClock_3
//  339 
//  340 	}
//  341 	else
//  342 	{
//  343 		PLLM = HSI_VALUE/1000000;
??SetSysClock_0:
        MOVS     R1,#+16
??SetSysClock_3:
        STR      R1,[SP, #+0]
//  344 	}
//  345 
//  346 	{
//  347 	    /* HCLK = SYSCLK / 1*/
//  348 	    RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
        LDR.N    R1,??DataTable2  ;; 0x40023800
        LDR      R2,[R1, #+8]
        STR      R2,[R1, #+8]
//  349 	      
//  350 	    /* PCLK2 = HCLK / 2*/
//  351 	    RCC->CFGR |= RCC_CFGR_PPRE2_DIV2;
        LDR      R2,[R1, #+8]
        ORR      R2,R2,#0x8000
        STR      R2,[R1, #+8]
//  352 	    
//  353 	    /* PCLK1 = HCLK / 4*/
//  354 	    RCC->CFGR |= RCC_CFGR_PPRE1_DIV4;
        LDR      R2,[R1, #+8]
        ORR      R2,R2,#0x1400
        STR      R2,[R1, #+8]
//  355 
//  356 	    /* Configure the main PLL */
//  357 	    RCC->__B.PLLCFGR.PLLP = (PLL_P >> 1)-1;
        LDR      R2,[R1, #+4]
        BIC      R2,R2,#0x18000
        STR      R2,[R1, #+4]
//  358 	    RCC->__B.PLLCFGR.PLLM = PLLM;
        LDR      R2,[SP, #+0]
        LDR      R3,[R1, #+4]
        BFI      R3,R2,#+0,#+6
        STR      R3,[R1, #+4]
//  359 	    RCC->__B.PLLCFGR.PLLN = PLL_N;
        LDR      R2,[R1, #+4]
        BIC      R2,R2,#0x3FC0
        ORR      R2,R2,#0x3C00
        STR      R2,[R1, #+4]
//  360 	    RCC->__B.PLLCFGR.PLLQ = PLL_Q;
        LDR      R2,[R1, #+4]
        BIC      R2,R2,#0x7800000
        ORR      R2,R2,#0x2800000
        STR      R2,[R1, #+4]
//  361 	    RCC->__B.PLLCFGR.PLLSRC = IsItHSE;
        LDR      R2,[R1, #+4]
        BFI      R2,R0,#+21,#+1
        STR      R2,[R1, #+4]
//  362 
//  363 	    /* Enable the main PLL */
//  364 	    RCC->CR |= RCC_CR_PLLON;
        LDR      R0,[R1, #+0]
        ORR      R0,R0,#0x1000000
        STR      R0,[R1, #+0]
//  365 
//  366 	    /* Wait till the main PLL is ready */
//  367 	    while((RCC->CR & RCC_CR_PLLRDY) == 0)
??SetSysClock_4:
        LDR      R0,[R1, #+0]
        LSLS     R0,R0,#+6
        BPL.N    ??SetSysClock_4
//  368 	    {
//  369 	    }
//  370 	   
//  371 	    /* Configure Flash prefetch, Instruction cache, Data cache and wait state */
//  372 	    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN | FLASH_ACR_DCEN | FLASH_ACR_LATENCY_3WS;
        LDR.N    R0,??DataTable2_7  ;; 0x40023c00
        MOVW     R2,#+1795
        STR      R2,[R0, #+0]
//  373 
//  374 	    /* Select the main PLL as system clock source */
//  375 	    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
        LDR      R0,[R1, #+8]
        LSRS     R0,R0,#+2
        LSLS     R0,R0,#+2
        STR      R0,[R1, #+8]
//  376 	    RCC->CFGR |= RCC_CFGR_SW_PLL;
        LDR      R0,[R1, #+8]
        ORR      R0,R0,#0x2
        STR      R0,[R1, #+8]
//  377 
//  378 	    /* Wait till the main PLL is used as system clock source */
//  379 	    while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS ) != RCC_CFGR_SWS_PLL);
??SetSysClock_5:
        LDR      R0,[R1, #+8]
        AND      R0,R0,#0xC
        CMP      R0,#+8
        BNE.N    ??SetSysClock_5
//  380 	    {
//  381 
//  382 	    }
//  383 	}
//  384 	/* LSI ON to use watchdog */
//  385 	RCC->__B.CSR.LSION = ENABLE;
        LDR      R0,[R1, #+116]
        ORR      R0,R0,#0x1
        STR      R0,[R1, #+116]
//  386 	/* Wait till LSI is ready */
//  387 	while(!RCC->__B.CSR.LSIRDY){};
??SetSysClock_6:
        LDR      R0,[R1, #+116]
        LSLS     R0,R0,#+30
        BPL.N    ??SetSysClock_6
//  388 }
        ADD      SP,SP,#+12
        CFI CFA R13+0
        BX       LR               ;; return
        CFI EndBlock cfiBlock2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2:
        DC32     0x40023800

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2_1:
        DC32     0xfef6ffff

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2_2:
        DC32     0x24003010

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2_3:
        DC32     0x40023804

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2_4:
        DC32     0xf42400

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2_5:
        DC32     0x17d7840

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2_6:
        DC32     AHBPrescTable

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable2_7:
        DC32     0x40023c00

        SECTION `.iar_vfe_header`:DATA:REORDER:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        END
//  389 
//  390 /**
//  391   * @brief  Setup the external memory controller. Called in startup_stm32f2xx.s
//  392   *         before jump to __main
//  393   * @param  None
//  394   * @retval None
//  395   */
//  396 #ifdef DATA_IN_ExtSRAM
//  397 /**
//  398   * @brief  Setup the external memory controller.
//  399   *         Called in startup_stm32f2xx.s before jump to main.
//  400   *         This function configures the external SRAM mounted on STM322xG_EVAL board
//  401   *         This SRAM will be used as program data memory (including heap and stack).
//  402   * @param  None
//  403   * @retval None
//  404   */
//  405 void SystemInit_ExtMemCtl(void)
//  406 {
//  407 /*-- GPIOs Configuration -----------------------------------------------------*/
//  408 /*
//  409  +-------------------+--------------------+------------------+------------------+
//  410  +                       SRAM pins assignment                                  +
//  411  +-------------------+--------------------+------------------+------------------+
//  412  | PD0  <-> FSMC_D2  | PE0  <-> FSMC_NBL0 | PF0  <-> FSMC_A0 | PG0 <-> FSMC_A10 |
//  413  | PD1  <-> FSMC_D3  | PE1  <-> FSMC_NBL1 | PF1  <-> FSMC_A1 | PG1 <-> FSMC_A11 |
//  414  | PD4  <-> FSMC_NOE | PE7  <-> FSMC_D4   | PF2  <-> FSMC_A2 | PG2 <-> FSMC_A12 |
//  415  | PD5  <-> FSMC_NWE | PE8  <-> FSMC_D5   | PF3  <-> FSMC_A3 | PG3 <-> FSMC_A13 |
//  416  | PD8  <-> FSMC_D13 | PE9  <-> FSMC_D6   | PF4  <-> FSMC_A4 | PG4 <-> FSMC_A14 |
//  417  | PD9  <-> FSMC_D14 | PE10 <-> FSMC_D7   | PF5  <-> FSMC_A5 | PG5 <-> FSMC_A15 |
//  418  | PD10 <-> FSMC_D15 | PE11 <-> FSMC_D8   | PF12 <-> FSMC_A6 | PG9 <-> FSMC_NE2 |
//  419  | PD11 <-> FSMC_A16 | PE12 <-> FSMC_D9   | PF13 <-> FSMC_A7 |------------------+
//  420  | PD12 <-> FSMC_A17 | PE13 <-> FSMC_D10  | PF14 <-> FSMC_A8 | 
//  421  | PD14 <-> FSMC_D0  | PE14 <-> FSMC_D11  | PF15 <-> FSMC_A9 | 
//  422  | PD15 <-> FSMC_D1  | PE15 <-> FSMC_D12  |------------------+
//  423  +-------------------+--------------------+
//  424 */
//  425    /* Enable GPIOD, GPIOE, GPIOF and GPIOG interface clock */
//  426   RCC->AHB1ENR   = 0x00000078;
//  427   
//  428   /* Connect PDx pins to FSMC Alternate function */
//  429   GPIOD->AFR[0]  = 0x00cc00cc;
//  430   GPIOD->AFR[1]  = 0xcc0ccccc;
//  431   /* Configure PDx pins in Alternate function mode */  
//  432   GPIOD->MODER   = 0xa2aa0a0a;
//  433   /* Configure PDx pins speed to 100 MHz */  
//  434   GPIOD->OSPEEDR = 0xf3ff0f0f;
//  435   /* Configure PDx pins Output type to push-pull */  
//  436   GPIOD->OTYPER  = 0x00000000;
//  437   /* No pull-up, pull-down for PDx pins */ 
//  438   GPIOD->PUPDR   = 0x00000000;
//  439 
//  440   /* Connect PEx pins to FSMC Alternate function */
//  441   GPIOE->AFR[0]  = 0xc00000cc;
//  442   GPIOE->AFR[1]  = 0xcccccccc;
//  443   /* Configure PEx pins in Alternate function mode */ 
//  444   GPIOE->MODER   = 0xaaaa800a;
//  445   /* Configure PEx pins speed to 100 MHz */ 
//  446   GPIOE->OSPEEDR = 0xffffc00f;
//  447   /* Configure PEx pins Output type to push-pull */  
//  448   GPIOE->OTYPER  = 0x00000000;
//  449   /* No pull-up, pull-down for PEx pins */ 
//  450   GPIOE->PUPDR   = 0x00000000;
//  451 
//  452   /* Connect PFx pins to FSMC Alternate function */
//  453   GPIOF->AFR[0]  = 0x00cccccc;
//  454   GPIOF->AFR[1]  = 0xcccc0000;
//  455   /* Configure PFx pins in Alternate function mode */   
//  456   GPIOF->MODER   = 0xaa000aaa;
//  457   /* Configure PFx pins speed to 100 MHz */ 
//  458   GPIOF->OSPEEDR = 0xff000fff;
//  459   /* Configure PFx pins Output type to push-pull */  
//  460   GPIOF->OTYPER  = 0x00000000;
//  461   /* No pull-up, pull-down for PFx pins */ 
//  462   GPIOF->PUPDR   = 0x00000000;
//  463 
//  464   /* Connect PGx pins to FSMC Alternate function */
//  465   GPIOG->AFR[0]  = 0x00cccccc;
//  466   GPIOG->AFR[1]  = 0x000000c0;
//  467   /* Configure PGx pins in Alternate function mode */ 
//  468   GPIOG->MODER   = 0x00080aaa;
//  469   /* Configure PGx pins speed to 100 MHz */ 
//  470   GPIOG->OSPEEDR = 0x000c0fff;
//  471   /* Configure PGx pins Output type to push-pull */  
//  472   GPIOG->OTYPER  = 0x00000000;
//  473   /* No pull-up, pull-down for PGx pins */ 
//  474   GPIOG->PUPDR   = 0x00000000;
//  475   
//  476 /*-- FSMC Configuration ------------------------------------------------------*/
//  477   /* Enable the FSMC interface clock */
//  478   RCC->AHB3ENR         = 0x00000001;
//  479 
//  480   /* Configure and enable Bank1_SRAM2 */
//  481   FSMC_Bank1->BTCR[2]  = 0x00001015;
//  482   FSMC_Bank1->BTCR[3]  = 0x00010400;
//  483   FSMC_Bank1E->BWTR[2] = 0x0fffffff;
//  484 /*
//  485   Bank1_SRAM2 is configured as follow:
//  486 
//  487   p.FSMC_AddressSetupTime = 0;
//  488   p.FSMC_AddressHoldTime = 0;
//  489   p.FSMC_DataSetupTime = 4;
//  490   p.FSMC_BusTurnAroundDuration = 1;
//  491   p.FSMC_CLKDivision = 0;
//  492   p.FSMC_DataLatency = 0;
//  493   p.FSMC_AccessMode = FSMC_AccessMode_A;
//  494 
//  495   FSMC_NORSRAMInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM2;
//  496   FSMC_NORSRAMInitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable;
//  497   FSMC_NORSRAMInitStructure.FSMC_MemoryType = FSMC_MemoryType_PSRAM;
//  498   FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;
//  499   FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
//  500   FSMC_NORSRAMInitStructure.FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;  
//  501   FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
//  502   FSMC_NORSRAMInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable;
//  503   FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
//  504   FSMC_NORSRAMInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable;
//  505   FSMC_NORSRAMInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable;
//  506   FSMC_NORSRAMInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
//  507   FSMC_NORSRAMInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable;
//  508   FSMC_NORSRAMInitStructure.FSMC_ReadWriteTimingStruct = &p;
//  509   FSMC_NORSRAMInitStructure.FSMC_WriteTimingStruct = &p;
//  510 */
//  511   
//  512 }
//  513 #endif /* DATA_IN_ExtSRAM */
//  514 
//  515 
//  516 /**
//  517   * @}
//  518   */
//  519 
//  520 /**
//  521   * @}
//  522   */
//  523   
//  524 /**
//  525   * @}
//  526   */
//  527 /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/
// 
//  20 bytes in section .data
// 368 bytes in section .text
// 
// 368 bytes of CODE memory
//  20 bytes of DATA memory
//
//Errors: none
//Warnings: none

###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     22/Apr/2015  10:20:32 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327\uC #
#                    OS-II\Source\os_flag.c                                   #
#    Command line =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327\uC #
#                    OS-II\Source\os_flag.c -lC D:\Project\TRIO_MD\3.F_W\TRIO #
#                    _MD_appl_stm207_20150327\out\ -o                         #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327\ou #
#                    t\ --endian=little --cpu=Cortex-M3 -e --fpu=None         #
#                    --dlib_config "C:\Program Files (x86)\IAR                #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_2 #
#                    0150327\include\ -I D:\Project\TRIO_MD\3.F_W\TRIO_MD_app #
#                    l_stm207_20150327\STM32F2xx_StdPeriph_Driver_v1212\ -I   #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\inc\ -I                   #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327\uC #
#                    -CPU\ -I D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20 #
#                    150327\uC-LIB\ -I D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_ #
#                    stm207_20150327\uCOS-II\Ports\ -I                        #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327\uC #
#                    OS-II\Source\ -I D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_s #
#                    tm207_20150327\uC-Probe\ -Oh --use_c++_inline            #
#    List file    =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327\ou #
#                    t\os_flag.lst                                            #
#    Object file  =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327\ou #
#                    t\os_flag.o                                              #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327\uCOS-II\Source\os_flag.c
      1          /*
      2          *********************************************************************************************************
      3          *                                                uC/OS-II
      4          *                                          The Real-Time Kernel
      5          *                                         EVENT FLAG  MANAGEMENT
      6          *
      7          *                          (c) Copyright 2001-2007, Jean J. Labrosse, Weston, FL
      8          *                                           All Rights Reserved
      9          *
     10          * File    : OS_FLAG.C
     11          * By      : Jean J. Labrosse
     12          * Version : V2.85
     13          *
     14          * LICENSING TERMS:
     15          * ---------------
     16          *   uC/OS-II is provided in source form for FREE evaluation, for educational use or for peaceful research.  
     17          * If you plan on using  uC/OS-II  in a commercial product you need to contact Micriµm to properly license 
     18          * its use in your product. We provide ALL the source code for your convenience and to help you experience 
     19          * uC/OS-II.   The fact that the  source is provided does  NOT  mean that you can use it without  paying a 
     20          * licensing fee.
     21          *********************************************************************************************************
     22          */
     23          
     24          #ifndef  OS_MASTER_FILE
     25          
     26          #include <ucos_ii.h>
     27          #endif
     28          
     29          #if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
     30          /*
     31          *********************************************************************************************************
     32          *                                            LOCAL PROTOTYPES
     33          *********************************************************************************************************
     34          */
     35          
     36          static  void     OS_FlagBlock(OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout);
     37          static  BOOLEAN  OS_FlagTaskRdy(OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy);
     38          
     39          /*$PAGE*/
     40          /*
     41          *********************************************************************************************************
     42          *                              CHECK THE STATUS OF FLAGS IN AN EVENT FLAG GROUP
     43          *
     44          * Description: This function is called to check the status of a combination of bits to be set or cleared
     45          *              in an event flag group.  Your application can check for ANY bit to be set/cleared or ALL
     46          *              bits to be set/cleared.
     47          *
     48          *              This call does not block if the desired flags are not present.
     49          *
     50          * Arguments  : pgrp          is a pointer to the desired event flag group.
     51          *
     52          *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
     53          *                            The bits you want are specified by setting the corresponding bits in
     54          *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
     55          *                            'flags' would contain 0x03.
     56          *
     57          *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
     58          *                            to be set/cleared.
     59          *                            You can specify the following argument:
     60          *
     61          *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'flags' to be clear (0)
     62          *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'flags' to be clear (0)
     63          *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'flags' to be set   (1)
     64          *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'flags' to be set   (1)
     65          *
     66          *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
     67          *                                  the call.  Example, to wait for any flag in a group AND then clear
     68          *                                  the flags that are present, set 'wait_type' to:
     69          *
     70          *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
     71          *
     72          *              perr          is a pointer to an error code and can be:
     73          *                            OS_ERR_NONE               No error
     74          *                            OS_ERR_EVENT_TYPE         You are not pointing to an event flag group
     75          *                            OS_ERR_FLAG_WAIT_TYPE     You didn't specify a proper 'wait_type' argument.
     76          *                            OS_ERR_FLAG_INVALID_PGRP  You passed a NULL pointer instead of the event flag
     77          *                                                      group handle.
     78          *                            OS_ERR_FLAG_NOT_RDY       The desired flags you are waiting for are not
     79          *                                                      available.
     80          *
     81          * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
     82          *              occurred.
     83          *
     84          * Called from: Task or ISR
     85          *
     86          * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
     87          *                 function NOW returns the flags that were ready INSTEAD of the current state of the
     88          *                 event flags.
     89          *********************************************************************************************************
     90          */
     91          
     92          #if OS_FLAG_ACCEPT_EN > 0

   \                                 In section .text, align 2, keep-with-next
     93          OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
     94          {
   \                     OSFlagAccept:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461C             MOV      R4,R3
     95              OS_FLAGS      flags_rdy;
     96              INT8U         result;
     97              BOOLEAN       consume;
     98          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
     99              OS_CPU_SR     cpu_sr = 0;
    100          #endif
    101          
    102          
    103          
    104          #if OS_ARG_CHK_EN > 0
    105              if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
    106                  return ((OS_FLAGS)0);
    107              }
    108              if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
    109                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    110                  return ((OS_FLAGS)0);
    111              }
    112          #endif
    113              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
   \   0000000C   0x7828             LDRB     R0,[R5, #+0]
   \   0000000E   0x2805             CMP      R0,#+5
   \   00000010   0xBF1E             ITTT     NE 
   \   00000012   0x2001             MOVNE    R0,#+1
   \   00000014   0x7020             STRBNE   R0,[R4, #+0]
   \   00000016   0x2000             MOVNE    R0,#+0
    114                  *perr = OS_ERR_EVENT_TYPE;
    115                  return ((OS_FLAGS)0);
   \   00000018   0xD139             BNE.N    ??OSFlagAccept_0
    116              }
    117              result = (INT8U)(wait_type & OS_FLAG_CONSUME);
    118              if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
   \   0000001A   0x0630             LSLS     R0,R6,#+24
   \   0000001C   0xBF46             ITTE     MI 
   \   0000001E   0xF006 0x067F      ANDMI    R6,R6,#0x7F
   \   00000022   0x2701             MOVMI    R7,#+1
   \   00000024   0x2700             MOVPL    R7,#+0
    119                  wait_type &= ~OS_FLAG_CONSUME;
    120                  consume    = OS_TRUE;
    121              } else {
    122                  consume    = OS_FALSE;
    123              }
    124          /*$PAGE*/
    125              *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x7020             STRB     R0,[R4, #+0]
    126              OS_ENTER_CRITICAL();
   \   0000002A   0x.... 0x....      BL       OS_CPU_SR_Save
    127              switch (wait_type) {
   \   0000002E   0xB1D6             CBZ.N    R6,??OSFlagAccept_1
   \   00000030   0x2E02             CMP      R6,#+2
   \   00000032   0xD003             BEQ.N    ??OSFlagAccept_2
   \   00000034   0xD31D             BCC.N    ??OSFlagAccept_3
   \   00000036   0x2E03             CMP      R6,#+3
   \   00000038   0xD00A             BEQ.N    ??OSFlagAccept_4
   \   0000003A   0xE022             B.N      ??OSFlagAccept_5
    128                  case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
    129                       flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
   \                     ??OSFlagAccept_2:
   \   0000003C   0x8929             LDRH     R1,[R5, #+8]
   \   0000003E   0xEA08 0x0601      AND      R6,R8,R1
    130                       if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
   \   00000042   0x4546             CMP      R6,R8
   \   00000044   0xD008             BEQ.N    ??OSFlagAccept_6
    131                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
    132                               pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
    133                           }
    134                       } else {
    135                           *perr = OS_ERR_FLAG_NOT_RDY;
    136                       }
    137                       OS_EXIT_CRITICAL();
    138                       break;
    139          
    140                  case OS_FLAG_WAIT_SET_ANY:
    141                       flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
    142                       if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
    143                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
    144                               pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
    145                           }
    146                       } else {
    147                           *perr = OS_ERR_FLAG_NOT_RDY;
    148                       }
    149                       OS_EXIT_CRITICAL();
    150                       break;
    151          
    152          #if OS_FLAG_WAIT_CLR_EN > 0
    153                  case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
    154                       flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
    155                       if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
    156                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
    157                               pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
    158                           }
    159                       } else {
    160                           *perr = OS_ERR_FLAG_NOT_RDY;
    161                       }
    162                       OS_EXIT_CRITICAL();
    163                       break;
    164          
    165                  case OS_FLAG_WAIT_CLR_ANY:
    166                       flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
    167                       if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
    168                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
    169                               pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
    170                           }
    171                       } else {
    172                           *perr = OS_ERR_FLAG_NOT_RDY;
   \                     ??OSFlagAccept_7:
   \   00000046   0x2170             MOVS     R1,#+112
   \   00000048   0x7021             STRB     R1,[R4, #+0]
    173                       }
    174                       OS_EXIT_CRITICAL();
   \                     ??OSFlagAccept_8:
   \   0000004A   0x.... 0x....      BL       OS_CPU_SR_Restore
    175                       break;
   \   0000004E   0xE01D             B.N      ??OSFlagAccept_9
   \                     ??OSFlagAccept_4:
   \   00000050   0x8929             LDRH     R1,[R5, #+8]
   \   00000052   0xEA18 0x0601      ANDS     R6,R8,R1
   \   00000056   0xD0F6             BEQ.N    ??OSFlagAccept_7
   \                     ??OSFlagAccept_6:
   \   00000058   0x2F00             CMP      R7,#+0
   \   0000005A   0xD0F6             BEQ.N    ??OSFlagAccept_8
   \   0000005C   0x43B1             BICS     R1,R1,R6
   \                     ??OSFlagAccept_10:
   \   0000005E   0x8129             STRH     R1,[R5, #+8]
   \   00000060   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   00000064   0xE012             B.N      ??OSFlagAccept_9
   \                     ??OSFlagAccept_1:
   \   00000066   0x8929             LDRH     R1,[R5, #+8]
   \   00000068   0xEA28 0x0601      BIC      R6,R8,R1
   \   0000006C   0x4546             CMP      R6,R8
   \   0000006E   0xD1EA             BNE.N    ??OSFlagAccept_7
   \   00000070   0xE003             B.N      ??OSFlagAccept_11
   \                     ??OSFlagAccept_3:
   \   00000072   0x8929             LDRH     R1,[R5, #+8]
   \   00000074   0xEA38 0x0601      BICS     R6,R8,R1
   \   00000078   0xD0E5             BEQ.N    ??OSFlagAccept_7
   \                     ??OSFlagAccept_11:
   \   0000007A   0x2F00             CMP      R7,#+0
   \   0000007C   0xD0E5             BEQ.N    ??OSFlagAccept_8
   \   0000007E   0x4331             ORRS     R1,R6,R1
   \   00000080   0xE7ED             B.N      ??OSFlagAccept_10
    176          #endif
    177          
    178                  default:
    179                       OS_EXIT_CRITICAL();
   \                     ??OSFlagAccept_5:
   \   00000082   0x.... 0x....      BL       OS_CPU_SR_Restore
    180                       flags_rdy = (OS_FLAGS)0;
   \   00000086   0x2600             MOVS     R6,#+0
    181                       *perr     = OS_ERR_FLAG_WAIT_TYPE;
   \   00000088   0x206F             MOVS     R0,#+111
   \   0000008A   0x7020             STRB     R0,[R4, #+0]
    182                       break;
    183              }
    184              return (flags_rdy);
   \                     ??OSFlagAccept_9:
   \   0000008C   0x4630             MOV      R0,R6
   \                     ??OSFlagAccept_0:
   \   0000008E   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    185          }
    186          #endif
    187          
    188          /*$PAGE*/
    189          /*
    190          *********************************************************************************************************
    191          *                                           CREATE AN EVENT FLAG
    192          *
    193          * Description: This function is called to create an event flag group.
    194          *
    195          * Arguments  : flags         Contains the initial value to store in the event flag group.
    196          *
    197          *              perr          is a pointer to an error code which will be returned to your application:
    198          *                               OS_ERR_NONE               if the call was successful.
    199          *                               OS_ERR_CREATE_ISR         if you attempted to create an Event Flag from an
    200          *                                                         ISR.
    201          *                               OS_ERR_FLAG_GRP_DEPLETED  if there are no more event flag groups
    202          *
    203          * Returns    : A pointer to an event flag group or a NULL pointer if no more groups are available.
    204          *
    205          * Called from: Task ONLY
    206          *********************************************************************************************************
    207          */
    208          

   \                                 In section .text, align 2, keep-with-next
    209          OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
    210          {
   \                     OSFlagCreate:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460C             MOV      R4,R1
    211              OS_FLAG_GRP *pgrp;
    212          #if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    213              OS_CPU_SR    cpu_sr = 0;
    214          #endif
    215          
    216          
    217          
    218          #if OS_ARG_CHK_EN > 0
    219              if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
    220                  return ((OS_FLAG_GRP *)0);
    221              }
    222          #endif
    223              if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0xB118             CBZ.N    R0,??OSFlagCreate_0
    224                  *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
   \   0000000E   0x2010             MOVS     R0,#+16
   \   00000010   0x7020             STRB     R0,[R4, #+0]
    225                  return ((OS_FLAG_GRP *)0);
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD70             POP      {R4-R6,PC}
    226              }
    227              OS_ENTER_CRITICAL();
   \                     ??OSFlagCreate_0:
   \   00000016   0x.... 0x....      BL       OS_CPU_SR_Save
    228              pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable8_1
   \   0000001E   0x680A             LDR      R2,[R1, #+0]
   \   00000020   0x0016             MOVS     R6,R2
    229              if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
   \   00000022   0xD00E             BEQ.N    ??OSFlagCreate_1
    230                                                              /* Adjust free list                                */
    231                  OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
   \   00000024   0x6852             LDR      R2,[R2, #+4]
   \   00000026   0x600A             STR      R2,[R1, #+0]
    232                  pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
   \   00000028   0x2105             MOVS     R1,#+5
   \   0000002A   0x7031             STRB     R1,[R6, #+0]
    233                  pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
   \   0000002C   0x8135             STRH     R5,[R6, #+8]
    234                  pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x6071             STR      R1,[R6, #+4]
    235          #if OS_FLAG_NAME_SIZE > 1
    236                  pgrp->OSFlagName[0]  = '?';
   \   00000032   0x213F             MOVS     R1,#+63
   \   00000034   0x72B1             STRB     R1,[R6, #+10]
    237                  pgrp->OSFlagName[1]  = OS_ASCII_NUL;
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x72F1             STRB     R1,[R6, #+11]
    238          #endif
    239                  OS_EXIT_CRITICAL();
   \   0000003A   0x.... 0x....      BL       OS_CPU_SR_Restore
    240                  *perr                = OS_ERR_NONE;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0xE002             B.N      ??OSFlagCreate_2
    241              } else {
    242                  OS_EXIT_CRITICAL();
   \                     ??OSFlagCreate_1:
   \   00000042   0x.... 0x....      BL       OS_CPU_SR_Restore
    243                  *perr                = OS_ERR_FLAG_GRP_DEPLETED;
   \   00000046   0x2072             MOVS     R0,#+114
   \                     ??OSFlagCreate_2:
   \   00000048   0x7020             STRB     R0,[R4, #+0]
    244              }
    245              return (pgrp);                                  /* Return pointer to event flag group              */
   \   0000004A   0x4630             MOV      R0,R6
   \   0000004C   0xBD70             POP      {R4-R6,PC}       ;; return
    246          }
    247          
    248          /*$PAGE*/
    249          /*
    250          *********************************************************************************************************
    251          *                                     DELETE AN EVENT FLAG GROUP
    252          *
    253          * Description: This function deletes an event flag group and readies all tasks pending on the event flag
    254          *              group.
    255          *
    256          * Arguments  : pgrp          is a pointer to the desired event flag group.
    257          *
    258          *              opt           determines delete options as follows:
    259          *                            opt == OS_DEL_NO_PEND   Deletes the event flag group ONLY if no task pending
    260          *                            opt == OS_DEL_ALWAYS    Deletes the event flag group even if tasks are
    261          *                                                    waiting.  In this case, all the tasks pending will be
    262          *                                                    readied.
    263          *
    264          *              perr          is a pointer to an error code that can contain one of the following values:
    265          *                            OS_ERR_NONE               The call was successful and the event flag group was
    266          *                                                      deleted
    267          *                            OS_ERR_DEL_ISR            If you attempted to delete the event flag group from
    268          *                                                      an ISR
    269          *                            OS_ERR_FLAG_INVALID_PGRP  If 'pgrp' is a NULL pointer.
    270          *                            OS_ERR_EVENT_TYPE         If you didn't pass a pointer to an event flag group
    271          *                            OS_ERR_INVALID_OPT        An invalid option was specified
    272          *                            OS_ERR_TASK_WAITING       One or more tasks were waiting on the event flag
    273          *                                                      group.
    274          *
    275          * Returns    : pgrp          upon error
    276          *              (OS_EVENT *)0 if the event flag group was successfully deleted.
    277          *
    278          * Note(s)    : 1) This function must be used with care.  Tasks that would normally expect the presence of
    279          *                 the event flag group MUST check the return code of OSFlagAccept() and OSFlagPend().
    280          *              2) This call can potentially disable interrupts for a long time.  The interrupt disable
    281          *                 time is directly proportional to the number of tasks waiting on the event flag group.
    282          *********************************************************************************************************
    283          */
    284          
    285          #if OS_FLAG_DEL_EN > 0

   \                                 In section .text, align 2, keep-with-next
    286          OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
    287          {
   \                     OSFlagDel:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4615             MOV      R5,R2
    288              BOOLEAN       tasks_waiting;
    289              OS_FLAG_NODE *pnode;
    290              OS_FLAG_GRP  *pgrp_return;
    291          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    292              OS_CPU_SR     cpu_sr = 0;
    293          #endif
    294          
    295          
    296          
    297          #if OS_ARG_CHK_EN > 0
    298              if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
    299                  return (pgrp);
    300              }
    301              if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
    302                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    303                  return (pgrp);
    304              }
    305          #endif
    306              if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000000E   0x7800             LDRB     R0,[R0, #+0]
   \   00000010   0xB108             CBZ.N    R0,??OSFlagDel_0
    307                  *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
   \   00000012   0x200F             MOVS     R0,#+15
   \   00000014   0xE048             B.N      ??OSFlagDel_1
    308                  return (pgrp);
    309              }
    310              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
   \                     ??OSFlagDel_0:
   \   00000016   0x7820             LDRB     R0,[R4, #+0]
   \   00000018   0x2805             CMP      R0,#+5
   \   0000001A   0xBF18             IT       NE 
   \   0000001C   0x2001             MOVNE    R0,#+1
    311                  *perr = OS_ERR_EVENT_TYPE;
   \   0000001E   0xD143             BNE.N    ??OSFlagDel_1
    312                  return (pgrp);
    313              }
    314              OS_ENTER_CRITICAL();
   \   00000020   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000024   0x4681             MOV      R9,R0
    315              if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
   \   00000026   0x6867             LDR      R7,[R4, #+4]
   \   00000028   0x2F00             CMP      R7,#+0
   \   0000002A   0xBF14             ITE      NE 
   \   0000002C   0x2601             MOVNE    R6,#+1
   \   0000002E   0x2600             MOVEQ    R6,#+0
    316                  tasks_waiting = OS_TRUE;                           /* Yes                                      */
    317              } else {
    318                  tasks_waiting = OS_FALSE;                          /* No                                       */
    319              }
    320              switch (opt) {
   \   00000030   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000034   0xD003             BEQ.N    ??OSFlagDel_2
   \   00000036   0xF1B8 0x0F01      CMP      R8,#+1
   \   0000003A   0xD015             BEQ.N    ??OSFlagDel_3
   \   0000003C   0xE031             B.N      ??OSFlagDel_4
    321                  case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
    322                       if (tasks_waiting == OS_FALSE) {
   \                     ??OSFlagDel_2:
   \   0000003E   0xB97E             CBNZ.N   R6,??OSFlagDel_5
    323          #if OS_FLAG_NAME_SIZE > 1
    324                           pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
   \   00000040   0x203F             MOVS     R0,#+63
   \   00000042   0x72A0             STRB     R0,[R4, #+10]
    325                           pgrp->OSFlagName[1]  = OS_ASCII_NUL;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x72E0             STRB     R0,[R4, #+11]
    326          #endif
    327                           pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
   \   00000048   0x7020             STRB     R0,[R4, #+0]
    328                           pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   0000004E   0x6801             LDR      R1,[R0, #+0]
   \   00000050   0x6061             STR      R1,[R4, #+4]
    329                           pgrp->OSFlagFlags    = (OS_FLAGS)0;
   \   00000052   0x2100             MOVS     R1,#+0
   \   00000054   0x8121             STRH     R1,[R4, #+8]
    330                           OSFlagFreeList       = pgrp;
   \   00000056   0x6004             STR      R4,[R0, #+0]
    331                           OS_EXIT_CRITICAL();
   \   00000058   0x4648             MOV      R0,R9
   \   0000005A   0x.... 0x....      BL       OS_CPU_SR_Restore
    332                           *perr                = OS_ERR_NONE;
   \   0000005E   0xE01D             B.N      ??OSFlagDel_6
    333                           pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
    334                       } else {
    335                           OS_EXIT_CRITICAL();
   \                     ??OSFlagDel_5:
   \   00000060   0x.... 0x....      BL       OS_CPU_SR_Restore
    336                           *perr                = OS_ERR_TASK_WAITING;
   \   00000064   0x2049             MOVS     R0,#+73
    337                           pgrp_return          = pgrp;
   \   00000066   0xE01F             B.N      ??OSFlagDel_1
    338                       }
    339                       break;
    340          
    341                  case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
    342                       pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    343                       while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
   \                     ??OSFlagDel_3:
   \   00000068   0xB137             CBZ.N    R7,??OSFlagDel_7
    344                           (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
   \                     ??OSFlagDel_8:
   \   0000006A   0x2100             MOVS     R1,#+0
   \   0000006C   0x4638             MOV      R0,R7
   \   0000006E   0x.... 0x....      BL       OS_FlagTaskRdy
    345                           pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
   \   00000072   0x683F             LDR      R7,[R7, #+0]
   \   00000074   0x2F00             CMP      R7,#+0
   \   00000076   0xD1F8             BNE.N    ??OSFlagDel_8
    346                       }
    347          #if OS_FLAG_NAME_SIZE > 1
    348                       pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
   \                     ??OSFlagDel_7:
   \   00000078   0x203F             MOVS     R0,#+63
   \   0000007A   0x72A0             STRB     R0,[R4, #+10]
    349                       pgrp->OSFlagName[1]  = OS_ASCII_NUL;
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x72E0             STRB     R0,[R4, #+11]
    350          #endif
    351                       pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
   \   00000080   0x7020             STRB     R0,[R4, #+0]
    352                       pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable8_1
   \   00000086   0x6801             LDR      R1,[R0, #+0]
   \   00000088   0x6061             STR      R1,[R4, #+4]
    353                       pgrp->OSFlagFlags    = (OS_FLAGS)0;
   \   0000008A   0x2100             MOVS     R1,#+0
   \   0000008C   0x8121             STRH     R1,[R4, #+8]
    354                       OSFlagFreeList       = pgrp;
   \   0000008E   0x6004             STR      R4,[R0, #+0]
    355                       OS_EXIT_CRITICAL();
   \   00000090   0x4648             MOV      R0,R9
   \   00000092   0x.... 0x....      BL       OS_CPU_SR_Restore
    356                       if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
   \   00000096   0xB10E             CBZ.N    R6,??OSFlagDel_6
    357                           OS_Sched();                               /* Find highest priority task ready to run  */
   \   00000098   0x.... 0x....      BL       OS_Sched
    358                       }
    359                       *perr = OS_ERR_NONE;
   \                     ??OSFlagDel_6:
   \   0000009C   0x2000             MOVS     R0,#+0
    360                       pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
   \   0000009E   0x2400             MOVS     R4,#+0
    361                       break;
   \   000000A0   0xE002             B.N      ??OSFlagDel_1
    362          
    363                  default:
    364                       OS_EXIT_CRITICAL();
   \                     ??OSFlagDel_4:
   \   000000A2   0x.... 0x....      BL       OS_CPU_SR_Restore
    365                       *perr                = OS_ERR_INVALID_OPT;
   \   000000A6   0x2007             MOVS     R0,#+7
    366                       pgrp_return          = pgrp;
    367                       break;
   \                     ??OSFlagDel_1:
   \   000000A8   0x7028             STRB     R0,[R5, #+0]
    368              }
    369              return (pgrp_return);
   \   000000AA   0x4620             MOV      R0,R4
   \   000000AC   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
    370          }
    371          #endif
    372          /*$PAGE*/
    373          /*
    374          *********************************************************************************************************
    375          *                                 GET THE NAME OF AN EVENT FLAG GROUP
    376          *
    377          * Description: This function is used to obtain the name assigned to an event flag group
    378          *
    379          * Arguments  : pgrp      is a pointer to the event flag group.
    380          *
    381          *              pname     is a pointer to an ASCII string that will receive the name of the event flag
    382          *                        group.  The string must be able to hold at least OS_FLAG_NAME_SIZE characters.
    383          *
    384          *              perr      is a pointer to an error code that can contain one of the following values:
    385          *
    386          *                        OS_ERR_NONE                if the requested task is resumed
    387          *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag group
    388          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    389          *                        OS_ERR_FLAG_INVALID_PGRP   if you passed a NULL pointer for 'pgrp'
    390          *                        OS_ERR_NAME_GET_ISR        if you called this function from an ISR
    391          *
    392          * Returns    : The length of the string or 0 if the 'pgrp' is a NULL pointer.
    393          *********************************************************************************************************
    394          */
    395          
    396          #if OS_FLAG_NAME_SIZE > 1

   \                                 In section .text, align 2, keep-with-next
    397          INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
    398          {
   \                     OSFlagNameGet:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4614             MOV      R4,R2
    399              INT8U      len;
    400          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    401              OS_CPU_SR  cpu_sr = 0;
    402          #endif
    403          
    404          
    405          
    406          #if OS_ARG_CHK_EN > 0
    407              if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
    408                  return (0);
    409              }
    410              if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
    411                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    412                  return (0);
    413              }
    414              if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
    415                  *perr = OS_ERR_PNAME_NULL;
    416                  return (0);
    417              }
    418          #endif
    419              if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable8
   \   0000000C   0x7800             LDRB     R0,[R0, #+0]
   \   0000000E   0xB108             CBZ.N    R0,??OSFlagNameGet_0
    420                  *perr = OS_ERR_NAME_GET_ISR;
   \   00000010   0x2011             MOVS     R0,#+17
   \   00000012   0xE009             B.N      ??OSFlagNameGet_1
    421                  return (0);
    422              }
    423              OS_ENTER_CRITICAL();
   \                     ??OSFlagNameGet_0:
   \   00000014   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000018   0x4607             MOV      R7,R0
    424              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
   \   0000001A   0x7828             LDRB     R0,[R5, #+0]
   \   0000001C   0x2805             CMP      R0,#+5
   \   0000001E   0xD006             BEQ.N    ??OSFlagNameGet_2
    425                  OS_EXIT_CRITICAL();
   \   00000020   0x4638             MOV      R0,R7
   \   00000022   0x.... 0x....      BL       OS_CPU_SR_Restore
    426                  *perr = OS_ERR_EVENT_TYPE;
   \   00000026   0x2001             MOVS     R0,#+1
   \                     ??OSFlagNameGet_1:
   \   00000028   0x7020             STRB     R0,[R4, #+0]
    427                  return (0);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0xBDF2             POP      {R1,R4-R7,PC}
    428              }
    429              len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
   \                     ??OSFlagNameGet_2:
   \   0000002E   0xF105 0x010A      ADD      R1,R5,#+10
   \   00000032   0x4630             MOV      R0,R6
   \   00000034   0x.... 0x....      BL       OS_StrCopy
   \   00000038   0x4605             MOV      R5,R0
    430              OS_EXIT_CRITICAL();
   \   0000003A   0x4638             MOV      R0,R7
   \   0000003C   0x.... 0x....      BL       OS_CPU_SR_Restore
    431              *perr = OS_ERR_NONE;
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x7020             STRB     R0,[R4, #+0]
    432              return (len);
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    433          }
    434          #endif
    435          
    436          /*$PAGE*/
    437          /*
    438          *********************************************************************************************************
    439          *                                 ASSIGN A NAME TO AN EVENT FLAG GROUP
    440          *
    441          * Description: This function assigns a name to an event flag group.
    442          *
    443          * Arguments  : pgrp      is a pointer to the event flag group.
    444          *
    445          *              pname     is a pointer to an ASCII string that will be used as the name of the event flag
    446          *                        group.  The string must be able to hold at least OS_FLAG_NAME_SIZE characters.
    447          *
    448          *              perr      is a pointer to an error code that can contain one of the following values:
    449          *
    450          *                        OS_ERR_NONE                if the requested task is resumed
    451          *                        OS_ERR_EVENT_TYPE          if 'pevent' is not pointing to an event flag group
    452          *                        OS_ERR_PNAME_NULL          You passed a NULL pointer for 'pname'
    453          *                        OS_ERR_FLAG_INVALID_PGRP   if you passed a NULL pointer for 'pgrp'
    454          *                        OS_ERR_NAME_SET_ISR        if you called this function from an ISR
    455          *
    456          * Returns    : None
    457          *********************************************************************************************************
    458          */
    459          
    460          #if OS_FLAG_NAME_SIZE > 1

   \                                 In section .text, align 2, keep-with-next
    461          void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
    462          {
   \                     OSFlagNameSet:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
   \   00000004   0x460E             MOV      R6,R1
   \   00000006   0x4614             MOV      R4,R2
    463              INT8U      len;
    464          #if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    465              OS_CPU_SR  cpu_sr = 0;
    466          #endif
    467          
    468          
    469          
    470          #if OS_ARG_CHK_EN > 0
    471              if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
    472                  return;
    473              }
    474              if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
    475                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    476                  return;
    477              }
    478              if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
    479                  *perr = OS_ERR_PNAME_NULL;
    480                  return;
    481              }
    482          #endif
    483              if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
   \   00000008   0x....             LDR.N    R0,??DataTable8
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0xB108             CBZ.N    R0,??OSFlagNameSet_0
    484                  *perr = OS_ERR_NAME_SET_ISR;
   \   0000000E   0x2012             MOVS     R0,#+18
   \   00000010   0xE01D             B.N      ??OSFlagNameSet_1
    485                  return;
    486              }
    487              OS_ENTER_CRITICAL();
   \                     ??OSFlagNameSet_0:
   \   00000012   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000016   0x4607             MOV      R7,R0
    488              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
   \   00000018   0x7828             LDRB     R0,[R5, #+0]
   \   0000001A   0x2805             CMP      R0,#+5
   \   0000001C   0xD004             BEQ.N    ??OSFlagNameSet_2
    489                  OS_EXIT_CRITICAL();
   \   0000001E   0x4638             MOV      R0,R7
   \   00000020   0x.... 0x....      BL       OS_CPU_SR_Restore
    490                  *perr = OS_ERR_EVENT_TYPE;
   \   00000024   0x2001             MOVS     R0,#+1
   \   00000026   0xE012             B.N      ??OSFlagNameSet_1
    491                  return;
    492              }
    493              len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
    494              if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
   \                     ??OSFlagNameSet_2:
   \   00000028   0x4630             MOV      R0,R6
   \   0000002A   0x.... 0x....      BL       OS_StrLen
   \   0000002E   0x2810             CMP      R0,#+16
   \   00000030   0xD304             BCC.N    ??OSFlagNameSet_3
    495                  OS_EXIT_CRITICAL();
   \   00000032   0x4638             MOV      R0,R7
   \   00000034   0x.... 0x....      BL       OS_CPU_SR_Restore
    496                  *perr = OS_ERR_FLAG_NAME_TOO_LONG;
   \   00000038   0x2073             MOVS     R0,#+115
   \   0000003A   0xE008             B.N      ??OSFlagNameSet_1
    497                  return;
    498              }
    499              (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
   \                     ??OSFlagNameSet_3:
   \   0000003C   0x4631             MOV      R1,R6
   \   0000003E   0xF105 0x000A      ADD      R0,R5,#+10
   \   00000042   0x.... 0x....      BL       OS_StrCopy
    500              OS_EXIT_CRITICAL();
   \   00000046   0x4638             MOV      R0,R7
   \   00000048   0x.... 0x....      BL       OS_CPU_SR_Restore
    501              *perr = OS_ERR_NONE;
   \   0000004C   0x2000             MOVS     R0,#+0
   \                     ??OSFlagNameSet_1:
   \   0000004E   0x7020             STRB     R0,[R4, #+0]
    502              return;
   \   00000050   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    503          }
    504          #endif
    505          
    506          /*$PAGE*/
    507          /*
    508          *********************************************************************************************************
    509          *                                        WAIT ON AN EVENT FLAG GROUP
    510          *
    511          * Description: This function is called to wait for a combination of bits to be set in an event flag
    512          *              group.  Your application can wait for ANY bit to be set or ALL bits to be set.
    513          *
    514          * Arguments  : pgrp          is a pointer to the desired event flag group.
    515          *
    516          *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to wait for.
    517          *                            The bits you want are specified by setting the corresponding bits in
    518          *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
    519          *                            'flags' would contain 0x03.
    520          *
    521          *              wait_type     specifies whether you want ALL bits to be set or ANY of the bits to be set.
    522          *                            You can specify the following argument:
    523          *
    524          *                            OS_FLAG_WAIT_CLR_ALL   You will wait for ALL bits in 'mask' to be clear (0)
    525          *                            OS_FLAG_WAIT_SET_ALL   You will wait for ALL bits in 'mask' to be set   (1)
    526          *                            OS_FLAG_WAIT_CLR_ANY   You will wait for ANY bit  in 'mask' to be clear (0)
    527          *                            OS_FLAG_WAIT_SET_ANY   You will wait for ANY bit  in 'mask' to be set   (1)
    528          *
    529          *                            NOTE: Add OS_FLAG_CONSUME if you want the event flag to be 'consumed' by
    530          *                                  the call.  Example, to wait for any flag in a group AND then clear
    531          *                                  the flags that are present, set 'wait_type' to:
    532          *
    533          *                                  OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME
    534          *
    535          *              timeout       is an optional timeout (in clock ticks) that your task will wait for the
    536          *                            desired bit combination.  If you specify 0, however, your task will wait
    537          *                            forever at the specified event flag group or, until a message arrives.
    538          *
    539          *              perr          is a pointer to an error code and can be:
    540          *                            OS_ERR_NONE               The desired bits have been set within the specified
    541          *                                                      'timeout'.
    542          *                            OS_ERR_PEND_ISR           If you tried to PEND from an ISR
    543          *                            OS_ERR_FLAG_INVALID_PGRP  If 'pgrp' is a NULL pointer.
    544          *                            OS_ERR_EVENT_TYPE         You are not pointing to an event flag group
    545          *                            OS_ERR_TIMEOUT            The bit(s) have not been set in the specified
    546          *                                                      'timeout'.
    547          *                            OS_ERR_PEND_ABORT         The wait on the flag was aborted.
    548          *                            OS_ERR_FLAG_WAIT_TYPE     You didn't specify a proper 'wait_type' argument.
    549          *
    550          * Returns    : The flags in the event flag group that made the task ready or, 0 if a timeout or an error
    551          *              occurred.
    552          *
    553          * Called from: Task ONLY
    554          *
    555          * Note(s)    : 1) IMPORTANT, the behavior of this function has changed from PREVIOUS versions.  The
    556          *                 function NOW returns the flags that were ready INSTEAD of the current state of the
    557          *                 event flags.
    558          *********************************************************************************************************
    559          */
    560          

   \                                 In section .text, align 2, keep-with-next
    561          OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
    562          {
   \                     OSFlagPend:
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x4689             MOV      R9,R1
   \   0000000A   0x4692             MOV      R10,R2
   \   0000000C   0x9D10             LDR      R5,[SP, #+64]
    563              OS_FLAG_NODE  node;
    564              OS_FLAGS      flags_rdy;
    565              INT8U         result;
    566              INT8U         pend_stat;
    567              BOOLEAN       consume;
    568          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    569              OS_CPU_SR     cpu_sr = 0;
    570          #endif
    571          
    572          
    573          
    574          #if OS_ARG_CHK_EN > 0
    575              if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
    576                  return ((OS_FLAGS)0);
    577              }
    578              if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
    579                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    580                  return ((OS_FLAGS)0);
    581              }
    582          #endif
    583              if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
   \   0000000E   0x....             LDR.N    R0,??DataTable8
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0xB108             CBZ.N    R0,??OSFlagPend_0
    584                  *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
   \   00000014   0x2002             MOVS     R0,#+2
   \   00000016   0xE084             B.N      ??OSFlagPend_1
    585                  return ((OS_FLAGS)0);
    586              }
    587              if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
   \                     ??OSFlagPend_0:
   \   00000018   0x....             LDR.N    R0,??DataTable8_2
   \   0000001A   0x7800             LDRB     R0,[R0, #+0]
   \   0000001C   0xB108             CBZ.N    R0,??OSFlagPend_2
    588                  *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
   \   0000001E   0x200D             MOVS     R0,#+13
   \   00000020   0xE07F             B.N      ??OSFlagPend_1
    589                  return ((OS_FLAGS)0);
    590              }
    591              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
   \                     ??OSFlagPend_2:
   \   00000022   0x7820             LDRB     R0,[R4, #+0]
   \   00000024   0x2805             CMP      R0,#+5
   \   00000026   0xBF18             IT       NE 
   \   00000028   0x2001             MOVNE    R0,#+1
    592                  *perr = OS_ERR_EVENT_TYPE;
   \   0000002A   0xD17A             BNE.N    ??OSFlagPend_1
    593                  return ((OS_FLAGS)0);
    594              }
    595              result = (INT8U)(wait_type & OS_FLAG_CONSUME);
    596              if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
   \   0000002C   0xEA5F 0x600A      LSLS     R0,R10,#+24
   \   00000030   0xBF46             ITTE     MI 
   \   00000032   0xF00A 0x0A7F      ANDMI    R10,R10,#0x7F
   \   00000036   0xF04F 0x0B01      MOVMI    R11,#+1
   \   0000003A   0xF04F 0x0B00      MOVPL    R11,#+0
    597                  wait_type &= ~(INT8U)OS_FLAG_CONSUME;
    598                  consume    = OS_TRUE;
    599              } else {
    600                  consume    = OS_FALSE;
    601              }
    602          /*$PAGE*/
    603              OS_ENTER_CRITICAL();
   \   0000003E   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000042   0x4680             MOV      R8,R0
    604              switch (wait_type) {
   \   00000044   0x4657             MOV      R7,R10
   \   00000046   0x2F00             CMP      R7,#+0
   \   00000048   0xD03C             BEQ.N    ??OSFlagPend_3
   \   0000004A   0x2F02             CMP      R7,#+2
   \   0000004C   0xD003             BEQ.N    ??OSFlagPend_4
   \   0000004E   0xD33F             BCC.N    ??OSFlagPend_5
   \   00000050   0x2F03             CMP      R7,#+3
   \   00000052   0xD02E             BEQ.N    ??OSFlagPend_6
   \   00000054   0xE061             B.N      ??OSFlagPend_7
    605                  case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
    606                       flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
   \                     ??OSFlagPend_4:
   \   00000056   0x8920             LDRH     R0,[R4, #+8]
   \   00000058   0xEA09 0x0600      AND      R6,R9,R0
    607                       if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
   \   0000005C   0x454E             CMP      R6,R9
   \   0000005E   0xD02C             BEQ.N    ??OSFlagPend_8
    608                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
    609                               pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
    610                           }
    611                           OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
    612                           OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
    613                           *perr                   = OS_ERR_NONE;
    614                           return (flags_rdy);
    615                       } else {                                      /* Block task until events occur or timeout */
    616                           OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
    617                           OS_EXIT_CRITICAL();
    618                       }
    619                       break;
    620          
    621                  case OS_FLAG_WAIT_SET_ANY:
    622                       flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
    623                       if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
    624                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
    625                               pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
    626                           }
    627                           OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
    628                           OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
    629                           *perr                   = OS_ERR_NONE;
    630                           return (flags_rdy);
    631                       } else {                                      /* Block task until events occur or timeout */
    632                           OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
    633                           OS_EXIT_CRITICAL();
    634                       }
    635                       break;
    636          
    637          #if OS_FLAG_WAIT_CLR_EN > 0
    638                  case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
    639                       flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
    640                       if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
    641                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
    642                               pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
    643                           }
    644                           OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
    645                           OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
    646                           *perr                   = OS_ERR_NONE;
    647                           return (flags_rdy);
    648                       } else {                                      /* Block task until events occur or timeout */
    649                           OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
    650                           OS_EXIT_CRITICAL();
    651                       }
    652                       break;
    653          
    654                  case OS_FLAG_WAIT_CLR_ANY:
    655                       flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
    656                       if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
    657                           if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
    658                               pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
    659                           }
    660                           OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
    661                           OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
    662                           *perr                   = OS_ERR_NONE;
    663                           return (flags_rdy);
    664                       } else {                                      /* Block task until events occur or timeout */
    665                           OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
   \                     ??OSFlagPend_9:
   \   00000060   0xF8BD 0x0018      LDRH     R0,[SP, #+24]
   \   00000064   0x9000             STR      R0,[SP, #+0]
   \   00000066   0x4653             MOV      R3,R10
   \   00000068   0x464A             MOV      R2,R9
   \   0000006A   0xA901             ADD      R1,SP,#+4
   \   0000006C   0x4620             MOV      R0,R4
   \   0000006E   0x.... 0x....      BL       OS_FlagBlock
    666                           OS_EXIT_CRITICAL();
   \   00000072   0x4640             MOV      R0,R8
   \   00000074   0x.... 0x....      BL       OS_CPU_SR_Restore
    667                       }
    668                       break;
    669          #endif
    670          
    671                  default:
    672                       OS_EXIT_CRITICAL();
    673                       flags_rdy = (OS_FLAGS)0;
    674                       *perr      = OS_ERR_FLAG_WAIT_TYPE;
    675                       return (flags_rdy);
    676              }
    677          /*$PAGE*/
    678              OS_Sched();                                            /* Find next HPT ready to run               */
   \   00000078   0x.... 0x....      BL       OS_Sched
    679              OS_ENTER_CRITICAL();
   \   0000007C   0x.... 0x....      BL       OS_CPU_SR_Save
   \   00000080   0x4680             MOV      R8,R0
    680              if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
   \   00000082   0x....             LDR.N    R6,??DataTable8_3
   \   00000084   0x6830             LDR      R0,[R6, #+0]
   \   00000086   0xF890 0xA01D      LDRB     R10,[R0, #+29]
   \   0000008A   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000008E   0xD02C             BEQ.N    ??OSFlagPend_10
    681                  pend_stat                = OSTCBCur->OSTCBStatPend;
    682                  OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
   \   00000090   0x2100             MOVS     R1,#+0
   \   00000092   0x7741             STRB     R1,[R0, #+29]
    683                  OS_FlagUnlink(&node);
   \   00000094   0xA801             ADD      R0,SP,#+4
   \   00000096   0x.... 0x....      BL       OS_FlagUnlink
    684                  OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
   \   0000009A   0x6830             LDR      R0,[R6, #+0]
   \   0000009C   0x2100             MOVS     R1,#+0
   \   0000009E   0x7701             STRB     R1,[R0, #+28]
    685                  OS_EXIT_CRITICAL();
   \   000000A0   0x4640             MOV      R0,R8
   \   000000A2   0x.... 0x....      BL       OS_CPU_SR_Restore
    686                  flags_rdy                = (OS_FLAGS)0;
    687                  switch (pend_stat) {
   \   000000A6   0xF1BA 0x0F02      CMP      R10,#+2
   \   000000AA   0xBF0C             ITE      EQ 
   \   000000AC   0x200E             MOVEQ    R0,#+14
   \   000000AE   0x200A             MOVNE    R0,#+10
    688                      case OS_STAT_PEND_TO:
    689                      default:
    690                           *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
    691                           break;
   \   000000B0   0xE037             B.N      ??OSFlagPend_1
    692          
    693                      case OS_STAT_PEND_ABORT:
    694                           *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
    695                           break;
    696                  }
    697                  return (flags_rdy);
    698              }
   \                     ??OSFlagPend_6:
   \   000000B2   0x8920             LDRH     R0,[R4, #+8]
   \   000000B4   0xEA19 0x0600      ANDS     R6,R9,R0
   \   000000B8   0xD0D2             BEQ.N    ??OSFlagPend_9
   \                     ??OSFlagPend_8:
   \   000000BA   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000BE   0xD010             BEQ.N    ??OSFlagPend_11
   \   000000C0   0x43B0             BICS     R0,R0,R6
   \   000000C2   0xE00D             B.N      ??OSFlagPend_12
   \                     ??OSFlagPend_3:
   \   000000C4   0x8920             LDRH     R0,[R4, #+8]
   \   000000C6   0xEA29 0x0600      BIC      R6,R9,R0
   \   000000CA   0x454E             CMP      R6,R9
   \   000000CC   0xD1C8             BNE.N    ??OSFlagPend_9
   \   000000CE   0xE003             B.N      ??OSFlagPend_13
   \                     ??OSFlagPend_5:
   \   000000D0   0x8920             LDRH     R0,[R4, #+8]
   \   000000D2   0xEA39 0x0600      BICS     R6,R9,R0
   \   000000D6   0xD0C3             BEQ.N    ??OSFlagPend_9
   \                     ??OSFlagPend_13:
   \   000000D8   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000DC   0xD001             BEQ.N    ??OSFlagPend_11
   \   000000DE   0x4330             ORRS     R0,R6,R0
   \                     ??OSFlagPend_12:
   \   000000E0   0x8120             STRH     R0,[R4, #+8]
   \                     ??OSFlagPend_11:
   \   000000E2   0x....             LDR.N    R0,??DataTable8_3
   \   000000E4   0x6800             LDR      R0,[R0, #+0]
   \   000000E6   0x8306             STRH     R6,[R0, #+24]
   \   000000E8   0xE00B             B.N      ??OSFlagPend_14
    699              flags_rdy = OSTCBCur->OSTCBFlagsRdy;
   \                     ??OSFlagPend_10:
   \   000000EA   0x8B06             LDRH     R6,[R0, #+24]
    700              if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
   \   000000EC   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000F0   0xD007             BEQ.N    ??OSFlagPend_14
    701                  switch (wait_type) {
   \   000000F2   0x2F01             CMP      R7,#+1
   \   000000F4   0xD90E             BLS.N    ??OSFlagPend_15
   \   000000F6   0x1EBF             SUBS     R7,R7,#+2
   \   000000F8   0x2F01             CMP      R7,#+1
   \   000000FA   0xD80E             BHI.N    ??OSFlagPend_7
    702                      case OS_FLAG_WAIT_SET_ALL:
    703                      case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
    704                           pgrp->OSFlagFlags &= ~flags_rdy;
   \   000000FC   0x8920             LDRH     R0,[R4, #+8]
   \   000000FE   0x43B0             BICS     R0,R0,R6
   \                     ??OSFlagPend_16:
   \   00000100   0x8120             STRH     R0,[R4, #+8]
    705                           break;
    706          
    707          #if OS_FLAG_WAIT_CLR_EN > 0
    708                      case OS_FLAG_WAIT_CLR_ALL:
    709                      case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
    710                           pgrp->OSFlagFlags |=  flags_rdy;
    711                           break;
    712          #endif
    713                      default:
    714                           OS_EXIT_CRITICAL();
    715                           *perr = OS_ERR_FLAG_WAIT_TYPE;
    716                           return ((OS_FLAGS)0);
    717                  }
    718              }
    719              OS_EXIT_CRITICAL();
   \                     ??OSFlagPend_14:
   \   00000102   0x4640             MOV      R0,R8
   \   00000104   0x.... 0x....      BL       OS_CPU_SR_Restore
    720              *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0x7028             STRB     R0,[R5, #+0]
    721              return (flags_rdy);
   \   0000010C   0x4630             MOV      R0,R6
   \                     ??OSFlagPend_17:
   \   0000010E   0xB007             ADD      SP,SP,#+28
   \   00000110   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??OSFlagPend_15:
   \   00000114   0x8920             LDRH     R0,[R4, #+8]
   \   00000116   0x4330             ORRS     R0,R6,R0
   \   00000118   0xE7F2             B.N      ??OSFlagPend_16
   \                     ??OSFlagPend_7:
   \   0000011A   0x4640             MOV      R0,R8
   \   0000011C   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   00000120   0x206F             MOVS     R0,#+111
   \                     ??OSFlagPend_1:
   \   00000122   0x7028             STRB     R0,[R5, #+0]
   \   00000124   0x2000             MOVS     R0,#+0
   \   00000126   0xE7F2             B.N      ??OSFlagPend_17
    722          }
    723          /*$PAGE*/
    724          /*
    725          *********************************************************************************************************
    726          *                               GET FLAGS WHO CAUSED TASK TO BECOME READY
    727          *
    728          * Description: This function is called to obtain the flags that caused the task to become ready to run.
    729          *              In other words, this function allows you to tell "Who done it!".
    730          *
    731          * Arguments  : None
    732          *
    733          * Returns    : The flags that caused the task to be ready.
    734          *
    735          * Called from: Task ONLY
    736          *********************************************************************************************************
    737          */
    738          

   \                                 In section .text, align 2, keep-with-next
    739          OS_FLAGS  OSFlagPendGetFlagsRdy (void)
    740          {
   \                     OSFlagPendGetFlagsRdy:
   \   00000000   0xB510             PUSH     {R4,LR}
    741              OS_FLAGS      flags;
    742          #if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    743              OS_CPU_SR     cpu_sr = 0;
    744          #endif
    745          
    746          
    747          
    748              OS_ENTER_CRITICAL();
   \   00000002   0x.... 0x....      BL       OS_CPU_SR_Save
    749              flags = OSTCBCur->OSTCBFlagsRdy;
   \   00000006   0x....             LDR.N    R1,??DataTable8_3
   \   00000008   0x6809             LDR      R1,[R1, #+0]
   \   0000000A   0x8B0C             LDRH     R4,[R1, #+24]
    750              OS_EXIT_CRITICAL();
   \   0000000C   0x.... 0x....      BL       OS_CPU_SR_Restore
    751              return (flags);
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
    752          }
    753          
    754          /*$PAGE*/
    755          /*
    756          *********************************************************************************************************
    757          *                                         POST EVENT FLAG BIT(S)
    758          *
    759          * Description: This function is called to set or clear some bits in an event flag group.  The bits to
    760          *              set or clear are specified by a 'bit mask'.
    761          *
    762          * Arguments  : pgrp          is a pointer to the desired event flag group.
    763          *
    764          *              flags         If 'opt' (see below) is OS_FLAG_SET, each bit that is set in 'flags' will
    765          *                            set the corresponding bit in the event flag group.  e.g. to set bits 0, 4
    766          *                            and 5 you would set 'flags' to:
    767          *
    768          *                                0x31     (note, bit 0 is least significant bit)
    769          *
    770          *                            If 'opt' (see below) is OS_FLAG_CLR, each bit that is set in 'flags' will
    771          *                            CLEAR the corresponding bit in the event flag group.  e.g. to clear bits 0,
    772          *                            4 and 5 you would specify 'flags' as:
    773          *
    774          *                                0x31     (note, bit 0 is least significant bit)
    775          *
    776          *              opt           indicates whether the flags will be:
    777          *                                set     (OS_FLAG_SET) or
    778          *                                cleared (OS_FLAG_CLR)
    779          *
    780          *              perr          is a pointer to an error code and can be:
    781          *                            OS_ERR_NONE                The call was successfull
    782          *                            OS_ERR_FLAG_INVALID_PGRP   You passed a NULL pointer
    783          *                            OS_ERR_EVENT_TYPE          You are not pointing to an event flag group
    784          *                            OS_ERR_FLAG_INVALID_OPT    You specified an invalid option
    785          *
    786          * Returns    : the new value of the event flags bits that are still set.
    787          *
    788          * Called From: Task or ISR
    789          *
    790          * WARNING(s) : 1) The execution time of this function depends on the number of tasks waiting on the event
    791          *                 flag group.
    792          *              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
    793          *                 the event flag group.
    794          *********************************************************************************************************
    795          */

   \                                 In section .text, align 2, keep-with-next
    796          OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
    797          {
   \                     OSFlagPost:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x4606             MOV      R6,R0
   \   00000006   0x460F             MOV      R7,R1
   \   00000008   0x4615             MOV      R5,R2
   \   0000000A   0x461C             MOV      R4,R3
    798              OS_FLAG_NODE *pnode;
    799              BOOLEAN       sched;
    800              OS_FLAGS      flags_cur;
    801              OS_FLAGS      flags_rdy;
    802              BOOLEAN       rdy;
    803          #if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    804              OS_CPU_SR     cpu_sr = 0;
    805          #endif
    806          
    807          
    808          
    809          #if OS_ARG_CHK_EN > 0
    810              if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
    811                  return ((OS_FLAGS)0);
    812              }
    813              if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
    814                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    815                  return ((OS_FLAGS)0);
    816              }
    817          #endif
    818              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
   \   0000000C   0x7830             LDRB     R0,[R6, #+0]
   \   0000000E   0x2805             CMP      R0,#+5
   \   00000010   0xBF18             IT       NE 
   \   00000012   0x2001             MOVNE    R0,#+1
    819                  *perr = OS_ERR_EVENT_TYPE;
   \   00000014   0xD13A             BNE.N    ??OSFlagPost_0
    820                  return ((OS_FLAGS)0);
    821              }
    822          /*$PAGE*/
    823              OS_ENTER_CRITICAL();
   \   00000016   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000001A   0x4680             MOV      R8,R0
    824              switch (opt) {
   \   0000001C   0xB115             CBZ.N    R5,??OSFlagPost_1
   \   0000001E   0x2D01             CMP      R5,#+1
   \   00000020   0xD006             BEQ.N    ??OSFlagPost_2
   \   00000022   0xE008             B.N      ??OSFlagPost_3
    825                  case OS_FLAG_CLR:
    826                       pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
   \                     ??OSFlagPost_1:
   \   00000024   0x8930             LDRH     R0,[R6, #+8]
   \   00000026   0x43B8             BICS     R0,R0,R7
   \                     ??OSFlagPost_4:
   \   00000028   0x8130             STRH     R0,[R6, #+8]
    827                       break;
    828          
    829                  case OS_FLAG_SET:
    830                       pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
    831                       break;
    832          
    833                  default:
    834                       OS_EXIT_CRITICAL();                     /* INVALID option                                 */
    835                       *perr = OS_ERR_FLAG_INVALID_OPT;
    836                       return ((OS_FLAGS)0);
    837              }
    838              sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
   \   0000002A   0x2700             MOVS     R7,#+0
    839              pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
   \   0000002C   0x6875             LDR      R5,[R6, #+4]
   \   0000002E   0xE012             B.N      ??OSFlagPost_5
   \                     ??OSFlagPost_2:
   \   00000030   0x8930             LDRH     R0,[R6, #+8]
   \   00000032   0x4338             ORRS     R0,R7,R0
   \   00000034   0xE7F8             B.N      ??OSFlagPost_4
   \                     ??OSFlagPost_3:
   \   00000036   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   0000003A   0x2071             MOVS     R0,#+113
   \   0000003C   0xE026             B.N      ??OSFlagPost_0
    840              while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
    841                  switch (pnode->OSFlagNodeWaitType) {
    842                      case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
    843                           flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
   \                     ??OSFlagPost_6:
   \   0000003E   0x8A28             LDRH     R0,[R5, #+16]
   \   00000040   0x8931             LDRH     R1,[R6, #+8]
   \   00000042   0x4001             ANDS     R1,R0,R1
    844                           if (flags_rdy == pnode->OSFlagNodeFlags) {
   \                     ??OSFlagPost_7:
   \   00000044   0x4281             CMP      R1,R0
   \   00000046   0xD105             BNE.N    ??OSFlagPost_8
    845                               rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
    846                               if (rdy == OS_TRUE) {
   \                     ??OSFlagPost_9:
   \   00000048   0x4628             MOV      R0,R5
   \   0000004A   0x.... 0x....      BL       OS_FlagTaskRdy
   \   0000004E   0x2801             CMP      R0,#+1
   \   00000050   0xBF08             IT       EQ 
   \   00000052   0x2701             MOVEQ    R7,#+1
    847                                   sched = OS_TRUE;                     /* When done we will reschedule          */
    848                               }
    849                           }
    850                           break;
    851          
    852                      case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
    853                           flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
    854                           if (flags_rdy != (OS_FLAGS)0) {
    855                               rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
    856                               if (rdy == OS_TRUE) {
    857                                   sched = OS_TRUE;                     /* When done we will reschedule          */
    858                               }
    859                           }
    860                           break;
    861          
    862          #if OS_FLAG_WAIT_CLR_EN > 0
    863                      case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
    864                           flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
    865                           if (flags_rdy == pnode->OSFlagNodeFlags) {
    866                               rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
    867                               if (rdy == OS_TRUE) {
    868                                   sched = OS_TRUE;                     /* When done we will reschedule          */
    869                               }
    870                           }
    871                           break;
    872          
    873                      case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
    874                           flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
    875                           if (flags_rdy != (OS_FLAGS)0) {
    876                               rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
    877                               if (rdy == OS_TRUE) {
    878                                   sched = OS_TRUE;                     /* When done we will reschedule          */
    879                               }
    880                           }
    881                           break;
    882          #endif
    883                      default:
    884                           OS_EXIT_CRITICAL();
    885                           *perr = OS_ERR_FLAG_WAIT_TYPE;
    886                           return ((OS_FLAGS)0);
    887                  }
    888                  pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
   \                     ??OSFlagPost_8:
   \   00000054   0x682D             LDR      R5,[R5, #+0]
   \                     ??OSFlagPost_5:
   \   00000056   0xB1E5             CBZ.N    R5,??OSFlagPost_10
   \   00000058   0x7CA8             LDRB     R0,[R5, #+18]
   \   0000005A   0xB148             CBZ.N    R0,??OSFlagPost_11
   \   0000005C   0x2802             CMP      R0,#+2
   \   0000005E   0xD0EE             BEQ.N    ??OSFlagPost_6
   \   00000060   0xD30B             BCC.N    ??OSFlagPost_12
   \   00000062   0x2803             CMP      R0,#+3
   \   00000064   0xD10E             BNE.N    ??OSFlagPost_13
   \   00000066   0x8930             LDRH     R0,[R6, #+8]
   \   00000068   0x8A29             LDRH     R1,[R5, #+16]
   \   0000006A   0x4001             ANDS     R1,R1,R0
   \   0000006C   0xD0F2             BEQ.N    ??OSFlagPost_8
   \   0000006E   0xE7EB             B.N      ??OSFlagPost_9
   \                     ??OSFlagPost_11:
   \   00000070   0x8A28             LDRH     R0,[R5, #+16]
   \   00000072   0x8931             LDRH     R1,[R6, #+8]
   \   00000074   0xEA20 0x0101      BIC      R1,R0,R1
   \   00000078   0xE7E4             B.N      ??OSFlagPost_7
   \                     ??OSFlagPost_12:
   \   0000007A   0x8930             LDRH     R0,[R6, #+8]
   \   0000007C   0x8A29             LDRH     R1,[R5, #+16]
   \   0000007E   0x4381             BICS     R1,R1,R0
   \   00000080   0xD0E8             BEQ.N    ??OSFlagPost_8
   \   00000082   0xE7E1             B.N      ??OSFlagPost_9
   \                     ??OSFlagPost_13:
   \   00000084   0x4640             MOV      R0,R8
   \   00000086   0x.... 0x....      BL       OS_CPU_SR_Restore
   \   0000008A   0x206F             MOVS     R0,#+111
   \                     ??OSFlagPost_0:
   \   0000008C   0x7020             STRB     R0,[R4, #+0]
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0xE00D             B.N      ??OSFlagPost_14
    889              }
    890              OS_EXIT_CRITICAL();
   \                     ??OSFlagPost_10:
   \   00000092   0x4640             MOV      R0,R8
   \   00000094   0x.... 0x....      BL       OS_CPU_SR_Restore
    891              if (sched == OS_TRUE) {
   \   00000098   0xB10F             CBZ.N    R7,??OSFlagPost_15
    892                  OS_Sched();
   \   0000009A   0x.... 0x....      BL       OS_Sched
    893              }
    894              OS_ENTER_CRITICAL();
   \                     ??OSFlagPost_15:
   \   0000009E   0x.... 0x....      BL       OS_CPU_SR_Save
    895              flags_cur = pgrp->OSFlagFlags;
   \   000000A2   0x8936             LDRH     R6,[R6, #+8]
    896              OS_EXIT_CRITICAL();
   \   000000A4   0x.... 0x....      BL       OS_CPU_SR_Restore
    897              *perr     = OS_ERR_NONE;
   \   000000A8   0x2000             MOVS     R0,#+0
   \   000000AA   0x7020             STRB     R0,[R4, #+0]
    898              return (flags_cur);
   \   000000AC   0x4630             MOV      R0,R6
   \                     ??OSFlagPost_14:
   \   000000AE   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    899          }
    900          /*$PAGE*/
    901          /*
    902          *********************************************************************************************************
    903          *                                           QUERY EVENT FLAG
    904          *
    905          * Description: This function is used to check the value of the event flag group.
    906          *
    907          * Arguments  : pgrp         is a pointer to the desired event flag group.
    908          *
    909          *              perr          is a pointer to an error code returned to the called:
    910          *                            OS_ERR_NONE                The call was successfull
    911          *                            OS_ERR_FLAG_INVALID_PGRP   You passed a NULL pointer
    912          *                            OS_ERR_EVENT_TYPE          You are not pointing to an event flag group
    913          *
    914          * Returns    : The current value of the event flag group.
    915          *
    916          * Called From: Task or ISR
    917          *********************************************************************************************************
    918          */
    919          
    920          #if OS_FLAG_QUERY_EN > 0

   \                                 In section .text, align 2, keep-with-next
    921          OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
    922          {
   \                     OSFlagQuery:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    923              OS_FLAGS   flags;
    924          #if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    925              OS_CPU_SR  cpu_sr = 0;
    926          #endif
    927          
    928          
    929          
    930          #if OS_ARG_CHK_EN > 0
    931              if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
    932                  return ((OS_FLAGS)0);
    933              }
    934              if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
    935                  *perr = OS_ERR_FLAG_INVALID_PGRP;
    936                  return ((OS_FLAGS)0);
    937              }
    938          #endif
    939              if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2805             CMP      R0,#+5
   \   0000000A   0xD003             BEQ.N    ??OSFlagQuery_0
    940                  *perr = OS_ERR_EVENT_TYPE;
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x7028             STRB     R0,[R5, #+0]
    941                  return ((OS_FLAGS)0);
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xBD32             POP      {R1,R4,R5,PC}
    942              }
    943              OS_ENTER_CRITICAL();
   \                     ??OSFlagQuery_0:
   \   00000014   0x.... 0x....      BL       OS_CPU_SR_Save
    944              flags = pgrp->OSFlagFlags;
   \   00000018   0x8924             LDRH     R4,[R4, #+8]
    945              OS_EXIT_CRITICAL();
   \   0000001A   0x.... 0x....      BL       OS_CPU_SR_Restore
    946              *perr = OS_ERR_NONE;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x7028             STRB     R0,[R5, #+0]
    947              return (flags);                               /* Return the current value of the event flags       */
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    948          }
    949          #endif
    950          
    951          /*$PAGE*/
    952          /*
    953          *********************************************************************************************************
    954          *                         SUSPEND TASK UNTIL EVENT FLAG(s) RECEIVED OR TIMEOUT OCCURS
    955          *
    956          * Description: This function is internal to uC/OS-II and is used to put a task to sleep until the desired
    957          *              event flag bit(s) are set.
    958          *
    959          * Arguments  : pgrp          is a pointer to the desired event flag group.
    960          *
    961          *              pnode         is a pointer to a structure which contains data about the task waiting for
    962          *                            event flag bit(s) to be set.
    963          *
    964          *              flags         Is a bit pattern indicating which bit(s) (i.e. flags) you wish to check.
    965          *                            The bits you want are specified by setting the corresponding bits in
    966          *                            'flags'.  e.g. if your application wants to wait for bits 0 and 1 then
    967          *                            'flags' would contain 0x03.
    968          *
    969          *              wait_type     specifies whether you want ALL bits to be set/cleared or ANY of the bits
    970          *                            to be set/cleared.
    971          *                            You can specify the following argument:
    972          *
    973          *                            OS_FLAG_WAIT_CLR_ALL   You will check ALL bits in 'mask' to be clear (0)
    974          *                            OS_FLAG_WAIT_CLR_ANY   You will check ANY bit  in 'mask' to be clear (0)
    975          *                            OS_FLAG_WAIT_SET_ALL   You will check ALL bits in 'mask' to be set   (1)
    976          *                            OS_FLAG_WAIT_SET_ANY   You will check ANY bit  in 'mask' to be set   (1)
    977          *
    978          *              timeout       is the desired amount of time that the task will wait for the event flag
    979          *                            bit(s) to be set.
    980          *
    981          * Returns    : none
    982          *
    983          * Called by  : OSFlagPend()  OS_FLAG.C
    984          *
    985          * Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
    986          *********************************************************************************************************
    987          */
    988          

   \                                 In section .text, align 2, keep-with-next
    989          static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
    990          {
   \                     OS_FlagBlock:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x9C04             LDR      R4,[SP, #+16]
    991              OS_FLAG_NODE  *pnode_next;
    992              INT8U          y;
    993          
    994          
    995              OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
   \   00000004   0x....             LDR.N    R5,??DataTable8_3
   \   00000006   0x682E             LDR      R6,[R5, #+0]
   \   00000008   0x7F37             LDRB     R7,[R6, #+28]
   \   0000000A   0xF047 0x0720      ORR      R7,R7,#0x20
   \   0000000E   0x7737             STRB     R7,[R6, #+28]
    996              OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
   \   00000010   0x682E             LDR      R6,[R5, #+0]
   \   00000012   0x2700             MOVS     R7,#+0
   \   00000014   0x7777             STRB     R7,[R6, #+29]
    997              OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
   \   00000016   0x682E             LDR      R6,[R5, #+0]
   \   00000018   0x8374             STRH     R4,[R6, #+26]
    998          #if OS_TASK_DEL_EN > 0
    999              OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
   \   0000001A   0x6171             STR      R1,[R6, #+20]
   1000          #endif
   1001              pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
   \   0000001C   0x820A             STRH     R2,[R1, #+16]
   1002              pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
   \   0000001E   0x748B             STRB     R3,[R1, #+18]
   1003              pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
   \   00000020   0x682A             LDR      R2,[R5, #+0]
   \   00000022   0x608A             STR      R2,[R1, #+8]
   1004              pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
   \   00000024   0x6843             LDR      R3,[R0, #+4]
   \   00000026   0x600B             STR      R3,[R1, #+0]
   1005              pnode->OSFlagNodePrev     = (void *)0;
   \   00000028   0x604F             STR      R7,[R1, #+4]
   1006              pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
   \   0000002A   0x60C8             STR      R0,[R1, #+12]
   1007              pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
   \   0000002C   0x6843             LDR      R3,[R0, #+4]
   1008              if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
   \   0000002E   0xB103             CBZ.N    R3,??OS_FlagBlock_0
   1009                  pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
   \   00000030   0x6059             STR      R1,[R3, #+4]
   1010              }
   1011              pgrp->OSFlagWaitList = (void *)pnode;
   \                     ??OS_FlagBlock_0:
   \   00000032   0x6041             STR      R1,[R0, #+4]
   1012          
   1013              y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
   \   00000034   0xF892 0x0020      LDRB     R0,[R2, #+32]
   1014              OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
   \   00000038   0xF102 0x0120      ADD      R1,R2,#+32
   \   0000003C   0x....             LDR.N    R2,??DataTable8_4
   \   0000003E   0x5C83             LDRB     R3,[R0, R2]
   \   00000040   0x784C             LDRB     R4,[R1, #+1]
   \   00000042   0x43A3             BICS     R3,R3,R4
   \   00000044   0x5483             STRB     R3,[R0, R2]
   1015              if (OSRdyTbl[y] == 0x00) {
   \   00000046   0xD105             BNE.N    ??OS_FlagBlock_1
   1016                  OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
   \   00000048   0x....             LDR.N    R0,??DataTable8_5
   \   0000004A   0x7802             LDRB     R2,[R0, #+0]
   \   0000004C   0x7889             LDRB     R1,[R1, #+2]
   \   0000004E   0xEA22 0x0101      BIC      R1,R2,R1
   \   00000052   0x7001             STRB     R1,[R0, #+0]
   1017              }
   1018          }
   \                     ??OS_FlagBlock_1:
   \   00000054   0xBCF0             POP      {R4-R7}
   \   00000056   0x4770             BX       LR               ;; return
   1019          
   1020          /*$PAGE*/
   1021          /*
   1022          *********************************************************************************************************
   1023          *                                    INITIALIZE THE EVENT FLAG MODULE
   1024          *
   1025          * Description: This function is called by uC/OS-II to initialize the event flag module.  Your application
   1026          *              MUST NOT call this function.  In other words, this function is internal to uC/OS-II.
   1027          *
   1028          * Arguments  : none
   1029          *
   1030          * Returns    : none
   1031          *
   1032          * WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
   1033          *********************************************************************************************************
   1034          */
   1035          

   \                                 In section .text, align 2, keep-with-next
   1036          void  OS_FlagInit (void)
   1037          {
   \                     OS_FlagInit:
   \   00000000   0xB510             PUSH     {R4,LR}
   1038          #if OS_MAX_FLAGS == 1
   1039              OSFlagFreeList                 = (OS_FLAG_GRP *)&OSFlagTbl[0];  /* Only ONE event flag group!      */
   1040              OSFlagFreeList->OSFlagType     = OS_EVENT_TYPE_UNUSED;
   1041              OSFlagFreeList->OSFlagWaitList = (void *)0;
   1042              OSFlagFreeList->OSFlagFlags    = (OS_FLAGS)0;
   1043          #if OS_FLAG_NAME_SIZE > 1
   1044              OSFlagFreeList->OSFlagName[0]  = '?';
   1045              OSFlagFreeList->OSFlagName[1]  = OS_ASCII_NUL;
   1046          #endif
   1047          #endif
   1048          
   1049          #if OS_MAX_FLAGS >= 2
   1050              INT16U       i;
   1051              OS_FLAG_GRP *pgrp1;
   1052              OS_FLAG_GRP *pgrp2;
   1053          
   1054          
   1055              OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
   \   00000002   0x....             LDR.N    R4,??DataTable8_6
   \   00000004   0x218C             MOVS     R1,#+140
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      BL       OS_MemClr
   1056              pgrp1 = &OSFlagTbl[0];
   \   0000000C   0x4620             MOV      R0,R4
   1057              pgrp2 = &OSFlagTbl[1];
   \   0000000E   0xF204 0x011C      ADDW     R1,R4,#+28
   1058              for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
   \   00000012   0x2204             MOVS     R2,#+4
   1059                  pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
   \                     ??OS_FlagInit_0:
   \   00000014   0x2300             MOVS     R3,#+0
   \   00000016   0xF800 0x3B04      STRB     R3,[R0], #+4
   1060                  pgrp1->OSFlagWaitList = (void *)pgrp2;
   \   0000001A   0xF840 0x1B06      STR      R1,[R0], #+6
   1061          #if OS_FLAG_NAME_SIZE > 1
   1062                  pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
   \   0000001E   0x233F             MOVS     R3,#+63
   \   00000020   0xF800 0x3B01      STRB     R3,[R0], #+1
   1063                  pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
   \   00000024   0x2300             MOVS     R3,#+0
   \   00000026   0xF800 0x3B11      STRB     R3,[R0], #+17
   1064          #endif
   1065                  pgrp1++;
   1066                  pgrp2++;
   \   0000002A   0xF201 0x011C      ADDW     R1,R1,#+28
   1067              }
   \   0000002E   0x1E52             SUBS     R2,R2,#+1
   \   00000030   0xD1F0             BNE.N    ??OS_FlagInit_0
   1068              pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
   \   00000032   0x7003             STRB     R3,[R0, #+0]
   1069              pgrp1->OSFlagWaitList = (void *)0;
   \   00000034   0x6043             STR      R3,[R0, #+4]
   1070          #if OS_FLAG_NAME_SIZE > 1
   1071              pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
   \   00000036   0x213F             MOVS     R1,#+63
   \   00000038   0x7281             STRB     R1,[R0, #+10]
   1072              pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
   \   0000003A   0x72C3             STRB     R3,[R0, #+11]
   1073          #endif
   1074              OSFlagFreeList        = &OSFlagTbl[0];
   \   0000003C   0x....             LDR.N    R0,??DataTable8_1
   \   0000003E   0x6004             STR      R4,[R0, #+0]
   1075          #endif
   1076          }
   \   00000040   0xBD10             POP      {R4,PC}          ;; return
   1077          
   1078          /*$PAGE*/
   1079          /*
   1080          *********************************************************************************************************
   1081          *                              MAKE TASK READY-TO-RUN, EVENT(s) OCCURRED
   1082          *
   1083          * Description: This function is internal to uC/OS-II and is used to make a task ready-to-run because the
   1084          *              desired event flag bits have been set.
   1085          *
   1086          * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
   1087          *                            event flag bit(s) to be set.
   1088          *
   1089          *              flags_rdy     contains the bit pattern of the event flags that cause the task to become
   1090          *                            ready-to-run.
   1091          *
   1092          * Returns    : OS_TRUE       If the task has been placed in the ready list and thus needs scheduling
   1093          *              OS_FALSE      The task is still not ready to run and thus scheduling is not necessary
   1094          *
   1095          * Called by  : OSFlagsPost() OS_FLAG.C
   1096          *
   1097          * Note(s)    : 1) This function assumes that interrupts are disabled.
   1098          *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
   1099          *********************************************************************************************************
   1100          */
   1101          

   \                                 In section .text, align 2, keep-with-next
   1102          static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
   1103          {
   \                     OS_FlagTaskRdy:
   \   00000000   0xB510             PUSH     {R4,LR}
   1104              OS_TCB   *ptcb;
   1105              BOOLEAN   sched;
   1106          
   1107          
   1108              ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
   \   00000002   0x6883             LDR      R3,[R0, #+8]
   1109              ptcb->OSTCBDly       = 0;
   \   00000004   0xF103 0x0218      ADD      R2,R3,#+24
   \   00000008   0x2400             MOVS     R4,#+0
   \   0000000A   0x8054             STRH     R4,[R2, #+2]
   1110              ptcb->OSTCBFlagsRdy  = flags_rdy;
   \   0000000C   0x8319             STRH     R1,[R3, #+24]
   1111              ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
   \   0000000E   0x7911             LDRB     R1,[R2, #+4]
   \   00000010   0xF001 0x01DF      AND      R1,R1,#0xDF
   \   00000014   0x7111             STRB     R1,[R2, #+4]
   1112              ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
   \   00000016   0x7154             STRB     R4,[R2, #+5]
   1113              if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
   \   00000018   0x7911             LDRB     R1,[R2, #+4]
   \   0000001A   0xB959             CBNZ.N   R1,??OS_FlagTaskRdy_0
   1114                  OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
   \   0000001C   0x....             LDR.N    R1,??DataTable8_5
   \   0000001E   0x780B             LDRB     R3,[R1, #+0]
   \   00000020   0x7A94             LDRB     R4,[R2, #+10]
   \   00000022   0x4323             ORRS     R3,R4,R3
   \   00000024   0x700B             STRB     R3,[R1, #+0]
   \   00000026   0x7A11             LDRB     R1,[R2, #+8]
   \   00000028   0x....             LDR.N    R3,??DataTable8_4
   \   0000002A   0x5CCC             LDRB     R4,[R1, R3]
   \   0000002C   0x7A52             LDRB     R2,[R2, #+9]
   \   0000002E   0x4322             ORRS     R2,R2,R4
   \   00000030   0x54CA             STRB     R2,[R1, R3]
   1115                  OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
   1116                  sched                   = OS_TRUE;
   \   00000032   0x2401             MOVS     R4,#+1
   1117              } else {
   1118                  sched                   = OS_FALSE;
   1119              }
   1120              OS_FlagUnlink(pnode);
   \                     ??OS_FlagTaskRdy_0:
   \   00000034   0x.... 0x....      BL       OS_FlagUnlink
   1121              return (sched);
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0xBD10             POP      {R4,PC}          ;; return
   1122          }
   1123          
   1124          /*$PAGE*/
   1125          /*
   1126          *********************************************************************************************************
   1127          *                                  UNLINK EVENT FLAG NODE FROM WAITING LIST
   1128          *
   1129          * Description: This function is internal to uC/OS-II and is used to unlink an event flag node from a
   1130          *              list of tasks waiting for the event flag.
   1131          *
   1132          * Arguments  : pnode         is a pointer to a structure which contains data about the task waiting for
   1133          *                            event flag bit(s) to be set.
   1134          *
   1135          * Returns    : none
   1136          *
   1137          * Called by  : OS_FlagTaskRdy() OS_FLAG.C
   1138          *              OSFlagPend()     OS_FLAG.C
   1139          *              OSTaskDel()      OS_TASK.C
   1140          *
   1141          * Note(s)    : 1) This function assumes that interrupts are disabled.
   1142          *              2) This function is INTERNAL to uC/OS-II and your application should not call it.
   1143          *********************************************************************************************************
   1144          */
   1145          

   \                                 In section .text, align 2, keep-with-next
   1146          void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
   1147          {
   1148          #if OS_TASK_DEL_EN > 0
   1149              OS_TCB       *ptcb;
   1150          #endif
   1151              OS_FLAG_GRP  *pgrp;
   1152              OS_FLAG_NODE *pnode_prev;
   1153              OS_FLAG_NODE *pnode_next;
   1154          
   1155          
   1156              pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
   \                     OS_FlagUnlink:
   \   00000000   0x6841             LDR      R1,[R0, #+4]
   1157              pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
   \   00000002   0x6802             LDR      R2,[R0, #+0]
   1158              if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
   \   00000004   0xB921             CBNZ.N   R1,??OS_FlagUnlink_0
   1159                  pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
   1160                  pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
   \   00000006   0x68C1             LDR      R1,[R0, #+12]
   \   00000008   0x604A             STR      R2,[R1, #+4]
   1161                  if (pnode_next != (OS_FLAG_NODE *)0) {
   \   0000000A   0xB122             CBZ.N    R2,??OS_FlagUnlink_1
   1162                      pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xE001             B.N      ??OS_FlagUnlink_2
   1163                  }
   1164              } else {                                                    /* No,  A node somewhere in the list   */
   1165                  pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
   \                     ??OS_FlagUnlink_0:
   \   00000010   0x600A             STR      R2,[R1, #+0]
   1166                  if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
   \   00000012   0xB102             CBZ.N    R2,??OS_FlagUnlink_1
   1167                      pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
   \                     ??OS_FlagUnlink_2:
   \   00000014   0x6051             STR      R1,[R2, #+4]
   1168                  }
   1169              }
   1170          #if OS_TASK_DEL_EN > 0
   1171              ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
   1172              ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
   \                     ??OS_FlagUnlink_1:
   \   00000016   0x6880             LDR      R0,[R0, #+8]
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x6141             STR      R1,[R0, #+20]
   1173          #endif
   1174          }
   \   0000001C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     OSIntNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     OSFlagFreeList

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x........         DC32     OSLockNesting

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x........         DC32     OSTCBCur

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x........         DC32     OSRdyTbl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x........         DC32     OSRdyGrp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x........         DC32     OSFlagTbl
   1175          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       24  OSFlagAccept
             24 -> OS_CPU_SR_Restore
             24 -> OS_CPU_SR_Save
       16  OSFlagCreate
             16 -> OS_CPU_SR_Restore
             16 -> OS_CPU_SR_Save
       32  OSFlagDel
             32 -> OS_CPU_SR_Restore
             32 -> OS_CPU_SR_Save
             32 -> OS_FlagTaskRdy
             32 -> OS_Sched
       24  OSFlagNameGet
             24 -> OS_CPU_SR_Restore
             24 -> OS_CPU_SR_Save
             24 -> OS_StrCopy
       24  OSFlagNameSet
             24 -> OS_CPU_SR_Restore
             24 -> OS_CPU_SR_Save
             24 -> OS_StrCopy
             24 -> OS_StrLen
       64  OSFlagPend
             64 -> OS_CPU_SR_Restore
             64 -> OS_CPU_SR_Save
             64 -> OS_FlagBlock
             64 -> OS_FlagUnlink
             64 -> OS_Sched
        8  OSFlagPendGetFlagsRdy
              8 -> OS_CPU_SR_Restore
              8 -> OS_CPU_SR_Save
       24  OSFlagPost
             24 -> OS_CPU_SR_Restore
             24 -> OS_CPU_SR_Save
             24 -> OS_FlagTaskRdy
             24 -> OS_Sched
       16  OSFlagQuery
             16 -> OS_CPU_SR_Restore
             16 -> OS_CPU_SR_Save
       16  OS_FlagBlock
        8  OS_FlagInit
              8 -> OS_MemClr
        8  OS_FlagTaskRdy
              8 -> OS_FlagUnlink
        0  OS_FlagUnlink


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
     146  OSFlagAccept
      78  OSFlagCreate
     176  OSFlagDel
      72  OSFlagNameGet
      82  OSFlagNameSet
     296  OSFlagPend
      20  OSFlagPendGetFlagsRdy
     178  OSFlagPost
      38  OSFlagQuery
      88  OS_FlagBlock
      66  OS_FlagInit
      60  OS_FlagTaskRdy
      30  OS_FlagUnlink

 
 1 358 bytes in section .text
 
 1 358 bytes of CODE memory

Errors: none
Warnings: none

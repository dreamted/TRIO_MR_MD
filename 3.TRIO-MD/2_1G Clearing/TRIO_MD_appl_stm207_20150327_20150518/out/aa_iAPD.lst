###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     18/May/2015  16:57:15 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\code\aa_iAPD.c                                    #
#    Command line =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\code\aa_iAPD.c -lC D:\Project\TRIO_MD\3.F_W\TRIO_ #
#                    MD_appl_stm207_20150327_20150518\out\ -o                 #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\out\ --endian=little --cpu=Cortex-M3 -e           #
#                    --fpu=None --dlib_config "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_2 #
#                    0150327_20150518\include\ -I                             #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\STM32F2xx_StdPeriph_Driver_v1212\ -I              #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\STM32F2xx_StdPeriph_Driver_v1212\inc\ -I          #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\uC-CPU\ -I D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_ #
#                    stm207_20150327_20150518\uC-LIB\ -I                      #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\uCOS-II\Ports\ -I D:\Project\TRIO_MD\3.F_W\TRIO_M #
#                    D_appl_stm207_20150327_20150518\uCOS-II\Source\ -I       #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\uC-Probe\ -Oh --use_c++_inline                    #
#    List file    =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\out\aa_iAPD.lst                                   #
#    Object file  =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\out\aa_iAPD.o                                     #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20150518\code\aa_iAPD.c
      1          /******************** (C) COPYRIGHT 2007 STMicroelectronics ********************
      2          * File Name          : stm32f10x_bkp.c
      3          * Author             : MCD Application Team
      4          * Date First Issued  : 09/29/2006
      5          * Description        : This file provides all the BKP firmware functions.
      6          ********************************************************************************/
      7          #if 1
      8          
      9          #define APD_C
     10          //#define APD_DEBUG
     11          
     12          #include "../include/main.h"

   \                                 In section .bss, align 4
   \   __absolute DevSPIxStr AT25DFSpi
   \                     AT25DFSpi:
   \   00000000                      DS8 8
   \   __absolute DevSPIxStr N25QSpi
   \                     N25QSpi:
   \   00000008                      DS8 8
   \   __absolute DevSPIxStr iFPGASpi
   \                     iFPGASpi:
   \   00000010                      DS8 8
   \   __absolute INT16U FlashTotFrame
   \                     FlashTotFrame:
   \   00000018                      DS8 2
   \   __absolute INT16U FlashSwcrc16
   \                     FlashSwcrc16:
   \   0000001A                      DS8 2
   \   __absolute DevSPIxStr FPGASpi
   \                     FPGASpi:
   \   0000001C                      DS8 8
   \   00000024                      DS8 800

   \                                 In section .bss, align 4
   \   __absolute DevSPIxStr FPGACfgSpi
   \                     FPGACfgSpi:
   \   00000000                      DS8 8

   \                                 In section .bss, align 1
   \   __absolute INT8U FPGACfgFinish
   \                     FPGACfgFinish:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute INT8U FPGARUSumAlm
   \                     FPGARUSumAlm:
   \   00000000                      DS8 1
     13          //#include    "stm32f10x_spi_v1203.h"

   \                                 In section .text, align 2, keep-with-next
     14          void iAPDInit(void)
     15          {
   \                     iAPDInit:
   \   00000000   0xB510             PUSH     {R4,LR}
     16          	sFLASH_CS0_Init();		// SPI2
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable17
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x.... 0x....      BL       OSSemCreate
   \   0000000C   0x6060             STR      R0,[R4, #+4]
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x7060             STRB     R0,[R4, #+1]
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x7020             STRB     R0,[R4, #+0]
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       sFLASH_Init
     17          	sFLASH_CS1_Init();		// SPI1
   \   0000001C   0x2000             MOVS     R0,#+0
   \   0000001E   0x7260             STRB     R0,[R4, #+9]
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x7220             STRB     R0,[R4, #+8]
   \   00000024   0xF104 0x0008      ADD      R0,R4,#+8
   \   00000028   0x.... 0x....      BL       iSPIxInit
     18          	
     19          ///////////////////////////////////
     20          	iFPGA_CS1_Init();		// SPI2
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x.... 0x....      BL       OSSemCreate
   \   00000032   0x6160             STR      R0,[R4, #+20]
   \   00000034   0x2001             MOVS     R0,#+1
   \   00000036   0x7460             STRB     R0,[R4, #+17]
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x7420             STRB     R0,[R4, #+16]
   \   0000003C   0xF104 0x0010      ADD      R0,R4,#+16
   \   00000040   0x.... 0x....      BL       iSPIxInit
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x7420             STRB     R0,[R4, #+16]
   \   00000048   0xF104 0x0010      ADD      R0,R4,#+16
   \   0000004C   0x.... 0x....      BL       iSPIxInit
   \   00000050   0x2002             MOVS     R0,#+2
   \   00000052   0x7420             STRB     R0,[R4, #+16]
   \   00000054   0xF104 0x0010      ADD      R0,R4,#+16
   \   00000058   0x.... 0x....      BL       iSPIxInit
   \   0000005C   0x2003             MOVS     R0,#+3
   \   0000005E   0x7420             STRB     R0,[R4, #+16]
   \   00000060   0xF104 0x0010      ADD      R0,R4,#+16
   \   00000064   0x.... 0x....      BL       iSPIxInit
   \   00000068   0x2004             MOVS     R0,#+4
   \   0000006A   0x7420             STRB     R0,[R4, #+16]
   \   0000006C   0xF104 0x0010      ADD      R0,R4,#+16
   \   00000070   0x.... 0x....      BL       iSPIxInit
     21          
     22          
     23          //	_nFPGA_RESET = SET;
     24          //	_nSYN_PWRDN = SET;
     25          //	_nSYN_RST = SET;
     26          
     27          	OSTaskCreate(iAPDTask, (void *)NULL, (OS_STK *)&APD0TaskStk[APD_START_STK_SIZE - 1], APD0_TASK_PRIO);
   \   00000074   0x2306             MOVS     R3,#+6
   \   00000076   0xF204 0x3240      ADDW     R2,R4,#+832
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0x.... 0x....      ADR.W    R0,iAPDTask
   \   00000080   0xE8BD 0x4010      POP      {R4,LR}
   \   00000084   0x.... 0x....      B.W      OSTaskCreate
     28          }
     29          

   \                                 In section .text, align 4, keep-with-next
     30          void iAPDTask(void * pdata)
     31          {
   \                     iAPDTask:
   \   00000000   0xB580             PUSH     {R7,LR}
     32          //	INT8U tmpSwFlag = FALSE;
     33          	OSTimeDly(100*APD0_TASK_PRIO);
   \   00000002   0xF44F 0x7016      MOV      R0,#+600
   \   00000006   0x.... 0x....      BL       OSTimeDly
     34          	
     35          //	iFpgaConfigDown();
     36          //	iFPGA_ResetCtrl();
     37          	OSTimeDly(3000);
   \   0000000A   0xF640 0x30B8      MOVW     R0,#+3000
     38          //	iFPGA_INIT();
     39          
     40          	while(1)
     41          	{
     42          		while(!DownLoadGiveupTimerSet(NULL))
     43          		{
     44          #if 0
     45          			DTU_WriteData(CS0SEL, DTU_STATUS, INIT_CHECK_DATA);
     46          			tmp1 = DTU_ReadData(CS0SEL, DTU_STATUS);
     47          				
     48          			Ser3Ptr->printf("DTU_STATUS[%x][%d]\n",tmp1,tmpData);
     49          #endif
     50          		
     51          #if 0
     52          			if(tmpSwFlag)	iFPGAGetStatus();
     53          //			else			Install_StatusUpdate();
     54          			tmpSwFlag ^= TRUE;
     55          #endif			
     56          			OSTimeDly(500L);
   \                     ??iAPDTask_0:
   \   0000000E   0x.... 0x....      BL       OSTimeDly
     57          		}
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       DownLoadGiveupTimerSet
   \   00000018   0xF44F 0x70FA      MOV      R0,#+500
     58          		OSTimeDly(500L);
   \   0000001C   0xE7F7             B.N      ??iAPDTask_0
     59          	}
     60          }
     61          

   \                                 In section .text, align 2, keep-with-next
     62          void iFPGA_ResetCtrl(void)
     63          {
   \                     iFPGA_ResetCtrl:
   \   00000000   0xB510             PUSH     {R4,LR}
     64          //	_nFPGA_RESET = 0;			// DAC ENABLE!!(LOW)
     65          	OSTimeDly(100);
   \   00000002   0x2064             MOVS     R0,#+100
   \   00000004   0x.... 0x....      BL       OSTimeDly
     66          //	_nFPGA_RESET = 1;			// DAC ENABLE!!(LOW)
     67          	OSTimeDly(100);
   \   00000008   0x2064             MOVS     R0,#+100
   \   0000000A   0x.... 0x....      BL       OSTimeDly
     68          
     69          	iFPGA_CS0_Write(Reset_CS, 0x03);
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable17
   \   00000012   0x2203             MOVS     R2,#+3
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0xF104 0x001C      ADD      R0,R4,#+28
   \   0000001A   0x.... 0x....      BL       WriteFPGA
     70          	iFPGA_CS0_Write(Reset_CS, 0x00);
   \   0000001E   0x2200             MOVS     R2,#+0
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0xF104 0x001C      ADD      R0,R4,#+28
   \   00000026   0x.... 0x....      BL       WriteFPGA
     71          	iFPGA_CS0_Write(Reset_CS, 0x00);
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x4611             MOV      R1,R2
   \   0000002E   0x....             B.N      ?Subroutine0
     72          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0xF104 0x001C      ADD      R0,R4,#+28
   \   00000004   0xE8BD 0x4010      POP      {R4,LR}
   \   00000008   0x....             B.N      WriteFPGA
     73          

   \                                 In section .text, align 2, keep-with-next
     74          void iFPGA_INIT(void)
     75          {
     76          #if 0
     77              INT8U tmp = 0;
     78          	__RUStatusStr *Sts = RUStatus;
     79          
     80          	iFPGA_CS0_Write(Mode_CS, Sts->FpgaMode);
     81          
     82          	if(Sts->FwdSigBlock) 	BitSet(tmp, 0);
     83          	if(Sts->RvsSigBlock) 	BitSet(tmp, 1);
     84          
     85          	iFPGA_CS0_Write(SigBlock_CS, tmp);
     86          
     87          	Sts->DcOffsetRemoval = SET;
     88          	iFPGA_CS0_Write(DcOffsetRemove_CS, !Sts->DcOffsetRemoval);
     89          
     90          	FPGACfgFinish = TRUE;
     91          #endif    
     92          }
   \                     iFPGA_INIT:
   \   00000000   0x4770             BX       LR               ;; return
     93          
     94          
     95          /******************************************************************************
     96          * Function Name      : isItFPGACfgInit.h
     97          * Author             : bgyoon(bgyoon.naver.com
     98          * Date               : 2012.04.17
     99          * Description        : prototype definition: "aa_ipad.h"
    100          ********************************************************************************
    101          * check for fpga configuration fininish information
    102          * 1. return value: variable "FPGACfgFinish": (1): finish, else not yet!!
    103          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    104          INT8U isItFPGACfgInit(void)
    105          {
    106          	return FPGACfgFinish;
   \                     isItFPGACfgInit:
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x4770             BX       LR               ;; return
    107          }
    108          
    109          

   \                                 In section .text, align 2, keep-with-next
    110          void iFPGAGetStatus(void)
    111          {
    112          #if 0
    113              INT8U tmp;
    114          	__RUStatusStr *Sts = RUStatus;
    115          	
    116          	Sts->FPGAVersion = iFPGA_CS0_Read(FPGAVer_CS);
    117          	tmp = iFPGA_CS0_Read(Tr_RxFail) & 0x01;
    118          	
    119          	if(!Sts->UTPRxLink && tmp){
    120          		if(RUStatus->UTPRxLinkCnt != 0xFFFF)
    121          		{
    122          			RUStatus->UTPRxLinkCnt++;
    123          		}
    124          	}
    125          	Sts->UTPRxLink = tmp;	
    126          
    127          	tmp = iFPGA_CS0_Read(Lof_Count_H_CS);
    128          	Sts->LofCountValue = (tmp << 8) | iFPGA_CS0_Read(Lof_Count_L_CS);
    129          #endif
    130          }
   \                     iFPGAGetStatus:
   \   00000000   0x4770             BX       LR               ;; return
    131          

   \                                 In section .text, align 2, keep-with-next
    132          void iFPGALOFClrFunc(void)
    133          {
   \                     iFPGALOFClrFunc:
   \   00000000   0xB510             PUSH     {R4,LR}
    134          	iFPGA_CS0_Write(Lof_Count_Clr_CS, 0);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable17
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x2120             MOVS     R1,#+32
   \   0000000A   0xF104 0x001C      ADD      R0,R4,#+28
   \   0000000E   0x.... 0x....      BL       WriteFPGA
    135          	ForDelay(100);
   \   00000012   0x2064             MOVS     R0,#+100
   \   00000014   0x.... 0x....      BL       ForDelay
    136          	iFPGA_CS0_Write(Lof_Count_Clr_CS, 1);
   \   00000018   0x2201             MOVS     R2,#+1
   \   0000001A   0x2120             MOVS     R1,#+32
   \   0000001C   0xF104 0x001C      ADD      R0,R4,#+28
   \   00000020   0x.... 0x....      BL       WriteFPGA
    137          	ForDelay(100);
   \   00000024   0x2064             MOVS     R0,#+100
   \   00000026   0x.... 0x....      BL       ForDelay
    138          	iFPGA_CS0_Write(Lof_Count_Clr_CS, 0);
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x2120             MOVS     R1,#+32
   \   0000002E                      REQUIRE ?Subroutine0
   \   0000002E                      ;; // Fall through to label ?Subroutine0
    139          }
    140          

   \                                 In section .text, align 2, keep-with-next
    141          INT8U iFpgaConfigDown(void)
    142          {
   \                     iFpgaConfigDown:
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB0B3             SUB      SP,SP,#+204
    143          	INT32U i = 0, j = 0;
   \   00000006   0x2400             MOVS     R4,#+0
    144          //	INT32U rtry = 100;
    145          	DevSPIxStr *Devptr = &FPGASpi;
    146          
    147          	pUSART3.printf("FPGA CONFIGURATION FUNCTION START\n");
   \   00000008   0x.... 0x....      LDR.W    R5,??DataTable17_2
   \   0000000C   0x.... 0x....      ADR.W    R0,`?<Constant "FPGA CONFIGURATION FU...">`
   \   00000010   0x6929             LDR      R1,[R5, #+16]
   \   00000012   0x4788             BLX      R1
    148          #if 0
    149          	_nFPGA_CONF_PROG = SET;
    150          	_nFPGA_CONF_PROG = RESET;
    151          	OSTimeDly(1);
    152          	_nFPGA_CONF_PROG = SET;
    153          
    154          	OSTimeDly(30);
    155          	while(!_nFPGA_CONF_INITB && rtry--){
    156          		OSTimeDly(30);
    157          	}
    158          #endif
    159          	{
    160          		INT16S IsitDown = FALSE;
    161          		INT32U getlen = 0;
    162          		INT16U getCRC16 = 0;
    163          		INT32U getADDR = 0;
    164          		INT16U remain = 0;
    165          		
    166          #define DUMPSIZE	200			
    167          		INT8U tmpData[DUMPSIZE];
    168          
    169          		if((IsitDown = iFPGAConfig_DnCheck()) == -1){
    170          			pUSART3.printf("FPGA ALL IMAGE ERROR\n");
    171          			return FALSE;
    172          		}
    173          
    174          		if(IsitDown == (INT16S)FPGAAPPMODE)
    175          		{
    176          #if 0
    177                      getlen = vEE_BACK1->sFlashApplArea.totalSize;
    178          			getCRC16 = vEE_BACK1->sFlashApplArea.totalCRC;
    179          			getADDR = sFLASH_APPLAddr;
    180          			pUSART5.printf("FPGA APPLICATION MODE\n");
    181          #endif
    182          #if 0
    183          {
    184          	EE_BACK1 *tptr = (EE_BACK1 *)&gEE_BACK1;
    185          
    186          	*((INT8U *)tptr + i) = ReadEEprom(At24cDevID, vEE_BACK1Addr + i, 0);
    187          
    188          }
    189          			WriteEEprom(At24cDevID, SearchOffsetEeprom((INT32U)&tptr->BackUp.FwdGainSet_LTE), Sts->FwdGainSet_LTE, 0);
    190          #endif
    191          		}
    192          		else if (IsitDown == (INT16S)FPGAAPDNMODE)
    193          		{
    194          #if 0
    195                      getlen = vEE_TABLE->sFlashDownArea.totalSize;
    196          			getCRC16 = vEE_TABLE->sFlashDownArea.totalCRC;
    197          			getADDR = sFLASH_APBKAddr;
    198          			
    199          			iFPGAConfig_ApplFlagSet();
    200          			pUSART5.printf("FPGA DOWN MODE\n");
    201          #endif            
    202          		}
    203          		
    204          		FlashSwcrc16 = 0;
   \   00000014   0x.... 0x....      LDR.W    R6,??DataTable17
    205          
    206          		FlashTotFrame = getlen/DUMPSIZE;
   \   00000018   0x61B4             STR      R4,[R6, #+24]
    207          		remain = getlen%DUMPSIZE;
    208          		pUSART3.printf("TotFrame = %d, getlen = %d, remain = %d\n", FlashTotFrame, getlen, remain);
   \   0000001A   0x2300             MOVS     R3,#+0
   \   0000001C   0x4622             MOV      R2,R4
   \   0000001E   0x4621             MOV      R1,R4
   \   00000020   0x.... 0x....      ADR.W    R0,`?<Constant "TotFrame = %d, getlen...">`
   \   00000024   0xF8D5 0xA010      LDR      R10,[R5, #+16]
   \   00000028   0x47D0             BLX      R10
    209          		
    210          		for(i = 0; i < FlashTotFrame && !DownLoadGiveupTimerSet(NULL); i++)
   \   0000002A   0x.... 0x....      ADR.W    R10,??DataTable13  ;; "."
   \   0000002E   0xF44F 0x58FA      MOV      R8,#+8000
   \   00000032   0xE029             B.N      ??iFpgaConfigDown_0
    211          		{
    212          			// READ!!
    213          			sFLASH_CS0_BufferRead(getADDR + i*DUMPSIZE, tmpData, DUMPSIZE);
   \                     ??iFpgaConfigDown_1:
   \   00000034   0x20C8             MOVS     R0,#+200
   \   00000036   0xFB00 0xF904      MUL      R9,R0,R4
   \   0000003A   0x23C8             MOVS     R3,#+200
   \   0000003C   0xAA00             ADD      R2,SP,#+0
   \   0000003E   0x4649             MOV      R1,R9
   \   00000040   0x4630             MOV      R0,R6
   \   00000042   0x.... 0x....      BL       sFLASH_BufferRead
    214          			FlashSwcrc16 = Crc16Calc((INT8U*)tmpData, DUMPSIZE, FlashSwcrc16);
   \   00000046   0x8B72             LDRH     R2,[R6, #+26]
   \   00000048   0x21C8             MOVS     R1,#+200
   \   0000004A   0xA800             ADD      R0,SP,#+0
   \   0000004C   0x.... 0x....      BL       Crc16Calc
   \   00000050   0x8370             STRH     R0,[R6, #+26]
    215          
    216          			for(j = 0; j < DUMPSIZE; j += 2)
   \   00000052   0xAF00             ADD      R7,SP,#+0
   \   00000054   0xF04F 0x0B64      MOV      R11,#+100
    217          			{
    218          				iFPGAConfig_SndData(Devptr, (tmpData[j + 1] << 8) | tmpData[j]);
   \                     ??iFpgaConfigDown_2:
   \   00000058   0x7878             LDRB     R0,[R7, #+1]
   \   0000005A   0xF817 0x1B02      LDRB     R1,[R7], #+2
   \   0000005E   0xEA41 0x2100      ORR      R1,R1,R0, LSL #+8
   \   00000062   0xF106 0x001C      ADD      R0,R6,#+28
   \   00000066   0x.... 0x....      BL       iFPGAConfig_SndData
    219          			}
   \   0000006A   0xF1BB 0x0B01      SUBS     R11,R11,#+1
   \   0000006E   0xD1F3             BNE.N    ??iFpgaConfigDown_2
    220          
    221          			if(IsitDown == FPGAAPDNMODE)
    222          			{
    223          				sFLASH_CS0_BL4kCheckErase(sFLASH_APPLAddr + i*DUMPSIZE, DUMPSIZE);
    224          				sFLASH_CS0_DataWrite(sFLASH_APPLAddr + i*DUMPSIZE, tmpData, DUMPSIZE);
    225          			}
    226          			else { 
    227          				if(!((i*DUMPSIZE)%8000)){
   \   00000070   0xFBB9 0xF0F8      UDIV     R0,R9,R8
   \   00000074   0xFB08 0x9010      MLS      R0,R8,R0,R9
   \   00000078   0xB928             CBNZ.N   R0,??iFpgaConfigDown_3
    228          					OSTimeDly(10);
   \   0000007A   0x200A             MOVS     R0,#+10
   \   0000007C   0x.... 0x....      BL       OSTimeDly
    229          					pUSART3.printf(".");
   \   00000080   0x4650             MOV      R0,R10
   \   00000082   0x6929             LDR      R1,[R5, #+16]
   \   00000084   0x4788             BLX      R1
    230          				}
    231          			}
    232          		}
   \                     ??iFpgaConfigDown_3:
   \   00000086   0x1C64             ADDS     R4,R4,#+1
   \                     ??iFpgaConfigDown_0:
   \   00000088   0x8B30             LDRH     R0,[R6, #+24]
   \   0000008A   0x4284             CMP      R4,R0
   \   0000008C   0xD204             BCS.N    ??iFpgaConfigDown_4
   \   0000008E   0x2000             MOVS     R0,#+0
   \   00000090   0x.... 0x....      BL       DownLoadGiveupTimerSet
   \   00000094   0x2800             CMP      R0,#+0
   \   00000096   0xD0CD             BEQ.N    ??iFpgaConfigDown_1
    233          ////////////////////////////////////////////////////////////////////////////////		
    234          
    235          		OSTimeDly(10);
   \                     ??iFpgaConfigDown_4:
   \   00000098   0x200A             MOVS     R0,#+10
   \   0000009A   0x.... 0x....      BL       OSTimeDly
    236          		if(remain)
    237          		{
    238          			sFLASH_CS0_BufferRead(getADDR + i*DUMPSIZE, tmpData, remain);
    239          			FlashSwcrc16 = Crc16Calc((INT8U*)tmpData, remain, FlashSwcrc16);
    240          
    241          			for(j = 0; j < remain && !DownLoadGiveupTimerSet(NULL); j += 2)
    242          			{
    243          				iFPGAConfig_SndData(Devptr, (tmpData[j + 1] << 8) | tmpData[j]);
    244          			}
    245          
    246          			if(IsitDown == FPGAAPDNMODE)
    247          			{
    248          				sFLASH_CS0_BL4kCheckErase(sFLASH_APPLAddr + i*DUMPSIZE, DUMPSIZE);
    249          				sFLASH_CS0_DataWrite(sFLASH_APPLAddr + i*DUMPSIZE, tmpData, DUMPSIZE);
    250          			}
    251          
    252          		}
    253          
    254          		if(IsitDown == FPGAAPDNMODE && !DownLoadGiveupTimerSet(NULL))
    255          		{
    256          			iFPGAConfig_DnFlagRst();
    257          		}
    258          		
    259          pUSART3.printf("\n");
   \   0000009E   0x....             ADR.N    R0,??DataTable16  ;; "\n"
   \   000000A0   0x6929             LDR      R1,[R5, #+16]
   \   000000A2   0x4788             BLX      R1
    260          pUSART3.printf("Swcrc16 = %04x, getCRC16 = %04x\n", FlashSwcrc16, getCRC16);
   \   000000A4   0x2200             MOVS     R2,#+0
   \   000000A6   0x8B71             LDRH     R1,[R6, #+26]
   \   000000A8   0x.... 0x....      ADR.W    R0,`?<Constant "Swcrc16 = %04x, getCR...">`
   \   000000AC   0x692B             LDR      R3,[R5, #+16]
   \   000000AE   0x4798             BLX      R3
    261          	}
    262          	OSTimeDly(100);
   \   000000B0   0x2064             MOVS     R0,#+100
   \   000000B2   0x.... 0x....      BL       OSTimeDly
    263          	
    264          //	if(_nFPGA_CONF_DONE)	pUSART3.printf("DONE\n");
    265          //	else					pUSART3.printf("FAIL\n");
    266          
    267              return TRUE;	
   \   000000B6   0x2001             MOVS     R0,#+1
   \   000000B8   0xB033             ADD      SP,SP,#+204
   \   000000BA   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
    268          }
    269          
    270          
    271          

   \                                 In section .text, align 2, keep-with-next
    272          void iFPGAConfig_SndData(DevSPIxStr *Devptr, INT16U DATA)
    273          {
   \                     iFPGAConfig_SndData:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    274          	INT8U err;
    275          
    276          	OSSemPend(Devptr->OSSem, 0, &err);
   \   00000006   0xAA00             ADD      R2,SP,#+0
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x6860             LDR      R0,[R4, #+4]
   \   0000000C   0x.... 0x....      BL       OSSemPend
    277          
    278          	SetSPIxCommand(Devptr->SPIx, DATA);
   \   00000010   0x4629             MOV      R1,R5
   \   00000012   0x7860             LDRB     R0,[R4, #+1]
   \   00000014   0x.... 0x....      BL       SetSPIxCommand
    279          
    280          	OSSemPost(Devptr->OSSem);
   \   00000018   0x6860             LDR      R0,[R4, #+4]
   \   0000001A   0x.... 0x....      BL       OSSemPost
    281          }
   \   0000001E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    282          

   \                                 In section .text, align 2, keep-with-next
    283          INT16U ReadFPGAData(DevSPIxStr *Devptr, INT16U ADDR)
    284          {
   \                     ReadFPGAData:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    285          	INT16U rval;
    286          	INT8U err = 0;
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF88D 0x0000      STRB     R0,[SP, #+0]
    287          
    288          	OSSemPend(Devptr->OSSem, 0, &err);
   \   0000000C   0xAA00             ADD      R2,SP,#+0
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x6860             LDR      R0,[R4, #+4]
   \   00000012   0x.... 0x....      BL       OSSemPend
    289          
    290          	iDev_SPIx_CS_RST(Devptr->nDevNo);
   \   00000016   0x7820             LDRB     R0,[R4, #+0]
   \   00000018   0x.... 0x....      BL       iDev_SPIx_CS_RST
    291          
    292          	SetSPIxCommand(Devptr->SPIx, ADDR | 0x80);
   \   0000001C   0xF045 0x0180      ORR      R1,R5,#0x80
   \   00000020   0x7860             LDRB     R0,[R4, #+1]
   \   00000022   0x.... 0x....      BL       SetSPIxCommand
    293          	rval = SetSPIxCommand(Devptr->SPIx, NULL);
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0x7860             LDRB     R0,[R4, #+1]
   \   0000002A   0x.... 0x....      BL       SetSPIxCommand
   \   0000002E   0x4605             MOV      R5,R0
    294          
    295          	iDev_SPIx_CS_SET(Devptr->nDevNo);
   \   00000030   0x7820             LDRB     R0,[R4, #+0]
   \   00000032   0x.... 0x....      BL       iDev_SPIx_CS_SET
    296          
    297          	OSSemPost(Devptr->OSSem);
   \   00000036   0x6860             LDR      R0,[R4, #+4]
   \   00000038   0x.... 0x....      BL       OSSemPost
    298          
    299          	return (rval);
   \   0000003C   0x4628             MOV      R0,R5
   \   0000003E   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    300          }
    301          

   \                                 In section .text, align 2, keep-with-next
    302          void WriteFPGA(DevSPIxStr *Devptr, INT16U ADDR, INT8U DATA)
    303          {
   \                     WriteFPGA:
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
    304          	INT8U err = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xF88D 0x0000      STRB     R0,[SP, #+0]
    305          
    306          	OSSemPend(Devptr->OSSem, 0, &err);
   \   00000010   0xAA00             ADD      R2,SP,#+0
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x6860             LDR      R0,[R4, #+4]
   \   00000016   0x.... 0x....      BL       OSSemPend
    307          	
    308          	iDev_SPIx_CS_RST(Devptr->nDevNo);
   \   0000001A   0x7820             LDRB     R0,[R4, #+0]
   \   0000001C   0x.... 0x....      BL       iDev_SPIx_CS_RST
    309          
    310          	SetSPIxCommand(Devptr->SPIx, ADDR);
   \   00000020   0x4629             MOV      R1,R5
   \   00000022   0x7860             LDRB     R0,[R4, #+1]
   \   00000024   0x.... 0x....      BL       SetSPIxCommand
    311          	SetSPIxCommand(Devptr->SPIx, DATA);
   \   00000028   0x4631             MOV      R1,R6
   \   0000002A   0x7860             LDRB     R0,[R4, #+1]
   \   0000002C   0x.... 0x....      BL       SetSPIxCommand
    312          
    313          	iDev_SPIx_CS_SET(Devptr->nDevNo);
   \   00000030   0x7820             LDRB     R0,[R4, #+0]
   \   00000032   0x.... 0x....      BL       iDev_SPIx_CS_SET
    314          	
    315          	OSSemPost(Devptr->OSSem);
   \   00000036   0x6860             LDR      R0,[R4, #+4]
   \   00000038   0x.... 0x....      BL       OSSemPost
    316          }
   \   0000003C   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    317          
    318          /////////////////////////////////////////////////////////////////////////////////

   \                                 In section .text, align 2, keep-with-next
    319          void iSPIxInit(DevSPIxStr *Devptr)
    320          {
   \                     iSPIxInit:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    321          	iDev_SPIxInit(Devptr->SPIx);
   \   00000004   0x7860             LDRB     R0,[R4, #+1]
   \   00000006   0x.... 0x....      BL       iDev_SPIxInit
    322          	iDev_SPIx_CS_SET(Devptr->nDevNo);
   \   0000000A   0x7820             LDRB     R0,[R4, #+0]
   \   0000000C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000010                      REQUIRE iDev_SPIx_CS_SET
   \   00000010                      ;; // Fall through to label iDev_SPIx_CS_SET
    323          }
    324          

   \                                 In section .text, align 2, keep-with-next
    325          void  iDev_SPIx_CS_SET(INT8U nDev)
    326          {
    327          		 if(nDev == SPI_FLASHCH) 	_nFLASH_nCS1 = 1;  ///SPI2
   \                     iDev_SPIx_CS_SET:
   \   00000000   0xB110             CBZ.N    R0,??iDev_SPIx_CS_SET_0
    328          	else if(nDev == SPI_FLASHCH1) 	_nFPGA_nCS0 = 1;   ///SPI1
   \   00000002   0x2801             CMP      R0,#+1
   \   00000004   0xD105             BNE.N    ??iDev_SPIx_CS_SET_1
   \   00000006   0xE009             B.N      ??iDev_SPIx_CS_SET_2
    329          //////////////////////20150420 Adder
    330          	else if(nDev == SPI_FLASH_CH0)	_nFLASH_nCS1 = 1;   ///SPI2
   \                     ??iDev_SPIx_CS_SET_0:
   \   00000008   0x....             LDR.N    R0,??DataTable17_3  ;; 0x40020414
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0xF441 0x5180      ORR      R1,R1,#0x1000
   \   00000010   0xE008             B.N      ??iDev_SPIx_CS_SET_3
    331          	else if(nDev == SPI_FLASH_CH1)	_nFPGA_nCS0 = 1;   ///SPI1
    332          	else if(nDev == SPI_AD9528)		_nFPGA_nCS0 = 1;   ///SPI2
   \                     ??iDev_SPIx_CS_SET_1:
   \   00000012   0x2802             CMP      R0,#+2
   \   00000014   0xBF1C             ITT      NE 
   \   00000016   0x2803             CMPNE    R0,#+3
    333          	else if(nDev == SPI_ADC9368)	_nFPGA_nCS0 = 1;   ///SPI2
   \   00000018   0x2804             CMPNE    R0,#+4
    334          	else if(nDev == SPI_ADC9652)	_nFPGA_nCS0 = 1;   ///SPI2
   \   0000001A   0xD104             BNE.N    ??iDev_SPIx_CS_SET_4
   \                     ??iDev_SPIx_CS_SET_2:
   \   0000001C   0x....             LDR.N    R0,??DataTable17_4  ;; 0x40020014
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0xF041 0x0110      ORR      R1,R1,#0x10
   \                     ??iDev_SPIx_CS_SET_3:
   \   00000024   0x6001             STR      R1,[R0, #+0]
    335          }
   \                     ??iDev_SPIx_CS_SET_4:
   \   00000026   0x4770             BX       LR               ;; return
    336          

   \                                 In section .text, align 2, keep-with-next
    337          void iDev_SPIx_CS_RST(INT8U nDev)
    338          {
    339          		 if(nDev == SPI_FLASHCH) 	_nFLASH_nCS1 = 0;
   \                     iDev_SPIx_CS_RST:
   \   00000000   0xB110             CBZ.N    R0,??iDev_SPIx_CS_RST_0
    340          	else if(nDev == SPI_FLASHCH1) 	_nFPGA_nCS0 = 0;
   \   00000002   0x2801             CMP      R0,#+1
   \   00000004   0xD105             BNE.N    ??iDev_SPIx_CS_RST_1
   \   00000006   0xE009             B.N      ??iDev_SPIx_CS_RST_2
    341          
    342          	else if(nDev == SPI_FLASH_CH0)	_nFLASH_nCS1 = 0;	///SPI2
   \                     ??iDev_SPIx_CS_RST_0:
   \   00000008   0x....             LDR.N    R0,??DataTable17_3  ;; 0x40020414
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0xF421 0x5180      BIC      R1,R1,#0x1000
   \   00000010   0xE008             B.N      ??iDev_SPIx_CS_RST_3
    343          	else if(nDev == SPI_FLASH_CH1)	_nFPGA_nCS0 = 0;   ///SPI1
    344          	else if(nDev == SPI_AD9528) 	_nFPGA_nCS0 = 0;   ///SPI2
   \                     ??iDev_SPIx_CS_RST_1:
   \   00000012   0x2802             CMP      R0,#+2
   \   00000014   0xBF1C             ITT      NE 
   \   00000016   0x2803             CMPNE    R0,#+3
    345          	else if(nDev == SPI_ADC9368)	_nFPGA_nCS0 = 0;   ///SPI2
   \   00000018   0x2804             CMPNE    R0,#+4
    346          	else if(nDev == SPI_ADC9652)	_nFPGA_nCS0 = 0;   ///SPI2
   \   0000001A   0xD104             BNE.N    ??iDev_SPIx_CS_RST_4
   \                     ??iDev_SPIx_CS_RST_2:
   \   0000001C   0x....             LDR.N    R0,??DataTable17_4  ;; 0x40020014
   \   0000001E   0x6801             LDR      R1,[R0, #+0]
   \   00000020   0xF021 0x0110      BIC      R1,R1,#0x10
   \                     ??iDev_SPIx_CS_RST_3:
   \   00000024   0x6001             STR      R1,[R0, #+0]
    347          	
    348          }
   \                     ??iDev_SPIx_CS_RST_4:
   \   00000026   0x4770             BX       LR               ;; return
    349          	

   \                                 In section .text, align 2, keep-with-next
    350          SPI_TypeDef *iDev_SPIx_BASE(INT8U SPIx)
    351          {
    352          	SPI_TypeDef *nBASE;
    353          	
    354          	     if(SPIx == USE_SPI2) 	nBASE = SPI2;
   \                     iDev_SPIx_BASE:
   \   00000000   0x2801             CMP      R0,#+1
   \   00000002   0xD101             BNE.N    ??iDev_SPIx_BASE_0
   \   00000004   0x....             LDR.N    R0,??DataTable17_5  ;; 0x40003800
   \   00000006   0x4770             BX       LR
    355          	else if(SPIx == USE_SPI1) 	nBASE = SPI1;
   \                     ??iDev_SPIx_BASE_0:
   \   00000008   0xB908             CBNZ.N   R0,??iDev_SPIx_BASE_1
   \   0000000A   0x....             LDR.N    R0,??DataTable17_6  ;; 0x40013000
   \   0000000C   0x4770             BX       LR
    356          	else 						nBASE = SPI3;
   \                     ??iDev_SPIx_BASE_1:
   \   0000000E   0x....             LDR.N    R0,??DataTable17_7  ;; 0x40003c00
    357          
    358          	return nBASE;
   \   00000010   0x4770             BX       LR               ;; return
    359          }
    360          

   \                                 In section .text, align 2, keep-with-next
    361          void iDev_SPIxInit(INT8U SPIx)
    362          {
   \                     iDev_SPIxInit:
   \   00000000   0xB510             PUSH     {R4,LR}
    363              if(SPIx == USE_SPI1) {
   \   00000002   0xB9B0             CBNZ.N   R0,??iDev_SPIxInit_0
    364          		__PA5_SPI_SCK();  /// SPI1_SCK
   \   00000004   0x....             LDR.N    R4,??DataTable17_8  ;; 0x40020000
   \   00000006   0x2305             MOVS     R3,#+5
   \   00000008   0x4622             MOV      R2,R4
   \   0000000A   0x2105             MOVS     R1,#+5
   \   0000000C   0x2022             MOVS     R0,#+34
   \   0000000E   0x.... 0x....      BL       GPIOPortInit
    365          		__PA6_SPI_MISO(); /// SPI1_MISO
   \   00000012   0x2306             MOVS     R3,#+6
   \   00000014   0x4622             MOV      R2,R4
   \   00000016   0x2105             MOVS     R1,#+5
   \   00000018   0x2022             MOVS     R0,#+34
   \   0000001A   0x.... 0x....      BL       GPIOPortInit
    366          		__PA7_SPI_MOSI(); /// SPI1_MOSI
   \   0000001E   0x2307             MOVS     R3,#+7
   \   00000020   0x4622             MOV      R2,R4
   \   00000022   0x2105             MOVS     R1,#+5
   \   00000024   0x2022             MOVS     R0,#+34
   \   00000026   0x.... 0x....      BL       GPIOPortInit
    367          
    368          		SPI1Init();
   \   0000002A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000002E   0x.... 0x....      B.W      SPI1Init
    369          	}
    370          	else if(SPIx == USE_SPI2) {
   \                     ??iDev_SPIxInit_0:
   \   00000032   0x2801             CMP      R0,#+1
   \   00000034   0xD116             BNE.N    ??iDev_SPIxInit_1
    371          		__PB13_SPI_SCK();  ////SPI2_SCK
   \   00000036   0x230D             MOVS     R3,#+13
   \   00000038   0x....             LDR.N    R2,??DataTable17_9  ;; 0x40020400
   \   0000003A   0x2105             MOVS     R1,#+5
   \   0000003C   0x2022             MOVS     R0,#+34
   \   0000003E   0x.... 0x....      BL       GPIOPortInit
    372          		__PC2_SPI_MISO(); //// SPI2_MISO
   \   00000042   0x....             LDR.N    R4,??DataTable17_10  ;; 0x40020800
   \   00000044   0x2302             MOVS     R3,#+2
   \   00000046   0x4622             MOV      R2,R4
   \   00000048   0x2105             MOVS     R1,#+5
   \   0000004A   0x2022             MOVS     R0,#+34
   \   0000004C   0x.... 0x....      BL       GPIOPortInit
    373          		__PC3_SPI_MOSI(); ///  SPI2_MOSI
   \   00000050   0x2303             MOVS     R3,#+3
   \   00000052   0x4622             MOV      R2,R4
   \   00000054   0x2105             MOVS     R1,#+5
   \   00000056   0x2022             MOVS     R0,#+34
   \   00000058   0x.... 0x....      BL       GPIOPortInit
    374          		SPI2Init();
   \   0000005C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000060   0x.... 0x....      B.W      SPI2Init
    375          	}
    376          }
   \                     ??iDev_SPIxInit_1:
   \   00000064   0xBD10             POP      {R4,PC}          ;; return
    377          

   \                                 In section .text, align 2, keep-with-next
    378          INT16U SetSPIxCommand(INT8U SPIx, INT16U Comm)
    379          {
   \                     SetSPIxCommand:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    380          	SPI_TypeDef *nBASE = iDev_SPIx_BASE(SPIx);
   \   00000004   0x.... 0x....      BL       iDev_SPIx_BASE
   \   00000008   0x4605             MOV      R5,R0
   \   0000000A   0x....             B.N      ?Subroutine1
    381          	
    382          
    383          //	pUSART1.printf("SetSPIxCommand = %x \n", Comm);
    384          
    385          	while(SPI_I2S_GetFlagStatus(nBASE, SPI_I2S_FLAG_TXE) == RESET); 	// Wait to Transfer a byte
    386          	SPI_I2S_SendData(nBASE, Comm);                                     	// Send SPI2 data
    387          	while(SPI_I2S_GetFlagStatus(nBASE, SPI_I2S_FLAG_RXNE) == RESET);    // Wait to receive a byte
    388          	return SPI_I2S_ReceiveData(nBASE);                                 	// Return the byte read from the SPI bus
    389          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0x2102             MOVS     R1,#+2
   \   00000002   0x4628             MOV      R0,R5
   \   00000004   0x.... 0x....      BL       SPI_I2S_GetFlagStatus
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD0F9             BEQ.N    ?Subroutine1
   \   0000000C   0x4621             MOV      R1,R4
   \   0000000E   0x4628             MOV      R0,R5
   \   00000010   0x.... 0x....      BL       SPI_I2S_SendData
   \                     ??Subroutine1_0:
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0x.... 0x....      BL       SPI_I2S_GetFlagStatus
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD0F9             BEQ.N    ??Subroutine1_0
   \   00000020   0x4628             MOV      R0,R5
   \   00000022   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000026   0x.... 0x....      B.W      SPI_I2S_ReceiveData
    390          
    391          

   \                                 In section .text, align 2, keep-with-next
    392          INT16U SetSPIxCommand_Test(INT8U SPIx, INT16U Comm)
    393          {
   \                     SetSPIxCommand_Test:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    394          	SPI_TypeDef *nBASE = iDev_SPIx_BASE(SPIx);
   \   00000004   0x.... 0x....      BL       iDev_SPIx_BASE
   \   00000008   0x4605             MOV      R5,R0
    395          	
    396          	pUSART1.printf("SetSPIxCommand = %x \n", Comm);
   \   0000000A   0x4621             MOV      R1,R4
   \   0000000C   0x.... 0x....      ADR.W    R0,`?<Constant "SetSPIxCommand = %x \\n">`
   \   00000010   0x....             LDR.N    R2,??DataTable17_11
   \   00000012   0x6912             LDR      R2,[R2, #+16]
   \   00000014   0x4790             BLX      R2
   \   00000016                      REQUIRE ?Subroutine1
   \   00000016                      ;; // Fall through to label ?Subroutine1
    397          
    398          	while(SPI_I2S_GetFlagStatus(nBASE, SPI_I2S_FLAG_TXE) == RESET); 	// Wait to Transfer a byte
    399          	SPI_I2S_SendData(nBASE, Comm);                                     	// Send SPI2 data
    400          	while(SPI_I2S_GetFlagStatus(nBASE, SPI_I2S_FLAG_RXNE) == RESET);    // Wait to receive a byte
    401          	return SPI_I2S_ReceiveData(nBASE);                                 	// Return the byte read from the SPI bus
    402          }
    403          
    404          
    405          

   \                                 In section .text, align 2, keep-with-next
    406          INT16S iFPGAConfig_DnCheck(void)
    407          {
    408          	INT16S rval = FALSE;
    409          #if 0
    410          	     if(vEE_TABLE->sFlashDownArea.DnFlag == FPGAAPDNMODE)rval = FPGAAPDNMODE;
    411          	else if(vEE_BACK1->sFlashApplArea.DnFlag == FPGAAPPMODE) rval = FPGAAPPMODE;
    412          	else rval = -1;	// Image Error(Init Value)
    413          #endif
    414          	return rval;
   \                     iFPGAConfig_DnCheck:
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return
    415          }
    416          

   \                                 In section .text, align 2, keep-with-next
    417          void iFPGAConfig_DnFlagSet(INT32S nSize, INT16U nCRC)
    418          {
   \                     iFPGAConfig_DnFlagSet:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x460F             MOV      R7,R1
    419          #if 0
    420              INT32U cpu_sr;
    421          	EE_TABLE *tptr;
    422          	
    423          	OS_ENTER_CRITICAL();
    424          
    425          	tptr = (EE_TABLE *)RoadBackuptobuffer(vEE_TABLEAddr); // Load 1st Area	
    426          
    427          	tptr->sFlashDownArea.totalSize = nSize;
    428          	tptr->sFlashDownArea.totalCRC = nCRC;
    429          	tptr->sFlashDownArea.DnFlag = FPGAAPDNMODE;
    430          	
    431          	WriteBuffertoBackup(vEE_TABLEAddr, sizeof(EE_TABLE));	
    432          
    433          	OS_EXIT_CRITICAL();
    434          #endif
    435          
    436          
    437          
    438          #if 1
    439          	INT8U i;
    440          	type32 tmp32;
    441          	type16 tmp16;
    442          
    443              INT32U cpu_sr;
    444          //	EE_TABLE *tptr;
    445          	
    446          	OS_ENTER_CRITICAL();
   \   00000006   0x.... 0x....      BL       OS_CPU_SR_Save
   \   0000000A   0x4604             MOV      R4,R0
    447          
    448          //	tptr = (EE_TABLE *)RoadBackuptobuffer(vEE_TABLEAddr); // Load 1st Area	
    449          	EE_BACK1 *tptr = &gEE_BACK1;
    450          
    451          
    452          	tptr->BackUp.sFlashDownArea.totalSize.uD32 = nSize;
   \   0000000C   0x....             LDR.N    R5,??DataTable17_12
   \   0000000E   0xF8C5 0x6218      STR      R6,[R5, #+536]
    453          	tmp32.uD32 = nSize;
   \   00000012   0x9600             STR      R6,[SP, #+0]
    454          	for(i = 0; i < 4; i++)
    455          	{
    456          		WriteEEprom(At24cDevID, SearchOffsetEeprom((INT32U)&tptr->BackUp.sFlashDownArea.totalSize.uD8[i]), tmp32.uD8[i], 0);
   \   00000014   0xF205 0x2018      ADDW     R0,R5,#+536
   \   00000018   0x.... 0x....      BL       SearchOffsetEeprom
   \   0000001C   0x2300             MOVS     R3,#+0
   \   0000001E   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000022   0x4601             MOV      R1,R0
   \   00000024   0x20A0             MOVS     R0,#+160
   \   00000026   0x.... 0x....      BL       WriteEEprom
   \   0000002A   0xF205 0x2019      ADDW     R0,R5,#+537
   \   0000002E   0x.... 0x....      BL       SearchOffsetEeprom
   \   00000032   0x4601             MOV      R1,R0
   \   00000034   0x2300             MOVS     R3,#+0
   \   00000036   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   0000003A   0x20A0             MOVS     R0,#+160
   \   0000003C   0x.... 0x....      BL       WriteEEprom
   \   00000040   0xF205 0x201A      ADDW     R0,R5,#+538
   \   00000044   0x.... 0x....      BL       SearchOffsetEeprom
   \   00000048   0x2300             MOVS     R3,#+0
   \   0000004A   0xF89D 0x2002      LDRB     R2,[SP, #+2]
   \   0000004E   0x4601             MOV      R1,R0
   \   00000050   0x20A0             MOVS     R0,#+160
   \   00000052   0x.... 0x....      BL       WriteEEprom
   \   00000056   0xF205 0x201B      ADDW     R0,R5,#+539
   \   0000005A   0x.... 0x....      BL       SearchOffsetEeprom
   \   0000005E   0x2300             MOVS     R3,#+0
   \   00000060   0xF89D 0x2003      LDRB     R2,[SP, #+3]
   \   00000064   0x4601             MOV      R1,R0
   \   00000066   0x20A0             MOVS     R0,#+160
   \   00000068   0x.... 0x....      BL       WriteEEprom
    457          	}	
    458          	
    459          	tptr->BackUp.sFlashDownArea.totalCRC.uD32 = nCRC;
   \   0000006C   0xF205 0x2618      ADDW     R6,R5,#+536
   \   00000070   0x6077             STR      R7,[R6, #+4]
    460          	tmp32.uD32 = nCRC;
   \   00000072   0x9700             STR      R7,[SP, #+0]
    461          	for(i = 0; i < 4; i++)
    462          	{
    463          		WriteEEprom(At24cDevID, SearchOffsetEeprom((INT32U)&tptr->BackUp.sFlashDownArea.totalCRC.uD8[i]), tmp32.uD8[i], 0);
   \   00000074   0xF205 0x201C      ADDW     R0,R5,#+540
   \   00000078   0x.... 0x....      BL       SearchOffsetEeprom
   \   0000007C   0x2300             MOVS     R3,#+0
   \   0000007E   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   00000082   0x4601             MOV      R1,R0
   \   00000084   0x20A0             MOVS     R0,#+160
   \   00000086   0x.... 0x....      BL       WriteEEprom
   \   0000008A   0xF205 0x201D      ADDW     R0,R5,#+541
   \   0000008E   0x.... 0x....      BL       SearchOffsetEeprom
   \   00000092   0x2300             MOVS     R3,#+0
   \   00000094   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   00000098   0x4601             MOV      R1,R0
   \   0000009A   0x20A0             MOVS     R0,#+160
   \   0000009C   0x.... 0x....      BL       WriteEEprom
   \   000000A0   0xF205 0x201E      ADDW     R0,R5,#+542
   \   000000A4   0x.... 0x....      BL       SearchOffsetEeprom
   \   000000A8   0x2300             MOVS     R3,#+0
   \   000000AA   0xF89D 0x2002      LDRB     R2,[SP, #+2]
   \   000000AE   0x4601             MOV      R1,R0
   \   000000B0   0x20A0             MOVS     R0,#+160
   \   000000B2   0x.... 0x....      BL       WriteEEprom
   \   000000B6   0xF205 0x201F      ADDW     R0,R5,#+543
   \   000000BA   0x.... 0x....      BL       SearchOffsetEeprom
   \   000000BE   0x2300             MOVS     R3,#+0
   \   000000C0   0xF89D 0x2003      LDRB     R2,[SP, #+3]
   \   000000C4   0x4601             MOV      R1,R0
   \   000000C6   0x20A0             MOVS     R0,#+160
   \   000000C8   0x.... 0x....      BL       WriteEEprom
    464          	}	
    465          
    466          	tptr->BackUp.sFlashDownArea.DnFlag.uD16 = FPGAAPDNMODE;
   \   000000CC   0xF645 0x20A5      MOVW     R0,#+23205
   \   000000D0   0x8130             STRH     R0,[R6, #+8]
    467          	tmp16.uD16 = FPGAAPDNMODE;
   \   000000D2   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    468          	for(i = 0; i < 2; i++)
    469          	{
    470          		WriteEEprom(At24cDevID, SearchOffsetEeprom((INT32U)&tptr->BackUp.sFlashDownArea.DnFlag.uD8[i]), tmp16.uD8[i], 0);
   \   000000D6   0xF205 0x2020      ADDW     R0,R5,#+544
   \   000000DA   0x.... 0x....      BL       SearchOffsetEeprom
   \   000000DE   0x2300             MOVS     R3,#+0
   \   000000E0   0xF89D 0x2000      LDRB     R2,[SP, #+0]
   \   000000E4   0x4601             MOV      R1,R0
   \   000000E6   0x20A0             MOVS     R0,#+160
   \   000000E8   0x.... 0x....      BL       WriteEEprom
   \   000000EC   0xF205 0x2021      ADDW     R0,R5,#+545
   \   000000F0   0x.... 0x....      BL       SearchOffsetEeprom
   \   000000F4   0x2300             MOVS     R3,#+0
   \   000000F6   0xF89D 0x2001      LDRB     R2,[SP, #+1]
   \   000000FA   0x4601             MOV      R1,R0
   \   000000FC   0x20A0             MOVS     R0,#+160
   \   000000FE   0x.... 0x....      BL       WriteEEprom
    471          	}	
    472          //	WriteBuffertoBackup(vEE_TABLEAddr, sizeof(EE_TABLE));	
    473          //	tptr->BackUp.FwdOutUpperLmt_3G[0] = Sts->FwdOutUpperLmt_3G[0];
    474          
    475          //	WriteEEprom(At24cDevID, SearchOffsetEeprom((INT32U)&tptr->BackUp.FwdOutUpperLmt_3G[i]), Sts->FwdOutUpperLmt_3G[i], 0);
    476          
    477          
    478          	OS_EXIT_CRITICAL();
   \   00000102   0x4620             MOV      R0,R4
   \   00000104   0xE8BD 0x40F2      POP      {R1,R4-R7,LR}
   \   00000108   0x.... 0x....      B.W      OS_CPU_SR_Restore
    479          #endif
    480          
    481          }
    482          

   \                                 In section .text, align 2, keep-with-next
    483          void iFPGAConfig_ApplFlagSet(void)
    484          {
   \                     iFPGAConfig_ApplFlagSet:
   \   00000000   0xB510             PUSH     {R4,LR}
    485          #if 1
    486          #if 0
    487              INT32U cpu_sr;
    488          	EE_BACK1 *tptr;
    489          	
    490          	OS_ENTER_CRITICAL();
    491          	tptr = (EE_BACK1 *)RoadBackuptobuffer(vEE_BACK1Addr); // Load 1st Area	
    492          
    493          	tptr->sFlashApplArea.DnFlag = FPGAAPDNMODE;
    494          
    495          	WriteBuffertoBackup(vEE_BACK1Addr, sizeof(EE_BACK1));	
    496          #endif
    497          
    498          	{
    499          	#if 0
    500          		INT8U i;
    501          		EE_BACK1 *tptr = &gEE_BACK1;
    502          		tptr->BackUp.FPGADownLoadFlag1 = (INT8U)(FPGAAPDNMODE >> 8);
    503          		tptr->BackUp.FPGADownLoadFlag2 = (INT8U)(FPGAAPDNMODE     );
    504          
    505          		for(i = 0; i < 2; i++)
    506          		{
    507          			WriteEEprom(At24cDevID, SearchOffsetEeprom((INT32U)&tptr->BackUp.FwdOutUpperLmt_3G[i]), Sts->FwdOutUpperLmt_3G[i], 0);
    508          		}
    509          	#endif	
    510            		EE_BACK1 *tptr = &gEE_BACK1;
    511          
    512          		WriteEEprom(At24cDevID, SearchOffsetEeprom((INT32U)&tptr->BackUp.FPGADownLoadFlag1), (INT8U)(FPGAAPDNMODE >> 8), 0);
   \   00000002   0x....             LDR.N    R4,??DataTable17_13
   \   00000004   0x4620             MOV      R0,R4
   \   00000006   0x.... 0x....      BL       SearchOffsetEeprom
   \   0000000A   0x2300             MOVS     R3,#+0
   \   0000000C   0x225A             MOVS     R2,#+90
   \   0000000E   0x4601             MOV      R1,R0
   \   00000010   0x20A0             MOVS     R0,#+160
   \   00000012   0x.... 0x....      BL       WriteEEprom
    513          		WriteEEprom(At24cDevID, SearchOffsetEeprom((INT32U)&tptr->BackUp.FPGADownLoadFlag1), (INT8U)(FPGAAPDNMODE 	  ), 0);
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       SearchOffsetEeprom
   \   0000001C   0x4601             MOV      R1,R0
   \   0000001E   0x2300             MOVS     R3,#+0
   \   00000020   0x22A5             MOVS     R2,#+165
   \   00000022   0x20A0             MOVS     R0,#+160
   \   00000024   0xE8BD 0x4010      POP      {R4,LR}
   \   00000028   0x.... 0x....      B.W      WriteEEprom
    514          
    515          	}
    516          	
    517          //	OS_EXIT_CRITICAL();
    518           #endif
    519            
    520          }
    521          
    522          

   \                                 In section .text, align 2, keep-with-next
    523          void iFPGAConfig_DnFlagRst(void)
    524          {
    525          #if 0
    526          //   INT32U nSize = vEE_TABLE->sFlashDownArea.totalSize;
    527          //   INT32U nCRC  = vEE_TABLE->sFlashDownArea.totalCRC;
    528          
    529          	INT32U nSize = 0;
    530          	INT32U nCRC = 0;
    531          	INT8U i = 0;
    532          	
    533          	INT32U cpu_sr;
    534          
    535          	{
    536          //		EE_BACK1 *tptr;
    537          		EE_BACK1 *tptr = &gEE_BACK1;
    538          		
    539          		OS_ENTER_CRITICAL();
    540          
    541          //		tptr = (EE_BACK1 *)RoadBackuptobuffer(vEE_BACK1Addr); // Load 1st Area	
    542          
    543          		tptr->BackUp.sFlashApplArea.totalSize.sD32 = nSize;
    544          		tptr->BackUp.sFlashApplArea.totalCRC.sD32 = nCRC;
    545          		tptr->BackUp.sFlashApplArea.DnFlag.sD16 = FPGAAPPMODE;
    546          
    547          //		WriteEEprom(At24cDevID, SearchOffsetEeprom((INT32U)&tptr->BackUp.FwdGainSet_3G), Sts->FwdGainSet_3G, 0);
    548          
    549          		
    550          //		WriteBuffertoBackup(vEE_BACK1Addr, sizeof(EE_BACK1));	
    551          		WriteEEprom(At24cDevID, SearchOffsetEeprom((INT32U)&tptr->BackUp.SampleOffsetA.sD8[i]), Sts->SampleOffsetA.sD8[i], 0);
    552          
    553          #if 1
    554          		for(i = 0; i < 2; i++)
    555          		{
    556          //			WriteEEprom(At24cDevID, SearchOffsetEeprom((INT32U)&tptr->BackUp.SampleOffsetA.sD8[i]), Sts->SampleOffsetA.sD8[i], 0);
    557          
    558          //			WriteEEprom(At24cDevID, SearchOffsetEeprom((INT32U)&tptr->BackUp.FwdOutUpperLmt_3G[i]), Sts->FwdOutUpperLmt_3G[i], 0);
    559          		}
    560          #endif
    561          
    562          		OS_EXIT_CRITICAL();
    563          	}
    564          #if 0
    565          	{
    566          		EE_TABLE *tptr;
    567          		
    568          		OS_ENTER_CRITICAL();
    569          
    570          		tptr = (EE_TABLE *)RoadBackuptobuffer(vEE_TABLEAddr); // Load 1st Area	
    571          
    572          		tptr->sFlashDownArea.DnFlag = FPGAAPPMODE;
    573          		
    574          		WriteBuffertoBackup(vEE_TABLEAddr, sizeof(EE_TABLE));	
    575          		OS_EXIT_CRITICAL();
    576          	}
    577          #endif
    578          #endif    
    579          
    580          }
   \                     iFPGAConfig_DnFlagRst:
   \   00000000   0x4770             BX       LR               ;; return
    581          #endif
    582          
    583          
    584          
    585          #if 0
    586          /******************** (C) COPYRIGHT 2007 STMicroelectronics ********************
    587          * File Name          : stm32f10x_bkp.c
    588          * Author             : MCD Application Team
    589          * Date First Issued  : 09/29/2006
    590          * Description        : This file provides all the BKP firmware functions.
    591          ********************************************************************************/
    592          
    593          #define APD_C
    594          //#define APD_DEBUG
    595          
    596          #include "../include/main.h"
    597          
    598          void iAPDInit(void)
    599          {
    600          	sFLASH_CS0_Init();		// SPI2
    601          	iFPGA_CS0_Init();		// SPI2
    602          	
    603          //	iFPGAConfig_CS_Init();	// SPI1
    604          
    605          	_nFPGA_RESET = SET;
    606          //	_nSYN_PWRDN = SET;
    607          //	_nSYN_RST = SET;
    608          
    609          	OSTaskCreate(iAPDTask, (void *)NULL, (OS_STK *)&APD0TaskStk[APD_START_STK_SIZE - 1], APD0_TASK_PRIO);
    610          
    611          }
    612          
    613          void iAPDTask(void * pdata)
    614          {
    615          	INT8U tmpSwFlag = FALSE;
    616          	OSTimeDly(100*APD0_TASK_PRIO);
    617          	
    618          
    619          	iFpgaConfigDown();
    620          	iFPGA_ResetCtrl();
    621          	OSTimeDly(3000);
    622          	iFPGA_INIT();
    623          
    624          	while(1)
    625          	{
    626          		while(!DownLoadGiveupTimerSet(NULL))
    627          		{
    628          //			if(tmpSwFlag)	iFPGAGetStatus();
    629          //			else			Install_StatusUpdate();
    630          			tmpSwFlag ^= TRUE;
    631          			
    632          			OSTimeDly(500L);
    633          		}
    634          		OSTimeDly(500L);
    635          	}
    636          }
    637          
    638          void iFPGA_ResetCtrl(void)
    639          {
    640          	_nFPGA_RESET = 0;			// DAC ENABLE!!(LOW)
    641          	OSTimeDly(100);
    642          	_nFPGA_RESET = 1;			// DAC ENABLE!!(LOW)
    643          	OSTimeDly(100);
    644          
    645          	iFPGA_CS0_Write(Reset_CS, 0x03);
    646          	iFPGA_CS0_Write(Reset_CS, 0x00);
    647          	iFPGA_CS0_Write(Reset_CS, 0x00);
    648          }
    649          
    650          void iFPGA_INIT(void)
    651          {
    652          #if 0
    653              INT8U tmp = 0;
    654          	__RUStatusStr *Sts = RUStatus;
    655          
    656          	iFPGA_CS0_Write(Mode_CS, Sts->FpgaMode);
    657          
    658          	if(Sts->FwdSigBlock) 	BitSet(tmp, 0);
    659          	if(Sts->RvsSigBlock) 	BitSet(tmp, 1);
    660          
    661          	iFPGA_CS0_Write(SigBlock_CS, tmp);
    662          
    663          	Sts->DcOffsetRemoval = SET;
    664          	iFPGA_CS0_Write(DcOffsetRemove_CS, !Sts->DcOffsetRemoval);
    665          
    666          	FPGACfgFinish = TRUE;
    667          #endif    
    668          }
    669          
    670          
    671          /******************************************************************************
    672          * Function Name      : isItFPGACfgInit.h
    673          * Author             : bgyoon(bgyoon.naver.com
    674          * Date               : 2012.04.17
    675          * Description        : prototype definition: "aa_ipad.h"
    676          ********************************************************************************
    677          * check for fpga configuration fininish information
    678          * 1. return value: variable "FPGACfgFinish": (1): finish, else not yet!!
    679          *******************************************************************************/
    680          
    681          INT8U isItFPGACfgInit(void)
    682          {
    683          	return FPGACfgFinish;
    684          }
    685          
    686          
    687          void iFPGAGetStatus(void)
    688          {
    689          #if 0
    690              INT8U tmp;
    691          	__RUStatusStr *Sts = RUStatus;
    692          	
    693          	Sts->FPGAVersion = iFPGA_CS0_Read(FPGAVer_CS);
    694          	tmp = iFPGA_CS0_Read(Tr_RxFail) & 0x01;
    695          	
    696          	if(!Sts->UTPRxLink && tmp){
    697          		if(RUStatus->UTPRxLinkCnt != 0xFFFF)
    698          		{
    699          			RUStatus->UTPRxLinkCnt++;
    700          		}
    701          	}
    702          	Sts->UTPRxLink = tmp;	
    703          
    704          	tmp = iFPGA_CS0_Read(Lof_Count_H_CS);
    705          	Sts->LofCountValue = (tmp << 8) | iFPGA_CS0_Read(Lof_Count_L_CS);
    706          #endif
    707          }
    708          
    709          void iFPGALOFClrFunc(void)
    710          {
    711          	iFPGA_CS0_Write(Lof_Count_Clr_CS, 0);
    712          	ForDelay(100);
    713          	iFPGA_CS0_Write(Lof_Count_Clr_CS, 1);
    714          	ForDelay(100);
    715          	iFPGA_CS0_Write(Lof_Count_Clr_CS, 0);
    716          }
    717          
    718          INT8U iFpgaConfigDown(void)
    719          {
    720          	INT32U i = 0, j = 0;
    721          	INT32U rtry = 100;
    722          	DevSPIxStr *Devptr = &FPGACfgSpi;
    723          
    724          	pUSART3.printf("FPGA CONFIGURATION FUNCTION START\n");
    725          	
    726          	_nFPGA_CONF_PROG = SET;
    727          	_nFPGA_CONF_PROG = RESET;
    728          	OSTimeDly(1);
    729          	_nFPGA_CONF_PROG = SET;
    730          
    731          	OSTimeDly(30);
    732          	while(!_nFPGA_CONF_INITB && rtry--){
    733          		OSTimeDly(30);
    734          	}
    735          
    736          	{
    737          		INT16S IsitDown = FALSE;
    738          		INT32U getlen = 0;
    739          		INT16U getCRC16 = 0;
    740          		INT32U getADDR = 0;
    741          		INT16U remain = 0;
    742          		
    743          #define DUMPSIZE	200			
    744          		INT8U tmpData[DUMPSIZE];
    745          
    746          		if((IsitDown = iFPGAConfig_DnCheck()) == -1){
    747          			pUSART3.printf("FPGA ALL IMAGE ERROR\n");
    748          			return FALSE;
    749          		}
    750          
    751          		if(IsitDown == (INT16S)FPGAAPPMODE)
    752          		{
    753          			getlen = vEE_BACK1->sFlashApplArea.totalSize;
    754          			getCRC16 = vEE_BACK1->sFlashApplArea.totalCRC;
    755          			getADDR = sFLASH_APPLAddr;
    756          			pUSART3.printf("FPGA APPLICATION MODE\n");
    757          		}
    758          		else if (IsitDown == (INT16S)FPGAAPDNMODE)
    759          		{
    760          			getlen = vEE_TABLE->sFlashDownArea.totalSize;
    761          			getCRC16 = vEE_TABLE->sFlashDownArea.totalCRC;
    762          			getADDR = sFLASH_APBKAddr;
    763          			
    764          			iFPGAConfig_ApplFlagSet();
    765          			pUSART3.printf("FPGA DOWN MODE\n");
    766          		}
    767          		
    768          		FlashSwcrc16 = 0;
    769          
    770          		FlashTotFrame = getlen/DUMPSIZE;
    771          		remain = getlen%DUMPSIZE;
    772          		pUSART3.printf("TotFrame = %d, getlen = %d, remain = %d\n", FlashTotFrame, getlen, remain);
    773          		
    774          		for(i = 0; i < FlashTotFrame && !DownLoadGiveupTimerSet(NULL); i++)
    775          		{
    776          			// READ!!
    777          			sFLASH_CS0_BufferRead(getADDR + i*DUMPSIZE, tmpData, DUMPSIZE);
    778          			FlashSwcrc16 = Crc16Calc((INT8U*)tmpData, DUMPSIZE, FlashSwcrc16);
    779          
    780          			for(j = 0; j < DUMPSIZE; j += 2)
    781          			{
    782          				iFPGAConfig_SndData(Devptr, (tmpData[j + 1] << 8) | tmpData[j]);
    783          			}
    784          
    785          			if(IsitDown == FPGAAPDNMODE)
    786          			{
    787          				sFLASH_CS0_BL4kCheckErase(sFLASH_APPLAddr + i*DUMPSIZE, DUMPSIZE);
    788          				sFLASH_CS0_DataWrite(sFLASH_APPLAddr + i*DUMPSIZE, tmpData, DUMPSIZE);
    789          			}
    790          			else { 
    791          				if(!((i*DUMPSIZE)%8000)){
    792          					OSTimeDly(10);
    793          					pUSART3.printf(".");
    794          				}
    795          			}
    796          		}
    797          ////////////////////////////////////////////////////////////////////////////////		
    798          
    799          		OSTimeDly(10);
    800          		if(remain)
    801          		{
    802          			sFLASH_CS0_BufferRead(getADDR + i*DUMPSIZE, tmpData, remain);
    803          			FlashSwcrc16 = Crc16Calc((INT8U*)tmpData, remain, FlashSwcrc16);
    804          
    805          			for(j = 0; j < remain && !DownLoadGiveupTimerSet(NULL); j += 2)
    806          			{
    807          				iFPGAConfig_SndData(Devptr, (tmpData[j + 1] << 8) | tmpData[j]);
    808          			}
    809          
    810          			if(IsitDown == FPGAAPDNMODE)
    811          			{
    812          				sFLASH_CS0_BL4kCheckErase(sFLASH_APPLAddr + i*DUMPSIZE, DUMPSIZE);
    813          				sFLASH_CS0_DataWrite(sFLASH_APPLAddr + i*DUMPSIZE, tmpData, DUMPSIZE);
    814          			}
    815          
    816          		}
    817          
    818          		if(IsitDown == FPGAAPDNMODE && !DownLoadGiveupTimerSet(NULL))
    819          		{
    820          			iFPGAConfig_DnFlagRst();
    821          		}
    822          		
    823          pUSART3.printf("\n");
    824          pUSART3.printf("Swcrc16 = %04x, getCRC16 = %04x\n", FlashSwcrc16, getCRC16);
    825          	}
    826          	OSTimeDly(100);
    827          	
    828          	if(_nFPGA_CONF_DONE)	pUSART3.printf("DONE\n");
    829          	else					pUSART3.printf("FAIL\n");
    830          
    831              return TRUE;	
    832          }
    833          
    834          
    835          
    836          void iFPGAConfig_SndData(DevSPIxStr *Devptr, INT16U DATA)
    837          {
    838          	INT8U err;
    839          
    840          	OSSemPend(Devptr->OSSem, 0, &err);
    841          
    842          	SetSPIxCommand(Devptr->SPIx, DATA);
    843          
    844          	OSSemPost(Devptr->OSSem);
    845          }
    846          
    847          INT16U ReadFPGAData(DevSPIxStr *Devptr, INT16U ADDR)
    848          {
    849          	INT16U rval;
    850          	INT8U err = 0;
    851          
    852          	OSSemPend(Devptr->OSSem, 0, &err);
    853          
    854          	iDev_SPIx_CS_RST(Devptr->nDevNo);
    855          
    856          	SetSPIxCommand(Devptr->SPIx, ADDR | 0x80);
    857          	rval = SetSPIxCommand(Devptr->SPIx, NULL);
    858          
    859          	iDev_SPIx_CS_SET(Devptr->nDevNo);
    860          
    861          	OSSemPost(Devptr->OSSem);
    862          
    863          	return (rval);
    864          }
    865          
    866          void WriteFPGA(DevSPIxStr *Devptr, INT16U ADDR, INT8U DATA)
    867          {
    868          	INT8U err = 0;
    869          
    870          	OSSemPend(Devptr->OSSem, 0, &err);
    871          	
    872          	iDev_SPIx_CS_RST(Devptr->nDevNo);
    873          
    874          	SetSPIxCommand(Devptr->SPIx, ADDR);
    875          	SetSPIxCommand(Devptr->SPIx, DATA);
    876          
    877          	iDev_SPIx_CS_SET(Devptr->nDevNo);
    878          	
    879          	OSSemPost(Devptr->OSSem);
    880          }
    881          
    882          /////////////////////////////////////////////////////////////////////////////////
    883          void iSPIxInit(DevSPIxStr *Devptr)
    884          {
    885          	iDev_SPIxInit(Devptr->SPIx);
    886          	iDev_SPIx_CS_SET(Devptr->nDevNo);
    887          }
    888          
    889          #if 1
    890          void  iDev_SPIx_CS_SET(INT8U nDev)
    891          {
    892          		 if(nDev == SPI_FLASHCH) 	_nFLASH_nCS1 = 1;  ///SPI2
    893          	else if(nDev == SPI_FLASHCH1) 	_nFPGA_nCS0 = 1;   ///SPI1
    894          }
    895          
    896          void iDev_SPIx_CS_RST(INT8U nDev)
    897          {
    898          		 if(nDev == SPI_FLASHCH) 	_nFLASH_nCS1 = 0;
    899          	else if(nDev == SPI_FLASHCH1) 	_nFPGA_nCS0 = 0;
    900          }
    901          	
    902          SPI_TypeDef *iDev_SPIx_BASE(INT8U SPIx)
    903          {
    904          	SPI_TypeDef *nBASE;
    905          	
    906          	     if(SPIx == USE_SPI2) 	nBASE = SPI2;
    907          	else if(SPIx == USE_SPI1) 	nBASE = SPI1;
    908          	else 						nBASE = SPI3;
    909          
    910          	return nBASE;
    911          }
    912          
    913          void iDev_SPIxInit(INT8U SPIx)
    914          {
    915              if(SPIx == USE_SPI1) {
    916          //		GPIOA->CNF.B5 = __SPI1_SCK;
    917          //		GPIOA->CNF.B7 = __SPI1_MOSI;
    918          //		GPIOA->CNF.B6 = __SPI1_MISO;
    919          		__PA5_SPI_SCK();  /// SPI1_SCK
    920          		__PA6_SPI_MISO(); /// SPI1_MISO
    921          		__PA7_SPI_MOSI(); /// SPI1_MOSI
    922          
    923          		SPI1Init();
    924          	}
    925          	else if(SPIx == USE_SPI2) {
    926          		__PB13_SPI_SCK();  ////SPI2_SCK
    927          		__PC2_SPI_MISO(); //// SPI2_MISO
    928          		__PC3_SPI_MOSI(); ///  SPI2_MOSI
    929          		SPI2Init();
    930          	}
    931          }
    932          
    933          
    934          
    935          #endif
    936          
    937          
    938          INT16U SetSPIxCommand(INT8U SPIx, INT16U Comm)
    939          {
    940          	SPI_TypeDef *nBASE = iDev_SPIx_BASE(SPIx);
    941          	
    942          	while(SPI_I2S_GetFlagStatus(nBASE, SPI_I2S_FLAG_TXE) == RESET); 	// Wait to Transfer a byte
    943          	SPI_I2S_SendData(nBASE, Comm);                                     	// Send SPI2 data
    944          	while(SPI_I2S_GetFlagStatus(nBASE, SPI_I2S_FLAG_RXNE) == RESET);    // Wait to receive a byte
    945          	return SPI_I2S_ReceiveData(nBASE);                                 	// Return the byte read from the SPI bus
    946          }
    947          
    948          
    949          INT16S iFPGAConfig_DnCheck(void)
    950          {
    951          	INT16S rval = FALSE;
    952          
    953          	     if(vEE_TABLE->sFlashDownArea.DnFlag == FPGAAPDNMODE)rval = FPGAAPDNMODE;
    954          	else if(vEE_BACK1->sFlashApplArea.DnFlag == FPGAAPPMODE) rval = FPGAAPPMODE;
    955          	else rval = -1;	// Image Error(Init Value)
    956          
    957          	return rval;
    958          }
    959          
    960          void iFPGAConfig_DnFlagSet(INT32S nSize, INT16U nCRC)
    961          {
    962          	INT32U cpu_sr;
    963          	EE_TABLE *tptr;
    964          	
    965          	OS_ENTER_CRITICAL();
    966          
    967          	tptr = (EE_TABLE *)RoadBackuptobuffer(vEE_TABLEAddr); // Load 1st Area	
    968          
    969          	tptr->sFlashDownArea.totalSize = nSize;
    970          	tptr->sFlashDownArea.totalCRC = nCRC;
    971          	tptr->sFlashDownArea.DnFlag = FPGAAPDNMODE;
    972          	
    973          	WriteBuffertoBackup(vEE_TABLEAddr, sizeof(EE_TABLE));	
    974          
    975          	OS_EXIT_CRITICAL();
    976          }
    977          
    978          void iFPGAConfig_ApplFlagSet(void)
    979          {
    980          	INT32U cpu_sr;
    981          	EE_BACK1 *tptr;
    982          	
    983          	OS_ENTER_CRITICAL();
    984          
    985          	tptr = (EE_BACK1 *)RoadBackuptobuffer(vEE_BACK1Addr); // Load 1st Area	
    986          
    987          	tptr->sFlashApplArea.DnFlag = FPGAAPDNMODE;
    988          
    989          	WriteBuffertoBackup(vEE_BACK1Addr, sizeof(EE_BACK1));	
    990          
    991          	OS_EXIT_CRITICAL();
    992          }
    993          #endif
    994          
    995          #if 0
    996          void iFPGAConfig_DnFlagRst1(void)
    997          {
    998          	INT32U nSize = vEE_TABLE->sFlashDownArea.totalSize;
    999          	INT32U nCRC  = vEE_TABLE->sFlashDownArea.totalCRC;
   1000          	
   1001          	INT32U cpu_sr;
   1002          
   1003          	{
   1004          		EE_BACK1 *tptr;
   1005          		
   1006          		OS_ENTER_CRITICAL();
   1007          
   1008          		tptr = (EE_BACK1 *)RoadBackuptobuffer(vEE_BACK1Addr); // Load 1st Area	
   1009          
   1010          		tptr->sFlashApplArea.totalSize = nSize;
   1011          		tptr->sFlashApplArea.totalCRC = nCRC;
   1012          		tptr->sFlashApplArea.DnFlag = FPGAAPPMODE;
   1013          		
   1014          		WriteBuffertoBackup(vEE_BACK1Addr, sizeof(EE_BACK1));	
   1015          
   1016          		OS_EXIT_CRITICAL();
   1017          	}
   1018          	
   1019          	{
   1020          		EE_TABLE *tptr;
   1021          		
   1022          		OS_ENTER_CRITICAL();
   1023          
   1024          		tptr = (EE_TABLE *)RoadBackuptobuffer(vEE_TABLEAddr); // Load 1st Area	
   1025          
   1026          		tptr->sFlashDownArea.DnFlag = FPGAAPPMODE;
   1027          		
   1028          		WriteBuffertoBackup(vEE_TABLEAddr, sizeof(EE_TABLE));	
   1029          
   1030          		OS_EXIT_CRITICAL();
   1031          	}
   1032          
   1033          }
   1034          ////////////////////////////////////////////////////////////////////////////////
   1035          
   1036          ////////////////////////////////////////////////////////////////////////////////
   1037          // End of Source File
   1038          /////////////////////
   1039          
   1040          
   1041          
   1042          
   1043          
   1044          
   1045          
   1046          #endif
   1047          
   1048          
   1049          
   1050          /*!******************************************************************************
   1051          * @fn		INT32U ReadFPGAs(INT8U OPCODE, INT16U ADDR, INT8U *DATA, INT32U nlen)
   1052          * @brief	to read spi datas for each channel	
   1053          * @return	length of Read
   1054          * @param	OPCODE : ndev channel no
   1055          * @param	ADDR   : spi Address
   1056          * @param	DATA   : data point read
   1057          * @param	nlen   : length read
   1058          * @remarks	prototype is declared in ther iapd.h
   1059          ********************************************************************************/
   1060          

   \                                 In section .text, align 2, keep-with-next
   1061          INT32U ReadFPGAs(INT8U OPCODE, INT16U ADDR, INT8U *DATA, INT32U nlen)
   1062          {
   \                     ReadFPGAs:
   \   00000000   0xB580             PUSH     {R7,LR}
   1063          	return (iFPGA_GetRegister(&iFPGASpi, OPCODE, (ADDR & 0x7fff), DATA, nlen));
   \   00000002   0x9300             STR      R3,[SP, #+0]
   \   00000004   0x4613             MOV      R3,R2
   \   00000006   0x044A             LSLS     R2,R1,#+17
   \   00000008   0x0C52             LSRS     R2,R2,#+17
   \   0000000A   0x4601             MOV      R1,R0
   \   0000000C   0x....             LDR.N    R0,??DataTable17_14
   \   0000000E   0x.... 0x....      BL       iFPGA_GetRegister
   \   00000012   0xBD02             POP      {R1,PC}          ;; return
   1064          }
   1065          
   1066          /*!******************************************************************************
   1067          * @fn		void WriteFPGAs(INT8U OPCODE, INT16U ADDR, INT8U *DATA, INT32U nlen)
   1068          * @brief	to write spi datas for each channel	
   1069          * @return	none
   1070          * @param	OPCODE : ndev channel no
   1071          * @param	ADDR   : spi Address
   1072          * @param	DATA   : data point write
   1073          * @param	nlen   : length of writing
   1074          * @remarks	prototype is declared in ther iapd.h
   1075          ********************************************************************************/
   1076          

   \                                 In section .text, align 2, keep-with-next
   1077          void WriteFPGAs(INT8U OPCODE, INT16U ADDR, INT8U *DATA, INT32U nlen)
   1078          {
   \                     WriteFPGAs:
   \   00000000   0xB580             PUSH     {R7,LR}
   1079          	iFPGA_SetRegister(&iFPGASpi, OPCODE, (ADDR | 0x8000), DATA, nlen);
   \   00000002   0x9300             STR      R3,[SP, #+0]
   \   00000004   0x4613             MOV      R3,R2
   \   00000006   0xF441 0x4200      ORR      R2,R1,#0x8000
   \   0000000A   0x4601             MOV      R1,R0
   \   0000000C   0x....             LDR.N    R0,??DataTable17_14
   \   0000000E   0x.... 0x....      BL       iFPGA_SetRegister
   1080          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
   1081          
   1082          /*!******************************************************************************
   1083          * @fn		INT32S sFLASH_SetRegister(DevSPIxStr *Devptr, INT8U OPCODE, INT32U ADDR, INT8U *DATA, INT32U nlen)
   1084          * @brief	to read/write spi datas for each channel	
   1085          * @return	length of Read/writed
   1086          * @param	Devptr : spi pointer
   1087          * @param	OPCODE : ndev channel no
   1088          * @param	ADDR   : spi Address
   1089          * @param	DATA   : data point returned or write
   1090          * @param	nlen   : length returned or write
   1091          * @remarks	prototype is declared in ther iapd.h
   1092          ********************************************************************************/
   1093          

   \                                 In section .text, align 2, keep-with-next
   1094          INT32S iFPGA_SetRegister(DevSPIxStr *Devptr, INT8U OPCODE, INT32U ADDR, INT8U *DATA, INT32U nlen)
   1095          {
   \                     iFPGA_SetRegister:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x4615             MOV      R5,R2
   \   0000000A   0x4698             MOV      R8,R3
   \   0000000C   0x9E08             LDR      R6,[SP, #+32]
   1096          	INT32U i = 0;
   \   0000000E   0x2700             MOVS     R7,#+0
   1097          	INT8U err = 0;
   \   00000010   0xF88D 0x7000      STRB     R7,[SP, #+0]
   1098          
   1099          	OSSemPend(Devptr->OSSem, 0, &err);
   \   00000014   0xAA00             ADD      R2,SP,#+0
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x6860             LDR      R0,[R4, #+4]
   \   0000001A   0x.... 0x....      BL       OSSemPend
   1100          
   1101          	Devptr->nDevNo = OPCODE;
   \   0000001E   0xF884 0x9000      STRB     R9,[R4, #+0]
   1102          
   1103          	ADDR |= ((nlen - 1) & 0x07) << 12;
   \   00000022   0x1E70             SUBS     R0,R6,#+1
   \   00000024   0xF000 0x0007      AND      R0,R0,#0x7
   \   00000028   0xEA45 0x3500      ORR      R5,R5,R0, LSL #+12
   1104          
   1105          	iDev_SPIx_CS_RST(Devptr->nDevNo);
   \   0000002C   0x4648             MOV      R0,R9
   \   0000002E   0x.... 0x....      BL       iDev_SPIx_CS_RST
   1106          		
   1107          	SetSPIxCommand(Devptr->SPIx, (ADDR >>  8) & 0xFF);
   \   00000032   0xF3C5 0x2107      UBFX     R1,R5,#+8,#+8
   \   00000036   0x7860             LDRB     R0,[R4, #+1]
   \   00000038   0x.... 0x....      BL       SetSPIxCommand
   1108          	SetSPIxCommand(Devptr->SPIx, (ADDR >>  0) & 0xFF);
   \   0000003C   0xB2E9             UXTB     R1,R5
   \   0000003E   0x7860             LDRB     R0,[R4, #+1]
   \   00000040   0x.... 0x....      BL       SetSPIxCommand
   1109          
   1110          	for(i = 0; i < nlen && i < 4; i++)
   \   00000044   0xE005             B.N      ??iFPGA_SetRegister_0
   1111          	{
   1112          		SetSPIxCommand(Devptr->SPIx, DATA[i]);
   \                     ??iFPGA_SetRegister_1:
   \   00000046   0xF818 0x1B01      LDRB     R1,[R8], #+1
   \   0000004A   0x7860             LDRB     R0,[R4, #+1]
   \   0000004C   0x.... 0x....      BL       SetSPIxCommand
   1113          	}
   \   00000050   0x1C7F             ADDS     R7,R7,#+1
   \                     ??iFPGA_SetRegister_0:
   \   00000052   0x42B7             CMP      R7,R6
   \   00000054   0xBF38             IT       CC 
   \   00000056   0x2F04             CMPCC    R7,#+4
   \   00000058   0xD3F5             BCC.N    ??iFPGA_SetRegister_1
   1114          
   1115          	iDev_SPIx_CS_SET(Devptr->nDevNo);
   \   0000005A   0x....             B.N      ?Subroutine2
   1116          
   1117          	OSSemPost(Devptr->OSSem);
   1118          	return i;
   1119          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine2:
   \   00000000   0x7820             LDRB     R0,[R4, #+0]
   \   00000002   0x.... 0x....      BL       iDev_SPIx_CS_SET
   \   00000006   0x6860             LDR      R0,[R4, #+4]
   \   00000008   0x.... 0x....      BL       OSSemPost
   \   0000000C   0x4638             MOV      R0,R7
   \   0000000E   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   1120          

   \                                 In section .text, align 2, keep-with-next
   1121          INT32S iFPGA_GetRegister(DevSPIxStr *Devptr, INT8U OPCODE, INT32U ADDR, INT8U *DATA, INT32U nlen)
   1122          {
   \                     iFPGA_GetRegister:
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x4690             MOV      R8,R2
   \   0000000A   0x461D             MOV      R5,R3
   \   0000000C   0x9E08             LDR      R6,[SP, #+32]
   1123          	INT32U i = 0;
   \   0000000E   0x2700             MOVS     R7,#+0
   1124          	INT8U err = 0;
   \   00000010   0xF88D 0x7000      STRB     R7,[SP, #+0]
   1125          
   1126          	OSSemPend(Devptr->OSSem, 0, &err);
   \   00000014   0xAA00             ADD      R2,SP,#+0
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x6860             LDR      R0,[R4, #+4]
   \   0000001A   0x.... 0x....      BL       OSSemPend
   1127          
   1128          	Devptr->nDevNo = OPCODE;
   \   0000001E   0xF884 0x9000      STRB     R9,[R4, #+0]
   1129          
   1130          	ADDR |= ((nlen - 1) & 0x07) << 12;
   \   00000022   0x1E70             SUBS     R0,R6,#+1
   \   00000024   0xF000 0x0007      AND      R0,R0,#0x7
   \   00000028   0xEA48 0x3800      ORR      R8,R8,R0, LSL #+12
   1131          
   1132          	iDev_SPIx_CS_RST(Devptr->nDevNo);
   \   0000002C   0x4648             MOV      R0,R9
   \   0000002E   0x.... 0x....      BL       iDev_SPIx_CS_RST
   1133          		
   1134          	SetSPIxCommand(Devptr->SPIx, (ADDR >>  8) & 0xFF);
   \   00000032   0xF3C8 0x2107      UBFX     R1,R8,#+8,#+8
   \   00000036   0x7860             LDRB     R0,[R4, #+1]
   \   00000038   0x.... 0x....      BL       SetSPIxCommand
   1135          	SetSPIxCommand(Devptr->SPIx, (ADDR >>  0) & 0xFF);
   \   0000003C   0xFA5F 0xF188      UXTB     R1,R8
   \   00000040   0x7860             LDRB     R0,[R4, #+1]
   \   00000042   0x.... 0x....      BL       SetSPIxCommand
   1136          
   1137          	for(i = 0; i < nlen && i < 4; i++)
   \   00000046   0xE006             B.N      ??iFPGA_GetRegister_0
   1138          	{
   1139          		DATA[i] = SetSPIxCommand(Devptr->SPIx, DATA[i]);
   \                     ??iFPGA_GetRegister_1:
   \   00000048   0x7829             LDRB     R1,[R5, #+0]
   \   0000004A   0x7860             LDRB     R0,[R4, #+1]
   \   0000004C   0x.... 0x....      BL       SetSPIxCommand
   \   00000050   0xF805 0x0B01      STRB     R0,[R5], #+1
   1140          	}
   \   00000054   0x1C7F             ADDS     R7,R7,#+1
   \                     ??iFPGA_GetRegister_0:
   \   00000056   0x42B7             CMP      R7,R6
   \   00000058   0xBF38             IT       CC 
   \   0000005A   0x2F04             CMPCC    R7,#+4
   \   0000005C   0xD3F4             BCC.N    ??iFPGA_GetRegister_1
   1141          
   1142          	iDev_SPIx_CS_SET(Devptr->nDevNo);
   \   0000005E                      REQUIRE ?Subroutine2
   \   0000005E                      ;; // Fall through to label ?Subroutine2
   1143          
   1144          	OSSemPost(Devptr->OSSem);
   1145          	return i;
   1146          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   0x2E 0x00          DC8      ".",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     AT25DFSpi

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x........         DC32     FPGACfgFinish

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x........         DC32     pUSART3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x40020414         DC32     0x40020414

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x40020014         DC32     0x40020014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   0x40003800         DC32     0x40003800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \   00000000   0x40013000         DC32     0x40013000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \   00000000   0x40003C00         DC32     0x40003c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_8:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_9:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_10:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_11:
   \   00000000   0x........         DC32     pUSART1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_12:
   \   00000000   0x........         DC32     gEE_BACK1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_13:
   \   00000000   0x........         DC32     gEE_BACK1+0x210

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_14:
   \   00000000   0x........         DC32     AT25DFSpi+0x10

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant ".">`:
   \   00000000   0x2E 0x00          DC8 "."

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "FPGA CONFIGURATION FU...">`:
   \   00000000   0x46 0x50          DC8 "FPGA CONFIGURATION FUNCTION START\012"
   \              0x47 0x41    
   \              0x20 0x43    
   \              0x4F 0x4E    
   \              0x46 0x49    
   \              0x47 0x55    
   \              0x52 0x41    
   \              0x54 0x49    
   \              0x4F 0x4E    
   \              0x20 0x46    
   \              0x55 0x4E    
   \              0x43 0x54    
   \              0x49 0x4F    
   \              0x4E 0x20    
   \              0x53 0x54    
   \              0x41 0x52    
   \              0x54 0x0A    
   \              0x00         
   \   00000023   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "TotFrame = %d, getlen...">`:
   \   00000000   0x54 0x6F          DC8 "TotFrame = %d, getlen = %d, remain = %d\012"
   \              0x74 0x46    
   \              0x72 0x61    
   \              0x6D 0x65    
   \              0x20 0x3D    
   \              0x20 0x25    
   \              0x64 0x2C    
   \              0x20 0x67    
   \              0x65 0x74    
   \              0x6C 0x65    
   \              0x6E 0x20    
   \              0x3D 0x20    
   \              0x25 0x64    
   \              0x2C 0x20    
   \              0x72 0x65    
   \              0x6D 0x61    
   \              0x69 0x6E    
   \              0x20 0x3D    
   \              0x20 0x25    
   \              0x64 0x0A    
   \              0x00         
   \   00000029   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Swcrc16 = %04x, getCR...">`:
   \   00000000   0x53 0x77          DC8 "Swcrc16 = %04x, getCRC16 = %04x\012"
   \              0x63 0x72    
   \              0x63 0x31    
   \              0x36 0x20    
   \              0x3D 0x20    
   \              0x25 0x30    
   \              0x34 0x78    
   \              0x2C 0x20    
   \              0x67 0x65    
   \              0x74 0x43    
   \              0x52 0x43    
   \              0x31 0x36    
   \              0x20 0x3D    
   \              0x20 0x25    
   \              0x30 0x34    
   \              0x78 0x0A    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "SetSPIxCommand = %x \\n">`:
   \   00000000   0x53 0x65          DC8 "SetSPIxCommand = %x \012"
   \              0x74 0x53    
   \              0x50 0x49    
   \              0x78 0x43    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x20 0x3D    
   \              0x20 0x25    
   \              0x78 0x20    
   \              0x0A 0x00    
   \   00000016   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "\\n">`:
   \   00000000   0x0A 0x00          DC8 "\012"
   1147          
   1148          
   1149          
   1150          
   1151          
   1152          /////////////////////////////////////////////////////////////////////////////////
   1153          #if 0
   1154          void iSPIxInit(DevSPIxStr *Devptr)
   1155          {
   1156          	iDev_SPIxInit(Devptr->SPIx);
   1157          	iDev_SPIx_CS_SET(Devptr->nDevNo);
   1158          }
   1159          
   1160          void  iDev_SPIx_CS_SET(INT8U nDev)
   1161          {
   1162                   if(nDev == SPI_3G_TX_CH) 	_3G_SPI_TX_nCS = 1;
   1163          	else if(nDev == SPI_3G_RX_CH) 	_3G_SPI_RX_nCS = 1;
   1164          	else if(nDev == SPI_4G_TX_CH) 	_4G_SPI_TX_nCS = 1;
   1165          	else if(nDev == SPI_4G_RX_CH) 	_4G_SPI_RX_nCS = 1;
   1166          	else if(nDev == SPI_FPGA_CH) 	_FPGA_SPI_RX_nCS = 1;
   1167          
   1168          }
   1169          
   1170          void iDev_SPIx_CS_RST(INT8U nDev)
   1171          {
   1172                   if(nDev == SPI_3G_TX_CH) 	_3G_SPI_TX_nCS = 0;
   1173          	else if(nDev == SPI_3G_RX_CH) 	_3G_SPI_RX_nCS = 0;
   1174          	else if(nDev == SPI_4G_TX_CH) 	_4G_SPI_TX_nCS = 0;
   1175          	else if(nDev == SPI_4G_RX_CH) 	_4G_SPI_RX_nCS = 0;
   1176          	else if(nDev == SPI_FPGA_CH) 	_FPGA_SPI_RX_nCS = 0;
   1177          }
   1178          
   1179          SPI_TypeDef *iDev_SPIx_BASE(INT8U SPIx)
   1180          {
   1181          	SPI_TypeDef *nBASE;
   1182          	
   1183          	     if(SPIx == USE_SPI2) 	nBASE = SPI2;
   1184          	else if(SPIx == USE_SPI1) 	nBASE = SPI1;
   1185          	else 						nBASE = SPI3;
   1186          
   1187          	return nBASE;
   1188          }
   1189          
   1190          void iDev_SPIxInit(INT8U SPIx)
   1191          {
   1192          	if(SPIx == USE_SPI1) {
   1193          		GPIOA->CNF.B5 = __SPI1_SCK;
   1194          		GPIOA->CNF.B7 = __SPI1_MOSI;
   1195          		GPIOA->CNF.B6 = __SPI1_MISO;
   1196          		SPI1Init();
   1197          	}
   1198          	else if(SPIx == USE_SPI2) {
   1199          		GPIOB->CNF.B13 = __SPI2_SCK; 
   1200          		GPIOB->CNF.B15 = __SPI2_MOSI; 
   1201          		GPIOB->CNF.B14 = __SPI2_MISO; 
   1202          		SPI2Init();
   1203          	}
   1204          	else if(SPIx == USE_SPI3) {
   1205          		GPIOB->CNF.B3 = __SPI3_SCK; 
   1206          		GPIOB->CNF.B5 = __SPI3_MOSI; 
   1207          		GPIOB->CNF.B4 = __SPI3_MISO; 
   1208          		SPI3Init();
   1209          	}
   1210          }
   1211          
   1212          INT16U SetSPIxCommand(INT8U SPIx, INT16U Comm)
   1213          {
   1214          	SPI_TypeDef *nBASE = iDev_SPIx_BASE(SPIx);
   1215          	
   1216          	while(SPI_I2S_GetFlagStatus(nBASE, SPI_I2S_FLAG_TXE) == RESET); 	// Wait to Transfer a byte
   1217          	SPI_I2S_SendData(nBASE, Comm);                                     	// Send SPI2 data
   1218          	while(SPI_I2S_GetFlagStatus(nBASE, SPI_I2S_FLAG_RXNE) == RESET);    // Wait to receive a byte
   1219          	return SPI_I2S_ReceiveData(nBASE);                                 	// Return the byte read from the SPI bus
   1220          }
   1221          
   1222          #endif
   1223          
   1224          
   1225          
   1226          ////////////////////////////////////////////////////////////////////////////////
   1227          
   1228          ////////////////////////////////////////////////////////////////////////////////
   1229          // End of Source File
   1230          /////////////////////
   1231          
   1232          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  ReadFPGAData
              16 -> OSSemPend
              16 -> OSSemPost
              16 -> SetSPIxCommand
              16 -> iDev_SPIx_CS_RST
              16 -> iDev_SPIx_CS_SET
        8  ReadFPGAs
               8 -> iFPGA_GetRegister
       16  SetSPIxCommand
              16 -> SPI_I2S_GetFlagStatus
               0 -> SPI_I2S_ReceiveData
              16 -> SPI_I2S_SendData
              16 -> iDev_SPIx_BASE
       16  SetSPIxCommand_Test
              16 -- Indirect call
              16 -> SPI_I2S_GetFlagStatus
               0 -> SPI_I2S_ReceiveData
              16 -> SPI_I2S_SendData
              16 -> iDev_SPIx_BASE
       24  WriteFPGA
              24 -> OSSemPend
              24 -> OSSemPost
              24 -> SetSPIxCommand
              24 -> iDev_SPIx_CS_RST
              24 -> iDev_SPIx_CS_SET
        8  WriteFPGAs
               8 -> iFPGA_SetRegister
        8  iAPDInit
               8 -> OSSemCreate
               0 -> OSTaskCreate
               8 -> iSPIxInit
               8 -> sFLASH_Init
        8  iAPDTask
               8 -> DownLoadGiveupTimerSet
               8 -> OSTimeDly
        8  iDev_SPIxInit
               8 -> GPIOPortInit
               0 -> SPI1Init
               0 -> SPI2Init
        0  iDev_SPIx_BASE
        0  iDev_SPIx_CS_RST
        0  iDev_SPIx_CS_SET
        8  iFPGAConfig_ApplFlagSet
               8 -> SearchOffsetEeprom
               0 -> WriteEEprom
               8 -> WriteEEprom
        0  iFPGAConfig_DnCheck
        0  iFPGAConfig_DnFlagRst
       24  iFPGAConfig_DnFlagSet
               0 -> OS_CPU_SR_Restore
              24 -> OS_CPU_SR_Save
              24 -> SearchOffsetEeprom
              24 -> WriteEEprom
       16  iFPGAConfig_SndData
              16 -> OSSemPend
              16 -> OSSemPost
              16 -> SetSPIxCommand
        0  iFPGAGetStatus
        8  iFPGALOFClrFunc
               8 -> ForDelay
               0 -> WriteFPGA
               8 -> WriteFPGA
       32  iFPGA_GetRegister
              32 -> OSSemPend
              32 -> OSSemPost
              32 -> SetSPIxCommand
              32 -> iDev_SPIx_CS_RST
              32 -> iDev_SPIx_CS_SET
        0  iFPGA_INIT
        8  iFPGA_ResetCtrl
               8 -> OSTimeDly
               0 -> WriteFPGA
               8 -> WriteFPGA
       32  iFPGA_SetRegister
              32 -> OSSemPend
              32 -> OSSemPost
              32 -> SetSPIxCommand
              32 -> iDev_SPIx_CS_RST
              32 -> iDev_SPIx_CS_SET
      240  iFpgaConfigDown
             240 -- Indirect call
             240 -> Crc16Calc
             240 -> DownLoadGiveupTimerSet
             240 -> OSTimeDly
             240 -> iFPGAConfig_SndData
             240 -> sFLASH_BufferRead
        8  iSPIxInit
               8 -> iDev_SPIxInit
               0 -> iDev_SPIx_CS_SET
        0  isItFPGACfgInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       2  ?<Constant ".">
      36  ?<Constant "FPGA CONFIGURATION FU...">
      24  ?<Constant "SetSPIxCommand = %x \n">
      36  ?<Constant "Swcrc16 = %04x, getCR...">
      44  ?<Constant "TotFrame = %d, getlen...">
       2  ?<Constant "\n">
       4  ??DataTable13
       4  ??DataTable16
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_10
       4  ??DataTable17_11
       4  ??DataTable17_12
       4  ??DataTable17_13
       4  ??DataTable17_14
       4  ??DataTable17_2
       4  ??DataTable17_3
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable17_8
       4  ??DataTable17_9
      10  ?Subroutine0
      42  ?Subroutine1
      18  ?Subroutine2
     836  AT25DFSpi
          N25QSpi
          iFPGASpi
          FlashTotFrame
          FlashSwcrc16
          FPGASpi
          APD0TaskStk
       1  FPGACfgFinish
       8  FPGACfgSpi
       1  FPGARUSumAlm
      64  ReadFPGAData
      20  ReadFPGAs
      12  SetSPIxCommand
      22  SetSPIxCommand_Test
      62  WriteFPGA
      20  WriteFPGAs
     136  iAPDInit
      30  iAPDTask
     102  iDev_SPIxInit
      18  iDev_SPIx_BASE
      40  iDev_SPIx_CS_RST
      40  iDev_SPIx_CS_SET
      44  iFPGAConfig_ApplFlagSet
       4  iFPGAConfig_DnCheck
       2  iFPGAConfig_DnFlagRst
     268  iFPGAConfig_DnFlagSet
      32  iFPGAConfig_SndData
       2  iFPGAGetStatus
      46  iFPGALOFClrFunc
      94  iFPGA_GetRegister
       2  iFPGA_INIT
      48  iFPGA_ResetCtrl
      92  iFPGA_SetRegister
     190  iFpgaConfigDown
      16  iSPIxInit
       8  isItFPGACfgInit

 
   846 bytes in section .bss
     4 bytes in section .rodata
 1 692 bytes in section .text
 
 1 692 bytes of CODE  memory
     4 bytes of CONST memory
   846 bytes of DATA  memory

Errors: none
Warnings: none

###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     18/May/2015  16:57:18 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\code\exlib.c                                      #
#    Command line =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\code\exlib.c -lC D:\Project\TRIO_MD\3.F_W\TRIO_MD #
#                    _appl_stm207_20150327_20150518\out\ -o                   #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\out\ --endian=little --cpu=Cortex-M3 -e           #
#                    --fpu=None --dlib_config "C:\Program Files (x86)\IAR     #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Nor #
#                    mal.h" -I D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_2 #
#                    0150327_20150518\include\ -I                             #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\STM32F2xx_StdPeriph_Driver_v1212\ -I              #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\STM32F2xx_StdPeriph_Driver_v1212\inc\ -I          #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\uC-CPU\ -I D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_ #
#                    stm207_20150327_20150518\uC-LIB\ -I                      #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\uCOS-II\Ports\ -I D:\Project\TRIO_MD\3.F_W\TRIO_M #
#                    D_appl_stm207_20150327_20150518\uCOS-II\Source\ -I       #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\uC-Probe\ -Oh --use_c++_inline                    #
#    List file    =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\out\exlib.lst                                     #
#    Object file  =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20 #
#                    150518\out\exlib.o                                       #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20150327_20150518\code\exlib.c
      1          
      2          /******************** (C) COPYRIGHT 2008 PILOG, NSINFO *************************
      3          * File Name          : exlib.c
      4          * Author             : Yoon Byong-Gyu(bgyoon@naver.com)
      5          * Date First Issued  : 02/01/2008
      6          * Description        : This file provides all the port/input/update firmware functions.
      7          * $Revision: 0.1 $
      8          * $Revision date: 2008.01.__
      9          ********************************************************************************/
     10          
     11          #define EXLIB_C
     12          
     13          #include "../include/main.h"

   \                                 In section .text, align 4, keep-with-next
   \   __absolute unsigned long const ExpioCS[(enum <unnamed>)20U]
   \                     ExpioCS:
   \   00000000   0x0001800B         DC32 98315, 98312, 16393, 16396, 16397, 16398, 16399, 32782, 32783, 11
   \              0x00018008   
   \              0x00004009   
   \              0x0000400C   
   \              0x0000400D   
   \              0x0000400E   
   \              0x0000400F   
   \              0x0000800E   
   \              0x0000800F   
   \              0x0000000B   
   \   00000028   0x0000000C         DC32 12, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   

   \                                 In section .bss, align 4
   \   __absolute unsigned short EXPIOrawData[(enum <unnamed>)20U]
   \                     EXPIOrawData:
   \   00000000                      DS8 40
     14          
     15          

   \                                 In section .text, align 2, keep-with-next
     16          void ExpioModeChanege(INT8U tmode)
     17          {
   \                     ExpioModeChanege:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
     18          	if(tmode == 0)
   \   00000002   0x....             LDR.N    R4,??DataTable4  ;; 0x40020400
   \   00000004   0x....             LDR.N    R5,??DataTable4_1  ;; 0x40020000
   \   00000006   0x....             LDR.N    R6,??DataTable4_2  ;; 0x40021800
   \   00000008   0x....             LDR.N    R7,??DataTable4_3  ;; 0x40020800
   \   0000000A   0xBB70             CBNZ.N   R0,??ExpioModeChanege_0
     19          	{
     20          		__PC0_PP_PP();
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0x463A             MOV      R2,R7
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x2021             MOVS     R0,#+33
   \   00000014   0x.... 0x....      BL       GPIOPortInit
     21          		__PC1_PP_PP();
   \   00000018   0x2301             MOVS     R3,#+1
   \   0000001A   0x463A             MOV      R2,R7
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x2021             MOVS     R0,#+33
   \   00000020   0x.... 0x....      BL       GPIOPortInit
     22          		__PG8_PP_PP();
   \   00000024   0x2308             MOVS     R3,#+8
   \   00000026   0x4632             MOV      R2,R6
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x2021             MOVS     R0,#+33
   \   0000002C   0x.... 0x....      BL       GPIOPortInit
     23          		__PA11_PP_PP();
   \   00000030   0x230B             MOVS     R3,#+11
   \   00000032   0x462A             MOV      R2,R5
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x2021             MOVS     R0,#+33
   \   00000038   0x.... 0x....      BL       GPIOPortInit
     24          		__PC4_PP_PP();
   \   0000003C   0x2304             MOVS     R3,#+4
   \   0000003E   0x463A             MOV      R2,R7
   \   00000040   0x2100             MOVS     R1,#+0
   \   00000042   0x2021             MOVS     R0,#+33
   \   00000044   0x.... 0x....      BL       GPIOPortInit
     25          		__PC5_PP_PP();
   \   00000048   0x2305             MOVS     R3,#+5
   \   0000004A   0x463A             MOV      R2,R7
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x2021             MOVS     R0,#+33
   \   00000050   0x.... 0x....      BL       GPIOPortInit
     26          		__PB0_PP_PP();
   \   00000054   0x2300             MOVS     R3,#+0
   \   00000056   0x4622             MOV      R2,R4
   \   00000058   0x4619             MOV      R1,R3
   \   0000005A   0x2021             MOVS     R0,#+33
   \   0000005C   0x.... 0x....      BL       GPIOPortInit
     27          		__PB1_PP_PP();
   \   00000060   0x2301             MOVS     R3,#+1
   \   00000062   0x4622             MOV      R2,R4
   \   00000064   0x2100             MOVS     R1,#+0
   \   00000066   0x2021             MOVS     R0,#+33
   \   00000068   0x....             B.N      ?Subroutine0
     28          	}
     29          	else
     30          #if 0
     31          	{
     32          		__PC0_IN_PU();
     33          		__PC1_IN_PU();
     34          		__PG8_IN_PU();
     35          		__PA11_IN_PU();
     36          		__PC4_IN_PU();
     37          		__PC5_IN_PU();
     38          		__PB0_IN_PU();
     39          		__PB1_IN_PU();
     40          	}
     41          #endif
     42          #if 1	
     43          	{
     44          		__PC0_IN_FL();
   \                     ??ExpioModeChanege_0:
   \   0000006A   0x2300             MOVS     R3,#+0
   \   0000006C   0x463A             MOV      R2,R7
   \   0000006E   0x2100             MOVS     R1,#+0
   \   00000070   0x4608             MOV      R0,R1
   \   00000072   0x.... 0x....      BL       GPIOPortInit
     45          		__PC1_IN_FL();
   \   00000076   0x2301             MOVS     R3,#+1
   \   00000078   0x463A             MOV      R2,R7
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0x4608             MOV      R0,R1
   \   0000007E   0x.... 0x....      BL       GPIOPortInit
     46          		__PG8_IN_FL();
   \   00000082   0x2308             MOVS     R3,#+8
   \   00000084   0x4632             MOV      R2,R6
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0x4608             MOV      R0,R1
   \   0000008A   0x.... 0x....      BL       GPIOPortInit
     47          		__PA11_IN_FL();
   \   0000008E   0x230B             MOVS     R3,#+11
   \   00000090   0x462A             MOV      R2,R5
   \   00000092   0x2100             MOVS     R1,#+0
   \   00000094   0x4608             MOV      R0,R1
   \   00000096   0x.... 0x....      BL       GPIOPortInit
     48          		__PC4_IN_FL();
   \   0000009A   0x2304             MOVS     R3,#+4
   \   0000009C   0x463A             MOV      R2,R7
   \   0000009E   0x2100             MOVS     R1,#+0
   \   000000A0   0x4608             MOV      R0,R1
   \   000000A2   0x.... 0x....      BL       GPIOPortInit
     49          		__PC5_IN_FL();
   \   000000A6   0x2305             MOVS     R3,#+5
   \   000000A8   0x463A             MOV      R2,R7
   \   000000AA   0x2100             MOVS     R1,#+0
   \   000000AC   0x4608             MOV      R0,R1
   \   000000AE   0x.... 0x....      BL       GPIOPortInit
     50          		__PB0_IN_FL();
   \   000000B2   0x2300             MOVS     R3,#+0
   \   000000B4   0x4622             MOV      R2,R4
   \   000000B6   0x4619             MOV      R1,R3
   \   000000B8   0x4608             MOV      R0,R1
   \   000000BA   0x.... 0x....      BL       GPIOPortInit
     51          		__PB1_IN_FL();
   \   000000BE   0x2301             MOVS     R3,#+1
   \   000000C0   0x4622             MOV      R2,R4
   \   000000C2   0x2100             MOVS     R1,#+0
   \   000000C4   0x4608             MOV      R0,R1
   \   000000C6                      REQUIRE ?Subroutine0
   \   000000C6                      ;; // Fall through to label ?Subroutine0
     52          	}
     53          #endif	
     54          
     55          		
     56          /*
     57          #ifdef STM32FRxT6_USED
     58          	GPIOC->CNF.B6 = tmode;
     59          	GPIOC->CNF.B7 = tmode;
     60          	GPIOC->CNF.B8 = tmode;
     61          	GPIOC->CNF.B9 = tmode;
     62          	GPIOC->CNF.B10 = tmode;
     63          	GPIOC->CNF.B11 = tmode;
     64          	GPIOC->CNF.B12 = tmode;
     65          	GPIOD->CNF.B2 = tmode;
     66          #else
     67          	GPIOD->CNF.B14 = tmode;
     68          	GPIOD->CNF.B15 = tmode;
     69          	GPIOD->CNF.B0 = tmode;
     70          	GPIOD->CNF.B1 = tmode;
     71          	GPIOE->CNF.B7 = tmode;
     72          	GPIOE->CNF.B8 = tmode;
     73          	GPIOE->CNF.B9 = tmode;
     74          	GPIOE->CNF.B10 = tmode;
     75          #endif
     76          */
     77          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0xB001             ADD      SP,SP,#+4
   \   00000002   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \   00000006   0x.... 0x....      B.W      GPIOPortInit
     78          
     79          

   \                                 In section .text, align 2, keep-with-next
     80          void ExpioWriteData(INT8U SEL, INT16U Data)
     81          {
   \                     ExpioWriteData:
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x460D             MOV      R5,R1
     82          	INT8U err;
     83          	
     84           	OSSemPend(ExpioSem, 0, &err);
   \   00000006   0x....             LDR.N    R4,??DataTable4_4
   \   00000008   0xAA00             ADD      R2,SP,#+0
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6820             LDR      R0,[R4, #+0]
   \   0000000E   0x.... 0x....      BL       OSSemPend
     85          	EXPIOrawData[SEL] = Data;
   \   00000012   0x....             LDR.N    R0,??DataTable4_5
   \   00000014   0xF820 0x5016      STRH     R5,[R0, R6, LSL #+1]
   \   00000018   0x.... 0x....      ADR.W    R0,ExpioCS
   \   0000001C   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   00000020   0x0906             LSRS     R6,R0,#+4
     86          
     87          	#ifdef __FSMC_SRAM_H
     88          		*(vu8 *)(EXPIOptr + SEL*EXPIOsize) = Data;
     89          	#else
     90          	{
     91          	
     92          		INT32U Addr = ExpioCS[SEL]/16;
     93          		INT32U BitAddr = ExpioCS[SEL]%16;
   \   00000022   0xF000 0x070F      AND      R7,R0,#0xF
     94          
     95          		ExpioModeChanege(0);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x.... 0x....      BL       ExpioModeChanege
     96          
     97          #ifdef STM32FRxT6_USED
     98          		GPIOC->ODR.B6  = (Data >> 0) & 0x01;
     99          		GPIOC->ODR.B7  = (Data >> 1) & 0x01;
    100          		GPIOC->ODR.B8  = (Data >> 2) & 0x01;
    101          		GPIOC->ODR.B9  = (Data >> 3) & 0x01;
    102          		GPIOC->ODR.B10 = (Data >> 4) & 0x01;
    103          		GPIOC->ODR.B11 = (Data >> 5) & 0x01;
    104          		GPIOC->ODR.B12 = (Data >> 6) & 0x01;
    105          		GPIOD->ODR.B2  = (Data >> 7) & 0x01;
    106          #else
    107          		GPIOD->__B.ODR.B14	= (Data >> 0) & 0x01;
   \   0000002C   0x....             LDR.N    R0,??DataTable4_6  ;; 0x40020c14
   \   0000002E   0x6801             LDR      R1,[R0, #+0]
   \   00000030   0xF365 0x318E      BFI      R1,R5,#+14,#+1
   \   00000034   0x6001             STR      R1,[R0, #+0]
    108          		GPIOD->__B.ODR.B15	= (Data >> 1) & 0x01;
   \   00000036   0x0629             LSLS     R1,R5,#+24
   \   00000038   0x0E49             LSRS     R1,R1,#+25
   \   0000003A   0x6802             LDR      R2,[R0, #+0]
   \   0000003C   0xF361 0x32CF      BFI      R2,R1,#+15,#+1
   \   00000040   0x6002             STR      R2,[R0, #+0]
    109          		GPIOD->__B.ODR.B0	= (Data >> 2) & 0x01;
   \   00000042   0x0629             LSLS     R1,R5,#+24
   \   00000044   0x0E89             LSRS     R1,R1,#+26
   \   00000046   0x6802             LDR      R2,[R0, #+0]
   \   00000048   0xF361 0x0200      BFI      R2,R1,#+0,#+1
   \   0000004C   0x6002             STR      R2,[R0, #+0]
    110          		GPIOD->__B.ODR.B1	= (Data >> 3) & 0x01;
   \   0000004E   0x0629             LSLS     R1,R5,#+24
   \   00000050   0x0EC9             LSRS     R1,R1,#+27
   \   00000052   0x6802             LDR      R2,[R0, #+0]
   \   00000054   0xF361 0x0241      BFI      R2,R1,#+1,#+1
   \   00000058   0x6002             STR      R2,[R0, #+0]
    111          		GPIOE->__B.ODR.B7	= (Data >> 4) & 0x01;
   \   0000005A   0x....             LDR.N    R0,??DataTable4_7  ;; 0x40021014
   \   0000005C   0x0629             LSLS     R1,R5,#+24
   \   0000005E   0x0F09             LSRS     R1,R1,#+28
   \   00000060   0x6802             LDR      R2,[R0, #+0]
   \   00000062   0xF361 0x12C7      BFI      R2,R1,#+7,#+1
   \   00000066   0x6002             STR      R2,[R0, #+0]
    112          		GPIOE->__B.ODR.B8	= (Data >> 5) & 0x01;
   \   00000068   0x0629             LSLS     R1,R5,#+24
   \   0000006A   0x0F49             LSRS     R1,R1,#+29
   \   0000006C   0x6802             LDR      R2,[R0, #+0]
   \   0000006E   0xF361 0x2208      BFI      R2,R1,#+8,#+1
   \   00000072   0x6002             STR      R2,[R0, #+0]
    113          		GPIOE->__B.ODR.B9	= (Data >> 6) & 0x01;
   \   00000074   0x0629             LSLS     R1,R5,#+24
   \   00000076   0x0F89             LSRS     R1,R1,#+30
   \   00000078   0x6802             LDR      R2,[R0, #+0]
   \   0000007A   0xF361 0x2249      BFI      R2,R1,#+9,#+1
   \   0000007E   0x6002             STR      R2,[R0, #+0]
    114          		GPIOE->__B.ODR.B10	= (Data >> 7) & 0x01;
   \   00000080   0x062D             LSLS     R5,R5,#+24
   \   00000082   0x0FE9             LSRS     R1,R5,#+31
   \   00000084   0x6802             LDR      R2,[R0, #+0]
   \   00000086   0xF361 0x228A      BFI      R2,R1,#+10,#+1
   \   0000008A   0x6002             STR      R2,[R0, #+0]
    115          #endif
    116          
    117          
    118          		// low
    119          		*(volatile INT32U *)(AHB1PERIPH_BASE + Addr + 0x0C) &=  ~(1 << BitAddr);
   \   0000008C   0x2001             MOVS     R0,#+1
   \   0000008E   0x40B8             LSLS     R0,R0,R7
   \   00000090   0x....             LDR.N    R1,??DataTable4_8  ;; 0x4002000c
   \   00000092   0x598A             LDR      R2,[R1, R6]
   \   00000094   0x4382             BICS     R2,R2,R0
   \   00000096   0x518A             STR      R2,[R1, R6]
    120          		// high
    121          		*(volatile INT32U *)(AHB1PERIPH_BASE + Addr + 0x0C) |=   (1 << BitAddr);
   \   00000098   0x598A             LDR      R2,[R1, R6]
   \   0000009A   0x4310             ORRS     R0,R0,R2
   \   0000009C   0x5188             STR      R0,[R1, R6]
    122          
    123          		ExpioModeChanege(1);
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0x.... 0x....      BL       ExpioModeChanege
    124          	}
    125          	#endif
    126          	
    127          	OSSemPost(ExpioSem);
   \   000000A4   0x6820             LDR      R0,[R4, #+0]
   \   000000A6   0x.... 0x....      BL       OSSemPost
    128          
    129          }
   \   000000AA   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    130          

   \                                 In section .text, align 2, keep-with-next
    131          INT16U ExpioReadData(INT8U SEL)
    132          {
   \                     ExpioReadData:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   \   00000006   0x4680             MOV      R8,R0
    133          	INT16U ret = 0;
    134          	INT8U err;
    135          	
    136          	OSSemPend(ExpioSem, 0, &err);
   \   00000008   0x....             LDR.N    R4,??DataTable4_4
   \   0000000A   0xAA00             ADD      R2,SP,#+0
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x6820             LDR      R0,[R4, #+0]
   \   00000010   0x.... 0x....      BL       OSSemPend
    137          
    138          	#ifdef __FSMC_SRAM_H
    139          		ret = EXPIOrawData[SEL] = *(vu8 *)(EXPIOptr + SEL*EXPIOsize);
    140          	#else
    141          	{
    142          		INT32U Addr = ExpioCS[SEL]/16;
   \   00000014   0x.... 0x....      ADR.W    R0,ExpioCS
   \   00000018   0xF850 0x0028      LDR      R0,[R0, R8, LSL #+2]
   \   0000001C   0x0901             LSRS     R1,R0,#+4
    143          		INT32U BitAddr = ExpioCS[SEL]%16;
   \   0000001E   0xF000 0x000F      AND      R0,R0,#0xF
    144          
    145          		*(volatile INT32U *)(AHB1PERIPH_BASE + Addr + 0x0C) &=  ~(1 << BitAddr);
   \   00000022   0x2201             MOVS     R2,#+1
   \   00000024   0xFA02 0xF600      LSL      R6,R2,R0
   \   00000028   0x....             LDR.N    R0,??DataTable4_8  ;; 0x4002000c
   \   0000002A   0x1847             ADDS     R7,R0,R1
   \   0000002C   0x6838             LDR      R0,[R7, #+0]
   \   0000002E   0x43B0             BICS     R0,R0,R6
   \   00000030   0x6038             STR      R0,[R7, #+0]
    146          		ExpioModeChanege(1);
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0x.... 0x....      BL       ExpioModeChanege
    147          
    148          		// low
    149          #ifdef STM32FRxT6_USED
    150          
    151          		ret = (ret << 1) | (GPIOD->IDR.B2);
    152          		ret = (ret << 1) | (GPIOC->IDR.B12);
    153          		ret = (ret << 1) | (GPIOC->IDR.B11);
    154          		ret = (ret << 1) | (GPIOC->IDR.B10);
    155          		ret = (ret << 1) | (GPIOC->IDR.B9);
    156          		ret = (ret << 1) | (GPIOC->IDR.B8);
    157          		ret = (ret << 1) | (GPIOC->IDR.B7);
    158          		ret = (ret << 1) | (GPIOC->IDR.B6);
    159          #else
    160          		ret = (ret << 1) | (GPIOE->__B.IDR.B10);
   \   00000038   0x....             LDR.N    R0,??DataTable4_9  ;; 0x40021010
   \   0000003A   0x6801             LDR      R1,[R0, #+0]
   \   0000003C   0xF3C1 0x2180      UBFX     R1,R1,#+10,#+1
    161          		ret = (ret << 1) | (GPIOE->__B.IDR.B9);
   \   00000040   0x6802             LDR      R2,[R0, #+0]
   \   00000042   0xF3C2 0x2240      UBFX     R2,R2,#+9,#+1
   \   00000046   0xEA42 0x0141      ORR      R1,R2,R1, LSL #+1
    162          		ret = (ret << 1) | (GPIOE->__B.IDR.B8);
   \   0000004A   0x6802             LDR      R2,[R0, #+0]
   \   0000004C   0xF3C2 0x2200      UBFX     R2,R2,#+8,#+1
   \   00000050   0xEA42 0x0141      ORR      R1,R2,R1, LSL #+1
    163          		ret = (ret << 1) | (GPIOE->__B.IDR.B7);
   \   00000054   0x6800             LDR      R0,[R0, #+0]
   \   00000056   0xF3C0 0x10C0      UBFX     R0,R0,#+7,#+1
   \   0000005A   0xEA40 0x0041      ORR      R0,R0,R1, LSL #+1
    164          		ret = (ret << 1) | (GPIOD->__B.IDR.B1);
   \   0000005E   0x....             LDR.N    R1,??DataTable4_10  ;; 0x40020c10
   \   00000060   0x680A             LDR      R2,[R1, #+0]
   \   00000062   0xF3C2 0x0240      UBFX     R2,R2,#+1,#+1
   \   00000066   0xEA42 0x0040      ORR      R0,R2,R0, LSL #+1
    165          		ret = (ret << 1) | (GPIOD->__B.IDR.B0);
   \   0000006A   0x680A             LDR      R2,[R1, #+0]
   \   0000006C   0x0852             LSRS     R2,R2,#+1
   \   0000006E   0x4140             ADCS     R0,R0,R0
   \   00000070   0xB280             UXTH     R0,R0
    166          		ret = (ret << 1) | (GPIOD->__B.IDR.B15);
   \   00000072   0x680A             LDR      R2,[R1, #+0]
   \   00000074   0xF3C2 0x32C0      UBFX     R2,R2,#+15,#+1
   \   00000078   0xEA42 0x0040      ORR      R0,R2,R0, LSL #+1
   \   0000007C   0xB280             UXTH     R0,R0
    167          		ret = (ret << 1) | (GPIOD->__B.IDR.B14);
   \   0000007E   0x6809             LDR      R1,[R1, #+0]
   \   00000080   0xF3C1 0x3180      UBFX     R1,R1,#+14,#+1
   \   00000084   0xEA41 0x0040      ORR      R0,R1,R0, LSL #+1
   \   00000088   0xB285             UXTH     R5,R0
    168          #endif
    169          		// SEL
    170          		// high
    171          		*(volatile INT32U *)(AHB1PERIPH_BASE + Addr + 0x0C) |=   (1 << BitAddr);
   \   0000008A   0x6838             LDR      R0,[R7, #+0]
   \   0000008C   0x4330             ORRS     R0,R6,R0
   \   0000008E   0x6038             STR      R0,[R7, #+0]
    172          
    173          		EXPIOrawData[SEL] = ret;
   \   00000090   0x....             LDR.N    R0,??DataTable4_5
   \   00000092   0xF820 0x5018      STRH     R5,[R0, R8, LSL #+1]
    174          	}
    175          	#endif
    176          	OSSemPost(ExpioSem);
   \   00000096   0x6820             LDR      R0,[R4, #+0]
   \   00000098   0x.... 0x....      BL       OSSemPost
    177          
    178              return ret;
   \   0000009C   0x4628             MOV      R0,R5
   \   0000009E   0xE8BD 0x81F6      POP      {R1,R2,R4-R8,PC}  ;; return
    179          }
    180          

   \                                 In section .text, align 2, keep-with-next
    181          unsigned short int ExpioBitRead (unsigned short int Bitaddr)
    182          {
   \                     ExpioBitRead:
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    183          	INT16U	ExselNo;
    184          	INT16U	BitNumber;
    185          
    186          	ExselNo = (Bitaddr/16);
   \   00000004   0x0925             LSRS     R5,R4,#+4
    187          	BitNumber = (Bitaddr % 16);
    188          
    189          	ExpioReadData(ExselNo);
   \   00000006   0xB2E8             UXTB     R0,R5
   \   00000008   0x.... 0x....      BL       ExpioReadData
    190          	return BitRead(EXPIOrawData[ExselNo], BitNumber);	
   \   0000000C   0x....             LDR.N    R0,??DataTable4_5
   \   0000000E   0xF830 0x0015      LDRH     R0,[R0, R5, LSL #+1]
   \   00000012   0xF004 0x010F      AND      R1,R4,#0xF
   \   00000016   0x40C8             LSRS     R0,R0,R1
   \   00000018   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000001C   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    191          }

   \                                 In section .text, align 2, keep-with-next
    192          void ExpioBitSet (unsigned short int Bitaddr)
    193          {
   \                     ExpioBitSet:
   \   00000000   0xB418             PUSH     {R3,R4}
    194          	INT16U	ExselNo;
    195          	INT16U	BitNumber;
    196          
    197          	ExselNo = (Bitaddr/16);
   \   00000002   0x0902             LSRS     R2,R0,#+4
    198          	BitNumber = (Bitaddr % 16);
    199           	EXPIOrawData[ExselNo] = ( EXPIOrawData[ExselNo] |(1 << BitNumber) );
   \   00000004   0x....             LDR.N    R3,??DataTable4_5
   \   00000006   0xF833 0x1012      LDRH     R1,[R3, R2, LSL #+1]
   \   0000000A   0x2401             MOVS     R4,#+1
   \   0000000C   0xF000 0x000F      AND      R0,R0,#0xF
   \   00000010   0xFA04 0xF000      LSL      R0,R4,R0
   \   00000014   0x4301             ORRS     R1,R0,R1
   \   00000016   0xF823 0x1012      STRH     R1,[R3, R2, LSL #+1]
    200          	ExpioWriteData(ExselNo, EXPIOrawData[ExselNo]);
   \   0000001A   0xB289             UXTH     R1,R1
   \   0000001C   0x....             B.N      ?Subroutine1
    201          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0xB2D0             UXTB     R0,R2
   \   00000002   0xBC14             POP      {R2,R4}
   \   00000004   0x....             B.N      ExpioWriteData
    202          

   \                                 In section .text, align 4, keep-with-next
    203          void ExpioBitRst(unsigned short int Bitaddr)
    204          {
   \                     ExpioBitRst:
   \   00000000   0xB418             PUSH     {R3,R4}
    205          	INT16U	ExselNo;
    206          	INT16U	BitNumber;
    207          
    208          	ExselNo = (Bitaddr/16);
   \   00000002   0x0902             LSRS     R2,R0,#+4
    209          	BitNumber = (Bitaddr % 16);
    210          	EXPIOrawData[ExselNo] = ( EXPIOrawData[ExselNo] & ~(1 << BitNumber) );
   \   00000004   0x4B00             LDR.N    R3,??ExpioBitRst_0
   \   00000006   0xE001             B.N      ??ExpioBitRst_1
   \                     ??ExpioBitRst_0:
   \   00000008   0x........         DC32     EXPIOrawData
   \                     ??ExpioBitRst_1:
   \   0000000C   0xF833 0x1012      LDRH     R1,[R3, R2, LSL #+1]
   \   00000010   0x2401             MOVS     R4,#+1
   \   00000012   0xF000 0x000F      AND      R0,R0,#0xF
   \   00000016   0xFA04 0xF000      LSL      R0,R4,R0
   \   0000001A   0x4381             BICS     R1,R1,R0
   \   0000001C   0xF823 0x1012      STRH     R1,[R3, R2, LSL #+1]
    211          	ExpioWriteData(ExselNo, EXPIOrawData[ExselNo]);
   \   00000020                      REQUIRE ?Subroutine1
   \   00000020                      ;; // Fall through to label ?Subroutine1
    212          	
    213          }
    214          #if 1

   \                                 In section .text, align 2, keep-with-next
    215          INT8U atoh (INT8U value )
    216          {
    217          	INT16U	num;
    218          
    219          	// isdigit() 는 입력값이 '0' ~ '9' 일경우 True
    220          	if( isdigit(value) ) num = value - '0';
   \                     atoh:
   \   00000000   0xF1A0 0x0130      SUB      R1,R0,#+48
   \   00000004   0x290A             CMP      R1,#+10
   \   00000006   0xBF38             IT       CC 
   \   00000008   0x3830             SUBCC    R0,R0,#+48
   \   0000000A   0xD30C             BCC.N    ??atoh_0
    221          
    222          	else if( (value >= 'a') && (value <= 'f') ) num = 10 + value - 'a';
   \   0000000C   0xF1A0 0x0161      SUB      R1,R0,#+97
   \   00000010   0x2906             CMP      R1,#+6
   \   00000012   0xBF38             IT       CC 
   \   00000014   0x3857             SUBCC    R0,R0,#+87
   \   00000016   0xD306             BCC.N    ??atoh_0
    223          	else if( (value >= 'A') && (value <= 'F') ) num = 10 + value - 'A';
   \   00000018   0xF1A0 0x0141      SUB      R1,R0,#+65
   \   0000001C   0x2906             CMP      R1,#+6
   \   0000001E   0xBF34             ITE      CC 
   \   00000020   0x3837             SUBCC    R0,R0,#+55
   \   00000022   0xF44F 0x7080      MOVCS    R0,#+256
    224          	else										num = 0x0100;
    225          
    226          	return (INT8U)num;
   \                     ??atoh_0:
   \   00000026   0xB2C0             UXTB     R0,R0
   \   00000028   0x4770             BX       LR               ;; return
    227          }
    228          #endif

   \                                 In section .text, align 2, keep-with-next
    229          INT16U ByteToWord(INT8U HighByte, INT8U LowByte)
    230          {
    231          	INT16U WordByte = 0;
    232          	
    233          	WordByte = (INT16U)HighByte;
    234          	WordByte = (WordByte << 8)& 0xff00;
    235          	WordByte = WordByte |(INT16U)LowByte;
    236          	return(WordByte);
   \                     ByteToWord:
   \   00000000   0xEA41 0x2000      ORR      R0,R1,R0, LSL #+8
   \   00000004   0x4770             BX       LR               ;; return
    237          }
    238          
    239          /*******************************************************************************
    240          * Table에서 Search한다.
    241          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    242          INT8U SearchWord(INT8U IsDec,INT8U nLen, INT16U SearchVal, INT16U *Buff)
    243          {
   \                     SearchWord:
   \   00000000   0xB470             PUSH     {R4-R6}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x1E48             SUBS     R0,R1,#+1
   \   00000006   0xB2C0             UXTB     R0,R0
   \   00000008   0xB38C             CBZ.N    R4,??SearchWord_0
    244              unsigned char Max = nLen - 1 ,Mid , Min = 0;
    245          
    246          	if(IsDec)///1
    247          	{ /* 정렬이 내림 차순으로 된경우.  RSSI */
    248          		Max = nLen-1;
    249          		Min = 0;
   \   0000000A   0x2100             MOVS     R1,#+0
    250          	    if((Buff[Max] & 0x0FFF) >= SearchVal)    return(Max);
   \   0000000C   0xF833 0x4010      LDRH     R4,[R3, R0, LSL #+1]
   \   00000010   0x0524             LSLS     R4,R4,#+20
   \   00000012   0x0D24             LSRS     R4,R4,#+20
   \   00000014   0x4294             CMP      R4,R2
   \   00000016   0xDB01             BLT.N    ??SearchWord_1
   \                     ??SearchWord_2:
   \   00000018   0xBC70             POP      {R4-R6}
   \   0000001A   0x4770             BX       LR               ;; return
    251          	    if((Buff[Min] & 0x0FFF) <= SearchVal)    return(Min);
   \                     ??SearchWord_1:
   \   0000001C   0x881C             LDRH     R4,[R3, #+0]
   \   0000001E   0x0524             LSLS     R4,R4,#+20
   \   00000020   0xEBB2 0x5F14      CMP      R2,R4, LSR #+20
   \   00000024   0xDA2F             BGE.N    ??SearchWord_3
    252          
    253          	    while(1)
    254          		{
    255          		    if((Min+1) == Max)
   \                     ??SearchWord_4:
   \   00000026   0x1C4C             ADDS     R4,R1,#+1
   \   00000028   0x4284             CMP      R4,R0
   \   0000002A   0xD10D             BNE.N    ??SearchWord_5
    256          			{
    257          			    if((Buff[Min] & 0x0FFF)- SearchVal > SearchVal - (Buff[Max] & 0x0FFF))return(Max);
   \   0000002C   0xF833 0x4010      LDRH     R4,[R3, R0, LSL #+1]
   \   00000030   0x0524             LSLS     R4,R4,#+20
   \   00000032   0xEBB2 0x5414      SUBS     R4,R2,R4, LSR #+20
   \   00000036   0xF833 0x3011      LDRH     R3,[R3, R1, LSL #+1]
   \   0000003A   0x051B             LSLS     R3,R3,#+20
   \   0000003C   0x0D1B             LSRS     R3,R3,#+20
   \   0000003E   0x1A9A             SUBS     R2,R3,R2
   \                     ??SearchWord_6:
   \   00000040   0x4294             CMP      R4,R2
   \   00000042   0xDBE9             BLT.N    ??SearchWord_2
    258          				else return(Min);
   \   00000044   0x4608             MOV      R0,R1
   \   00000046   0xE7E7             B.N      ??SearchWord_2
    259          			}
    260          
    261          			Mid = Min + (Max - Min)/2;
   \                     ??SearchWord_5:
   \   00000048   0x1A44             SUBS     R4,R0,R1
   \   0000004A   0xEB04 0x74D4      ADD      R4,R4,R4, LSR #+31
   \   0000004E   0xEB11 0x0464      ADDS     R4,R1,R4, ASR #+1
   \   00000052   0xB2E4             UXTB     R4,R4
   \   00000054   0xF833 0x5014      LDRH     R5,[R3, R4, LSL #+1]
   \   00000058   0x052E             LSLS     R6,R5,#+20
   \   0000005A   0x0D36             LSRS     R6,R6,#+20
   \   0000005C   0x4296             CMP      R6,R2
   \   0000005E   0xD02E             BEQ.N    ??SearchWord_7
    262          			if((Buff[Mid] & 0x0FFF) == SearchVal)  	return(Mid);
    263          			else if((Buff[Mid] & 0x0FFF) > SearchVal) 	Min = Mid;
   \   00000060   0x052D             LSLS     R5,R5,#+20
   \   00000062   0xEBB2 0x5F15      CMP      R2,R5, LSR #+20
   \   00000066   0xBFAC             ITE      GE 
   \   00000068   0x4620             MOVGE    R0,R4
   \   0000006A   0x4621             MOVLT    R1,R4
    264          			else										Max = Mid;
   \   0000006C   0xE7DB             B.N      ??SearchWord_4
    265          		}
    266          	}
    267          	else
    268          	{      /* 정렬이 오름 차순으로 된 경우. PM */
    269          
    270          		Max = nLen - 1;
    271          		Min = 0;
   \                     ??SearchWord_0:
   \   0000006E   0x2100             MOVS     R1,#+0
    272          
    273          	    if((Buff[Max] & 0x0FFF) <= SearchVal)	return(Max);
   \   00000070   0xF833 0x4010      LDRH     R4,[R3, R0, LSL #+1]
   \   00000074   0x0524             LSLS     R4,R4,#+20
   \   00000076   0xEBB2 0x5F14      CMP      R2,R4, LSR #+20
   \   0000007A   0xDACD             BGE.N    ??SearchWord_2
    274          	    if((Buff[Min] & 0x0FFF) >= SearchVal)   return(Min);
   \   0000007C   0x881C             LDRH     R4,[R3, #+0]
   \   0000007E   0x0524             LSLS     R4,R4,#+20
   \   00000080   0x0D24             LSRS     R4,R4,#+20
   \   00000082   0x4294             CMP      R4,R2
   \   00000084   0xDB01             BLT.N    ??SearchWord_8
   \                     ??SearchWord_3:
   \   00000086   0x2000             MOVS     R0,#+0
   \   00000088   0xE7C6             B.N      ??SearchWord_2
    275          
    276          	    while(1)
    277          		{
    278          		    if((Min + 1) == Max)
   \                     ??SearchWord_8:
   \   0000008A   0x1C4C             ADDS     R4,R1,#+1
   \   0000008C   0x4284             CMP      R4,R0
   \   0000008E   0xD10A             BNE.N    ??SearchWord_9
    279          			{
    280          			    if((Buff[Min] & 0x0FFF) - SearchVal < SearchVal - (Buff[Max] & 0x0FFF))	return(Max);
   \   00000090   0xF833 0x4011      LDRH     R4,[R3, R1, LSL #+1]
   \   00000094   0x0524             LSLS     R4,R4,#+20
   \   00000096   0x0D24             LSRS     R4,R4,#+20
   \   00000098   0x1AA4             SUBS     R4,R4,R2
   \   0000009A   0xF833 0x3010      LDRH     R3,[R3, R0, LSL #+1]
   \   0000009E   0x051B             LSLS     R3,R3,#+20
   \   000000A0   0xEBB2 0x5213      SUBS     R2,R2,R3, LSR #+20
   \   000000A4   0xE7CC             B.N      ??SearchWord_6
    281          				else																	return(Min);
    282          			}
    283          
    284          			Mid = Min + (Max - Min)/2;
   \                     ??SearchWord_9:
   \   000000A6   0x1A44             SUBS     R4,R0,R1
   \   000000A8   0xEB04 0x74D4      ADD      R4,R4,R4, LSR #+31
   \   000000AC   0xEB11 0x0464      ADDS     R4,R1,R4, ASR #+1
   \   000000B0   0xB2E4             UXTB     R4,R4
   \   000000B2   0xF833 0x5014      LDRH     R5,[R3, R4, LSL #+1]
   \   000000B6   0x052E             LSLS     R6,R5,#+20
   \   000000B8   0x0D36             LSRS     R6,R6,#+20
   \   000000BA   0x4296             CMP      R6,R2
   \   000000BC   0xD101             BNE.N    ??SearchWord_10
    285          			     if((Buff[Mid] & 0x0FFF) == SearchVal)	return(Mid);
   \                     ??SearchWord_7:
   \   000000BE   0x4620             MOV      R0,R4
   \   000000C0   0xE7AA             B.N      ??SearchWord_2
    286          			else if((Buff[Mid] & 0x0FFF) < SearchVal) 	Min = Mid;
   \                     ??SearchWord_10:
   \   000000C2   0x052D             LSLS     R5,R5,#+20
   \   000000C4   0x0D2D             LSRS     R5,R5,#+20
   \   000000C6   0x4295             CMP      R5,R2
   \   000000C8   0xBFAC             ITE      GE 
   \   000000CA   0x4620             MOVGE    R0,R4
   \   000000CC   0x4621             MOVLT    R1,R4
    287          			else										Max = Mid;
   \   000000CE   0xE7DC             B.N      ??SearchWord_8
    288          		}
    289          	}
    290          
    291          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x40021800         DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     ExpioSem

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     EXPIOrawData

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x40020C14         DC32     0x40020c14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x40021014         DC32     0x40021014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x4002000C         DC32     0x4002000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0x40021010         DC32     0x40021010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   0x40020C10         DC32     0x40020c10
    292          
    293          ///////////////////////////////////////////////////////////////////////////////
    294          // End of Source File
    295          ////////////////////////
    296          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  ByteToWord
       16  ExpioBitRead
             16 -> ExpioReadData
        8  ExpioBitRst
              0 -> ExpioWriteData
        8  ExpioBitSet
              0 -> ExpioWriteData
       24  ExpioModeChanege
              0 -> GPIOPortInit
             24 -> GPIOPortInit
       32  ExpioReadData
             32 -> ExpioModeChanege
             32 -> OSSemPend
             32 -> OSSemPost
       24  ExpioWriteData
             24 -> ExpioModeChanege
             24 -> OSSemPend
             24 -> OSSemPost
       12  SearchWord
        0  atoh


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
      10  ?Subroutine0
       6  ?Subroutine1
       6  ByteToWord
      40  EXPIOrawData
      30  ExpioBitRead
      32  ExpioBitRst
      30  ExpioBitSet
      80  ExpioCS
     198  ExpioModeChanege
     162  ExpioReadData
     172  ExpioWriteData
     208  SearchWord
      42  atoh

 
    40 bytes in section .bss
 1 020 bytes in section .text
 
 1 020 bytes of CODE memory
    40 bytes of DATA memory

Errors: none
Warnings: none

###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.21.1.52794/W32 for ARM     30/Aug/2012  21:21:16 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Work\Project\2012\NL_INBUILD\STM32F2xx_StdPeriph_Driv #
#                    er\src\stm32f2xx_flash_1208.c                            #
#    Command line =  D:\Work\Project\2012\NL_INBUILD\STM32F2xx_StdPeriph_Driv #
#                    er\src\stm32f2xx_flash_1208.c -D OS_INCLUDED -D          #
#                    APPL_SRC -lcN D:\Work\Project\2012\NL_INBUILD\FW\MU\sout #
#                    \ -o D:\Work\Project\2012\NL_INBUILD\FW\MU\sout\         #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Programming\IAR Systems\Embedded       #
#                    Workbench 6.0\arm\INC\c\DLib_Config_Normal.h" -I         #
#                    D:\Work\Project\2012\NL_INBUILD\FW\MU\include\ -I        #
#                    D:\Work\Project\2012\NL_INBUILD\FW\MU\..\..\STM32F2xx_St #
#                    dPeriph_Driver\ -I D:\Work\Project\2012\NL_INBUILD\FW\MU #
#                    \..\..\STM32F2xx_StdPeriph_Driver\inc\ -I                #
#                    D:\Work\Project\2012\NL_INBUILD\FW\MU\uC-CPU\ -I         #
#                    D:\Work\Project\2012\NL_INBUILD\FW\MU\uC-LIB\ -I         #
#                    D:\Work\Project\2012\NL_INBUILD\FW\MU\uCOS-II\Ports\ -I  #
#                    D:\Work\Project\2012\NL_INBUILD\FW\MU\uCOS-II\Source\    #
#                    -I D:\Work\Project\2012\NL_INBUILD\FW\MU\uC-Probe\ -Oh   #
#                    --use_c++_inline                                         #
#    List file    =  D:\Work\Project\2012\NL_INBUILD\FW\MU\sout\stm32f2xx_fla #
#                    sh_1208.lst                                              #
#    Object file  =  D:\Work\Project\2012\NL_INBUILD\FW\MU\sout\stm32f2xx_fla #
#                    sh_1208.o                                                #
#                                                                             #
#                                                                             #
###############################################################################

D:\Work\Project\2012\NL_INBUILD\STM32F2xx_StdPeriph_Driver\src\stm32f2xx_flash_1208.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_flash.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    18-April-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the FLASH peripheral:
      9            *            - FLASH Interface configuration
     10            *            - FLASH Memory Programming
     11            *            - Option Bytes Programming
     12            *            - Interrupts and flags management
     13            *  
     14            *  @verbatim
     15            *  
     16            *          ===================================================================
     17            *                                 How to use this driver
     18            *          ===================================================================
     19            *                           
     20            *          This driver provides functions to configure and program the FLASH 
     21            *          memory of all STM32F2xx devices.
     22            *          These functions are split in 4 groups:
     23            * 
     24            *           1. FLASH Interface configuration functions: this group includes the
     25            *              management of the following features:
     26            *                    - Set the latency
     27            *                    - Enable/Disable the prefetch buffer
     28            *                    - Enable/Disable the Instruction cache and the Data cache
     29            *                    - Reset the Instruction cache and the Data cache
     30            *  
     31            *           2. FLASH Memory Programming functions: this group includes all needed
     32            *              functions to erase and program the main memory:
     33            *                    - Lock and Unlock the FLASH interface
     34            *                    - Erase function: Erase sector, erase all sectors
     35            *                    - Program functions: byte, half word, word and double word
     36            *  
     37            *           3. Option Bytes Programming functions: this group includes all needed
     38            *              functions to manage the Option Bytes:
     39            *                    - Set/Reset the write protection
     40            *                    - Set the Read protection Level
     41            *                    - Set the BOR level
     42            *                    - Program the user Option Bytes
     43            *                    - Launch the Option Bytes loader
     44            *  
     45            *           4. Interrupts and flags management functions: this group 
     46            *              includes all needed functions to:
     47            *                    - Enable/Disable the FLASH interrupt sources
     48            *                    - Get flags status
     49            *                    - Clear flags
     50            *                    - Get FLASH operation status
     51            *                    - Wait for last FLASH operation
     52            * 
     53            *  @endverbatim
     54            *                      
     55            ******************************************************************************
     56            * @attention
     57            *
     58            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     59            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     60            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     61            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     62            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     63            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     64            *
     65            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     66            ******************************************************************************
     67            */
     68          
     69          /* Includes ------------------------------------------------------------------*/
     70          #include "stm32f2xx_flash_1208.h"
     71          
     72          /** @addtogroup STM32F2xx_StdPeriph_Driver
     73            * @{
     74            */
     75          
     76          /** @defgroup FLASH 
     77            * @brief FLASH driver modules
     78            * @{
     79            */ 
     80          
     81          /* Private typedef -----------------------------------------------------------*/
     82          /* Private define ------------------------------------------------------------*/ 
     83          #define SECTOR_MASK               ((uint32_t)0xFFFFFF07)
     84          
     85          /* Private macro -------------------------------------------------------------*/
     86          /* Private variables ---------------------------------------------------------*/
     87          /* Private function prototypes -----------------------------------------------*/
     88          /* Private functions ---------------------------------------------------------*/
     89          
     90          /** @defgroup FLASH_Private_Functions
     91            * @{
     92            */ 
     93          
     94          /** @defgroup FLASH_Group1 FLASH Interface configuration functions
     95            *  @brief   FLASH Interface configuration functions 
     96           *
     97          
     98          @verbatim   
     99           ===============================================================================
    100                                 FLASH Interface configuration functions
    101           ===============================================================================
    102          
    103             This group includes the following functions:
    104              - void FLASH_SetLatency(uint32_t FLASH_Latency)
    105                 To correctly read data from FLASH memory, the number of wait states (LATENCY) 
    106                 must be correctly programmed according to the frequency of the CPU clock 
    107                (HCLK) and the supply voltage of the device.
    108           +-------------------------------------------------------------------------------------+     
    109           | Latency       |                HCLK clock frequency (MHz)                           |
    110           |               |---------------------------------------------------------------------|     
    111           |               | voltage range  | voltage range  | voltage range   | voltage range   |
    112           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   |
    113           |---------------|----------------|----------------|-----------------|-----------------|              
    114           |0WS(1CPU cycle)|0 < HCLK <= 30  |0 < HCLK <= 24  |0 < HCLK <= 18   |0 < HCLK <= 16   |
    115           |---------------|----------------|----------------|-----------------|-----------------|   
    116           |1WS(2CPU cycle)|30 < HCLK <= 60 |24 < HCLK <= 48 |18 < HCLK <= 36  |16 < HCLK <= 32  | 
    117           |---------------|----------------|----------------|-----------------|-----------------|   
    118           |2WS(3CPU cycle)|60 < HCLK <= 90 |48 < HCLK <= 72 |36 < HCLK <= 54  |32 < HCLK <= 48  |
    119           |---------------|----------------|----------------|-----------------|-----------------| 
    120           |3WS(4CPU cycle)|90 < HCLK <= 120|72 < HCLK <= 96 |54 < HCLK <= 72  |48 < HCLK <= 64  |
    121           |---------------|----------------|----------------|-----------------|-----------------| 
    122           |4WS(5CPU cycle)|      NA        |96 < HCLK <= 120|72 < HCLK <= 90  |64 < HCLK <= 80  |
    123           |---------------|----------------|----------------|-----------------|-----------------| 
    124           |5WS(6CPU cycle)|      NA        |      NA        |90 < HCLK <= 108 |80 < HCLK <= 96  | 
    125           |---------------|----------------|----------------|-----------------|-----------------| 
    126           |6WS(7CPU cycle)|      NA        |      NA        |108 < HCLK <= 120|96 < HCLK <= 112 | 
    127           |---------------|----------------|----------------|-----------------|-----------------| 
    128           |7WS(8CPU cycle)|      NA        |      NA        |     NA          |112 < HCLK <= 120| 
    129           |***************|****************|****************|*****************|*****************|*****************************+
    130           |               | voltage range  | voltage range  | voltage range   | voltage range   | voltage range 2.7 V - 3.6 V |
    131           |               | 2.7 V - 3.6 V  | 2.4 V - 2.7 V  | 2.1 V - 2.4 V   | 1.8 V - 2.1 V   | with External Vpp = 9V      |
    132           |---------------|----------------|----------------|-----------------|-----------------|-----------------------------| 
    133           |Max Parallelism|      x32       |               x16                |       x8        |          x64                |              
    134           |---------------|----------------|----------------|-----------------|-----------------|-----------------------------|   
    135           |PSIZE[1:0]     |      10        |               01                 |       00        |           11                |
    136           +-------------------------------------------------------------------------------------------------------------------+  
    137              
    138              - void FLASH_PrefetchBufferCmd(FunctionalState NewState)
    139              - void FLASH_InstructionCacheCmd(FunctionalState NewState)
    140              - void FLASH_DataCacheCmd(FunctionalState NewState)
    141              - void FLASH_InstructionCacheReset(void)
    142              - void FLASH_DataCacheReset(void)
    143             
    144             The unlock sequence is not needed for these functions.
    145           
    146          @endverbatim
    147            * @{
    148            */
    149          
    150          
    151          /**
    152            * @brief  Unlocks Flash for write access
    153            * @param  None
    154            * @retval None
    155            */
    156          void FLASH_If_Init(void)
    157          { 
    158          	FLASH_Unlock(); 
    159          
    160          	/* Clear pending flags (if any) */  
    161          	FLASH_ClearFlag(FLASH_FLAG_EOP | FLASH_FLAG_OPERR | FLASH_FLAG_WRPERR | 
    162          	              FLASH_FLAG_PGAERR | FLASH_FLAG_PGPERR|FLASH_FLAG_PGSERR);
    163          }
    164          
    165           
    166          /**
    167            * @brief  Sets the code latency value.
    168            * @param  FLASH_Latency: specifies the FLASH Latency value.
    169            *          This parameter can be one of the following values:
    170            *            @arg FLASH_Latency_0: FLASH Zero Latency cycle
    171            *            @arg FLASH_Latency_1: FLASH One Latency cycle
    172            *            @arg FLASH_Latency_2: FLASH Two Latency cycles
    173            *            @arg FLASH_Latency_3: FLASH Three Latency cycles
    174            *            @arg FLASH_Latency_4: FLASH Four Latency cycles 
    175            *            @arg FLASH_Latency_5: FLASH Five Latency cycles 
    176            *            @arg FLASH_Latency_6: FLASH Six Latency cycles
    177            *            @arg FLASH_Latency_7: FLASH Seven Latency cycles      
    178            * @retval None
    179            */
    180          void FLASH_SetLatency(uint32_t FLASH_Latency)
    181          {
    182          	/* Check the parameters */
    183          	assert_param(IS_FLASH_LATENCY(FLASH_Latency));
    184          
    185          	/* Perform Byte access to FLASH_ACR[8:0] to set the Latency value */
    186          	*(__IO uint8_t *)ACR_BYTE0_ADDRESS = (uint8_t)FLASH_Latency;
    187          }
    188          
    189          /**
    190            * @brief  Enables or disables the Prefetch Buffer.
    191            * @param  NewState: new state of the Prefetch Buffer.
    192            *          This parameter  can be: ENABLE or DISABLE.
    193            * @retval None
    194            */
    195          void FLASH_PrefetchBufferCmd(FunctionalState NewState)
    196          {
    197          	/* Check the parameters */
    198          	assert_param(IS_FUNCTIONAL_STATE(NewState));
    199          
    200          	/* Enable or disable the Prefetch Buffer */
    201          	if(NewState != DISABLE)
    202          	{
    203          		FLASH->ACR |= FLASH_ACR_PRFTEN;
    204          	}
    205          	else
    206          	{
    207          		FLASH->ACR &= (~FLASH_ACR_PRFTEN);
    208          	}
    209          }
    210          
    211          /**
    212            * @brief  Enables or disables the Instruction Cache feature.
    213            * @param  NewState: new state of the Instruction Cache.
    214            *          This parameter  can be: ENABLE or DISABLE.
    215            * @retval None
    216            */
    217          void FLASH_InstructionCacheCmd(FunctionalState NewState)
    218          {
    219            /* Check the parameters */
    220            assert_param(IS_FUNCTIONAL_STATE(NewState));
    221            
    222            if(NewState != DISABLE)
    223            {
    224              FLASH->ACR |= FLASH_ACR_ICEN;
    225            }
    226            else
    227            {
    228              FLASH->ACR &= (~FLASH_ACR_ICEN);
    229            }
    230          }
    231          
    232          /**
    233            * @brief  Enables or disables the Data Cache feature.
    234            * @param  NewState: new state of the Data Cache.
    235            *          This parameter  can be: ENABLE or DISABLE.
    236            * @retval None
    237            */
    238          void FLASH_DataCacheCmd(FunctionalState NewState)
    239          {
    240          	/* Check the parameters */
    241          	assert_param(IS_FUNCTIONAL_STATE(NewState));
    242            
    243          	if(NewState != DISABLE)
    244          	{
    245          	FLASH->ACR |= FLASH_ACR_DCEN;
    246          	}
    247          	else
    248          	{
    249          	FLASH->ACR &= (~FLASH_ACR_DCEN);
    250          	}
    251          }
    252          
    253          /**
    254            * @brief  Resets the Instruction Cache.
    255            * @note   This function must be used only when the Instruction Cache is disabled.  
    256            * @param  None
    257            * @retval None
    258            */
    259          void FLASH_InstructionCacheReset(void)
    260          {
    261          	FLASH->ACR |= FLASH_ACR_ICRST;
    262          }
    263          
    264          /**
    265            * @brief  Resets the Data Cache.
    266            * @note   This function must be used only when the Data Cache is disabled.  
    267            * @param  None
    268            * @retval None
    269            */
    270          void FLASH_DataCacheReset(void)
    271          {
    272          	FLASH->ACR |= FLASH_ACR_DCRST;
    273          }
    274          
    275          /**
    276            * @}
    277            */
    278          
    279          /** @defgroup FLASH_Group2 FLASH Memory Programming functions
    280           *  @brief   FLASH Memory Programming functions
    281           *
    282          @verbatim   
    283           ===============================================================================
    284                                FLASH Memory Programming functions
    285           ===============================================================================   
    286          
    287             This group includes the following functions:
    288              - void FLASH_Unlock(void)
    289              - void FLASH_Lock(void)
    290              - FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector, uint8_t VoltageRange)
    291              - FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)
    292              - FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
    293              - FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
    294              - FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
    295              - FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
    296             
    297             Any operation of erase or program should follow these steps:
    298             1. Call the FLASH_Unlock() function to enable the FLASH control register access
    299          
    300             2. Call the desired function to erase sector(s) or program data
    301          
    302             3. Call the FLASH_Lock() function to disable the FLASH control register access
    303                (recommended to protect the FLASH memory against possible unwanted operation)
    304              
    305          @endverbatim
    306            * @{
    307            */
    308          
    309          /**
    310            * @brief  Unlocks the FLASH control register access
    311            * @param  None
    312            * @retval None
    313            */
    314          void FLASH_Unlock(void)
    315          {
    316            if((FLASH->CR & FLASH_CR_LOCK) != RESET)
    317            {
    318              /* Authorize the FLASH Registers access */
    319              FLASH->KEYR = FLASH_KEY1;
    320              FLASH->KEYR = FLASH_KEY2;
    321            }  
    322          }
    323          
    324          /**
    325            * @brief  Locks the FLASH control register access
    326            * @param  None
    327            * @retval None
    328            */
    329          void FLASH_Lock(void)
    330          {
    331          	/* Set the LOCK Bit to lock the FLASH Registers access */
    332          	FLASH->CR |= FLASH_CR_LOCK;
    333          }
    334          
    335          
    336          /**
    337            * @brief  This function does an erase of all user flash area
    338            * @param  StartSector: start of user flash area
    339            * @retval 0: user flash area successfully erased
    340            *         1: error occurred
    341            */
    342          uint32_t FLASH_If_Erase(uint32_t Addr)
    343          {
    344          	/* Get the sector where start the user flash area */
    345              if (FLASH_EraseSector(GetSector(Addr)) != FLASH_COMPLETE)
    346              {
    347          		/* Error occurred while page erase */
    348           		return (FALSE);
    349              }
    350          	return (TRUE);
    351          }
    352          
    353          /**
    354            * @brief  Erases a specified FLASH Sector.
    355            *   
    356            * @param  FLASH_Sector: The Sector number to be erased.
    357            *          This parameter can be a value between FLASH_Sector_0 and FLASH_Sector_11
    358            *    
    359            * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
    360            *          This parameter can be one of the following values:
    361            *            @arg VoltageRange_1: when the device voltage range is 1.8V to 2.1V, 
    362            *                                  the operation will be done by byte (8-bit) 
    363            *            @arg VoltageRange_2: when the device voltage range is 2.1V to 2.7V,
    364            *                                  the operation will be done by half word (16-bit)
    365            *            @arg VoltageRange_3: when the device voltage range is 2.7V to 3.6V,
    366            *                                  the operation will be done by word (32-bit)
    367            *            @arg VoltageRange_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
    368            *                                  the operation will be done by double word (64-bit)
    369            *       
    370            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    371            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    372            */
    373          FLASH_Status FLASH_EraseSector(uint32_t FLASH_Sector)
    374          {
    375          	FLASH_Status status = FLASH_COMPLETE;
    376          
    377          	/* Wait for last operation to be completed */
    378          	status = FLASH_WaitForLastOperation();
    379            
    380          	if(status == FLASH_COMPLETE)
    381          	{ 
    382          		/* if the previous operation is completed, proceed to erase the sector */
    383          		FLASH->CR &= CR_PSIZE_MASK;
    384          		FLASH->CR |= FLASH_PSIZE_BYTE;
    385          		//FLASH->CR &= SECTOR_MASK;
    386          		FLASH->__B.CR.SER = SET;
    387          		FLASH->__B.CR.SNB = FLASH_Sector;
    388          		//FLASH->CR |= FLASH_CR_SER | FLASH_Sector;
    389          		FLASH->CR |= FLASH_CR_STRT;
    390          
    391          		/* Wait for last operation to be completed */
    392          		status = FLASH_WaitForLastOperation();
    393          
    394          		/* if the erase operation is completed, disable the SER Bit */
    395          		FLASH->CR &= (~FLASH_CR_SER);
    396          		FLASH->CR &= SECTOR_MASK; 
    397          	}
    398          	else status = FLASH_NULL;
    399          	/* Return the Erase Status */
    400          	return status;
    401          }
    402          
    403          /**
    404            * @brief  Erases all FLASH Sectors.
    405            *    
    406            * @param  VoltageRange: The device voltage range which defines the erase parallelism.  
    407            *          This parameter can be one of the following values:
    408            *            @arg VoltageRange_1: when the device voltage range is 1.8V to 2.1V, 
    409            *                                  the operation will be done by byte (8-bit) 
    410            *            @arg VoltageRange_2: when the device voltage range is 2.1V to 2.7V,
    411            *                                  the operation will be done by half word (16-bit)
    412            *            @arg VoltageRange_3: when the device voltage range is 2.7V to 3.6V,
    413            *                                  the operation will be done by word (32-bit)
    414            *            @arg VoltageRange_4: when the device voltage range is 2.7V to 3.6V + External Vpp, 
    415            *                                  the operation will be done by double word (64-bit)
    416            *       
    417            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    418            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    419            */
    420          FLASH_Status FLASH_EraseAllSectors(uint8_t VoltageRange)
    421          {
    422            uint32_t tmp_psize = 0x0;
    423            FLASH_Status status = FLASH_COMPLETE;
    424            
    425            /* Wait for last operation to be completed */
    426            status = FLASH_WaitForLastOperation();
    427            assert_param(IS_VOLTAGERANGE(VoltageRange));
    428            
    429            if(VoltageRange == VoltageRange_1)
    430            {
    431               tmp_psize = FLASH_PSIZE_BYTE;
    432            }
    433            else if(VoltageRange == VoltageRange_2)
    434            {
    435              tmp_psize = FLASH_PSIZE_HALF_WORD;
    436            }
    437            else if(VoltageRange == VoltageRange_3)
    438            {
    439              tmp_psize = FLASH_PSIZE_WORD;
    440            }
    441            else
    442            {
    443              tmp_psize = FLASH_PSIZE_DOUBLE_WORD;
    444            }  
    445            if(status == FLASH_COMPLETE)
    446            {
    447              /* if the previous operation is completed, proceed to erase all sectors */
    448               FLASH->CR &= CR_PSIZE_MASK;
    449               FLASH->CR |= tmp_psize;
    450               FLASH->CR |= FLASH_CR_MER;
    451               FLASH->CR |= FLASH_CR_STRT;
    452              
    453              /* Wait for last operation to be completed */
    454              status = FLASH_WaitForLastOperation();
    455          
    456              /* if the erase operation is completed, disable the MER Bit */
    457              FLASH->CR &= (~FLASH_CR_MER);
    458          
    459            }   
    460            /* Return the Erase Status */
    461            return status;
    462          }
    463          
    464          /**
    465            * @brief  Programs a double word (64-bit) at a specified address.
    466            * @note   This function must be used when the device voltage range is from
    467            *         2.7V to 3.6V and an External Vpp is present.           
    468            * @param  Address: specifies the address to be programmed.
    469            * @param  Data: specifies the data to be programmed.
    470            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    471            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    472            */
    473          FLASH_Status FLASH_ProgramDoubleWord(uint32_t Address, uint64_t Data)
    474          {
    475            FLASH_Status status = FLASH_COMPLETE;
    476          
    477            /* Check the parameters */
    478            assert_param(IS_FLASH_ADDRESS(Address));
    479          
    480            /* Wait for last operation to be completed */
    481            status = FLASH_WaitForLastOperation();
    482            
    483            if(status == FLASH_COMPLETE)
    484            {
    485              /* if the previous operation is completed, proceed to program the new data */
    486              FLASH->CR &= CR_PSIZE_MASK;
    487              FLASH->CR |= FLASH_PSIZE_DOUBLE_WORD;
    488              FLASH->CR |= FLASH_CR_PG;
    489            
    490              *(__IO uint64_t*)Address = Data;
    491                  
    492              /* Wait for last operation to be completed */
    493              status = FLASH_WaitForLastOperation();
    494          
    495              /* if the program operation is completed, disable the PG Bit */
    496              FLASH->CR &= (~FLASH_CR_PG);
    497            } 
    498            /* Return the Program Status */
    499            return status;
    500          }
    501          
    502          /**
    503            * @brief  Programs a word (32-bit) at a specified address.
    504            * @param  Address: specifies the address to be programmed.
    505            *         This parameter can be any address in Program memory zone or in OTP zone.  
    506            * @note   This function must be used when the device voltage range is from 2.7V to 3.6V. 
    507            * @param  Data: specifies the data to be programmed.
    508            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    509            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    510            */
    511          FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
    512          {
    513          	FLASH_Status status = FLASH_COMPLETE;
    514          
    515          	/* Check the parameters */
    516          	assert_param(IS_FLASH_ADDRESS(Address));
    517          
    518          	/* Wait for last operation to be completed */
    519          	status = FLASH_WaitForLastOperation();
    520          
    521          	if(status == FLASH_COMPLETE)
    522          	{
    523          		/* if the previous operation is completed, proceed to program the new data */
    524          		FLASH->CR &= CR_PSIZE_MASK;
    525          		FLASH->CR |= FLASH_PSIZE_WORD;
    526          		FLASH->CR |= FLASH_CR_PG;
    527          
    528          		*(__IO uint32_t*)Address = Data;
    529          	    
    530          		/* Wait for last operation to be completed */
    531          		status = FLASH_WaitForLastOperation();
    532          
    533          		/* if the program operation is completed, disable the PG Bit */
    534          		FLASH->CR &= (~FLASH_CR_PG);
    535          	} 
    536          	/* Return the Program Status */
    537          	return status;
    538          }
    539          
    540          /**
    541            * @brief  Programs a half word (16-bit) at a specified address. 
    542            * @note   This function must be used when the device voltage range is from 2.1V to 3.6V.               
    543            * @param  Address: specifies the address to be programmed.
    544            *         This parameter can be any address in Program memory zone or in OTP zone.  
    545            * @param  Data: specifies the data to be programmed.
    546            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    547            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    548            */
    549          FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
    550          {
    551          	FLASH_Status status = FLASH_COMPLETE;
    552          
    553          	/* Check the parameters */
    554          	assert_param(IS_FLASH_ADDRESS(Address));
    555          
    556          	/* Wait for last operation to be completed */
    557          	status = FLASH_WaitForLastOperation();
    558          
    559          	if(status == FLASH_COMPLETE)
    560          	{
    561          		/* if the previous operation is completed, proceed to program the new data */
    562          		FLASH->CR &= CR_PSIZE_MASK;
    563          		FLASH->CR |= FLASH_PSIZE_HALF_WORD;
    564          		FLASH->CR |= FLASH_CR_PG;
    565          
    566          		*(__IO uint16_t*)Address = Data;
    567          		    
    568          		/* Wait for last operation to be completed */
    569          		status = FLASH_WaitForLastOperation();
    570          
    571          		/* if the program operation is completed, disable the PG Bit */
    572          		FLASH->CR &= (~FLASH_CR_PG);
    573          	} 
    574          	/* Return the Program Status */
    575          	return status;
    576          }
    577          
    578          /**
    579            * @brief  Programs a byte (8-bit) at a specified address.
    580            * @note   This function can be used within all the device supply voltage ranges.               
    581            * @param  Address: specifies the address to be programmed.
    582            *         This parameter can be any address in Program memory zone or in OTP zone.  
    583            * @param  Data: specifies the data to be programmed.
    584            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    585            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    586            */
    587          FLASH_Status FLASH_ProgramByte(uint32_t Address, uint8_t Data)
    588          {
    589            FLASH_Status status = FLASH_COMPLETE;
    590          
    591            /* Check the parameters */
    592            assert_param(IS_FLASH_ADDRESS(Address));
    593          
    594            /* Wait for last operation to be completed */
    595            status = FLASH_WaitForLastOperation();
    596            
    597            if(status == FLASH_COMPLETE)
    598            {
    599              /* if the previous operation is completed, proceed to program the new data */
    600              FLASH->CR &= CR_PSIZE_MASK;
    601              FLASH->CR |= FLASH_PSIZE_BYTE;
    602              FLASH->CR |= FLASH_CR_PG;
    603            
    604              *(__IO uint8_t*)Address = Data;
    605                  
    606              /* Wait for last operation to be completed */
    607              status = FLASH_WaitForLastOperation();
    608          
    609              /* if the program operation is completed, disable the PG Bit */
    610              FLASH->CR &= (~FLASH_CR_PG);
    611            } 
    612          
    613            /* Return the Program Status */
    614            return status;
    615          }
    616          
    617          /**
    618            * @}
    619            */
    620          
    621          /** @defgroup FLASH_Group3 Option Bytes Programming functions
    622           *  @brief   Option Bytes Programming functions 
    623           *
    624          @verbatim   
    625           ===============================================================================
    626                                  Option Bytes Programming functions
    627           ===============================================================================  
    628           
    629             This group includes the following functions:
    630             - void FLASH_OB_Unlock(void)
    631             - void FLASH_OB_Lock(void)
    632             - void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
    633             - void FLASH_OB_RDPConfig(uint8_t OB_RDP)
    634             - void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
    635             - void FLASH_OB_BORConfig(uint8_t OB_BOR)
    636             - FLASH_Status FLASH_ProgramOTP(uint32_t Address, uint32_t Data)							
    637             - FLASH_Status FLASH_OB_Launch(void)
    638             - uint32_t FLASH_OB_GetUser(void)						
    639             - uint8_t FLASH_OB_GetWRP(void)						
    640             - uint8_t FLASH_OB_GetRDP(void)							
    641             - uint8_t FLASH_OB_GetBOR(void)
    642             
    643             Any operation of erase or program should follow these steps:
    644             1. Call the FLASH_OB_Unlock() function to enable the FLASH option control register access
    645          
    646             2. Call one or several functions to program the desired Option Bytes:
    647                - void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState) => to Enable/Disable 
    648                  the desired sector write protection
    649                - void FLASH_OB_RDPConfig(uint8_t OB_RDP) => to set the desired read Protection Level
    650                - void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY) => to configure 
    651                  the user Option Bytes.
    652                - void FLASH_OB_BORConfig(uint8_t OB_BOR) => to set the BOR Level 			 
    653          
    654             3. Once all needed Option Bytes to be programmed are correctly written, call the
    655                FLASH_OB_Launch() function to launch the Option Bytes programming process.
    656               
    657               @note When changing the IWDG mode from HW to SW or from SW to HW, a system 
    658                     reset is needed to make the change effective.  
    659          
    660             4. Call the FLASH_OB_Lock() function to disable the FLASH option control register
    661                access (recommended to protect the Option Bytes against possible unwanted operations)
    662              
    663          @endverbatim
    664            * @{
    665            */
    666          
    667          /**
    668            * @brief  Unlocks the FLASH Option Control Registers access.
    669            * @param  None
    670            * @retval None
    671            */
    672          void FLASH_OB_Unlock(void)
    673          {
    674          	if((FLASH->OPTCR & FLASH_OPTCR_OPTLOCK) != RESET)
    675          	{
    676          		/* Authorizes the Option Byte register programming */
    677          		FLASH->OPTKEYR = FLASH_OPT_KEY1;
    678          		FLASH->OPTKEYR = FLASH_OPT_KEY2;
    679          	}  
    680          }
    681          
    682          /**
    683            * @brief  Locks the FLASH Option Control Registers access.
    684            * @param  None
    685            * @retval None
    686            */
    687          void FLASH_OB_Lock(void)
    688          {
    689          	/* Set the OPTLOCK Bit to lock the FLASH Option Byte Registers access */
    690          	FLASH->OPTCR |= FLASH_OPTCR_OPTLOCK;
    691          }
    692          
    693          /**
    694            * @brief  Enables or disables the write protection of the desired sectors
    695            * @param  OB_WRP: specifies the sector(s) to be write protected or unprotected.
    696            *          This parameter can be one of the following values:
    697            *            @arg OB_WRP: A value between OB_WRP_Sector0 and OB_WRP_Sector11                      
    698            *            @arg OB_WRP_Sector_All
    699            * @param  Newstate: new state of the Write Protection.
    700            *          This parameter can be: ENABLE or DISABLE.
    701            * @retval None  
    702            */
    703          void FLASH_OB_WRPConfig(uint32_t OB_WRP, FunctionalState NewState)
    704          { 
    705          	FLASH_Status status = FLASH_COMPLETE;
    706            
    707          	/* Check the parameters */
    708          	assert_param(IS_OB_WRP(OB_WRP));
    709          	assert_param(IS_FUNCTIONAL_STATE(NewState));
    710          
    711          	status = FLASH_WaitForLastOperation();
    712          
    713          	if(status == FLASH_COMPLETE)
    714          	{ 
    715          		if(NewState != DISABLE)
    716          		{
    717          			BitSet(FLASH->__B.OPTCR.nWRP, OB_WRP);
    718          			//*(__IO uint16_t*)OPTCR_BYTE2_ADDRESS &= (~OB_WRP);
    719          		}
    720          		else
    721          		{
    722          			BitRst(FLASH->__B.OPTCR.nWRP, OB_WRP);
    723          			//*(__IO uint16_t*)OPTCR_BYTE2_ADDRESS |= (uint16_t)OB_WRP;
    724          		}
    725          	}
    726          }
    727          
    728          /**
    729            * @brief  Sets the read protection level.
    730            * @param  OB_RDP: specifies the read protection level.
    731            *          This parameter can be one of the following values:
    732            *            @arg OB_RDP_Level_0: No protection
    733            *            @arg OB_RDP_Level_1: Read protection of the memory
    734            *            @arg OB_RDP_Level_2: Full chip protection
    735            *   
    736            * !!!Warning!!! When enabling OB_RDP level 2 it's no more possible to go back to level 1 or 0
    737            *    
    738            * @retval None
    739            */
    740          void FLASH_OB_RDPConfig(uint8_t OB_RDP)
    741          {
    742            FLASH_Status status = FLASH_COMPLETE;
    743          
    744            /* Check the parameters */
    745            assert_param(IS_OB_RDP(OB_RDP));
    746          
    747            status = FLASH_WaitForLastOperation();
    748          
    749            if(status == FLASH_COMPLETE)
    750            {
    751              *(__IO uint8_t*)OPTCR_BYTE1_ADDRESS = OB_RDP;
    752          
    753            }
    754          }
    755          
    756          /**
    757            * @brief  Programs the FLASH User Option Byte: IWDG_SW / RST_STOP / RST_STDBY.    
    758            * @param  OB_IWDG: Selects the IWDG mode
    759            *          This parameter can be one of the following values:
    760            *            @arg OB_IWDG_SW: Software IWDG selected
    761            *            @arg OB_IWDG_HW: Hardware IWDG selected
    762            * @param  OB_STOP: Reset event when entering STOP mode.
    763            *          This parameter  can be one of the following values:
    764            *            @arg OB_STOP_NoRST: No reset generated when entering in STOP
    765            *            @arg OB_STOP_RST: Reset generated when entering in STOP
    766            * @param  OB_STDBY: Reset event when entering Standby mode.
    767            *          This parameter  can be one of the following values:
    768            *            @arg OB_STDBY_NoRST: No reset generated when entering in STANDBY
    769            *            @arg OB_STDBY_RST: Reset generated when entering in STANDBY
    770            * @retval None
    771            */
    772          void FLASH_OB_UserConfig(uint8_t OB_IWDG, uint8_t OB_STOP, uint8_t OB_STDBY)
    773          {
    774            uint8_t optiontmp = 0xFF;
    775            FLASH_Status status = FLASH_COMPLETE; 
    776          
    777            /* Check the parameters */
    778            assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
    779            assert_param(IS_OB_STOP_SOURCE(OB_STOP));
    780            assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
    781          
    782            /* Wait for last operation to be completed */
    783            status = FLASH_WaitForLastOperation();
    784            
    785            if(status == FLASH_COMPLETE)
    786            { 
    787              /* Mask OPTLOCK, OPTSTRT and BOR_LEV bits */
    788              optiontmp =  (uint8_t)((*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0F); 
    789          
    790              /* Update User Option Byte */
    791              *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS = OB_IWDG | (uint8_t)(OB_STDBY | (uint8_t)(OB_STOP | ((uint8_t)optiontmp))); 
    792            }  
    793          }
    794          
    795          /**
    796            * @brief  Sets the BOR Level. 
    797            * @param  OB_BOR: specifies the Option Bytes BOR Reset Level.
    798            *          This parameter can be one of the following values:
    799            *            @arg OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V
    800            *            @arg OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
    801            *            @arg OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
    802            *            @arg OB_BOR_OFF: Supply voltage ranges from 1.62 to 2.1 V
    803            * @retval None
    804            */
    805          void FLASH_OB_BORConfig(uint8_t OB_BOR)
    806          {
    807            /* Check the parameters */
    808            assert_param(IS_OB_BOR(OB_BOR));
    809          
    810            /* Set the BOR Level */
    811            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS &= (~FLASH_OPTCR_BOR_LEV);
    812            *(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= OB_BOR;
    813          
    814          }
    815          
    816          /**
    817            * @brief  Launch the option byte loading.
    818            * @param  None
    819            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    820            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    821            */
    822          FLASH_Status FLASH_OB_Launch(void)
    823          {
    824          	FLASH_Status status = FLASH_COMPLETE;
    825          
    826          	/* Set the OPTSTRT bit in OPTCR register */
    827          	*(__IO uint8_t *)OPTCR_BYTE0_ADDRESS |= FLASH_OPTCR_OPTSTRT;
    828          
    829          	/* Wait for last operation to be completed */
    830          	status = FLASH_WaitForLastOperation();
    831          //FLASH_TypeDef
    832          	return status;
    833          }
    834          
    835          /**
    836            * @brief  Returns the FLASH User Option Bytes values.
    837            * @param  None
    838            * @retval The FLASH User Option Bytes values: IWDG_SW(Bit0), RST_STOP(Bit1)
    839            *         and RST_STDBY(Bit2).
    840            */
    841          uint8_t FLASH_OB_GetUser(void)
    842          {
    843            /* Return the User Option Byte */
    844            return (uint8_t)(FLASH->OPTCR >> 5);
    845          }
    846          
    847          /*******************************************************************************
    848            * @brief  Returns the FLASH Write Protection Option Bytes value.
    849            * @param  None
    850            * @retval The FLASH Write Protection  Option Bytes value
    851            *****************************************************************************/
    852          uint16_t FLASH_OB_GetWRP(uint32_t Sector)
    853          {
    854          	/* Return the FLASH write protection Register value */
    855          	return ((FLASH->__B.OPTCR.nWRP >> Sector) & 0x01);
    856          	//return (*(__IO uint16_t *)(OPTCR_BYTE2_ADDRESS));
    857          	// 0: write protection
    858          	// 1: no write protection
    859          }
    860          
    861          /*******************************************************************************
    862            * @brief  Returns the FLASH Read Protection level.
    863            * @param  None
    864            * @retval FLASH ReadOut Protection Status:
    865            *           - SET, when OB_RDP_Level_1 or OB_RDP_Level_2 is set
    866            *           - RESET, when OB_RDP_Level_0 is set
    867            ******************************************************************************/
    868          FlagStatus FLASH_OB_GetRDP(void)
    869          {
    870            FlagStatus readstatus = RESET;
    871          
    872            if ((*(__IO uint8_t*)(OPTCR_BYTE1_ADDRESS) != (uint8_t)OB_RDP_Level_0))
    873            {
    874              readstatus = SET;
    875            }
    876            else
    877            {
    878              readstatus = RESET;
    879            }
    880            return readstatus;
    881          }
    882          
    883          /**
    884            * @brief  Returns the FLASH BOR level.
    885            * @param  None
    886            * @retval The FLASH BOR level:
    887            *           - OB_BOR_LEVEL3: Supply voltage ranges from 2.7 to 3.6 V
    888            *           - OB_BOR_LEVEL2: Supply voltage ranges from 2.4 to 2.7 V
    889            *           - OB_BOR_LEVEL1: Supply voltage ranges from 2.1 to 2.4 V
    890            *           - OB_BOR_OFF   : Supply voltage ranges from 1.62 to 2.1 V  
    891            */
    892          uint8_t FLASH_OB_GetBOR(void)
    893          {
    894            /* Return the FLASH BOR level */
    895            return (uint8_t)(*(__IO uint8_t *)(OPTCR_BYTE0_ADDRESS) & (uint8_t)0x0C);
    896          }
    897          
    898          /**
    899            * @}
    900            */
    901          
    902          /** @defgroup FLASH_Group4 Interrupts and flags management functions
    903           *  @brief   Interrupts and flags management functions
    904           *
    905          @verbatim   
    906           ===============================================================================
    907                            Interrupts and flags management functions
    908           ===============================================================================  
    909          
    910          @endverbatim
    911            * @{
    912            */
    913          
    914          /**
    915            * @brief  Enables or disables the specified FLASH interrupts.
    916            * @param  FLASH_IT: specifies the FLASH interrupt sources to be enabled or disabled.
    917            *          This parameter can be any combination of the following values:
    918            *            @arg FLASH_IT_ERR: FLASH Error Interrupt
    919            *            @arg FLASH_IT_EOP: FLASH end of operation Interrupt
    920            * @retval None 
    921            */
    922          void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
    923          {
    924            /* Check the parameters */
    925            assert_param(IS_FLASH_IT(FLASH_IT)); 
    926            assert_param(IS_FUNCTIONAL_STATE(NewState));
    927          
    928            if(NewState != DISABLE)
    929            {
    930              /* Enable the interrupt sources */
    931              FLASH->CR |= FLASH_IT;
    932            }
    933            else
    934            {
    935              /* Disable the interrupt sources */
    936              FLASH->CR &= ~(uint32_t)FLASH_IT;
    937            }
    938          }
    939          
    940          /**
    941            * @brief  Checks whether the specified FLASH flag is set or not.
    942            * @param  FLASH_FLAG: specifies the FLASH flag to check.
    943            *          This parameter can be one of the following values:
    944            *            @arg FLASH_FLAG_EOP: FLASH End of Operation flag 
    945            *            @arg FLASH_FLAG_OPERR: FLASH operation Error flag 
    946            *            @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
    947            *            @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag
    948            *            @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
    949            *            @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
    950            *            @arg FLASH_FLAG_BSY: FLASH Busy flag
    951            * @retval The new state of FLASH_FLAG (SET or RESET).
    952            */
    953          FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
    954          {
    955            FlagStatus bitstatus = RESET;
    956            /* Check the parameters */
    957            assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG));
    958          
    959            if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
    960            {
    961              bitstatus = SET;
    962            }
    963            else
    964            {
    965              bitstatus = RESET;
    966            }
    967            /* Return the new state of FLASH_FLAG (SET or RESET) */
    968            return bitstatus; 
    969          }
    970          
    971          /**
    972            * @brief  Clears the FLASH's pending flags.
    973            * @param  FLASH_FLAG: specifies the FLASH flags to clear.
    974            *          This parameter can be any combination of the following values:
    975            *            @arg FLASH_FLAG_EOP: FLASH End of Operation flag 
    976            *            @arg FLASH_FLAG_OPERR: FLASH operation Error flag 
    977            *            @arg FLASH_FLAG_WRPERR: FLASH Write protected error flag 
    978            *            @arg FLASH_FLAG_PGAERR: FLASH Programming Alignment error flag 
    979            *            @arg FLASH_FLAG_PGPERR: FLASH Programming Parallelism error flag
    980            *            @arg FLASH_FLAG_PGSERR: FLASH Programming Sequence error flag
    981            * @retval None
    982            */
    983          void FLASH_ClearFlag(uint32_t FLASH_FLAG)
    984          {
    985          	/* Check the parameters */
    986          	assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG));
    987          
    988          	/* Clear the flags */
    989          	FLASH->SR = FLASH_FLAG;
    990          }
    991          
    992          /*******************************************************************************
    993            * @brief  Returns the FLASH Status.
    994            * @param  None
    995            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
    996            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
    997            *****************************************************************************/
    998          FLASH_Status FLASH_GetStatus(void)
    999          {
   1000          	FLASH_Status flashstatus = FLASH_COMPLETE;
   1001            
   1002          	if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
   1003          	{
   1004          		flashstatus = FLASH_BUSY;
   1005          	}
   1006          	else 
   1007          	{  
   1008          		if((FLASH->SR & FLASH_FLAG_WRPERR) != (uint32_t)0x00)
   1009          		{ 
   1010          			flashstatus = FLASH_ERROR_WRP;
   1011          		}
   1012          		else 
   1013          		{
   1014          			if((FLASH->SR & (uint32_t)0xEF) != (uint32_t)0x00)
   1015          		  	{
   1016          		   		flashstatus = FLASH_ERROR_PROGRAM; 
   1017          		  	}
   1018          		  	else
   1019          		  	{
   1020          		    	if((FLASH->SR & FLASH_FLAG_OPERR) != (uint32_t)0x00)
   1021          		    	{
   1022          		    	  	flashstatus = FLASH_ERROR_OPERATION;
   1023          		    	}
   1024          		    	else
   1025          		    	{
   1026          		     		flashstatus = FLASH_COMPLETE;
   1027          		    	}
   1028          		  	}
   1029          		}
   1030          	}
   1031          	/* Return the FLASH Status */
   1032          	return flashstatus;
   1033          }
   1034          
   1035          /*******************************************************************************
   1036            * @brief  Waits for a FLASH operation to complete.
   1037            * @param  None
   1038            * @retval FLASH Status: The returned value can be: FLASH_BUSY, FLASH_ERROR_PROGRAM,
   1039            *                       FLASH_ERROR_WRP, FLASH_ERROR_OPERATION or FLASH_COMPLETE.
   1040            *****************************************************************************/
   1041          FLASH_Status FLASH_WaitForLastOperation(void)
   1042          {
   1043          	u32 rtry = 0xffff;
   1044          	__IO FLASH_Status status = FLASH_COMPLETE;
   1045             
   1046          	/* Check for the FLASH Status */
   1047          	status = FLASH_GetStatus();
   1048          
   1049          	/* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
   1050          	 Even if the FLASH operation fails, the BUSY flag will be reset and an error
   1051          	 flag will be set */
   1052          	while(status == FLASH_BUSY && rtry--)
   1053          	{
   1054          		status = FLASH_GetStatus();
   1055          	}
   1056          	
   1057          	/* Return the operation status */
   1058          	return status;
   1059          }
   1060          
   1061          /*******************************************************************************
   1062            * @brief  Returns the write protection status of user flash area.
   1063            * @param  None
   1064            * @retval 0: No write protected sectors inside the user flash area
   1065            *         1: Some sectors inside the user flash area are write protected
   1066            *****************************************************************************/
   1067          uint16_t FLASH_If_GetWPStatus(uint32_t Addr)
   1068          {
   1069          	uint32_t uSector = GetSector(Addr);
   1070          
   1071          	return FLASH_OB_GetWRP(uSector);
   1072          
   1073          	/* 1: No write protected sectors inside the user flash area */
   1074          	/* 0: Some sectors inside the user flash area are write protected */
   1075          }
   1076          
   1077          /*******************************************************************************
   1078            * @brief  Disables the write protection of user flash area.
   1079            * @param  None
   1080            * @retval 1: Write Protection successfully disabled
   1081            *         2: Error: Flash write unprotection failed
   1082            ******************************************************************************/
   1083          uint32_t FLASH_WPDisable(uint32_t Addr)
   1084          {
   1085          	__IO uint32_t uSector = FLASH_Sector_1;
   1086          	//__IO uint32_t UserWrpSectors = OB_WRP_Sector_1;
   1087          
   1088          	/* Get the sector where start the user flash area */
   1089          	uSector = GetSector(Addr);
   1090          
   1091          	/* Mark all sectors inside the user flash area as non protected */  
   1092          	//UserWrpSectors = 0xFFF-((1 << (UserStartSector/8))-1);
   1093          
   1094          	/* Unlock the Option Bytes */
   1095          	FLASH_OB_Unlock();
   1096          
   1097          	/* Disable the write protection for all sectors inside the user flash area */
   1098          	FLASH_OB_WRPConfig(uSector, DISABLE);
   1099          
   1100          	/* Start the Option Bytes programming process. */  
   1101          	if (FLASH_OB_Launch() != FLASH_COMPLETE)
   1102          	{
   1103          		/* Error: Flash write unprotection failed */
   1104          		return (2);
   1105          	}
   1106          
   1107          	/* Write Protection successfully disabled */
   1108          	return (1);
   1109          //FLASH_TypeDef
   1110          }
   1111          
   1112          /*******************************************************************************
   1113            * @brief  Gets the sector of a given address
   1114            * @param  Address: Flash address
   1115            * @retval The sector of a given address
   1116            *****************************************************************************/
   1117          uint32_t GetSector(uint32_t Addr)
   1118          {
   1119          		 if(Addr < ADDR_FLASH_SECTOR_1)		return 0;
   1120          	else if(Addr < ADDR_FLASH_SECTOR_2) 	return 1;
   1121          	else if(Addr < ADDR_FLASH_SECTOR_3) 	return 2;
   1122          	else if(Addr < ADDR_FLASH_SECTOR_4) 	return 3;
   1123          	else if(Addr < ADDR_FLASH_SECTOR_5) 	return 4;
   1124          	else if(Addr < ADDR_FLASH_SECTOR_6) 	return 5;
   1125          	else if(Addr < ADDR_FLASH_SECTOR_7) 	return 6;
   1126          	else if(Addr < ADDR_FLASH_SECTOR_8) 	return 7;
   1127          	else if(Addr < ADDR_FLASH_SECTOR_9) 	return 8;
   1128          	else if(Addr < ADDR_FLASH_SECTOR_10)	return 9;
   1129          	else if(Addr < ADDR_FLASH_SECTOR_11)	return 10;
   1130          	else									return 11;
   1131          
   1132          }
   1133          
   1134          
   1135          /**
   1136            * @}
   1137            */ 
   1138          
   1139          /**
   1140            * @}
   1141            */ 
   1142          
   1143          /**
   1144            * @}
   1145            */ 
   1146          
   1147          /**
   1148            * @}
   1149            */
   1150          
   1151          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

     Function                    .cstack
     --------                    -------
     FLASH_ClearFlag                  0
     FLASH_DataCacheCmd               0
     FLASH_DataCacheReset             0
     FLASH_EraseAllSectors           16
     FLASH_EraseSector               16
     FLASH_GetFlagStatus              0
     FLASH_GetStatus                  0
     FLASH_ITConfig                   0
     FLASH_If_Erase                   8
     FLASH_If_GetWPStatus             8
     FLASH_If_Init                    8
     FLASH_InstructionCacheCmd        0
     FLASH_InstructionCacheReset      0
     FLASH_Lock                       0
     FLASH_OB_BORConfig               0
     FLASH_OB_GetBOR                  0
     FLASH_OB_GetRDP                  0
     FLASH_OB_GetUser                 0
     FLASH_OB_GetWRP                  0
     FLASH_OB_Launch                  8
     FLASH_OB_Lock                    0
     FLASH_OB_RDPConfig               8
     FLASH_OB_Unlock                  0
     FLASH_OB_UserConfig             16
     FLASH_OB_WRPConfig              16
     FLASH_PrefetchBufferCmd          0
     FLASH_ProgramByte               16
     FLASH_ProgramDoubleWord         24
     FLASH_ProgramHalfWord           16
     FLASH_ProgramWord               16
     FLASH_SetLatency                 0
     FLASH_Unlock                     0
     FLASH_WPDisable                  8
     FLASH_WaitForLastOperation      16
     GetSector                        0


   Section sizes:

     Function/Label              Bytes
     --------------              -----
     FLASH_If_Init                 16
     FLASH_SetLatency               8
     FLASH_PrefetchBufferCmd       24
     FLASH_InstructionCacheCmd     24
     FLASH_DataCacheCmd            22
     FLASH_InstructionCacheReset   14
     FLASH_DataCacheReset          14
     FLASH_Unlock                  24
     FLASH_Lock                    14
     FLASH_If_Erase                22
     FLASH_EraseSector             78
     FLASH_EraseAllSectors         84
     FLASH_ProgramDoubleWord       62
     FLASH_ProgramWord             58
     FLASH_ProgramHalfWord         58
     FLASH_ProgramByte             52
     FLASH_OB_Unlock               18
     FLASH_OB_Lock                 12
     FLASH_OB_WRPConfig            46
     FLASH_OB_RDPConfig            18
     FLASH_OB_UserConfig           36
     FLASH_OB_BORConfig            18
     FLASH_OB_Launch               12
     FLASH_OB_GetUser              10
     FLASH_OB_GetWRP               18
     FLASH_OB_GetRDP               14
     FLASH_OB_GetBOR               10
     FLASH_ITConfig                18
     FLASH_GetFlagStatus           16
     FLASH_ClearFlag                6
     FLASH_GetStatus               46
     FLASH_WaitForLastOperation    44
     FLASH_If_GetWPStatus          24
     FLASH_WPDisable               40
     GetSector                    114
     ??DataTable31                  4
     ??DataTable31_1                4
     ??DataTable31_2                4
     ??DataTable31_3                4
     ??DataTable31_4                4
     ??DataTable31_5                4
     ??DataTable31_6                4
     ??DataTable31_7                4
     ??DataTable31_8                4
     ??DataTable31_9                4
     ??DataTable31_10               4
     ??DataTable31_11               4
     ??DataTable31_12               4
     ??DataTable31_13               4
     ??DataTable31_14               4
     ??DataTable31_15               4
     ??DataTable31_16               4
     ??DataTable31_17               4
     ??DataTable31_18               4
     ??DataTable31_19               4
     ??DataTable31_20               4
     ??DataTable31_21               4

 
 1 182 bytes in section .text
 
 1 182 bytes of CODE memory

Errors: none
Warnings: none

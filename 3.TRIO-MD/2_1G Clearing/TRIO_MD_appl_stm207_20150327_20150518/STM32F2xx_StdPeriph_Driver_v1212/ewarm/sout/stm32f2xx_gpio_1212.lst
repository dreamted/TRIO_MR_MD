###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     03/Sep/2014  15:31:58 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\src\stm32f2xx_gpio_1212.c #
#    Command line =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\src\stm32f2xx_gpio_1212.c #
#                     -D NDEBUG -lC D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm #
#                    207_20140821\STM32F2xx_StdPeriph_Driver_v1212\ewarm\sout #
#                    \ -o D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_201408 #
#                    21\STM32F2xx_StdPeriph_Driver_v1212\ewarm\sout\          #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.0\arm\INC\c\DLib_Config_Normal.h" -I         #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\..\ -I              #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\..\inc\ -I          #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\..\..\uC-CPU\ -I    #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\..\..\uC-LIB\ -I    #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\..\..\uCOS-II\Ports #
#                    \ -I D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_201408 #
#                    21\STM32F2xx_StdPeriph_Driver_v1212\ewarm\..\..\uCOS-II\ #
#                    Source\ -Oh                                              #
#    List file    =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\sout\stm32f2xx_gpio #
#                    _1212.lst                                                #
#    Object file  =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\sout\stm32f2xx_gpio #
#                    _1212.o                                                  #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\STM32F2xx_StdPeriph_Driver_v1212\src\stm32f2xx_gpio_1212.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f2xx_gpio.c
      4            * @author  MCD Application Team
      5            * @version V1.0.0
      6            * @date    18-April-2011
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the GPIO peripheral:           
      9            *           - Initialization and Configuration
     10            *           - GPIO Read and Write
     11            *           - GPIO Alternate functions configuration
     12            * 
     13            *  @verbatim
     14            *
     15            *          ===================================================================
     16            *                                 How to use this driver
     17            *          ===================================================================       
     18            *           1. Enable the GPIO AHB clock using the following function
     19            *                RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOx, ENABLE);
     20            *             
     21            *           2. Configure the GPIO pin(s) using GPIO_Init()
     22            *              Four possible configuration are available for each pin:
     23            *                - Input: Floating, Pull-up, Pull-down.
     24            *                - Output: Push-Pull (Pull-up, Pull-down or no Pull)
     25            *                          Open Drain (Pull-up, Pull-down or no Pull).
     26            *                  In output mode, the speed is configurable: 2 MHz, 25 MHz,
     27            *                  50 MHz or 100 MHz.
     28            *                - Alternate Function: Push-Pull (Pull-up, Pull-down or no Pull)
     29            *                                      Open Drain (Pull-up, Pull-down or no Pull).
     30            *                - Analog: required mode when a pin is to be used as ADC channel
     31            *                          or DAC output.
     32            * 
     33            *          3- Peripherals alternate function:
     34            *              - For ADC and DAC, configure the desired pin in analog mode using 
     35            *                  GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AN;
     36            *              - For other peripherals (TIM, USART...):
     37            *                 - Connect the pin to the desired peripherals' Alternate 
     38            *                   Function (AF) using GPIO_PinAFConfig() function
     39            *                 - Configure the desired pin in alternate function mode using
     40            *                   GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF
     41            *                 - Select the type, pull-up/pull-down and output speed via 
     42            *                   GPIO_PuPd, GPIO_OType and GPIO_Speed members
     43            *                 - Call GPIO_Init() function
     44            *        
     45            *          4. To get the level of a pin configured in input mode use GPIO_ReadInputDataBit()
     46            *          
     47            *          5. To set/reset the level of a pin configured in output mode use
     48            *             GPIO_SetBits()/GPIO_ResetBits()
     49            *               
     50            *          6. During and just after reset, the alternate functions are not 
     51            *             active and the GPIO pins are configured in input floating mode
     52            *             (except JTAG pins).
     53            *
     54            *          7. The LSE oscillator pins OSC32_IN and OSC32_OUT can be used as 
     55            *             general-purpose (PC14 and PC15, respectively) when the LSE
     56            *             oscillator is off. The LSE has priority over the GPIO function.
     57            *
     58            *          8. The HSE oscillator pins OSC_IN/OSC_OUT can be used as 
     59            *             general-purpose PH0 and PH1, respectively, when the HSE 
     60            *             oscillator is off. The HSE has priority over the GPIO function.
     61            *             
     62            *  @endverbatim        
     63            *
     64            ******************************************************************************
     65            * @attention
     66            *
     67            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     68            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     69            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     70            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     71            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     72            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     73            *
     74            * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
     75            ******************************************************************************
     76            */
     77          
     78          /* Includes ------------------------------------------------------------------*/
     79          #include "stm32f2xx_1212.h"
     80          
     81          /** @addtogroup STM32F2xx_StdPeriph_Driver
     82            * @{
     83            */
     84          
     85          /** @defgroup GPIO 
     86            * @brief GPIO driver modules
     87            * @{
     88            */ 
     89          
     90          /* Private typedef -----------------------------------------------------------*/
     91          /* Private define ------------------------------------------------------------*/
     92          /* Private macro -------------------------------------------------------------*/
     93          /* Private variables ---------------------------------------------------------*/
     94          /* Private function prototypes -----------------------------------------------*/
     95          /* Private functions ---------------------------------------------------------*/
     96          
     97          /** @defgroup GPIO_Private_Functions
     98            * @{
     99            */ 
    100          
    101          /** @defgroup GPIO_Group1 Initialization and Configuration
    102           *  @brief   Initialization and Configuration
    103           *
    104          @verbatim   
    105           ===============================================================================
    106                                  Initialization and Configuration
    107           ===============================================================================  
    108          
    109          @endverbatim
    110            * @{
    111            */
    112          
    113          /**
    114            * @brief  Deinitializes the GPIOx peripheral registers to their default reset values.
    115            * @note   By default, The GPIO pins are configured in input floating mode (except JTAG pins).
    116            * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
    117            * @retval None
    118            */

   \                                 In section .text, align 2, keep-with-next
    119          void GPIO_DeInit(GPIO_TypeDef* GPIOx)
    120          {
   \                     GPIO_DeInit:
   \   00000000   0xB580             PUSH     {R7,LR}
    121            /* Check the parameters */
    122            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    123          
    124            if (GPIOx == GPIOA)
   \   00000002   0x....             LDR.N    R1,??DataTable0  ;; 0x40020000
   \   00000004   0x4288             CMP      R0,R1
   \   00000006   0xD106             BNE.N    ??GPIO_DeInit_0
    125            {
    126              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, ENABLE);
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    127              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOA, DISABLE);
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x2001             MOVS     R0,#+1
   \   00000014   0x....             B.N      ?Subroutine0
    128            }
    129            else if (GPIOx == GPIOB)
   \                     ??GPIO_DeInit_0:
   \   00000016   0x....             LDR.N    R1,??DataTable0_1  ;; 0x40020400
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD106             BNE.N    ??GPIO_DeInit_1
    130            {
    131              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, ENABLE);
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x2002             MOVS     R0,#+2
   \   00000020   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    132              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOB, DISABLE);
   \   00000024   0x2100             MOVS     R1,#+0
   \   00000026   0x2002             MOVS     R0,#+2
   \   00000028   0x....             B.N      ?Subroutine0
    133            }
    134            else if (GPIOx == GPIOC)
   \                     ??GPIO_DeInit_1:
   \   0000002A   0x....             LDR.N    R1,??DataTable0_2  ;; 0x40020800
   \   0000002C   0x4288             CMP      R0,R1
   \   0000002E   0xD106             BNE.N    ??GPIO_DeInit_2
    135            {
    136              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, ENABLE);
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0x2004             MOVS     R0,#+4
   \   00000034   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    137              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOC, DISABLE);
   \   00000038   0x2100             MOVS     R1,#+0
   \   0000003A   0x2004             MOVS     R0,#+4
   \   0000003C   0x....             B.N      ?Subroutine0
    138            }
    139            else if (GPIOx == GPIOD)
   \                     ??GPIO_DeInit_2:
   \   0000003E   0x....             LDR.N    R1,??DataTable0_3  ;; 0x40020c00
   \   00000040   0x4288             CMP      R0,R1
   \   00000042   0xD106             BNE.N    ??GPIO_DeInit_3
    140            {
    141              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, ENABLE);
   \   00000044   0x2101             MOVS     R1,#+1
   \   00000046   0x2008             MOVS     R0,#+8
   \   00000048   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    142              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOD, DISABLE);
   \   0000004C   0x2100             MOVS     R1,#+0
   \   0000004E   0x2008             MOVS     R0,#+8
   \   00000050   0x....             B.N      ?Subroutine0
    143            }
    144            else if (GPIOx == GPIOE)
   \                     ??GPIO_DeInit_3:
   \   00000052   0x....             LDR.N    R1,??DataTable0_4  ;; 0x40021000
   \   00000054   0x4288             CMP      R0,R1
   \   00000056   0xD106             BNE.N    ??GPIO_DeInit_4
    145            {
    146              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, ENABLE);
   \   00000058   0x2101             MOVS     R1,#+1
   \   0000005A   0x2010             MOVS     R0,#+16
   \   0000005C   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    147              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOE, DISABLE);
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x2010             MOVS     R0,#+16
   \   00000064   0x....             B.N      ?Subroutine0
    148            }
    149            else if (GPIOx == GPIOF)
   \                     ??GPIO_DeInit_4:
   \   00000066   0x....             LDR.N    R1,??DataTable0_5  ;; 0x40021400
   \   00000068   0x4288             CMP      R0,R1
   \   0000006A   0xD106             BNE.N    ??GPIO_DeInit_5
    150            {
    151              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, ENABLE);
   \   0000006C   0x2101             MOVS     R1,#+1
   \   0000006E   0x2020             MOVS     R0,#+32
   \   00000070   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    152              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOF, DISABLE);
   \   00000074   0x2100             MOVS     R1,#+0
   \   00000076   0x2020             MOVS     R0,#+32
   \   00000078   0x....             B.N      ?Subroutine0
    153            }
    154            else if (GPIOx == GPIOG)
   \                     ??GPIO_DeInit_5:
   \   0000007A   0x....             LDR.N    R1,??DataTable0_6  ;; 0x40021800
   \   0000007C   0x4288             CMP      R0,R1
   \   0000007E   0xD106             BNE.N    ??GPIO_DeInit_6
    155            {
    156              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, ENABLE);
   \   00000080   0x2101             MOVS     R1,#+1
   \   00000082   0x2040             MOVS     R0,#+64
   \   00000084   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    157              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOG, DISABLE);
   \   00000088   0x2100             MOVS     R1,#+0
   \   0000008A   0x2040             MOVS     R0,#+64
   \   0000008C   0x....             B.N      ?Subroutine0
    158            }
    159            else if (GPIOx == GPIOH)
   \                     ??GPIO_DeInit_6:
   \   0000008E   0x....             LDR.N    R1,??DataTable0_7  ;; 0x40021c00
   \   00000090   0x4288             CMP      R0,R1
   \   00000092   0xD106             BNE.N    ??GPIO_DeInit_7
    160            {
    161              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, ENABLE);
   \   00000094   0x2101             MOVS     R1,#+1
   \   00000096   0x2080             MOVS     R0,#+128
   \   00000098   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    162              RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOH, DISABLE);
   \   0000009C   0x2100             MOVS     R1,#+0
   \   0000009E   0x2080             MOVS     R0,#+128
   \   000000A0   0x....             B.N      ?Subroutine0
    163            }
    164            else
    165            {
    166              if (GPIOx == GPIOI)
   \                     ??GPIO_DeInit_7:
   \   000000A2   0x....             LDR.N    R1,??DataTable0_8  ;; 0x40022000
   \   000000A4   0x4288             CMP      R0,R1
   \   000000A6   0xD108             BNE.N    ??GPIO_DeInit_8
    167              {
    168                RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, ENABLE);
   \   000000A8   0x2101             MOVS     R1,#+1
   \   000000AA   0xF44F 0x7080      MOV      R0,#+256
   \   000000AE   0x.... 0x....      BL       RCC_AHB1PeriphResetCmd
    169                RCC_AHB1PeriphResetCmd(RCC_AHB1Periph_GPIOI, DISABLE);
   \   000000B2   0x2100             MOVS     R1,#+0
   \   000000B4   0xF44F 0x7080      MOV      R0,#+256
   \   000000B8   0x....             B.N      ?Subroutine0
    170              }
    171            }
    172          }
   \                     ??GPIO_DeInit_8:
   \   000000BA   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0xE8BD 0x4004      POP      {R2,LR}
   \   00000004   0x.... 0x....      B.W      RCC_AHB1PeriphResetCmd
    173          
    174          /**
    175            * @brief  Initializes the GPIOx peripheral according to the specified parameters in the GPIO_InitStruct.
    176            * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
    177            * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that contains
    178            *         the configuration information for the specified GPIO peripheral.
    179            * @retval None
    180            */

   \                                 In section .text, align 2, keep-with-next
    181          void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
    182          {
   \                     GPIO_Init:
   \   00000000   0xB4F0             PUSH     {R4-R7}
    183            uint32_t pinpos = 0x00, pos = 0x00 , currentpin = 0x00;
   \   00000002   0x2200             MOVS     R2,#+0
    184          
    185            /* Check the parameters */
    186            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    187            assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));
    188            assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
    189            assert_param(IS_GPIO_PUPD(GPIO_InitStruct->GPIO_PuPd));
    190          
    191            /* -------------------------Configure the port pins---------------- */
    192            /*-- GPIO Mode Configuration --*/
    193            for (pinpos = 0x00; pinpos < 0x10; pinpos++)
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x2401             MOVS     R4,#+1
    194            {
    195              pos = ((uint32_t)0x01) << pinpos;
   \                     ??GPIO_Init_0:
   \   00000008   0xFA04 0xF502      LSL      R5,R4,R2
    196              /* Get the port pins position */
    197              currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
    198          
    199              if (currentpin == pos)
   \   0000000C   0x680E             LDR      R6,[R1, #+0]
   \   0000000E   0x402E             ANDS     R6,R5,R6
   \   00000010   0x42AE             CMP      R6,R5
   \   00000012   0xD12F             BNE.N    ??GPIO_Init_1
    200              {
    201                GPIOx->MODER  &= ~(GPIO_MODER_MODER0 << (pinpos * 2));
   \   00000014   0x2603             MOVS     R6,#+3
   \   00000016   0x409E             LSLS     R6,R6,R3
   \   00000018   0x43F6             MVNS     R6,R6
   \   0000001A   0x6807             LDR      R7,[R0, #+0]
   \   0000001C   0x4037             ANDS     R7,R6,R7
   \   0000001E   0x6007             STR      R7,[R0, #+0]
    202                GPIOx->MODER |= (((uint32_t)GPIO_InitStruct->GPIO_Mode) << (pinpos * 2));
   \   00000020   0x6807             LDR      R7,[R0, #+0]
   \   00000022   0xF891 0xC004      LDRB     R12,[R1, #+4]
   \   00000026   0xFA0C 0xFC03      LSL      R12,R12,R3
   \   0000002A   0xEA4C 0x0707      ORR      R7,R12,R7
   \   0000002E   0x6007             STR      R7,[R0, #+0]
    203          
    204                if ((GPIO_InitStruct->GPIO_Mode == GPIO_Mode_OUT) || (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_AF))
   \   00000030   0x790F             LDRB     R7,[R1, #+4]
   \   00000032   0x2F01             CMP      R7,#+1
   \   00000034   0xBF18             IT       NE 
   \   00000036   0x2F02             CMPNE    R7,#+2
   \   00000038   0xD114             BNE.N    ??GPIO_Init_2
    205                {
    206                  /* Check Speed mode parameters */
    207                  assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    208          
    209                  /* Speed mode configuration */
    210                  GPIOx->OSPEEDR &= ~(GPIO_OSPEEDER_OSPEEDR0 << (pinpos * 2));
   \   0000003A   0x6887             LDR      R7,[R0, #+8]
   \   0000003C   0x4037             ANDS     R7,R6,R7
   \   0000003E   0x6087             STR      R7,[R0, #+8]
    211                  GPIOx->OSPEEDR |= ((uint32_t)(GPIO_InitStruct->GPIO_Speed) << (pinpos * 2));
   \   00000040   0x6887             LDR      R7,[R0, #+8]
   \   00000042   0xF891 0xC005      LDRB     R12,[R1, #+5]
   \   00000046   0xFA0C 0xFC03      LSL      R12,R12,R3
   \   0000004A   0xEA4C 0x0707      ORR      R7,R12,R7
   \   0000004E   0x6087             STR      R7,[R0, #+8]
    212          
    213                  /* Check Output mode parameters */
    214                  assert_param(IS_GPIO_OTYPE(GPIO_InitStruct->GPIO_OType));
    215          
    216                  /* Output mode configuration*/
    217                  GPIOx->OTYPER  &= ~((GPIO_OTYPER_OT_0) << ((uint16_t)pinpos)) ;
   \   00000050   0x6847             LDR      R7,[R0, #+4]
   \   00000052   0xEA27 0x0505      BIC      R5,R7,R5
   \   00000056   0x6045             STR      R5,[R0, #+4]
    218                  GPIOx->OTYPER |= (uint16_t)(((uint16_t)GPIO_InitStruct->GPIO_OType) << ((uint16_t)pinpos));
   \   00000058   0x6845             LDR      R5,[R0, #+4]
   \   0000005A   0x798F             LDRB     R7,[R1, #+6]
   \   0000005C   0x4097             LSLS     R7,R7,R2
   \   0000005E   0xB2BF             UXTH     R7,R7
   \   00000060   0x433D             ORRS     R5,R7,R5
   \   00000062   0x6045             STR      R5,[R0, #+4]
    219                }
    220          
    221                /* Pull-up Pull down resistor configuration*/
    222                GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPDR0 << ((uint16_t)pinpos * 2));
   \                     ??GPIO_Init_2:
   \   00000064   0x68C5             LDR      R5,[R0, #+12]
   \   00000066   0x4035             ANDS     R5,R6,R5
   \   00000068   0x60C5             STR      R5,[R0, #+12]
    223                GPIOx->PUPDR |= (((uint32_t)GPIO_InitStruct->GPIO_PuPd) << (pinpos * 2));
   \   0000006A   0x68C5             LDR      R5,[R0, #+12]
   \   0000006C   0x79CE             LDRB     R6,[R1, #+7]
   \   0000006E   0x409E             LSLS     R6,R6,R3
   \   00000070   0x4335             ORRS     R5,R6,R5
   \   00000072   0x60C5             STR      R5,[R0, #+12]
    224              }
    225            }
   \                     ??GPIO_Init_1:
   \   00000074   0x1C52             ADDS     R2,R2,#+1
   \   00000076   0x1C9B             ADDS     R3,R3,#+2
   \   00000078   0x2A10             CMP      R2,#+16
   \   0000007A   0xD3C5             BCC.N    ??GPIO_Init_0
    226          }
   \   0000007C   0xBCF0             POP      {R4-R7}
   \   0000007E   0x4770             BX       LR               ;; return
    227          
    228          /**
    229            * @brief  Fills each GPIO_InitStruct member with its default value.
    230            * @param  GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure which will be initialized.
    231            * @retval None
    232            */

   \                                 In section .text, align 2, keep-with-next
    233          void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
    234          {
    235            /* Reset GPIO init structure parameters values */
    236          	GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
   \                     GPIO_StructInit:
   \   00000000   0xF64F 0x71FF      MOVW     R1,#+65535
   \   00000004   0x6001             STR      R1,[R0, #+0]
    237          	GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN;
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x7101             STRB     R1,[R0, #+4]
    238          	GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
   \   0000000A   0x7141             STRB     R1,[R0, #+5]
    239          	GPIO_InitStruct->GPIO_OType = GPIO_OType_PP;
   \   0000000C   0x7181             STRB     R1,[R0, #+6]
    240          	GPIO_InitStruct->GPIO_PuPd = GPIO_PuPd_NOPULL;
   \   0000000E   0x71C1             STRB     R1,[R0, #+7]
    241          }
   \   00000010   0x4770             BX       LR               ;; return
    242          
    243          /**
    244            * @brief  Locks GPIO Pins configuration registers.
    245            * @note   The locked registers are GPIOx_MODER, GPIOx_OTYPER, GPIOx_OSPEEDR,
    246            *         GPIOx_PUPDR, GPIOx_AFRL and GPIOx_AFRH.
    247            * @note   The configuration of the locked GPIO pins can no longer be modified
    248            *         until the next reset.
    249            * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
    250            * @param  GPIO_Pin: specifies the port bit to be locked.
    251            *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    252            * @retval None
    253            */

   \                                 In section .text, align 2, keep-with-next
    254          void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    255          {
   \                     GPIO_PinLockConfig:
   \   00000000   0xB081             SUB      SP,SP,#+4
    256          	__IO uint32_t tmp = 0x00010000;
   \   00000002   0xF44F 0x3280      MOV      R2,#+65536
   \   00000006   0x9200             STR      R2,[SP, #+0]
    257          
    258          	/* Check the parameters */
    259          	assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    260          	assert_param(IS_GPIO_PIN(GPIO_Pin));
    261          
    262          	tmp |= GPIO_Pin;
   \   00000008   0x9A00             LDR      R2,[SP, #+0]
   \   0000000A   0x430A             ORRS     R2,R1,R2
   \   0000000C   0x9200             STR      R2,[SP, #+0]
    263          	/* Set LCKK bit */
    264          	GPIOx->LCKR = tmp;
   \   0000000E   0x9A00             LDR      R2,[SP, #+0]
   \   00000010   0x61C2             STR      R2,[R0, #+28]
    265          	/* Reset LCKK bit */
    266          	GPIOx->LCKR =  GPIO_Pin;
   \   00000012   0x61C1             STR      R1,[R0, #+28]
    267          	/* Set LCKK bit */
    268          	GPIOx->LCKR = tmp;
   \   00000014   0x9900             LDR      R1,[SP, #+0]
   \   00000016   0x61C1             STR      R1,[R0, #+28]
    269          	/* Read LCKK bit*/
    270          	tmp = GPIOx->LCKR;
   \   00000018   0x69C1             LDR      R1,[R0, #+28]
   \   0000001A   0x9100             STR      R1,[SP, #+0]
    271          	/* Read LCKK bit*/
    272          	tmp = GPIOx->LCKR;
   \   0000001C   0x69C0             LDR      R0,[R0, #+28]
   \   0000001E   0x9000             STR      R0,[SP, #+0]
    273          }
   \   00000020   0xB001             ADD      SP,SP,#+4
   \   00000022   0x4770             BX       LR               ;; return
    274          
    275          /**
    276            * @}
    277            */
    278          
    279          /** @defgroup GPIO_Group2 GPIO Read and Write
    280           *  @brief   GPIO Read and Write
    281           *
    282          @verbatim   
    283           ===============================================================================
    284                                        GPIO Read and Write
    285           ===============================================================================  
    286          
    287          @endverbatim
    288            * @{
    289            */
    290          
    291          /**
    292            * @brief  Reads the specified input port pin.
    293            * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
    294            * @param  GPIO_Pin: specifies the port bit to read.
    295            *         This parameter can be GPIO_Pin_x where x can be (0..15).
    296            * @retval The input port pin value.
    297            */

   \                                 In section .text, align 2, keep-with-next
    298          uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    299          {
    300            uint8_t bitstatus = 0x00;
   \                     GPIO_ReadInputDataBit:
   \   00000000   0x2200             MOVS     R2,#+0
    301          
    302            /* Check the parameters */
    303            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    304            assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
    305          
    306            if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
   \   00000002   0x6900             LDR      R0,[R0, #+16]
   \   00000004   0xB280             UXTH     R0,R0
   \   00000006   0x4208             TST      R0,R1
   \   00000008   0xBF18             IT       NE 
   \   0000000A   0x2201             MOVNE    R2,#+1
    307            {
    308              bitstatus = (uint8_t)Bit_SET;
    309            }
    310            else
    311            {
    312              bitstatus = (uint8_t)Bit_RESET;
    313            }
    314            return bitstatus;
   \   0000000C   0x4610             MOV      R0,R2
   \   0000000E   0x4770             BX       LR               ;; return
    315          }
    316          
    317          /**
    318            * @brief  Reads the specified GPIO input data port.
    319            * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
    320            * @retval GPIO input data port value.
    321            */

   \                                 In section .text, align 2, keep-with-next
    322          uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
    323          {
    324            /* Check the parameters */
    325            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    326          
    327            return ((uint16_t)GPIOx->IDR);
   \                     GPIO_ReadInputData:
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0xB280             UXTH     R0,R0
   \   00000004   0x4770             BX       LR               ;; return
    328          }
    329          
    330          /**
    331            * @brief  Reads the specified output data port bit.
    332            * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
    333            * @param  GPIO_Pin: specifies the port bit to read.
    334            *          This parameter can be GPIO_Pin_x where x can be (0..15).
    335            * @retval The output port pin value.
    336            */

   \                                 In section .text, align 2, keep-with-next
    337          uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    338          {
    339            uint8_t bitstatus = 0x00;
   \                     GPIO_ReadOutputDataBit:
   \   00000000   0x2200             MOVS     R2,#+0
    340          
    341            /* Check the parameters */
    342            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    343            assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
    344          
    345            if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
   \   00000002   0x6940             LDR      R0,[R0, #+20]
   \   00000004   0xB280             UXTH     R0,R0
   \   00000006   0x4208             TST      R0,R1
   \   00000008   0xBF18             IT       NE 
   \   0000000A   0x2201             MOVNE    R2,#+1
    346            {
    347              bitstatus = (uint8_t)Bit_SET;
    348            }
    349            else
    350            {
    351              bitstatus = (uint8_t)Bit_RESET;
    352            }
    353            return bitstatus;
   \   0000000C   0x4610             MOV      R0,R2
   \   0000000E   0x4770             BX       LR               ;; return
    354          }
    355          
    356          /**
    357            * @brief  Reads the specified GPIO output data port.
    358            * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
    359            * @retval GPIO output data port value.
    360            */

   \                                 In section .text, align 2, keep-with-next
    361          uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
    362          {
    363            /* Check the parameters */
    364            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    365          
    366            return ((uint16_t)GPIOx->ODR);
   \                     GPIO_ReadOutputData:
   \   00000000   0x6940             LDR      R0,[R0, #+20]
   \   00000002   0xB280             UXTH     R0,R0
   \   00000004   0x4770             BX       LR               ;; return
    367          }
    368          
    369          /**
    370            * @brief  Sets the selected data port bits.
    371            * @note   This functions uses GPIOx_BSRR register to allow atomic read/modify 
    372            *         accesses. In this way, there is no risk of an IRQ occurring between
    373            *         the read and the modify access.
    374            * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
    375            * @param  GPIO_Pin: specifies the port bits to be written.
    376            *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    377            * @retval None
    378            */

   \                                 In section .text, align 2, keep-with-next
    379          void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    380          {
    381            /* Check the parameters */
    382            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    383            assert_param(IS_GPIO_PIN(GPIO_Pin));
    384          
    385            GPIOx->BSRRL = GPIO_Pin;
   \                     GPIO_SetBits:
   \   00000000   0x8301             STRH     R1,[R0, #+24]
    386          }
   \   00000002   0x4770             BX       LR               ;; return
    387          
    388          /**
    389            * @brief  Clears the selected data port bits.
    390            * @note   This functions uses GPIOx_BSRR register to allow atomic read/modify 
    391            *         accesses. In this way, there is no risk of an IRQ occurring between
    392            *         the read and the modify access.
    393            * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
    394            * @param  GPIO_Pin: specifies the port bits to be written.
    395            *          This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    396            * @retval None
    397            */

   \                                 In section .text, align 2, keep-with-next
    398          void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    399          {
    400            /* Check the parameters */
    401            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    402            assert_param(IS_GPIO_PIN(GPIO_Pin));
    403          
    404            GPIOx->BSRRH = GPIO_Pin;
   \                     GPIO_ResetBits:
   \   00000000   0x8341             STRH     R1,[R0, #+26]
    405          }
   \   00000002   0x4770             BX       LR               ;; return
    406          
    407          /**
    408            * @brief  Sets or clears the selected data port bit.
    409            * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
    410            * @param  GPIO_Pin: specifies the port bit to be written.
    411            *          This parameter can be one of GPIO_Pin_x where x can be (0..15).
    412            * @param  BitVal: specifies the value to be written to the selected bit.
    413            *          This parameter can be one of the BitAction enum values:
    414            *            @arg Bit_RESET: to clear the port pin
    415            *            @arg Bit_SET: to set the port pin
    416            * @retval None
    417            */

   \                                 In section .text, align 2, keep-with-next
    418          void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
    419          {
    420            /* Check the parameters */
    421            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    422            assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
    423            assert_param(IS_GPIO_BIT_ACTION(BitVal));
    424          
    425            if (BitVal != Bit_RESET)
   \                     GPIO_WriteBit:
   \   00000000   0xB10A             CBZ.N    R2,??GPIO_WriteBit_0
    426            {
    427              GPIOx->BSRRL = GPIO_Pin;
   \   00000002   0x8301             STRH     R1,[R0, #+24]
   \   00000004   0x4770             BX       LR
    428            }
    429            else
    430            {
    431              GPIOx->BSRRH = GPIO_Pin ;
   \                     ??GPIO_WriteBit_0:
   \   00000006   0x8341             STRH     R1,[R0, #+26]
    432            }
    433          }
   \   00000008   0x4770             BX       LR               ;; return
    434          
    435          /**
    436            * @brief  Writes data to the specified GPIO data port.
    437            * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
    438            * @param  PortVal: specifies the value to be written to the port output data register.
    439            * @retval None
    440            */

   \                                 In section .text, align 2, keep-with-next
    441          void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
    442          {
    443            /* Check the parameters */
    444            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    445          
    446            GPIOx->ODR = PortVal;
   \                     GPIO_Write:
   \   00000000   0x6141             STR      R1,[R0, #+20]
    447          }
   \   00000002   0x4770             BX       LR               ;; return
    448          
    449          /**
    450            * @brief  Toggles the specified GPIO pins..
    451            * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
    452            * @param  GPIO_Pin: Specifies the pins to be toggled.
    453            * @retval None
    454            */

   \                                 In section .text, align 2, keep-with-next
    455          void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    456          {
    457            /* Check the parameters */
    458            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    459          
    460            GPIOx->ODR ^= GPIO_Pin;
   \                     GPIO_ToggleBits:
   \   00000000   0x6942             LDR      R2,[R0, #+20]
   \   00000002   0x4051             EORS     R1,R1,R2
   \   00000004   0x6141             STR      R1,[R0, #+20]
    461          }
   \   00000006   0x4770             BX       LR               ;; return
    462          
    463          /**
    464            * @}
    465            */
    466          
    467          /** @defgroup GPIO_Group3 GPIO Alternate functions configuration function
    468           *  @brief   GPIO Alternate functions configuration function
    469           *
    470          @verbatim   
    471           ===============================================================================
    472                         GPIO Alternate functions configuration function
    473           ===============================================================================  
    474          
    475          @endverbatim
    476            * @{
    477            */
    478          
    479          /**
    480            * @brief  Changes the mapping of the specified pin.
    481            * @param  GPIOx: where x can be (A..I) to select the GPIO peripheral.
    482            * @param  GPIO_PinSource: specifies the pin for the Alternate function.
    483            *         This parameter can be GPIO_PinSourcex where x can be (0..15).
    484            * @param  GPIO_AFSelection: selects the pin to used as Alternate function.
    485            *          This parameter can be one of the following values:
    486            *            @arg GPIO_AF_RTC_50Hz: Connect RTC_50Hz pin to AF0 (default after reset) 
    487            *            @arg GPIO_AF_MCO: Connect MCO pin (MCO1 and MCO2) to AF0 (default after reset) 
    488            *            @arg GPIO_AF_TAMPER: Connect TAMPER pins (TAMPER_1 and TAMPER_2) to AF0 (default after reset) 
    489            *            @arg GPIO_AF_SWJ: Connect SWJ pins (SWD and JTAG)to AF0 (default after reset) 
    490            *            @arg GPIO_AF_TRACE: Connect TRACE pins to AF0 (default after reset)
    491            *            @arg GPIO_AF_TIM1: Connect TIM1 pins to AF1
    492            *            @arg GPIO_AF_TIM2: Connect TIM2 pins to AF1
    493            *            @arg GPIO_AF_TIM3: Connect TIM3 pins to AF2
    494            *            @arg GPIO_AF_TIM4: Connect TIM4 pins to AF2
    495            *            @arg GPIO_AF_TIM5: Connect TIM5 pins to AF2
    496            *            @arg GPIO_AF_TIM8: Connect TIM8 pins to AF3
    497            *            @arg GPIO_AF_TIM9: Connect TIM9 pins to AF3
    498            *            @arg GPIO_AF_TIM10: Connect TIM10 pins to AF3
    499            *            @arg GPIO_AF_TIM11: Connect TIM11 pins to AF3
    500            *            @arg GPIO_AF_I2C1: Connect I2C1 pins to AF4
    501            *            @arg GPIO_AF_I2C2: Connect I2C2 pins to AF4
    502            *            @arg GPIO_AF_I2C3: Connect I2C3 pins to AF4
    503            *            @arg GPIO_AF_SPI1: Connect SPI1 pins to AF5
    504            *            @arg GPIO_AF_SPI2: Connect SPI2/I2S2 pins to AF5
    505            *            @arg GPIO_AF_SPI3: Connect SPI3/I2S3 pins to AF6
    506            *            @arg GPIO_AF_USART1: Connect USART1 pins to AF7
    507            *            @arg GPIO_AF_USART2: Connect USART2 pins to AF7
    508            *            @arg GPIO_AF_USART3: Connect USART3 pins to AF7
    509            *            @arg GPIO_AF_UART4: Connect UART4 pins to AF8
    510            *            @arg GPIO_AF_UART5: Connect UART5 pins to AF8
    511            *            @arg GPIO_AF_USART6: Connect USART6 pins to AF8
    512            *            @arg GPIO_AF_CAN1: Connect CAN1 pins to AF9
    513            *            @arg GPIO_AF_CAN2: Connect CAN2 pins to AF9
    514            *            @arg GPIO_AF_TIM12: Connect TIM12 pins to AF9
    515            *            @arg GPIO_AF_TIM13: Connect TIM13 pins to AF9
    516            *            @arg GPIO_AF_TIM14: Connect TIM14 pins to AF9
    517            *            @arg GPIO_AF_OTG_FS: Connect OTG_FS pins to AF10
    518            *            @arg GPIO_AF_OTG_HS: Connect OTG_HS pins to AF10
    519            *            @arg GPIO_AF_ETH: Connect ETHERNET pins to AF11
    520            *            @arg GPIO_AF_FSMC: Connect FSMC pins to AF12
    521            *            @arg GPIO_AF_OTG_HS_FS: Connect OTG HS (configured in FS) pins to AF12
    522            *            @arg GPIO_AF_SDIO: Connect SDIO pins to AF12
    523            *            @arg GPIO_AF_DCMI: Connect DCMI pins to AF13
    524            *            @arg GPIO_AF_EVENTOUT: Connect EVENTOUT pins to AF15
    525            * @retval None
    526            */

   \                                 In section .text, align 2, keep-with-next
    527          void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF)
    528          {
   \                     GPIO_PinAFConfig:
   \   00000000   0x10CB             ASRS     R3,R1,#+3
   \   00000002   0xEB00 0x0083      ADD      R0,R0,R3, LSL #+2
   \   00000006   0xF001 0x0107      AND      R1,R1,#0x7
   \   0000000A   0x0089             LSLS     R1,R1,#+2
   \   0000000C   0x6A03             LDR      R3,[R0, #+32]
   \   0000000E   0xF04F 0x0C0F      MOV      R12,#+15
   \   00000012   0xFA0C 0xFC01      LSL      R12,R12,R1
   \   00000016   0xEA23 0x030C      BIC      R3,R3,R12
   \   0000001A   0x6203             STR      R3,[R0, #+32]
    529            uint32_t temp = 0x00;
    530            uint32_t temp_2 = 0x00;
    531            
    532            /* Check the parameters */
    533            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    534            assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    535            assert_param(IS_GPIO_AF(GPIO_AF));
    536            
    537            temp = ((uint32_t)(GPIO_AF) << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
    538            GPIOx->AFR[GPIO_PinSource >> 0x03] &= ~((uint32_t)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;
    539            temp_2 = GPIOx->AFR[GPIO_PinSource >> 0x03] | temp;
   \   0000001C   0x6A03             LDR      R3,[R0, #+32]
    540            GPIOx->AFR[GPIO_PinSource >> 0x03] = temp_2;
   \   0000001E   0xFA02 0xF101      LSL      R1,R2,R1
   \   00000022   0x4319             ORRS     R1,R1,R3
   \   00000024   0x6201             STR      R1,[R0, #+32]
    541          }
   \   00000026   0x4770             BX       LR               ;; return
    542          
    543          

   \                                 In section .text, align 2, keep-with-next
    544          void GPIOPortInit(uint16_t Reg, uint8_t GPIO_AF, GPIO_TypeDef* GPIOx, uint16_t Pin_Src)
    545          {
   \                     GPIOPortInit:
   \   00000000   0xB4F0             PUSH     {R4-R7}
   \   00000002   0x4614             MOV      R4,R2
    546          	union uReg {
    547          		u16 Data;
    548          		struct {
    549          			u16 MODER		:2;
    550          			u16 OTYPER		:2;
    551          			u16 OSPEEDR		:2;
    552          			u16 PUPDR		:2;
    553          		};
    554          	} tmp;
    555          
    556          	tmp.Data = Reg;
    557          
    558          	GPIOx->MODER   &= ~(0x03 << Pin_Src*2);
   \   00000004   0x005A             LSLS     R2,R3,#+1
   \   00000006   0x2503             MOVS     R5,#+3
   \   00000008   0x4095             LSLS     R5,R5,R2
   \   0000000A   0x43ED             MVNS     R5,R5
   \   0000000C   0x6826             LDR      R6,[R4, #+0]
   \   0000000E   0x402E             ANDS     R6,R5,R6
   \   00000010   0x6026             STR      R6,[R4, #+0]
    559          	GPIOx->MODER   |=  (tmp.MODER << (Pin_Src*2));
   \   00000012   0x6826             LDR      R6,[R4, #+0]
   \   00000014   0xF000 0x0703      AND      R7,R0,#0x3
   \   00000018   0x4097             LSLS     R7,R7,R2
   \   0000001A   0x433E             ORRS     R6,R7,R6
   \   0000001C   0x6026             STR      R6,[R4, #+0]
    560          
    561          	GPIOx->OTYPER  &= ~(0x01 << Pin_Src);
   \   0000001E   0x6866             LDR      R6,[R4, #+4]
   \   00000020   0x2701             MOVS     R7,#+1
   \   00000022   0x409F             LSLS     R7,R7,R3
   \   00000024   0x43BE             BICS     R6,R6,R7
   \   00000026   0x6066             STR      R6,[R4, #+4]
    562          	GPIOx->OTYPER  |=  (tmp.OTYPER << Pin_Src);
   \   00000028   0x6866             LDR      R6,[R4, #+4]
   \   0000002A   0xF3C0 0x0781      UBFX     R7,R0,#+2,#+2
   \   0000002E   0x409F             LSLS     R7,R7,R3
   \   00000030   0x433E             ORRS     R6,R7,R6
   \   00000032   0x6066             STR      R6,[R4, #+4]
    563          
    564          	GPIOx->OSPEEDR &= ~(0x03 << Pin_Src*2);
   \   00000034   0x68A6             LDR      R6,[R4, #+8]
   \   00000036   0x402E             ANDS     R6,R5,R6
   \   00000038   0x60A6             STR      R6,[R4, #+8]
    565          	GPIOx->OSPEEDR |=  (tmp.OSPEEDR << (Pin_Src*2));
   \   0000003A   0x68A6             LDR      R6,[R4, #+8]
   \   0000003C   0xF3C0 0x1701      UBFX     R7,R0,#+4,#+2
   \   00000040   0x4097             LSLS     R7,R7,R2
   \   00000042   0x433E             ORRS     R6,R7,R6
   \   00000044   0x60A6             STR      R6,[R4, #+8]
    566          
    567          	GPIOx->PUPDR   &= ~(0x03 << Pin_Src*2);
   \   00000046   0x68E6             LDR      R6,[R4, #+12]
   \   00000048   0x4035             ANDS     R5,R5,R6
   \   0000004A   0x60E5             STR      R5,[R4, #+12]
    568          	GPIOx->PUPDR   |=  (tmp.PUPDR << (Pin_Src*2));
   \   0000004C   0x68E5             LDR      R5,[R4, #+12]
   \   0000004E   0xF3C0 0x1081      UBFX     R0,R0,#+6,#+2
   \   00000052   0x4090             LSLS     R0,R0,R2
   \   00000054   0x4328             ORRS     R0,R0,R5
   \   00000056   0x60E0             STR      R0,[R4, #+12]
    569          
    570          	GPIO_PinAFConfig(GPIOx, Pin_Src, GPIO_AF);
   \   00000058   0x460A             MOV      R2,R1
   \   0000005A   0x4619             MOV      R1,R3
   \   0000005C   0x4620             MOV      R0,R4
   \   0000005E   0xBCF0             POP      {R4-R7}
   \   00000060   0x....             B.N      GPIO_PinAFConfig
    571          	
    572          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x40020000         DC32     0x40020000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x40020400         DC32     0x40020400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \   00000000   0x40020800         DC32     0x40020800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_3:
   \   00000000   0x40020C00         DC32     0x40020c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_4:
   \   00000000   0x40021000         DC32     0x40021000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_5:
   \   00000000   0x40021400         DC32     0x40021400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_6:
   \   00000000   0x40021800         DC32     0x40021800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_7:
   \   00000000   0x40021C00         DC32     0x40021c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_8:
   \   00000000   0x40022000         DC32     0x40022000
    573          
    574          
    575          
    576          
    577          /**
    578            * @}
    579            */ 
    580          
    581          /**
    582            * @}
    583            */
    584          
    585          /**
    586            * @}
    587            */ 
    588          
    589          /**
    590            * @}
    591            */ 
    592          
    593          /******************* (C) COPYRIGHT 2011 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  GPIOPortInit
             0 -> GPIO_PinAFConfig
        8  GPIO_DeInit
             0 -> RCC_AHB1PeriphResetCmd
             8 -> RCC_AHB1PeriphResetCmd
       16  GPIO_Init
        0  GPIO_PinAFConfig
        4  GPIO_PinLockConfig
        0  GPIO_ReadInputData
        0  GPIO_ReadInputDataBit
        0  GPIO_ReadOutputData
        0  GPIO_ReadOutputDataBit
        0  GPIO_ResetBits
        0  GPIO_SetBits
        0  GPIO_StructInit
        0  GPIO_ToggleBits
        0  GPIO_Write
        0  GPIO_WriteBit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
       4  ??DataTable0_3
       4  ??DataTable0_4
       4  ??DataTable0_5
       4  ??DataTable0_6
       4  ??DataTable0_7
       4  ??DataTable0_8
       8  ?Subroutine0
      98  GPIOPortInit
     188  GPIO_DeInit
     128  GPIO_Init
      40  GPIO_PinAFConfig
      36  GPIO_PinLockConfig
       6  GPIO_ReadInputData
      16  GPIO_ReadInputDataBit
       6  GPIO_ReadOutputData
      16  GPIO_ReadOutputDataBit
       4  GPIO_ResetBits
       4  GPIO_SetBits
      18  GPIO_StructInit
       8  GPIO_ToggleBits
       4  GPIO_Write
      10  GPIO_WriteBit

 
 626 bytes in section .text
 
 626 bytes of CODE memory

Errors: none
Warnings: none

###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     03/Sep/2014  15:31:55 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\src\stm32f2xx_nvic_1208.c #
#    Command line =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\src\stm32f2xx_nvic_1208.c #
#                     -D NDEBUG -lC D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm #
#                    207_20140821\STM32F2xx_StdPeriph_Driver_v1212\ewarm\sout #
#                    \ -o D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_201408 #
#                    21\STM32F2xx_StdPeriph_Driver_v1212\ewarm\sout\          #
#                    --endian=little --cpu=Cortex-M3 -e --fpu=None            #
#                    --dlib_config "C:\Program Files\IAR Systems\Embedded     #
#                    Workbench 6.0\arm\INC\c\DLib_Config_Normal.h" -I         #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\..\ -I              #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\..\inc\ -I          #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\..\..\uC-CPU\ -I    #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\..\..\uC-LIB\ -I    #
#                    D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\..\..\uCOS-II\Ports #
#                    \ -I D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_201408 #
#                    21\STM32F2xx_StdPeriph_Driver_v1212\ewarm\..\..\uCOS-II\ #
#                    Source\ -Oh                                              #
#    List file    =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\sout\stm32f2xx_nvic #
#                    _1208.lst                                                #
#    Object file  =  D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\ST #
#                    M32F2xx_StdPeriph_Driver_v1212\ewarm\sout\stm32f2xx_nvic #
#                    _1208.o                                                  #
#                                                                             #
#                                                                             #
###############################################################################

D:\Project\TRIO_MD\3.F_W\TRIO_MD_appl_stm207_20140821\STM32F2xx_StdPeriph_Driver_v1212\src\stm32f2xx_nvic_1208.c
      1          /******************** (C) COPYRIGHT 2007 STMicroelectronics ********************
      2          * File Name          : stm32f10x_nvic.c
      3          * Author             : MCD Application Team
      4          * Date First Issued  : 09/29/2006
      5          * Description        : This file provides all the NVIC firmware functions.
      6          ********************************************************************************
      7          * History:
      8          * 05/21/2007: V0.3
      9          * 04/02/2007: V0.2
     10          * 02/05/2007: V0.1
     11          * 09/29/2006: V0.01
     12          ********************************************************************************
     13          * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     14          * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
     15          * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
     16          * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
     17          * CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
     18          * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     19          *******************************************************************************/
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "stm32f2xx_1212.h"
     23          
     24          /* Private typedef -----------------------------------------------------------*/
     25          /* Private define ------------------------------------------------------------*/
     26          /* Private macro -------------------------------------------------------------*/
     27          /* Private variables ---------------------------------------------------------*/
     28          /* Private function prototypes -----------------------------------------------*/
     29          /* Private functions ---------------------------------------------------------*/
     30          
     31          /*******************************************************************************
     32          * Function Name  : NVIC_DeInit
     33          * Description    : Deinitializes the NVIC peripheral registers to their default
     34          *                  reset values.
     35          * Input          : None
     36          * Output         : None
     37          * Return         : None
     38          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     39          void NVIC_DeInit(void)
     40          {
     41          	u32 index = 0;
     42          
     43          	for(index = 0; index < 15; index++)
   \                     NVIC_DeInit:
   \   00000000   0x....             LDR.N    R0,??DataTable19  ;; 0xe000e180
   \   00000002   0x....             LDR.N    R1,??DataTable19_1  ;; 0xe000e280
   \   00000004   0x2203             MOVS     R2,#+3
   \   00000006   0xF64F 0x73FF      MOVW     R3,#+65535
     44          	{
     45          		NVIC->__B.ICER[index] = 0xFFFF;
   \                     ??NVIC_DeInit_0:
   \   0000000A   0xF820 0x3B02      STRH     R3,[R0], #+2
     46          		NVIC->__B.ICPR[index] = 0xFFFF;
   \   0000000E   0xF841 0x3B04      STR      R3,[R1], #+4
   \   00000012   0xF820 0x3B02      STRH     R3,[R0], #+2
   \   00000016   0xF841 0x3B04      STR      R3,[R1], #+4
   \   0000001A   0xF820 0x3B02      STRH     R3,[R0], #+2
   \   0000001E   0xF841 0x3B04      STR      R3,[R1], #+4
   \   00000022   0xF820 0x3B02      STRH     R3,[R0], #+2
   \   00000026   0xF841 0x3B04      STR      R3,[R1], #+4
   \   0000002A   0xF820 0x3B02      STRH     R3,[R0], #+2
   \   0000002E   0xF841 0x3B04      STR      R3,[R1], #+4
     47          	}
   \   00000032   0x1E52             SUBS     R2,R2,#+1
   \   00000034   0xD1E9             BNE.N    ??NVIC_DeInit_0
     48          
     49          	for(index = 0; index < 240; index++)
     50          	{
     51          	 	NVIC->IP[index] = 0x00000000;
   \   00000036   0x21F0             MOVS     R1,#+240
   \   00000038   0x....             LDR.N    R0,??DataTable19_2  ;; 0xe000e400
   \   0000003A   0x.... 0x....      B.W      __aeabi_memclr4
     52          	} 
     53          }
     54          
     55          /*******************************************************************************
     56          * Function Name  : NVIC_SCBDeInit
     57          * Description    : Deinitializes the SCB peripheral registers to their default 
     58          *                  reset values.
     59          * Input          : None
     60          * Output         : None
     61          * Return         : None
     62          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     63          void NVIC_SCBDeInit(void)
     64          {
   \                     NVIC_SCBDeInit:
   \   00000000   0xB510             PUSH     {R4,LR}
     65          	u32 index = 0x00;
     66          
     67          	SCB->ICSR = 0x0A000000;
   \   00000002   0x....             LDR.N    R0,??DataTable19_3  ;; 0xe000ed04
   \   00000004   0xF04F 0x6120      MOV      R1,#+167772160
   \   00000008   0x6001             STR      R1,[R0, #+0]
     68          	SCB->VTOR = 0x00000000;
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x6041             STR      R1,[R0, #+4]
     69          	SCB->AIRCR = AIRC_VECTKEY_MASK;
   \   0000000E   0x....             LDR.N    R1,??DataTable19_4  ;; 0x5fa0000
   \   00000010   0x6081             STR      R1,[R0, #+8]
     70          	SCB->SCR = 0x00000000;
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x60C1             STR      R1,[R0, #+12]
     71          	SCB->CCR = 0x00000000;
   \   00000016   0x6101             STR      R1,[R0, #+16]
     72          	for(index = 0; index < 24; index++)
     73          	{
     74          	 	SCB->SHP[index] = 0;
   \   00000018   0x....             LDR.N    R4,??DataTable19_5  ;; 0xe000ed18
   \   0000001A   0x2118             MOVS     R1,#+24
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       __aeabi_memclr4
     75          	}
     76          	SCB->SHCSR = 0x00000000;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x60E0             STR      R0,[R4, #+12]
     77          	SCB->CFSR = 0xFFFFFFFF;
   \   00000026   0xF04F 0x30FF      MOV      R0,#-1
   \   0000002A   0x6120             STR      R0,[R4, #+16]
     78          	SCB->HFSR = 0xFFFFFFFF;
   \   0000002C   0x6160             STR      R0,[R4, #+20]
     79            	SCB->DFSR = 0xFFFFFFFF;
   \   0000002E   0x61A0             STR      R0,[R4, #+24]
     80          }
   \   00000030   0xBD10             POP      {R4,PC}          ;; return
     81          
     82          /*******************************************************************************
     83          * @brief  Configures the priority grouping: pre-emption priority and subpriority.
     84          * @param  NVIC_PriorityGroup: specifies the priority grouping bits length. 
     85          *	This parameter can be one of the following values:
     86          *	  @arg NVIC_PriorityGroup_0: 0 bits for pre-emption priority
     87          *								 4 bits for subpriority
     88          *	  @arg NVIC_PriorityGroup_1: 1 bits for pre-emption priority
     89          *								 3 bits for subpriority
     90          *	  @arg NVIC_PriorityGroup_2: 2 bits for pre-emption priority
     91          *								 2 bits for subpriority
     92          *	  @arg NVIC_PriorityGroup_3: 3 bits for pre-emption priority
     93          *								 1 bits for subpriority
     94          *	  @arg NVIC_PriorityGroup_4: 4 bits for pre-emption priority
     95          *								 0 bits for subpriority
     96          * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible. 
     97          *		  The pending IRQ priority will be managed only by the subpriority. 
     98          * @retval None
     99          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    100          void NVIC_PriorityGroupConfig(u32 NVIC_PriorityGroup)
    101          {
    102          	/* Check the parameters */
    103          	assert(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup));
    104          
    105          	/* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */
    106          	SCB->AIRCR = AIRC_VECTKEY_MASK | NVIC_PriorityGroup;
   \                     NVIC_PriorityGroupConfig:
   \   00000000   0x....             LDR.N    R1,??DataTable19_4  ;; 0x5fa0000
   \   00000002   0x4308             ORRS     R0,R1,R0
   \   00000004   0x....             LDR.N    R1,??DataTable19_6  ;; 0xe000ed0c
   \   00000006   0x6008             STR      R0,[R1, #+0]
    107          }
   \   00000008   0x4770             BX       LR               ;; return
    108          
    109          /*******************************************************************************
    110          * Function Name  : NVIC_Init
    111          * Description    : Initializes the NVIC peripheral according to the specified
    112          *                  parameters in the NVIC_InitStruct.
    113          * Input          : - NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure
    114          *                    that contains the configuration information for the
    115          *                    specified NVIC peripheral.
    116          * Output         : None
    117          * Return         : None
    118          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    119          void NVIC_Init(u32 NVIC_IRQChannel, u32 NVIC_IRQChannelCmd)
    120          {
    121          	if(NVIC_IRQChannelCmd == ENABLE)
   \                     NVIC_Init:
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0xF000 0x031F      AND      R3,R0,#0x1F
   \   00000006   0x409A             LSLS     R2,R2,R3
   \   00000008   0x0940             LSRS     R0,R0,#+5
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xBF0C             ITE      EQ 
   \   0000000E   0x....             LDREQ.N  R1,??DataTable19_7  ;; 0xe000e100
   \   00000010   0x....             LDRNE.N  R1,??DataTable19  ;; 0xe000e180
    122          	{
    123          		// Enable the Selected IRQ Channels ----------------------------------------
    124          		NVIC->ISER[(NVIC_IRQChannel >> 0x05)] = (u32)0x01 << (NVIC_IRQChannel & (u8)0x1F);
    125          	}
    126          	else
    127          	{
    128          		// Disable the Selected IRQ Channels ---------------------------------------
    129          		NVIC->ICER[(NVIC_IRQChannel >> 0x05)] = (u32)0x01 << (NVIC_IRQChannel & (u8)0x1F);
   \   00000012   0xF841 0x2020      STR      R2,[R1, R0, LSL #+2]
    130          	}
    131          }
   \   00000016   0x4770             BX       LR               ;; return
    132          
    133          #if 0
    134          void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct)
    135          {
    136            uint8_t tmppriority = 0x00, tmppre = 0x00, tmpsub = 0x0F;
    137            
    138            /* Check the parameters */
    139            assert_param(IS_FUNCTIONAL_STATE(NVIC_InitStruct->NVIC_IRQChannelCmd));
    140            assert_param(IS_NVIC_PREEMPTION_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority));  
    141            assert_param(IS_NVIC_SUB_PRIORITY(NVIC_InitStruct->NVIC_IRQChannelSubPriority));
    142              
    143            if (NVIC_InitStruct->NVIC_IRQChannelCmd != DISABLE)
    144            {
    145              /* Compute the Corresponding IRQ Priority --------------------------------*/    
    146              tmppriority = (0x700 - ((SCB->AIRCR) & (uint32_t)0x700))>> 0x08;
    147              tmppre = (0x4 - tmppriority);
    148              tmpsub = tmpsub >> tmppriority;
    149          
    150              tmppriority = NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    151              tmppriority |=  (uint8_t)(NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub);
    152                  
    153              tmppriority = tmppriority << 0x04;
    154                  
    155              NVIC->IP[NVIC_InitStruct->NVIC_IRQChannel] = tmppriority;
    156              
    157              /* Enable the Selected IRQ Channels --------------------------------------*/
    158              NVIC->ISER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
    159                (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
    160            }
    161            else
    162            {
    163              /* Disable the Selected IRQ Channels -------------------------------------*/
    164              NVIC->ICER[NVIC_InitStruct->NVIC_IRQChannel >> 0x05] =
    165                (uint32_t)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (uint8_t)0x1F);
    166            }
    167          }
    168          #endif
    169          
    170          /*******************************************************************************
    171          * Function Name  : NVIC_StructInit
    172          * Description    : Fills each NVIC_InitStruct member with its default value.
    173          * Input          : - NVIC_InitStruct: pointer to a NVIC_InitTypeDef structure which
    174          *                    will be initialized.
    175          * Output         : None
    176          * Return         : None
    177          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    178          void NVIC_StructInit(NVIC_InitTypeDef* NVIC_InitStruct)
    179          {
    180          	/* NVIC_InitStruct members default value */
    181          	NVIC_InitStruct->NVIC_IRQChannel = 0x00;
   \                     NVIC_StructInit:
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7001             STRB     R1,[R0, #+0]
    182          	NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority = 0x00;
   \   00000004   0x7041             STRB     R1,[R0, #+1]
    183          	NVIC_InitStruct->NVIC_IRQChannelSubPriority = 0x00;
   \   00000006   0x7081             STRB     R1,[R0, #+2]
    184          	NVIC_InitStruct->NVIC_IRQChannelCmd = DISABLE;
   \   00000008   0x70C1             STRB     R1,[R0, #+3]
    185          }
   \   0000000A   0x4770             BX       LR               ;; return
    186          
    187          /*******************************************************************************
    188          * Function Name  : NVIC_SETPRIMASK
    189          * Description    : Enables the PRIMASK priority: Raises the execution priority to 0.
    190          * Input          : None
    191          * Output         : None
    192          * Return         : None
    193          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    194          void NVIC_SETPRIMASK(void)
    195          {
    196          	__SETPRIMASK();
   \                     NVIC_SETPRIMASK:
   \   00000000   0x.... 0x....      B.W      __SETPRIMASK
    197          }
    198          
    199          /*******************************************************************************
    200          * Function Name  : NVIC_RESETPRIMASK
    201          * Description    : Disables the PRIMASK priority.
    202          * Input          : None
    203          * Output         : None
    204          * Return         : None
    205          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    206          void NVIC_RESETPRIMASK(void)
    207          {
    208          	__RESETPRIMASK();
   \                     NVIC_RESETPRIMASK:
   \   00000000   0x.... 0x....      B.W      __RESETPRIMASK
    209          }
    210          
    211          /*******************************************************************************
    212          * Function Name  : NVIC_SETFAULTMASK
    213          * Description    : Enables the FAULTMASK priority: Raises the execution priority to -1.
    214          * Input          : None
    215          * Output         : None
    216          * Return         : None
    217          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    218          void NVIC_SETFAULTMASK(void)
    219          {
    220          	__SETFAULTMASK();
   \                     NVIC_SETFAULTMASK:
   \   00000000   0x.... 0x....      B.W      __SETFAULTMASK
    221          }
    222          
    223          /*******************************************************************************
    224          * Function Name  : NVIC_RESETFAULTMASK
    225          * Description    : Disables the FAULTMASK priority.
    226          * Input          : None
    227          * Output         : None
    228          * Return         : None
    229          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    230          void NVIC_RESETFAULTMASK(void)
    231          {
    232          	__RESETFAULTMASK();
   \                     NVIC_RESETFAULTMASK:
   \   00000000   0x.... 0x....      B.W      __RESETFAULTMASK
    233          }
    234          
    235          /*******************************************************************************
    236          * Function Name  : NVIC_BASEPRICONFIG
    237          * Description    : The execution priority can be changed from 15 (lowest 
    238                             configurable priority) to 1.
    239          * Input          : None
    240          * Output         : None
    241          * Return         : None
    242          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    243          void NVIC_BASEPRICONFIG(u32 NewPriority)
    244          {
    245          	/* Check the parameters */
    246          	assert(IS_NVIC_BASE_PRI(NewPriority));
    247            
    248          	__BASEPRICONFIG(NewPriority << 0x04);
   \                     NVIC_BASEPRICONFIG:
   \   00000000   0x0100             LSLS     R0,R0,#+4
   \   00000002   0x.... 0x....      B.W      __BASEPRICONFIG
    249          }
    250          
    251          /*******************************************************************************
    252          * Function Name  : NVIC_GetBASEPRI
    253          * Description    : Returns the BASEPRI mask value.
    254          * Input          : None
    255          * Output         : None
    256          * Return         : BASEPRI register value
    257          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    258          u32 NVIC_GetBASEPRI(void)
    259          {
    260          	return (__GetBASEPRI());
   \                     NVIC_GetBASEPRI:
   \   00000000   0x.... 0x....      B.W      __GetBASEPRI
    261          }
    262          
    263          /*******************************************************************************
    264          * Function Name  : NVIC_GetCurrentPendingIRQChannel
    265          * Description    : Returns the current pending IRQ channel identifier.
    266          * Input          : None
    267          * Output         : None
    268          * Return         : Pending IRQ Channel Identifier.
    269          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    270          u16 NVIC_GetCurrentPendingIRQChannel(void)
    271          {
    272          	return ((u16)((SCB->ICSR & (u32)0x003FF000) >> 0x0C));
   \                     NVIC_GetCurrentPendingIRQChannel:
   \   00000000   0x....             LDR.N    R0,??DataTable19_3  ;; 0xe000ed04
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0280             LSLS     R0,R0,#+10
   \   00000006   0x0D80             LSRS     R0,R0,#+22
   \   00000008   0x4770             BX       LR               ;; return
    273          }
    274          
    275          /*******************************************************************************
    276          * Function Name  : NVIC_GetIRQChannelPendingBitStatus
    277          * Description    : Checks whether the specified IRQ Channel pending bit is set
    278          *                  or not.
    279          * Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to check.
    280          * Output         : None
    281          * Return         : The new state of IRQ Channel pending bit(SET or RESET).
    282          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    283          INT32U NVIC_GetIRQChannelPendingBitStatus(u8 NVIC_IRQChannel)
    284          {
    285          	INT32U pendingirqstatus = RESET;
   \                     NVIC_GetIRQChannelPendingBitStatus:
   \   00000000   0x2100             MOVS     R1,#+0
    286          	u32 tmp = 0x00;
    287          
    288          	/* Check the parameters */
    289          	assert(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
    290          
    291          	tmp = ((u32)0x01 << (NVIC_IRQChannel & (u32)0x1F));
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0xF000 0x031F      AND      R3,R0,#0x1F
   \   00000008   0x409A             LSLS     R2,R2,R3
    292          
    293          	if (((NVIC->ISPR[(NVIC_IRQChannel >> 0x05)]) & tmp) == tmp)
   \   0000000A   0x1140             ASRS     R0,R0,#+5
   \   0000000C   0x....             LDR.N    R3,??DataTable19_8  ;; 0xe000e200
   \   0000000E   0xF853 0x0020      LDR      R0,[R3, R0, LSL #+2]
   \   00000012   0x4010             ANDS     R0,R2,R0
   \   00000014   0x4290             CMP      R0,R2
   \   00000016   0xBF08             IT       EQ 
   \   00000018   0x2101             MOVEQ    R1,#+1
    294          	{
    295          		pendingirqstatus = SET;
    296          	}
    297          	else
    298          	{
    299          		pendingirqstatus = RESET;
    300          	}
    301          	return pendingirqstatus;
   \   0000001A   0x4608             MOV      R0,R1
   \   0000001C   0x4770             BX       LR               ;; return
    302          }
    303          
    304          /*******************************************************************************
    305          * Function Name  : NVIC_SetIRQChannelPendingBit
    306          * Description    : Sets the NVIC’s interrupt pending bit.
    307          * Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to Set.
    308          * Output         : None
    309          * Return         : None
    310          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    311          void NVIC_SetIRQChannelPendingBit(u8 NVIC_IRQChannel)
    312          {
    313            /* Check the parameters */
    314            assert(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
    315            
    316            *(u32*)0xE000EF00 = (u32)NVIC_IRQChannel;
   \                     NVIC_SetIRQChannelPendingBit:
   \   00000000   0x....             LDR.N    R1,??DataTable19_9  ;; 0xe000ef00
   \   00000002   0x6008             STR      R0,[R1, #+0]
    317          }
   \   00000004   0x4770             BX       LR               ;; return
    318          
    319          /*******************************************************************************
    320          * Function Name  : NVIC_ClearIRQChannelPendingBit
    321          * Description    : Clears the NVIC’s interrupt pending bit.
    322          * Input          : - NVIC_IRQChannel: specifies the interrupt pending bit to clear.
    323          * Output         : None
    324          * Return         : None
    325          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    326          void NVIC_ClearIRQChannelPendingBit(u8 NVIC_IRQChannel)
    327          {
    328              /* Check the parameters */
    329              assert(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
    330              NVIC->ICPR[(NVIC_IRQChannel >> 0x05)] = (u32)0x01 << (NVIC_IRQChannel & (u32)0x1F);
   \                     NVIC_ClearIRQChannelPendingBit:
   \   00000000   0x1141             ASRS     R1,R0,#+5
   \   00000002   0x....             LDR.N    R2,??DataTable19_1  ;; 0xe000e280
   \   00000004   0x2301             MOVS     R3,#+1
   \   00000006   0xF000 0x001F      AND      R0,R0,#0x1F
   \   0000000A   0xFA03 0xF000      LSL      R0,R3,R0
   \   0000000E   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
    331          }
   \   00000012   0x4770             BX       LR               ;; return
    332          
    333          /*******************************************************************************
    334          * Function Name  : NVIC_GetCurrentActiveHandler
    335          * Description    : Returns the current active Handler (IRQ Channel and
    336          *                  SystemHandler) identifier.
    337          * Input          : None
    338          * Output         : None
    339          * Return         : Active Handler Identifier.
    340          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    341          u16 NVIC_GetCurrentActiveHandler(void)
    342          {
    343          	return ((u16)(SCB->ICSR & (u32)0x3FF));
   \                     NVIC_GetCurrentActiveHandler:
   \   00000000   0x....             LDR.N    R0,??DataTable19_3  ;; 0xe000ed04
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0580             LSLS     R0,R0,#+22
   \   00000006   0x0D80             LSRS     R0,R0,#+22
   \   00000008   0x4770             BX       LR               ;; return
    344          }
    345          
    346          /*******************************************************************************
    347          * Function Name  : NVIC_GetIRQChannelActiveBitStatus
    348          * Description    : Checks whether the specified IRQ Channel active bit is set
    349          *                  or not.
    350          * Input          : - NVIC_IRQChannel: specifies the interrupt active bit to check.
    351          * Output         : None
    352          * Return         : The new state of IRQ Channel active bit(SET or RESET).
    353          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    354          INT32U NVIC_GetIRQChannelActiveBitStatus(u8 NVIC_IRQChannel)
    355          {
    356              INT32U activeirqstatus = RESET;
   \                     NVIC_GetIRQChannelActiveBitStatus:
   \   00000000   0x2100             MOVS     R1,#+0
    357              u32 tmp = 0x00;
    358          
    359              /* Check the parameters */
    360              assert(IS_NVIC_IRQ_CHANNEL(NVIC_IRQChannel));
    361            
    362              tmp = ((u32)0x01 << (NVIC_IRQChannel & (u32)0x1F));
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0xF000 0x031F      AND      R3,R0,#0x1F
   \   00000008   0x409A             LSLS     R2,R2,R3
    363          
    364              if (((NVIC->IABR[(NVIC_IRQChannel >> 0x05)]) & tmp) == tmp )
   \   0000000A   0x1140             ASRS     R0,R0,#+5
   \   0000000C   0x....             LDR.N    R3,??DataTable19_10  ;; 0xe000e300
   \   0000000E   0xF853 0x0020      LDR      R0,[R3, R0, LSL #+2]
   \   00000012   0x4010             ANDS     R0,R2,R0
   \   00000014   0x4290             CMP      R0,R2
   \   00000016   0xBF08             IT       EQ 
   \   00000018   0x2101             MOVEQ    R1,#+1
    365              {
    366                  activeirqstatus = SET;
    367              }
    368              else
    369              {
    370                  activeirqstatus = RESET;
    371              }
    372              return activeirqstatus;
   \   0000001A   0x4608             MOV      R0,R1
   \   0000001C   0x4770             BX       LR               ;; return
    373          }
    374          
    375          /*******************************************************************************
    376          * Function Name  : NVIC_GetCPUID
    377          * Description    : Returns the ID number, the version number and the implementation
    378          *                  details of the Cortex-M3 core.
    379          * Input          : None
    380          * Output         : None
    381          * Return         : CPU ID.
    382          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    383          u32 NVIC_GetCPUID(void)
    384          {
    385          	return (SCB->CPUID);
   \                     NVIC_GetCPUID:
   \   00000000   0x....             LDR.N    R0,??DataTable19_11  ;; 0xe000ed00
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
    386          }
    387          
    388          
    389          /*******************************************************************************
    390            * @brief  Sets the vector table location and Offset.
    391            * @param  NVIC_VectTab: specifies if the vector table is in RAM or FLASH memory.
    392            *   This parameter can be one of the following values:
    393            *     @arg NVIC_VectTab_RAM: Vector Table in internal SRAM.
    394            *     @arg NVIC_VectTab_FLASH: Vector Table in internal FLASH.
    395            * @param  Offset: Vector Table base offset field. This value must be a multiple of 0x200.
    396            * @retval None
    397            *****************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    398          void NVIC_SetVectorTable(u32 Addr)
    399          {
    400          	SCB->VTOR = Addr & 0x3FFFFF80;
   \                     NVIC_SetVectorTable:
   \   00000000   0x....             LDR.N    R1,??DataTable19_12  ;; 0x3fffff80
   \   00000002   0x4008             ANDS     R0,R1,R0
   \   00000004   0x....             LDR.N    R1,??DataTable19_13  ;; 0xe000ed08
   \   00000006   0x6008             STR      R0,[R1, #+0]
    401          }
   \   00000008   0x4770             BX       LR               ;; return
    402          
    403          /*******************************************************************************
    404            * @brief	Selects the condition for the system to enter low power mode.
    405            * @param	LowPowerMode: Specifies the new mode for the system to enter low power mode.
    406            *   This parameter can be one of the following values:
    407            * 	@arg NVIC_LP_SEVONPEND: Low Power SEV on Pend.
    408            * 	@arg NVIC_LP_SLEEPDEEP: Low Power DEEPSLEEP request.
    409            * 	@arg NVIC_LP_SLEEPONEXIT: Low Power Sleep on Exit.
    410            * @param	NewState: new state of LP condition. This parameter can be: ENABLE or DISABLE.
    411            * @retval None
    412            *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    413          void NVIC_SystemLPConfig(u8 LowPowerMode, INT32U NewState)
    414          {
    415          	/* Check the parameters */
    416          	assert(IS_NVIC_LP(LowPowerMode));
    417          	assert(IS_FUNCTIONAL_STATE(NewState));  
    418          
    419          	if (NewState != DISABLE)
   \                     NVIC_SystemLPConfig:
   \   00000000   0x....             LDR.N    R2,??DataTable19_14  ;; 0xe000ed10
   \   00000002   0x2900             CMP      R1,#+0
   \   00000004   0x6811             LDR      R1,[R2, #+0]
   \   00000006   0xBF14             ITE      NE 
   \   00000008   0x4308             ORRNE    R0,R0,R1
   \   0000000A   0xEA21 0x0000      BICEQ    R0,R1,R0
    420          	{
    421          		SCB->SCR |= LowPowerMode;
    422          	}
    423          	else
    424          	{
    425          		SCB->SCR &= (u32)(~(u32)LowPowerMode);
   \   0000000E   0x6010             STR      R0,[R2, #+0]
    426          	}
    427          }
   \   00000010   0x4770             BX       LR               ;; return
    428          
    429          /*******************************************************************************
    430          * Function Name  : NVIC_SystemHandlerConfig
    431          * Description    : Enables or disables the specified System Handlers.
    432          * Input          : - SystemHandler: specifies the system handler to be enabled
    433          *                    or disabled.
    434          *                    This parameter can be one of the following values:
    435          *                       - SystemHandler_MemoryManage
    436          *                       - SystemHandler_BusFault
    437          *                       - SystemHandler_UsageFault
    438          *                  - NewState: new state of  specified System Handlers.
    439          *                    This parameter can be: ENABLE or DISABLE.
    440          * Output         : None
    441          * Return         : None
    442          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    443          void NVIC_SystemHandlerConfig(u32 SystemHandler, INT32U NewState)
    444          {
    445          	u32 tmpreg = 0x00;
    446          
    447          	/* Check the parameters */
    448          	assert(IS_CONFIG_SYSTEM_HANDLER(SystemHandler));
    449          	assert(IS_FUNCTIONAL_STATE(NewState)); 
    450          
    451          	tmpreg =  (u32)0x01 << (SystemHandler & (u32)0x1F);
   \                     NVIC_SystemHandlerConfig:
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0xF000 0x001F      AND      R0,R0,#0x1F
   \   00000006   0xFA02 0xF000      LSL      R0,R2,R0
    452          
    453          	if (NewState != DISABLE)
   \   0000000A   0x....             LDR.N    R2,??DataTable19_15  ;; 0xe000ed24
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0x6811             LDR      R1,[R2, #+0]
   \   00000010   0xBF14             ITE      NE 
   \   00000012   0x4308             ORRNE    R0,R0,R1
   \   00000014   0xEA21 0x0000      BICEQ    R0,R1,R0
    454          	{
    455          		SCB->SHCSR |= tmpreg;
    456          	}
    457          	else
    458          	{
    459          		SCB->SHCSR &= ~tmpreg;
   \   00000018   0x6010             STR      R0,[R2, #+0]
    460          	}
    461          }
   \   0000001A   0x4770             BX       LR               ;; return
    462          
    463          /*******************************************************************************
    464          * Function Name  : NVIC_SystemHandlerPriorityConfig
    465          * Description    : Configures the specified System Handlers priority.
    466          * Input          : - SystemHandler: specifies the system handler to be
    467          *                    enabled or disabled.
    468          *                    This parameter can be one of the following values:
    469          *                       - SystemHandler_MemoryManage
    470          *                       - SystemHandler_BusFault
    471          *                       - SystemHandler_UsageFault
    472          *                       - SystemHandler_SVCall
    473          *                       - SystemHandler_DebugMonitor
    474          *                       - SystemHandler_PSV
    475          *                       - SystemHandler_SysTick
    476          *                  - SystemHandlerPreemptionPriority: new priority group of the
    477          *                    specified system handlers.
    478          *                  - SystemHandlerSubPriority: new sub priority of the specified
    479          *                    system handlers.
    480          * Output         : None
    481          * Return         : None
    482          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    483          void NVIC_SystemHandlerPriorityConfig(u32 SystemHandler, u8 SystemHandlerPreemptionPriority,
    484                                                u8 SystemHandlerSubPriority)
    485          {
   \                     NVIC_SystemHandlerPriorityConfig:
   \   00000000   0xB4F0             PUSH     {R4-R7}
    486            u32 tmp1 = 0x00, tmp2 = 0xFF, handlermask = 0x00;
    487            u32 tmppriority = 0x00;
    488          
    489            /* Check the parameters */
    490            assert(IS_PRIORITY_SYSTEM_HANDLER(SystemHandler));	//	SystemHandler_SysTick 0x02C39A
    491            assert(IS_NVIC_PREEMPTION_PRIORITY(SystemHandlerPreemptionPriority));  
    492            assert(IS_NVIC_SUB_PRIORITY(SystemHandlerSubPriority));
    493              
    494            tmppriority = (0x700 - (SCB->AIRCR & (u32)0x700))>> 0x08;
   \   00000002   0x....             LDR.N    R3,??DataTable19_6  ;; 0xe000ed0c
   \   00000004   0x681B             LDR      R3,[R3, #+0]
   \   00000006   0xF403 0x63E0      AND      R3,R3,#0x700
   \   0000000A   0xF5C3 0x63E0      RSB      R3,R3,#+1792
   \   0000000E   0x0A1B             LSRS     R3,R3,#+8
    495            tmp1 = (0x4 - tmppriority);
    496            tmp2 = tmp2 >> tmppriority;
    497              
    498            tmppriority = (u32)SystemHandlerPreemptionPriority << tmp1;
    499            tmppriority |=  SystemHandlerSubPriority & tmp2;
    500          
    501            tmppriority = tmppriority << 0x04;
    502            tmp1 = SystemHandler & (u32)0xC0;
    503            tmp1 = tmp1 >> 0x06; 
   \   00000010   0xF3C0 0x1481      UBFX     R4,R0,#+6,#+2
    504            tmp2 = (SystemHandler >> 0x08) & (u32)0x03;
   \   00000014   0xF3C0 0x2001      UBFX     R0,R0,#+8,#+2
    505            tmppriority = tmppriority << (tmp2 * 0x08);
    506            handlermask = (u32)0xFF << (tmp2 * 0x08);
    507            
    508            SCB->__B.SHP[tmp1] &= ~handlermask;
   \   00000018   0x00C0             LSLS     R0,R0,#+3
   \   0000001A   0x27FF             MOVS     R7,#+255
   \   0000001C   0x....             LDR.N    R5,??DataTable19_5  ;; 0xe000ed18
   \   0000001E   0xF855 0x6024      LDR      R6,[R5, R4, LSL #+2]
   \   00000022   0xFA07 0xFC00      LSL      R12,R7,R0
   \   00000026   0xEA26 0x060C      BIC      R6,R6,R12
   \   0000002A   0xF845 0x6024      STR      R6,[R5, R4, LSL #+2]
    509            SCB->__B.SHP[tmp1] |= tmppriority;
   \   0000002E   0xF855 0x6024      LDR      R6,[R5, R4, LSL #+2]
   \   00000032   0xF1C3 0x0C04      RSB      R12,R3,#+4
   \   00000036   0xFA01 0xF10C      LSL      R1,R1,R12
   \   0000003A   0xFA27 0xF303      LSR      R3,R7,R3
   \   0000003E   0x401A             ANDS     R2,R3,R2
   \   00000040   0x4311             ORRS     R1,R2,R1
   \   00000042   0x0109             LSLS     R1,R1,#+4
   \   00000044   0xFA01 0xF000      LSL      R0,R1,R0
   \   00000048   0x4330             ORRS     R0,R0,R6
   \   0000004A   0xF845 0x0024      STR      R0,[R5, R4, LSL #+2]
    510          }
   \   0000004E   0xBCF0             POP      {R4-R7}
   \   00000050   0x4770             BX       LR               ;; return
    511          
    512          /*******************************************************************************
    513          * Function Name  : NVIC_GetSystemHandlerPendingBitStatus
    514          * Description    : Checks whether the specified System handlers pending bit is
    515          *                  set or not.
    516          * Input          : - SystemHandler: specifies the system handler pending bit to
    517          *                    check.
    518          *                    This parameter can be one of the following values:
    519          *                       - SystemHandler_MemoryManage
    520          *                       - SystemHandler_BusFault
    521          *                       - SystemHandler_SVCall
    522          * Output         : None
    523          * Return         : The new state of System Handler pending bit(SET or RESET).
    524          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    525          INT32U NVIC_GetSystemHandlerPendingBitStatus(u32 SystemHandler)
    526          {
    527          	INT32U bitstatus  = RESET;
   \                     NVIC_GetSystemHandlerPendingBitStatus:
   \   00000000   0x2100             MOVS     R1,#+0
    528          	u32 tmp = 0x00, tmppos = 0x00;
    529          
    530          	/* Check the parameters */
    531          	assert(IS_GET_PENDING_SYSTEM_HANDLER(SystemHandler));
    532          
    533          	tmppos = (SystemHandler >> 0x0A);
    534          	tmppos &= (u32)0x0F;
    535          
    536          	tmppos = (u32)0x01 << tmppos;
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x0A80             LSRS     R0,R0,#+10
   \   00000006   0xF000 0x000F      AND      R0,R0,#0xF
   \   0000000A   0xFA02 0xF000      LSL      R0,R2,R0
    537          
    538          	tmp = SCB->SHCSR & tmppos;
   \   0000000E   0x....             LDR.N    R2,??DataTable19_15  ;; 0xe000ed24
   \   00000010   0x6812             LDR      R2,[R2, #+0]
    539          
    540          	if (tmp == tmppos)
   \   00000012   0x4002             ANDS     R2,R0,R2
   \   00000014   0x4282             CMP      R2,R0
   \   00000016   0xBF08             IT       EQ 
   \   00000018   0x2101             MOVEQ    R1,#+1
    541          	{
    542          		bitstatus = SET;
    543          	}
    544          	else
    545          	{
    546          		bitstatus = RESET;
    547          	}
    548          	return bitstatus;
   \   0000001A   0x4608             MOV      R0,R1
   \   0000001C   0x4770             BX       LR               ;; return
    549          }
    550          
    551          /*******************************************************************************
    552          * Function Name  : NVIC_SetSystemHandlerPendingBit
    553          * Description    : Sets System Handler pending bit.
    554          * Input          : - SystemHandler: specifies the system handler pending bit
    555          *                    to be set.
    556          *                    This parameter can be one of the following values:
    557          *                       - SystemHandler_NMI
    558          *                       - SystemHandler_PSV
    559          *                       - SystemHandler_SysTick
    560          * Output         : None
    561          * Return         : None
    562          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    563          void NVIC_SetSystemHandlerPendingBit(u32 SystemHandler)
    564          {
    565          	u32 tmp = 0x00;
    566          
    567          	/* Check the parameters */
    568          	assert(IS_SET_PENDING_SYSTEM_HANDLER(SystemHandler));
    569          
    570          	/* Get the System Handler pending bit position */
    571          	tmp = SystemHandler & (u32)0x1F;
    572          	/* Set the corresponding System Handler pending bit */
    573          	SCB->ICSR |= ((u32)0x01 << tmp);
   \                     NVIC_SetSystemHandlerPendingBit:
   \   00000000   0x....             LDR.N    R1,??DataTable19_3  ;; 0xe000ed04
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x2301             MOVS     R3,#+1
   \   00000006   0xF000 0x001F      AND      R0,R0,#0x1F
   \   0000000A   0x....             B.N      ?Subroutine0
    574          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0xFA03 0xF000      LSL      R0,R3,R0
   \   00000004   0x4310             ORRS     R0,R0,R2
   \   00000006   0x6008             STR      R0,[R1, #+0]
   \   00000008   0x4770             BX       LR               ;; return
    575          
    576          /*******************************************************************************
    577          * Function Name  : NVIC_ClearSystemHandlerPendingBit
    578          * Description    : Clears System Handler pending bit.
    579          * Input          : - SystemHandler: specifies the system handler pending bit to
    580          *                    be clear.
    581          *                    This parameter can be one of the following values:
    582          *                       - SystemHandler_PSV
    583          *                       - SystemHandler_SysTick
    584          * Output         : None
    585          * Return         : None
    586          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    587          void NVIC_ClearSystemHandlerPendingBit(u32 SystemHandler)
    588          {
    589          	u32 tmp = 0x00;
    590          
    591          	/* Check the parameters */
    592          	assert(IS_CLEAR_SYSTEM_HANDLER(SystemHandler));
    593          
    594          	/* Get the System Handler pending bit position */
    595          	tmp = SystemHandler & (u32)0x1F;
    596          	/* Clear the corresponding System Handler pending bit */
    597          	SCB->ICSR |= ((u32)0x01 << (tmp - 0x01));
   \                     NVIC_ClearSystemHandlerPendingBit:
   \   00000000   0x....             LDR.N    R1,??DataTable19_3  ;; 0xe000ed04
   \   00000002   0x680A             LDR      R2,[R1, #+0]
   \   00000004   0x2301             MOVS     R3,#+1
   \   00000006   0xF000 0x001F      AND      R0,R0,#0x1F
   \   0000000A   0x1E40             SUBS     R0,R0,#+1
   \   0000000C                      REQUIRE ?Subroutine0
   \   0000000C                      ;; // Fall through to label ?Subroutine0
    598          }
    599          
    600          /*******************************************************************************
    601          * Function Name  : NVIC_GetSystemHandlerActiveBitStatus
    602          * Description    : Checks whether the specified System handlers active bit is
    603          *                  set or not.
    604          * Input          : - SystemHandler: specifies the system handler active bit to
    605          *                    check.
    606          *                    This parameter can be one of the following values:
    607          *                       - SystemHandler_MemoryManage
    608          *                       - SystemHandler_BusFault
    609          *                       - SystemHandler_UsageFault
    610          *                       - SystemHandler_SVCall
    611          *                       - SystemHandler_DebugMonitor
    612          *                       - SystemHandler_PSV
    613          *                       - SystemHandler_SysTick
    614          * Output         : None
    615          * Return         : The new state of System Handler active bit(SET or RESET).
    616          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    617          INT32U NVIC_GetSystemHandlerActiveBitStatus(u32 SystemHandler)
    618          {
    619          	INT32U bitstatus  = RESET;
   \                     NVIC_GetSystemHandlerActiveBitStatus:
   \   00000000   0x2100             MOVS     R1,#+0
    620          
    621          	u32 tmp = 0x00, tmppos = 0x00;
    622          
    623          	/* Check the parameters */
    624          	assert(IS_GET_ACTIVE_SYSTEM_HANDLER(SystemHandler));
    625          
    626          	tmppos = (SystemHandler >> 0x0E) & (u32)0x0F;
    627          
    628          	tmppos = (u32)0x01 << tmppos;
   \   00000002   0x2201             MOVS     R2,#+1
   \   00000004   0x0B80             LSRS     R0,R0,#+14
   \   00000006   0xF000 0x000F      AND      R0,R0,#0xF
   \   0000000A   0xFA02 0xF000      LSL      R0,R2,R0
    629          
    630          	tmp = SCB->SHCSR & tmppos;
   \   0000000E   0x....             LDR.N    R2,??DataTable19_15  ;; 0xe000ed24
   \   00000010   0x6812             LDR      R2,[R2, #+0]
    631          
    632          	if (tmp == tmppos)
   \   00000012   0x4002             ANDS     R2,R0,R2
   \   00000014   0x4282             CMP      R2,R0
   \   00000016   0xBF08             IT       EQ 
   \   00000018   0x2101             MOVEQ    R1,#+1
    633          	{
    634          		bitstatus = SET;
    635          	}
    636          	else
    637          	{
    638          		bitstatus = RESET;
    639          	}
    640          	return bitstatus;
   \   0000001A   0x4608             MOV      R0,R1
   \   0000001C   0x4770             BX       LR               ;; return
    641          }
    642          
    643          /*******************************************************************************
    644          * Function Name  : NVIC_GetFaultHandlerSources
    645          * Description    : Returns the system fault handlers sources.
    646          * Input          : - SystemHandler: specifies the system handler to get its fault
    647          *                    sources.
    648          *                    This parameter can be one of the following values:
    649          *                       - SystemHandler_HardFault
    650          *                       - SystemHandler_MemoryManage
    651          *                       - SystemHandler_BusFault
    652          *                       - SystemHandler_UsageFault
    653          *                       - SystemHandler_DebugMonitor
    654          * Output         : None
    655          * Return         : Source of the fault handler.
    656          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    657          u32 NVIC_GetFaultHandlerSources(u32 SystemHandler)
    658          {
    659          	u32 faultsources = 0x00;
    660          	u32 tmpreg = 0x00, tmppos = 0x00;
    661          
    662          	/* Check the parameters */
    663          	assert(IS_FAULT_SOURCE_SYSTEM_HANDLER(SystemHandler));
    664          
    665          	tmpreg = (SystemHandler >> 0x12) & (u32)0x03;
   \                     NVIC_GetFaultHandlerSources:
   \   00000000   0xF3C0 0x4181      UBFX     R1,R0,#+18,#+2
    666          	tmppos = (SystemHandler >> 0x14) & (u32)0x03;
   \   00000004   0xF3C0 0x5001      UBFX     R0,R0,#+20,#+2
    667          
    668          	if (tmpreg == 0x00)
   \   00000008   0x....             LDR.N    R2,??DataTable19_16  ;; 0xe000ed28
   \   0000000A   0x000B             MOVS     R3,R1
   \   0000000C   0xD101             BNE.N    ??NVIC_GetFaultHandlerSources_0
    669          	{
    670          		faultsources = SCB->HFSR;
   \   0000000E   0x6850             LDR      R0,[R2, #+4]
   \   00000010   0x4770             BX       LR
    671          	}
    672          	else if (tmpreg == 0x01)
   \                     ??NVIC_GetFaultHandlerSources_0:
   \   00000012   0x2901             CMP      R1,#+1
   \   00000014   0xD109             BNE.N    ??NVIC_GetFaultHandlerSources_1
    673          	{
    674          		faultsources = SCB->CFSR >> (tmppos * 0x08);
   \   00000016   0x6811             LDR      R1,[R2, #+0]
   \   00000018   0x00C2             LSLS     R2,R0,#+3
   \   0000001A   0x40D1             LSRS     R1,R1,R2
    675          		if (tmppos != 0x02)
   \   0000001C   0x2802             CMP      R0,#+2
   \   0000001E   0xD002             BEQ.N    ??NVIC_GetFaultHandlerSources_2
    676          		{
    677          	  		faultsources &= (u32)0x0F;
   \   00000020   0xF001 0x000F      AND      R0,R1,#0xF
   \   00000024   0x4770             BX       LR
    678          		}
    679          		else
    680          		{
    681          	  		faultsources &= (u32)0xFF;
   \                     ??NVIC_GetFaultHandlerSources_2:
   \   00000026   0xB2C8             UXTB     R0,R1
   \   00000028   0x4770             BX       LR
    682          		}
    683          	}
    684          	else
    685          	{
    686          		faultsources = SCB->DFSR;
   \                     ??NVIC_GetFaultHandlerSources_1:
   \   0000002A   0x6890             LDR      R0,[R2, #+8]
    687          	}
    688          	return faultsources;
   \   0000002C   0x4770             BX       LR               ;; return
    689          }
    690          
    691          /*******************************************************************************
    692          * Function Name  : NVIC_GetFaultAddress
    693          * Description    : Returns the address of the location that generated a fault
    694          *                  handler.
    695          * Input          : - SystemHandler: specifies the system handler to get its
    696          *                    fault address.
    697          *                    This parameter can be one of the following values:
    698          *                       - SystemHandler_MemoryManage
    699          *                       - SystemHandler_BusFault
    700          * Output         : None
    701          * Return         : Fault address.
    702          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    703          u32 NVIC_GetFaultAddress(u32 SystemHandler)
    704          {
    705          	u32 faultaddress = 0x00;
    706          	u32 tmp = 0x00;
    707          
    708          	/* Check the parameters */
    709          	assert(IS_FAULT_ADDRESS_SYSTEM_HANDLER(SystemHandler));
    710          
    711          	tmp = (SystemHandler >> 0x16) & (u32)0x01;
    712          
    713          	if (tmp == 0x00)
   \                     NVIC_GetFaultAddress:
   \   00000000   0x....             LDR.N    R1,??DataTable19_17  ;; 0xe000ed34
   \   00000002   0x0240             LSLS     R0,R0,#+9
   \   00000004   0xD401             BMI.N    ??NVIC_GetFaultAddress_0
    714          	{
    715          		faultaddress = SCB->MMFAR;
   \   00000006   0x6808             LDR      R0,[R1, #+0]
   \   00000008   0x4770             BX       LR
    716          	}
    717          	else
    718          	{
    719          		faultaddress = SCB->BFAR;
   \                     ??NVIC_GetFaultAddress_0:
   \   0000000A   0x6848             LDR      R0,[R1, #+4]
    720          	}
    721          	return faultaddress;
   \   0000000C   0x4770             BX       LR               ;; return
    722          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0xE000E400         DC32     0xe000e400

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   0xE000ED04         DC32     0xe000ed04

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \   00000000   0x05FA0000         DC32     0x5fa0000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_5:
   \   00000000   0xE000ED18         DC32     0xe000ed18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_6:
   \   00000000   0xE000ED0C         DC32     0xe000ed0c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_7:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_8:
   \   00000000   0xE000E200         DC32     0xe000e200

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_9:
   \   00000000   0xE000EF00         DC32     0xe000ef00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_10:
   \   00000000   0xE000E300         DC32     0xe000e300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_11:
   \   00000000   0xE000ED00         DC32     0xe000ed00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_12:
   \   00000000   0x3FFFFF80         DC32     0x3fffff80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_13:
   \   00000000   0xE000ED08         DC32     0xe000ed08

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_14:
   \   00000000   0xE000ED10         DC32     0xe000ed10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_15:
   \   00000000   0xE000ED24         DC32     0xe000ed24

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_16:
   \   00000000   0xE000ED28         DC32     0xe000ed28

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_17:
   \   00000000   0xE000ED34         DC32     0xe000ed34
    723          
    724          /******************* (C) COPYRIGHT 2007 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  NVIC_BASEPRICONFIG
             0 -> __BASEPRICONFIG
        0  NVIC_ClearIRQChannelPendingBit
        0  NVIC_ClearSystemHandlerPendingBit
        0  NVIC_DeInit
             0 -> __aeabi_memclr4
        0  NVIC_GetBASEPRI
             0 -> __GetBASEPRI
        0  NVIC_GetCPUID
        0  NVIC_GetCurrentActiveHandler
        0  NVIC_GetCurrentPendingIRQChannel
        0  NVIC_GetFaultAddress
        0  NVIC_GetFaultHandlerSources
        0  NVIC_GetIRQChannelActiveBitStatus
        0  NVIC_GetIRQChannelPendingBitStatus
        0  NVIC_GetSystemHandlerActiveBitStatus
        0  NVIC_GetSystemHandlerPendingBitStatus
        0  NVIC_Init
        0  NVIC_PriorityGroupConfig
        0  NVIC_RESETFAULTMASK
             0 -> __RESETFAULTMASK
        0  NVIC_RESETPRIMASK
             0 -> __RESETPRIMASK
        8  NVIC_SCBDeInit
             8 -> __aeabi_memclr4
        0  NVIC_SETFAULTMASK
             0 -> __SETFAULTMASK
        0  NVIC_SETPRIMASK
             0 -> __SETPRIMASK
        0  NVIC_SetIRQChannelPendingBit
        0  NVIC_SetSystemHandlerPendingBit
        0  NVIC_SetVectorTable
        0  NVIC_StructInit
        0  NVIC_SystemHandlerConfig
       16  NVIC_SystemHandlerPriorityConfig
        0  NVIC_SystemLPConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_10
       4  ??DataTable19_11
       4  ??DataTable19_12
       4  ??DataTable19_13
       4  ??DataTable19_14
       4  ??DataTable19_15
       4  ??DataTable19_16
       4  ??DataTable19_17
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable19_5
       4  ??DataTable19_6
       4  ??DataTable19_7
       4  ??DataTable19_8
       4  ??DataTable19_9
      10  ?Subroutine0
       6  NVIC_BASEPRICONFIG
      20  NVIC_ClearIRQChannelPendingBit
      12  NVIC_ClearSystemHandlerPendingBit
      62  NVIC_DeInit
       4  NVIC_GetBASEPRI
       6  NVIC_GetCPUID
      10  NVIC_GetCurrentActiveHandler
      10  NVIC_GetCurrentPendingIRQChannel
      14  NVIC_GetFaultAddress
      46  NVIC_GetFaultHandlerSources
      30  NVIC_GetIRQChannelActiveBitStatus
      30  NVIC_GetIRQChannelPendingBitStatus
      30  NVIC_GetSystemHandlerActiveBitStatus
      30  NVIC_GetSystemHandlerPendingBitStatus
      24  NVIC_Init
      10  NVIC_PriorityGroupConfig
       4  NVIC_RESETFAULTMASK
       4  NVIC_RESETPRIMASK
      50  NVIC_SCBDeInit
       4  NVIC_SETFAULTMASK
       4  NVIC_SETPRIMASK
       6  NVIC_SetIRQChannelPendingBit
      12  NVIC_SetSystemHandlerPendingBit
      10  NVIC_SetVectorTable
      12  NVIC_StructInit
      28  NVIC_SystemHandlerConfig
      82  NVIC_SystemHandlerPriorityConfig
      18  NVIC_SystemLPConfig

 
 660 bytes in section .text
 
 660 bytes of CODE memory

Errors: none
Warnings: none
